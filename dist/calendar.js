(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
/**
 * ██████╗   ██████╗   ██████╗  ██████╗   █████╗  ██╗   ██╗ ██╗
 * ██╔══██╗ ██╔═══██╗ ██╔═══██╗ ██╔══██╗ ██╔══██╗ ╚██╗ ██╔╝ ██║
 * ██║  ██║ ██║   ██║ ██║   ██║ ██████╔╝ ███████║  ╚████╔╝  ██║
 * ██║  ██║ ██║   ██║ ██║   ██║ ██╔══██╗ ██╔══██║   ╚██╔╝   ╚═╝
 * ██████╔╝ ╚██████╔╝ ╚██████╔╝ ██║  ██║ ██║  ██║    ██║    ██╗
 * ╚═════╝   ╚═════╝   ╚═════╝  ╚═╝  ╚═╝ ╚═╝  ╚═╝    ╚═╝    ╚═╝
 *
 *  ██████╗  █████╗  ██╗      ███████╗ ███╗   ██╗ ██████╗   █████╗  ██████╗
 * ██╔════╝ ██╔══██╗ ██║      ██╔════╝ ████╗  ██║ ██╔══██╗ ██╔══██╗ ██╔══██╗
 * ██║      ███████║ ██║      █████╗   ██╔██╗ ██║ ██║  ██║ ███████║ ██████╔╝
 * ██║      ██╔══██║ ██║      ██╔══╝   ██║╚██╗██║ ██║  ██║ ██╔══██║ ██╔══██╗
 * ╚██████╗ ██║  ██║ ███████╗ ███████╗ ██║ ╚████║ ██████╔╝ ██║  ██║ ██║  ██║
 *  ╚═════╝ ╚═╝  ╚═╝ ╚══════╝ ╚══════╝ ╚═╝  ╚═══╝ ╚═════╝  ╚═╝  ╚═╝ ╚═╝  ╚═╝
 * @version 0.1.5
 */
/* eslint vars-on-top:0, strict:0 */

/**********
 * Common
 **********/
require('code-snippet');
require('./src/js/view/template/registerHelpers');
var dirty = require('./src/js/common/dirty');
var datetime = require('./src/js/common/datetime');
var array = require('./src/js/common/array');
var domevent = require('./src/js/common/domevent');
var domutil = require('./src/js/common/domutil');
var Colleciton = require('./src/js/common/collection');
var model = require('./src/js/common/model');
var common = require('./src/js/common/common');
var reqAnimFrame = require('./src/js/common/reqAnimFrame');
var AJAX = require('./src/js/common/ajax');

/**********
 * Models
 **********/
var Point = require('./src/js/common/point');
var Event = require('./src/js/model/event');

/**********
 * Views
 **********/
var View = require('./src/js/view/view');
var MonthWeek = require('./src/js/view/monthweek');

var Week = require('./src/js/view/week/week');
var DayName = require('./src/js/view/week/dayname');
var TimeGrid = require('./src/js/view/week/timeGrid');
var Time = require('./src/js/view/week/time');


/**********
 * View Models
 **********/
var EventViewModel = require('./src/js/model/viewModel/event');

/**********
 * Handlers
 **********/
var Drag = require('./src/js/handler/drag');
var TimeCore = require('./src/js/handler/time/core');
var TimeCreation = require('./src/js/handler/time/creation');
var TimeCreationGuide = require('./src/js/handler/time/creationGuide');
var TimeMove = require('./src/js/handler/time/move');
var TimeMoveGuide = require('./src/js/handler/time/moveGuide');
var TimeResize = require('./src/js/handler/time/resize');
var TimeResizeGuide = require('./src/js/handler/time/resizeGuide');

var AlldayCore = require('./src/js/handler/allday/core');
var AlldayCreation = require('./src/js/handler/allday/creation');
var AlldayCreationGuide = require('./src/js/handler/allday/creationGuide');
var AlldayMove = require('./src/js/handler/allday/move');
var AlldayMoveGuide = require('./src/js/handler/allday/moveGuide');
var AlldayResize = require('./src/js/handler/allday/resize');
var AlldayResizeGuide = require('./src/js/handler/allday/resizeGuide');

/**********
 * Factory
 **********/
var controllerFactory = require('./src/js/factory/controller');

/** @namespace ne.dooray.calendar */

global.ne.util.defineNamespace('ne.dooray.calendar', {
    // common
    dirty: dirty,
    datetime: datetime,
    array: array,
    domevent: domevent,
    domutil: domutil,
    Collection: Colleciton,
    model: model,
    common: common,
    reqAnimFrame: reqAnimFrame,
    AJAX: AJAX,
    Point: Point, 

    // model
    Event: Event,
    EventViewModel: EventViewModel,

    // view
    View: View,
    Week: Week,
    DayName: DayName,
    TimeGrid: TimeGrid,
    Time: Time,
    MonthWeek: MonthWeek,

    // handler, guide
    Drag: Drag,

    TimeCore: TimeCore,
    TimeCreation: TimeCreation,
    TimeCreationGuide: TimeCreationGuide,
    TimeMove: TimeMove,
    TimeMoveGuide: TimeMoveGuide,
    TimeResize: TimeResize,
    TimeResizeGuide: TimeResizeGuide,

    AlldayCore: AlldayCore,
    AlldayCreation: AlldayCreation,
    AlldayCreationGuide: AlldayCreationGuide,
    AlldayMove: AlldayMove,
    AlldayMoveGuide: AlldayMoveGuide,
    AlldayResize: AlldayResize,
    AlldayResizeGuide: AlldayResizeGuide,

    // only for test
    ControllerFactory: controllerFactory
});

/**********
 * SERVICE MODULE
 **********/
var calendarAPI = require('./src/js/dooray/calendarAPI');
var API = require('./src/js/dooray/controller/api');
var MiniCalendar = require('./src/js/dooray/view/minicalendar');
var DoorayEvent = require('./src/js/dooray/model/event');
var Calendars = require('./src/js/dooray/view/calendars');
var TaskView = require('./src/js/dooray/view/taskview');
var CalendarForm = require('./src/js/dooray/view/form/calendar');

/** @namespace ne.dooray.calendar.service */

global.ne.util.defineNamespace('ne.dooray.calendar.service', {
    DoorayEvent: DoorayEvent,
    calendarAPI: calendarAPI,
    API: API,

    MiniCalendar: MiniCalendar,
    Calendars: Calendars,
    TaskView: TaskView,

    CalendarForm: CalendarForm
});

/**********
 * Calendar Factory
 **********/

var Calendar = require('./src/js/factory/calendar');
var ServiceCalendar = require('./src/js/dooray/factory/calendar');

global.ne.dooray.calendar.OriginCalendar = function (options, container) {
    return new Calendar(options, container);
};

global.ne.dooray.calendar.Calendar = function(options, container) {
    return new ServiceCalendar(options, container);
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./src/js/common/ajax":23,"./src/js/common/array":24,"./src/js/common/collection":26,"./src/js/common/common":27,"./src/js/common/datetime":28,"./src/js/common/dirty":29,"./src/js/common/domevent":30,"./src/js/common/domutil":31,"./src/js/common/model":32,"./src/js/common/point":33,"./src/js/common/reqAnimFrame":34,"./src/js/dooray/calendarAPI":37,"./src/js/dooray/controller/api":38,"./src/js/dooray/factory/calendar":41,"./src/js/dooray/model/event":44,"./src/js/dooray/view/calendars":46,"./src/js/dooray/view/form/calendar":48,"./src/js/dooray/view/minicalendar":52,"./src/js/dooray/view/taskview":54,"./src/js/factory/calendar":56,"./src/js/factory/controller":57,"./src/js/handler/allday/core":59,"./src/js/handler/allday/creation":60,"./src/js/handler/allday/creationGuide":61,"./src/js/handler/allday/move":62,"./src/js/handler/allday/moveGuide":63,"./src/js/handler/allday/resize":64,"./src/js/handler/allday/resizeGuide":65,"./src/js/handler/drag":66,"./src/js/handler/time/core":67,"./src/js/handler/time/creation":68,"./src/js/handler/time/creationGuide":69,"./src/js/handler/time/move":70,"./src/js/handler/time/moveGuide":71,"./src/js/handler/time/resize":72,"./src/js/handler/time/resizeGuide":73,"./src/js/model/event":74,"./src/js/model/viewModel/event":75,"./src/js/view/monthweek":77,"./src/js/view/template/registerHelpers":81,"./src/js/view/view":86,"./src/js/view/week/dayname":88,"./src/js/view/week/time":89,"./src/js/view/week/timeGrid":90,"./src/js/view/week/week":91,"code-snippet":2}],2:[function(require,module,exports){
/*!code-snippet v1.0.4 | NHN Entertainment*/
/**********
 * array.js
 **********/

/**
 * @fileoverview This module has some functions for handling array.
 * @author NHN Ent.
 *         FE Development Team <jiung.kang@nhnent.com>
 * @dependency type.js
 */

(function(ne) {
    'use strict';
    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    var aps = Array.prototype.slice;

    /**
     * Generate an integer Array containing an arithmetic progression.
     * @param {number} start
     * @param {number} stop
     * @param {number} step
     * @memberof ne.util
     * @returns {Array}
     * @example
     *
     *   var arr = ne.util.range(5);
     *   console.log(arr); // [0,1,2,3,4]
     *
     *   arr = ne.util.range(1, 5);
     *   console.log(arr); // [1,2,3,4]
     *
     *   arr = ne.util.range(2, 10, 2);
     *   console.log(arr); // [2,4,6,8]
     *
     *   arr = ne.util.range(10, 2, -2);
     *   console.log(arr); // [10,8,6,4]
     */
    var range = function(start, stop, step) {
        var arr = [],
            flag;

        if (ne.util.isUndefined(stop)) {
            stop = start || 0;
            start = 0;
        }

        step = step || 1;
        flag = step < 0 ? -1 : 1;
        stop *= flag;

        for(; start * flag < stop; start += step) {
            arr.push(start);
        }

        return arr;
    };

    /**
     * Zip together multiple lists into a single array
     * @param {...Array}
     * @memberof ne.util
     * @returns {Array}
     * @example
     *
     *   var result = ne.util.zip([1, 2, 3], ['a', 'b','c'], [true, false, true]);
     *
     *   console.log(result[0]); // [1, 'a', true]
     *   console.log(result[1]); // [2, 'b', false]
     *   console.log(result[2]); // [3, 'c', true]
     */
    var zip = function() {
        var arr2d = aps.call(arguments),
            result = [];

        ne.util.forEach(arr2d, function(arr) {
            ne.util.forEach(arr, function(value, index) {
                if (!result[index]) {
                    result[index] = [];
                }
                result[index].push(value);
            });
        });

        return result;
    };

    ne.util.range = range;
    ne.util.zip = zip;
})(window.ne);
/**********
 * browser.js
 **********/

/**
 * @fileoverview This module detects the kind of well-known browser and version.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @namespace ne.util
 */

(function(ne) {
    'use strict';
    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    /* istanbul ignore if */
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * This object has an information that indicate the kind of browser.<br>
     * The list below is a detectable browser list.
     *  - ie7 ~ ie11
     *  - chrome
     *  - firefox
     *  - safari
     * @memberof ne.util
     * @example
     *  ne.util.browser.chrome === true;    // chrome
     *  ne.util.browser.firefox === true;    // firefox
     *  ne.util.browser.safari === true;    // safari
     *  ne.util.browser.msie === true;    // IE
     *  ne.util.browser.other === true;    // other browser
     *  ne.util.browser.version;    // browser version
     */
    var browser = {
        chrome: false,
        firefox: false,
        safari: false,
        msie: false,
        others: false,
        version: 0
    };

    var nav = window.navigator,
        appName = nav.appName.replace(/\s/g, '_'),
        userAgent = nav.userAgent;

    var rIE = /MSIE\s([0-9]+[.0-9]*)/,
        rIE11 = /Trident.*rv:11\./,
        versionRegex = {
            'firefox': /Firefox\/(\d+)\./,
            'chrome': /Chrome\/(\d+)\./,
            'safari': /Version\/([\d\.]+)\sSafari\/(\d+)/
        };

    var key, tmp;

    var detector = {
        'Microsoft_Internet_Explorer': function() {
            // ie8 ~ ie10
            browser.msie = true;
            browser.version = parseFloat(userAgent.match(rIE)[1]);
        },
        'Netscape': function() {
            var detected = false;

            if (rIE11.exec(userAgent)) {
                browser.msie = true;
                browser.version = 11;
            } else {
                for (key in versionRegex) {
                    if (versionRegex.hasOwnProperty(key)) {
                        tmp = userAgent.match(versionRegex[key]);
                        if (tmp && tmp.length > 1) {
                            browser[key] = detected = true;
                            browser.version = parseFloat(tmp[1] || 0);
                            break;
                        }
                    }
                }
            }
            if (!detected) {
                browser.others = true;
            }
        }
    };

    detector[appName]();
    ne.util.browser = browser;
})(window.ne);

/**********
 * collection.js
 **********/

/**
 * @fileoverview This module has some functions for handling object as collection.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency type.js, object.js
 */

(function(ne) {
    'use strict';
    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * This variable saves whether the 'indexOf' method is in Array.prototype or not.<br>
     * And it will be checked only once when the page is loaded.
     * @type {boolean}
     */
    var hasIndexOf = !!Array.prototype.indexOf;

    /**
     * Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.<br>
     * If the callback function returns false, the loop will be stopped.<br>
     * Callback function(iteratee) is invoked with three arguments:
     *  - The value of the element
     *  - The index of the element
     *  - The array(or Array-like object) being traversed
     * @param {Array} arr The array(or Array-like object) that will be traversed
     * @param {function} iteratee Callback function
     * @param {Object} [context] Context(this) of callback function
     * @memberof ne.util
     * @example
     *  var sum = 0;
     *
     *  forEachArray([1,2,3], function(value){
     *      sum += value;
     *   });
     *  alert(sum); // 6
     */
    function forEachArray(arr, iteratee, context) {
        var index = 0,
            len = arr.length;

        context = context || null;

        for (; index < len; index++) {
            if (iteratee.call(context, arr[index], index, arr) === false) {
                break;
            }
        }
    }


    /**
     * Execute the provided callback once for each property of object which actually exist.<br>
     * If the callback function returns false, the loop will be stopped.<br>
     * Callback function(iteratee) is invoked with three arguments:
     *  - The value of the property
     *  - The name of the property
     *  - The object being traversed
     * @param {Object} obj The object that will be traversed
     * @param {function} iteratee  Callback function
     * @param {Object} [context] Context(this) of callback function
     * @memberof ne.util
     * @example
     *  var sum = 0;
     *
     *  forEachOwnProperties({a:1,b:2,c:3}, function(value){
     *      sum += value;
     *  });
     *  alert(sum); // 6
     **/
    function forEachOwnProperties(obj, iteratee, context) {
        var key;

        context = context || null;

        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (iteratee.call(context, obj[key], key, obj) === false) {
                    break;
                }
            }
        }
    }

    /**
     * Execute the provided callback once for each property of object(or element of array) which actually exist.<br>
     * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).<br>
     * If the callback function returns false, the loop will be stopped.<br>
     * Callback function(iteratee) is invoked with three arguments:
     *  - The value of the property(or The value of the element)
     *  - The name of the property(or The index of the element)
     *  - The object being traversed
     * @param {Object} obj The object that will be traversed
     * @param {function} iteratee Callback function
     * @param {Object} [context] Context(this) of callback function
     * @memberof ne.util
     * @example
     *  //ex1
     *  var sum = 0;
     *
     *  forEach([1,2,3], function(value){
     *      sum += value;
     *  });
     *  alert(sum); // 6
     *
     *  //ex2 - In case of Array-like object
     *  function sum(){
     *      var factors = Array.prototype.slice.call(arguments);
     *      forEach(factors, function(value){
     *           //......
     *      });
     *  }
     */
    function forEach(obj, iteratee, context) {
        if (ne.util.isArray(obj)) {
            ne.util.forEachArray(obj, iteratee, context);
        } else {
            ne.util.forEachOwnProperties(obj, iteratee, context);
        }
    }

    /**
     * Execute the provided callback function once for each element in an array, in order, and constructs a new array from the results.<br>
     * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of forEach example)<br>
     * Callback function(iteratee) is invoked with three arguments:
     *  - The value of the property(or The value of the element)
     *  - The name of the property(or The index of the element)
     *  - The object being traversed
     * @param {Object} obj The object that will be traversed
     * @param {function} iteratee Callback function
     * @param {Object} [context] Context(this) of callback function
     * @returns {Array} A new array composed of returned values from callback function
     * @memberof ne.util
     * @example
     *  var result = map([0,1,2,3], function(value) {
     *      return value + 1;
     *  });
     *
     *  alert(result);  // 1,2,3,4
     */
    function map(obj, iteratee, context) {
        var resultArray = [];

        context = context || null;

        ne.util.forEach(obj, function() {
            resultArray.push(iteratee.apply(context, arguments));
        });

        return resultArray;
    }

    /**
     * Execute the callback function once for each element present in the array(or Array-like object or plain object).<br>
     * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of forEach example)<br>
     * Callback function(iteratee) is invoked with four arguments:
     *  - The previousValue
     *  - The currentValue
     *  - The index
     *  - The object being traversed
     * @param {Object} obj The object that will be traversed
     * @param {function} iteratee Callback function
     * @param {Object} [context] Context(this) of callback function
     * @returns {*} The result value
     * @memberof ne.util
     * @example
     *  var result = reduce([0,1,2,3], function(stored, value) {
     *      return stored + value;
     *  });
     *
     *  alert(result); // 6
     */
    function reduce(obj, iteratee, context) {
        var keys,
            index = 0,
            length,
            store;

        context = context || null;

        if (!ne.util.isArray(obj)) {
            keys = ne.util.keys(obj);
        }

        length = keys ? keys.length : obj.length;

        store = obj[keys ? keys[index++] : index++];

        for (; index < length; index++) {
            store = iteratee.call(context, store, obj[keys ? keys[index] : index]);
        }

        return store;
    }
    /**
     * Transform the Array-like object to Array.<br>
     * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.
     * @param {*} arrayLike Array-like object
     * @return {Array} Array
     * @memberof ne.util
     * @example
     *  var arrayLike = {
     *      0: 'one',
     *      1: 'two',
     *      2: 'three',
     *      3: 'four',
     *      length: 4
     *  };
     *  var result = toArray(arrayLike);
     *
     *  alert(result instanceof Array); // true
     *  alert(result); // one,two,three,four
     */
    function toArray(arrayLike) {
        var arr;
        try {
            arr = Array.prototype.slice.call(arrayLike);
        } catch (e) {
            arr = [];
            forEachArray(arrayLike, function(value) {
                arr.push(value);
            });
        }
        return arr;
    }

    /**
     * Create a new array or plain object with all elements(or properties) that pass the test implemented by the provided function.<br>
     * Callback function(iteratee) is invoked with three arguments:
     *  - The value of the property(or The value of the element)
     *  - The name of the property(or The index of the element)
     *  - The object being traversed
     * @param {Object} obj Object(plain object or Array) that will be traversed
     * @param {function} iteratee Callback function
     * @param {Object} [context] Context(this) of callback function
     * @returns {Object} plain object or Array
     * @memberof ne.util
     * @example
     *  var result1 = filter([0,1,2,3], function(value) {
     *      return (value % 2 === 0);
     *  });
     *  alert(result1); // 0,2
     *
     *  var result2 = filter({a : 1, b: 2, c: 3}, function(value) {
     *      return (value % 2 !== 0);
     *  });
     *  alert(result2.a); // 1
     *  alert(result2.b); // undefined
     *  alert(result2.c); // 3
     */
    var filter = function(obj, iteratee, context) {
        var result,
            add;

        context = context || null;

        if (!ne.util.isObject(obj) || !ne.util.isFunction(iteratee)) {
            throw new Error('wrong parameter');
        }

        if (ne.util.isArray(obj)) {
            result = [];
            add = function(result, args) {
                result.push(args[0]);
            };
        } else {
            result = {};
            add = function(result, args) {
                result[args[1]] = args[0];
            };
        }

        ne.util.forEach(obj, function() {
            if (iteratee.apply(context, arguments)) {
                add(result, arguments);
            }
        }, context);

        return result;
    };

    /**
     * Returns the first index at which a given element can be found in the array from start index(default 0), or -1 if it is not present.<br>
     * It compares searchElement to elements of the Array using strict equality (the same method used by the ===, or triple-equals, operator).
     * @param {*} searchElement Element to locate in the array
     * @param {Array} array Array that will be traversed.
     * @param {number} startIndex Start index in array for searching (default 0)
     * @memberof ne.util
     * @return {number} the First index at which a given element, or -1 if it is not present
     * @example
     *
     *   var arr = ['one', 'two', 'three', 'four'],
     *       idx1,
     *       idx2;
     *
     *   idx1 = ne.util.inArray('one', arr, 3);
     *   alert(idx1); // -1
     *
     *   idx2 = ne.util.inArray('one', arr);
     *   alert(idx2); // 0
     */
    var inArray = function(searchElement, array, startIndex) {
        if (!ne.util.isArray(array)) {
            return -1;
        }

        if (hasIndexOf) {
            return Array.prototype.indexOf.call(array, searchElement, startIndex);
        }

        var i,
            length = array.length;

        // set startIndex
        if (ne.util.isUndefined(startIndex)) {
            startIndex = 0;
        } else if (startIndex >= length || startIndex < 0) {
            return -1;
        }

        // search
        for (i = startIndex; i < length; i++) {
            if (array[i] === searchElement) {
                return i;
            }
        }

        return -1;
    };

    /**
     * fetching a property
     * @param {Array} arr target collection
     * @param {String|Number} property property name
     * @memberof ne.util
     * @returns {Array}
     * @example
     *   var objArr = [
     *         {'abc': 1, 'def': 2, 'ghi': 3},
     *         {'abc': 4, 'def': 5, 'ghi': 6},
     *         {'abc': 7, 'def': 8, 'ghi': 9}
     *       ],
     *       arr2d = [
     *         [1, 2, 3],
     *         [4, 5, 6],
     *         [7, 8, 9]
     *       ],
     *       result;
     *
     *   result = ne.util.pluck(objArr, 'abc');
     *   console.log(result) // [1, 4, 7]
     *
     *   result = ne.util.pluck(arr2d, 2);
     *   console.log(result) // [3, 6, 9]
     */
    var pluck = function(arr, property) {
        var result = ne.util.map(arr, function(item) {
            return item[property];
        });
        return result;
    };

    ne.util.forEachOwnProperties = forEachOwnProperties;
    ne.util.forEachArray = forEachArray;
    ne.util.forEach = forEach;
    ne.util.toArray = toArray;
    ne.util.map = map;
    ne.util.reduce = reduce;
    ne.util.filter = filter;
    ne.util.inArray = inArray;
    ne.util.pluck = pluck;

})(window.ne);

/**********
 * customEvent.js
 **********/

/**
 * @fileoverview
 *  This module provides some functions for custom events.<br>
 *  And it is implemented in the observer design pattern.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency type.js, collection.js object.js
 */

(function(ne) {
    'use strict';
    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }

    /* istanbul ignore if */
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * A unit of event handler item.
     * @ignore
     * @typedef {Object} handlerItem
     * @property {function} fn - event handler
     * @property {*} ctx - context of event handler
     */

    /**
     * A data structure for storing handlerItems bound with a specific context
     *  and is a unit item of ctxEvents.<br>
     * Handlers in this item, will be executed with same event.
     * @ignore
     * @typedef {Object.<string, handlerItem>} ctxEventsItem
     * @example
     *  ctxEventsItem = {
     *      1_1: {
     *          fn: function(){...},
     *          ctx: context1
     *      },
     *      2_1: {
     *          fn: function(){...},
     *          ctx: context1
     *      }
     *  }
     */

    /**
     * A data structure for storing ctxEventsItem and length for each event(or event name).
     * @ignore
     * @typedef {Object.<string, (ctxEventsItem|number)>} ctxEvents
     * @example
     *  ctxEvents = {
     *      eventName1_idx: {
     *          1_1: {
     *              fn: function(){...},
     *              ctx: context1
     *          },
     *          2_1: {
     *              fn: function(){...},
     *              ctx: context1
     *          }
     *      },
     *      eventName1_len: 2,
     *      eventName2_idx: {
     *          3_2: {
     *              fn: function(){...},
     *              ctx: context2
     *          },
     *          4_2: {
     *              fn: function(){...},
     *              ctx: context2
     *          }
     *      },
     *      eventName2_len: 2
     *  };
     */


    /**
     * @constructor
     * @memberof ne.util
     */
    function CustomEvents() {
        /**
         * Caching a data structure that has normal event handlers which are not bound with a specific context.
         * @type {object.<string, handlerItem[]>}
         * @private
         */
        this._events = null;

        /**
         * Caching a {ctxEvents}
         * @type {ctxEvents}
         * @private
         */
        this._ctxEvents = null;
    }


    /**********
     * static
     **********/

    /**
     * Use for making a constructor to be able to do CustomEvent's functions.
     * @param {function} func - Constructor
     * @example
     *  function Model() {
     *      this.name = '';
     *  }
     *  ne.util.CustomEvents.mixin(Model);
     *
     *  var model = new Model();
     *  model.on('change', function() { this.name = 'model'; }, this);
     *  model.fire('change');
     *  alert(model.name); // 'model';
     */
    CustomEvents.mixin = function(func) {
        ne.util.extend(func.prototype, CustomEvents.prototype);
    };

    /**********
     * private
     **********/

    /**
     * Work similarly to Array.prototype.forEach(),
     *  however does Array.prototype.splice() additionally.<br>
     * Callback(iteratee) function is invoked with four arguments:
     *  - The value of the element
     *  - The index of the element
     *  - The array being traversed
     *  - A special callback function that decreases the length of array
     * @param {Array} arr - Array that will be traversed
     * @param {function} iteratee - Callback function
     */
    CustomEvents.prototype._forEachArraySplice = function(arr, iteratee) {
        var i,
            len,
            item,
            decrease = function() {
                arr.splice(i, 1);
                len -= 1;
                i -= 1;
            };

        if (!ne.util.isExisty(arr) || !ne.util.isArray(arr)) {
            return;
        }

        for (i = 0, len = arr.length; i < len; i++) {
            item = arr[i];

            if (iteratee(item, i, arr, decrease) === false) {
                return;
            }
        }
    };

    /**********
     * context event handler
     **********/

    /**
     * Execute the callback once for each ctxEventsItem.<br>
     * Callback function(iteratee) is invoked with three arguments:
     *  - {ctxEventsItem} A unit item of ctxEvents
     *  - {string} A key (ex - 'eventName_idx' or 'eventName_len')
     *  - {ctxEvents} A ctxEvents being traversed
     * @param {function} iteratee - Callback function
     * @private
     */
    CustomEvents.prototype._eachCtxEvents = function(iteratee) {
        var events = this._ctxEvents;
        ne.util.forEachOwnProperties(events, iteratee);
    };

    /**
     * Execute the callback once
     *  for each handler item that is value of the key including a specific string(=id, arguments[1]).<br>
     * Callback function(iteratee) is invoked with two arguments:
     *  - handlerItem
     *  - handlerItemId
     * @param {ctxEventsItem} ctxEventsItem - A data structure storing handlerItems.
     * @param {string} id - An id of handler for searching
     * @param {function} iteratee - Callback function
     * @private
     */
    CustomEvents.prototype._eachCtxHandlerItemByContainId = function(ctxEventsItem, id, iteratee) {
        ne.util.forEachOwnProperties(ctxEventsItem, function(handlerItem, handlerItemId) {
            if (handlerItemId.indexOf(id) > -1) {
                iteratee(handlerItem, handlerItemId);
            }
        });
    };

    /**
     * Execute the callback once
     *  for each case of when the provided handler(arguments[0]) is equal to a handler in ctxEventsItem.<br>
     * Callback function(iteratee) is invoked with four arguments:
     *  - handlerItem
     *  - handlerItemId
     *  - ctxEventsItem
     *  - eventKey, A Name of custom event (ex - 'eventName_idx')
     * @param {function} handler - Event handler
     * @param {function} iteratee - Callback function
     * @private
     */
    CustomEvents.prototype._eachCtxEventByHandler = function(handler, iteratee) {
        var handlerId = ne.util.stamp(handler),
            eachById = this._eachCtxHandlerItemByContainId;

        this._eachCtxEvents(function(ctxEventsItem, eventKey) {
            eachById(ctxEventsItem, handlerId, function(handlerItem, handlerItemId) {
                iteratee(handlerItem, handlerItemId, ctxEventsItem, eventKey);
            });
        });
    };

    /**
     * Execute the callback once
     *  for each case of when the provided context(arguments[0]) is equal to a context in ctxEventsItem.<br>
     * Callback function(iteratee) is invoked with four arguments:
     *  - handlerItem
     *  - handlerItemId
     *  - ctxEventsItem
     *  - eventKey, A Name of custom event with postfix (ex - 'eventName_idx')
     * @param {*} context - Context for searching
     * @param {function} iteratee - Callback function
     * @private
     */
    CustomEvents.prototype._eachCtxEventByContext = function(context, iteratee) {
        var contextId = ne.util.stamp(context),
            eachById = this._eachCtxHandlerItemByContainId;

        this._eachCtxEvents(function(ctxEventsItem, eventKey) {
            eachById(ctxEventsItem, contextId, function(handlerItem, handlerItemId) {
                iteratee(handlerItem, handlerItemId, ctxEventsItem, eventKey);
            });
        });
    };

    /**
     * Execute the callback once for each handler of ctxEventsItem of the provided eventName(arguments[0]).<br>
     * Callback function(iteratee) is invoked with four arguments:
     *  - handlerItem
     *  - handlerItemId
     *  - ctxEventsItem
     *  - eventKey, A Name of custom event with postfix (ex - 'eventName_idx')
     * @param {string} eventName - Custom event name
     * @param {function} iteratee - Callback function
     * @private
     */
    CustomEvents.prototype._eachCtxEventByEventName = function(eventName, iteratee) {
        if (!this._ctxEvents) {
            return;
        }

        var key = this._getCtxKey(eventName),
            ctxEventsItem = this._ctxEvents[key],
            args;

        ne.util.forEachOwnProperties(ctxEventsItem, function() {
            args = Array.prototype.slice.call(arguments);
            args.push(key);
            iteratee.apply(null, args);
        });
    };

    /**********
     * normal event handler
     **********/

    /**
     * Execute the callback once
     *  for each handler in instance equal to the provided handler(arguments[0]).<br>
     * Callback function(iteratee) is invoked with five arguments:
     *  - handlerItem
     *  - index of handlerItem array
     *  - eventList by handler
     *  - eventKey, A Name of custom event with postfix (ex - 'eventName_idx')
     *  - decrease, A special callback function that decreases the length of array.
     * @param {function} handler - A handler for searching
     * @param {function} iteratee - Callback function
     * @private
     */
    CustomEvents.prototype._eachEventByHandler = function(handler, iteratee) {
        var events = this._events,
            forEachArrayDecrease = this._forEachArraySplice,
            idx = 0;

        ne.util.forEachOwnProperties(events, function(eventList, eventKey) {
            forEachArrayDecrease(eventList, function(handlerItem, index, eventList, decrease) {
                if (handlerItem.fn === handler) {
                    iteratee(handlerItem, idx, eventList, eventKey, decrease);
                    idx += 1;
                }
            });
        });
    };

    /**
     * Execute the callback once for each handler of normal events of the provided eventName.<br>
     * Callback function(iteratee) is invoked with four arguments:
     *  - handler
     *  - index of handler-list
     *  - handler-list
     *  - decrease, A special callback function that decreases the length of array
     * @param {string} eventName - Custom event name
     * @param {function} iteratee - Callback function
     * @private
     */
    CustomEvents.prototype._eachEventByEventName = function(eventName, iteratee) {
        var events;

        if (!this._events) {
            return;
        }

        events = this._events[eventName];
        if (!ne.util.isExisty(events)) {
            return;
        }

        this._forEachArraySplice(events, iteratee);
    };

    /**
     * Return a new key for saving a handler with a context in event name.
     * @param {string} eventName A event name
     * @returns {string} Key
     * @private
     */
    CustomEvents.prototype._getCtxKey = function(eventName) {
        return eventName + '_idx';
    };

    /**
     * Return a new key for saving length of handlers in event name.
     * @param {string} eventName A event name
     * @returns {string} Key
     * @private
     */
    CustomEvents.prototype._getCtxLenKey = function(eventName) {
        return eventName + '_len';
    };

    /**
     * Return a new key for storing to ctxEventsItem.
     * @param {function} func A event handler
     * @param {*} ctx A context in handler
     * @returns {string} Key
     * @private
     */
    CustomEvents.prototype._getHandlerKey = function(func, ctx) {
        return ne.util.stamp(func) + '_' + ne.util.stamp(ctx);
    };


    /**
     * Set the length of handlers in ctxEventsItem.
     * @param {string} lenKey - A key for saving the length of handlers in `this._ctxEvents`
     * @param {number} change - A variation value of length
     * @private
     */
    CustomEvents.prototype._setCtxLen = function(lenKey, change) {
        var events = this._ctxEvents;

        if (!ne.util.isExisty(events[lenKey])) {
            events[lenKey] = 0;
        }

        events[lenKey] += change;
    };


    /**
     * Store a {handlerItem} to instance.
     * @param {string} eventName - Custom event name
     * @param {*} context - Context for binding
     * @param {function} handler - Handler function
     * @private
     */
    CustomEvents.prototype._addCtxEvent = function(eventName, context, handler) {
        var events = this._ctxEvents,
            key = this._getCtxKey(eventName),
            event;

        if (!ne.util.isExisty(events)) {
            events = this._ctxEvents = {};
        }

        event = events[key];
        if (!ne.util.isExisty(event)) {
            event = events[key] = {};
        }

        var lenKey = this._getCtxLenKey(eventName),
            handlerItemId = this._getHandlerKey(handler, context);

        event[handlerItemId] = {
            fn: handler,
            ctx: context
        };

        this._setCtxLen(lenKey, +1);
    };

    /**
     * Store a event handler without context to instance.
     * @param {string} eventName - Custom event name
     * @param {function} handler - Handler function
     * @private
     */
    CustomEvents.prototype._addNormalEvent = function(eventName, handler) {
        var events = this._events,
            event;

        if (!ne.util.isExisty(events)) {
            events = this._events = {};
        }

        event = events[eventName];
        if (!ne.util.isExisty(event)) {
            event = events[eventName] = [];
        }

        event.push({ fn: handler });
    };


    /**
     * Take the event handler off by handler(arguments[0])
     * @param {function} handler - Handler for offing
     * @private
     */
    CustomEvents.prototype._offByHandler = function(handler) {
        var ctxEvents = this._ctxEvents,
            lenKey;

        this._eachCtxEventByHandler(handler, function(handlerItem, hanId, ctxItems, eventKey) {
            lenKey = eventKey.replace('_idx', '_len');
            delete ctxItems[hanId];
            ctxEvents[lenKey] -= 1;
        });

        this._eachEventByHandler(handler, function(handlerItem, index, items, eventKey, decrease) {
            items.splice(index, 1);
            decrease();
        });
    };

    /**
     * Take the event handler off by context with event name
     * @param {*} context - Context
     * @param {(string|function)} [eventName] - Custom event name
     * @private
     */
    CustomEvents.prototype._offByContext = function(context, eventName) {
        var ctxEvents = this._ctxEvents,
            hasArgs = ne.util.isExisty(eventName),
            matchEventName,
            matchHandler,
            lenKey;

        this._eachCtxEventByContext(context, function(handlerItem, hanId, ctxItems, eventKey) {
            lenKey = eventKey.replace('_idx', '_len');

            matchEventName = hasArgs && ne.util.isString(eventName) && eventKey.indexOf(eventName) > -1;
            matchHandler = hasArgs && ne.util.isFunction(eventName) && handlerItem.fn === eventName;

            if (!hasArgs || (matchEventName || matchHandler)) {
                delete ctxItems[hanId];
                ctxEvents[lenKey] -= 1;
            }
        });
    };

    /**
     * Take the event handler off by event name with handler
     * @param {string} eventName - Custom event name
     * @param {function} [handler] - Event handler
     * @private
     */
    CustomEvents.prototype._offByEventName = function(eventName, handler) {
        var ctxEvents = this._ctxEvents,
            hasHandler = ne.util.isExisty(handler),
            lenKey;

        this._eachCtxEventByEventName(eventName, function(handlerItem, hanId, ctxItems, eventKey) {
            lenKey = eventKey.replace('_idx', '_len');
            if (!hasHandler || (hasHandler && handlerItem.fn === handler)) {
                delete ctxItems[hanId];
                ctxEvents[lenKey] -= 1;
            }
        });

        this._eachEventByEventName(eventName, function(handlerItem, index, items, decrease) {
            if (!hasHandler || (hasHandler && handlerItem.fn === handler)) {
                items.splice(index, 1);
                decrease();
            }
        });

    };

    /**********
     * public
     **********/

    /**
     * Attach the event handler with event name and context.
     * @param {(string|{name:string, handler:function})} eventName - Custom event name or an object {eventName: handler}
     * @param {(function|*)} [handler] - Handler function or context
     * @param {*} [context] - Context for binding
     * @example
     *  // 1. Basic
     *  customEvent.on('onload', handler);
     *
     *  // 2. With context
     *  customEvent.on('onload', handler, myObj);
     *
     *  // 3. Attach with an object
     *  customEvent.on({
     *    'play': handler,
     *    'pause': handler2
     *  });
     *
     *  // 4. Attach with an object with context
     *  customEvent.on({
     *    'play': handler
     *  }, myObj);
     */
    CustomEvents.prototype.on = function(eventName, handler, context) {
        var eventNameList;

        if (ne.util.isObject(eventName)) {
            // {eventName: handler}
            context = handler;
            ne.util.forEachOwnProperties(eventName, function(handler, name) {
                 this.on(name, handler, context);
            }, this);
            return;
        } else if (ne.util.isString(eventName) && eventName.indexOf(' ') > -1) {
            // processing of multiple events by split event name
            eventNameList = eventName.split(' ');
            ne.util.forEachArray(eventNameList, function(name) {
                this.on(name, handler, context);
            }, this);
            return;
        }

        var ctxId;

        if (ne.util.isExisty(context)) {
            ctxId = ne.util.stamp(context);
        }

        if (ne.util.isExisty(ctxId)) {
            this._addCtxEvent(eventName, context, handler);
        } else {
            this._addNormalEvent(eventName, handler);
        }
    };

    /**
     * Detach the event handler.
     * @param {(string|{name:string, handler:function})} eventName - Custom event name or an object {eventName: handler}
     * @param {function} [handler] Handler function
     * @example
     * // 1. off by context
     * customEvent.off(myObj);
     *
     * // 2. off by event name
     * customEvent.off('onload');
     *
     * // 3. off by handler
     * customEvent.off(handler);
     *
     * // 4. off by event name and handler
     * customEvent.off('play', handler);
     *
     * // 5. off by context and handler
     * customEvent.off(myObj, handler);
     *
     * // 6. off by context and event name
     * customEvent.off(myObj, 'onload');
     *
     * // 7. off by an Object.<string, function> that is {eventName: handler}
     * customEvent.off({
     *   'play': handler,
     *   'pause': handler2
     * });
     *
     * // 8. off the all events
     * customEvent.off();
     */
    CustomEvents.prototype.off = function(eventName, handler) {
        if (!arguments.length) {
            // 8. off the all events
            this._events = null;
            this._ctxEvents = null;
            return;
        }

        if (ne.util.isFunction(eventName)) {
            // 3. off by handler
            this._offByHandler(eventName);

        } else if (ne.util.isObject(eventName)) {
            if (ne.util.hasStamp(eventName)) {
                // 1, 5, 6 off by context
                this._offByContext(eventName, handler);
            } else {
                // 4. off by an Object.<string, function>
                ne.util.forEachOwnProperties(eventName, function(handler, name) {
                    this.off(name, handler);
                }, this);
            }

        } else {
            // 2, 4 off by event name
            this._offByEventName(eventName, handler);

        }
    };

    /**
     * Return a count of events registered.
     * @param {string} eventName - Custom event name
     * @returns {*}
     */
    CustomEvents.prototype.getListenerLength = function(eventName) {
        var ctxEvents = this._ctxEvents,
            events = this._events,
            existy = ne.util.isExisty,
            lenKey = this._getCtxLenKey(eventName);

        var normal = (existy(events) && ne.util.isArray(events[eventName])) ? events[eventName].length : 0,
            ctx = (existy(ctxEvents) && existy(ctxEvents[lenKey])) ? ctxEvents[lenKey] : 0;

        return normal + ctx;
    };

    /**
     * Return whether at least one of the handlers is registered in the given event name.
     * @param {string} eventName - Custom event name
     * @returns {boolean} Is there at least one handler in event name?
     */
    CustomEvents.prototype.hasListener = function(eventName) {
        return this.getListenerLength(eventName) > 0;
    };



    /**
     * Fire a event and returns the result of operation 'boolean AND' with all listener's results.<br>
     * So, It is different from {@link CustomEvents#fire}.<br>
     * In service code,
     *  use this as a before event in component level usually for notifying that the event is cancelable.
     * @param {string} eventName - Custom event name
     * @param {...*} data - Data for event
     * @returns {boolean} The result of operation 'boolean AND'
     * @example
     *  if (this.invoke('beforeZoom')) {    // check the result of 'beforeZoom'
     *      // if true,
     *      // doSomething
     *  }
     *
     *  // In service code,
     *  map.on({
     *      'beforeZoom': function() {
     *          if (that.disabled && this.getState()) {    // It should cancel the 'zoom' event by some conditions.
     *              return false;
     *          }
     *          return true;
     *      }
     *  });
     */
    CustomEvents.prototype.invoke = function(eventName, data) {
        if (!this.hasListener(eventName)) {
            return true;
        }

        var args = Array.prototype.slice.call(arguments, 1),
            self = this,
            result = true,
            existy = ne.util.isExisty;

        this._eachEventByEventName(eventName, function(item) {
            if (existy(item) && item.fn.apply(self, args) === false) {
                result = false;
            }
        });

        this._eachCtxEventByEventName(eventName, function(item) {
            if (existy(item) && item.fn.apply(item.ctx, args) === false) {
                result = false;
            }
        });

        return result;
    };

    /**
     * Fire a event by event name with data.
     * @param {string} eventName - Custom event name
     * @param {...*} data - Data for event
     * @return {Object} this
     * @example
     *  instance.on('move', function(direction) {
     *      var direction = direction;
     *  });
     *  instance.fire('move', 'left');
     */
    CustomEvents.prototype.fire = function(eventName, data) {
        this.invoke.apply(this, arguments);
        return this;
    };

    /**
     * Attach a one-shot event.
     * @param {(object|string)} eventName - Custom event name or an object {eventName: handler}
     * @param {function} fn - Handler function
     * @param {*} [context] - Context for binding
     */
    CustomEvents.prototype.once = function(eventName, fn, context) {
        var that = this;

        if (ne.util.isObject(eventName)) {
            ne.util.forEachOwnProperties(eventName, function(handler, eventName) {
                this.once(eventName, handler, fn);
            }, this);

            return;
        }

        function onceHandler() {
            fn.apply(context, arguments);
            that.off(eventName, onceHandler, context);
        }

        this.on(eventName, onceHandler, context);
    };

    ne.util.CustomEvents = CustomEvents;

})(window.ne);

/**********
 * defineClass.js
 **********/

/**
 * @fileoverview
 *  This module provides a function to make a constructor that can inherit from the other constructors like the CLASS easily.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency inheritance.js, object.js
 */

(function(ne) {
    'use strict';
    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    /* istanbul ignore if */
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * Help a constructor to be defined and to inherit from the other constructors
     * @param {*} [parent] Parent constructor
     * @param {Object} props Members of constructor
     *  @param {Function} props.init Initialization method
     *  @param {Object} [props.static] Static members of constructor
     * @returns {*} Constructor
     * @memberof ne.util
     * @example
     *  var Parent = defineClass({
     *      init: function() {
     *          this.name = 'made by def';
     *      },
     *      method: function() {
     *          //..can do something with this
     *      },
     *      static: {
     *          staticMethod: function() {
     *               //..do something
     *          }
     *      }
     *  });
     *
     *  var Child = defineClass(Parent, {
     *      method2: function() {}
     *  });
     *
     *  Parent.staticMethod();
     *
     *  var parentInstance = new Parent();
     *  console.log(parentInstance.name); //made by def
     *  parentInstance.staticMethod(); // Error
     *
     *  var childInstance = new Child();
     *  childInstance.method();
     *  childInstance.method2();
     */
    ne.util.defineClass = function(parent, props) {
        var obj;

        if (!props) {
            props = parent;
            parent = null;
        }

        obj = props.init || function(){};

        if(parent) {
            ne.util.inherit(obj, parent);
        }

        if (props.hasOwnProperty('static')) {
            ne.util.extend(obj, props.static);
            delete props.static;
        }

        ne.util.extend(obj.prototype, props);

        return obj;
    };

})(window.ne);

/**********
 * defineModule.js
 **********/

/**
 * @fileoverview Define module
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency type.js, defineNamespace.js
 */
(function(ne) {
    'use strict';
    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    /* istanbul ignore if */
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    var util = ne.util,
        INITIALIZATION_METHOD_NAME = 'initialize';

    /**
     * Define module
     * @param {string} namespace - Namespace of module
     * @param {Object} moduleDefinition - Object literal for module
     * @returns {Object} Defined module
     * @memberof ne.util
     * @example
     *     var myModule = ne.util.defineModule('modules.myModule', {
     *          name: 'john',
     *          message: '',
     *          initialize: function() {
     *              this.message = 'hello world';
     *          },
     *          getMessage: function() {
     *              return this.name + ': ' + this.message
     *          }
     *     });
     *
     *     console.log(myModule.getMessage());  // 'john: hello world';
     *     console.log(window.modules.myModule.getMessage());   // 'john: hello world';
     */
    function defineModule(namespace, moduleDefinition) {
        var base = moduleDefinition || {};

        if (util.isFunction(base[INITIALIZATION_METHOD_NAME])) {
            base[INITIALIZATION_METHOD_NAME]();
            delete base[INITIALIZATION_METHOD_NAME];
        }

        return util.defineNamespace(namespace, base, true);
    }
    ne.util.defineModule = defineModule;
})(window.ne);

/**********
 * defineNamespace.js
 **********/

/**
 * @fileoverview Define namespace
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency inheritance.js, object.js, collection.js
 */
(function(ne) {

    'use strict';
    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    /* istanbul ignore if */
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * Define namespace
     * @param {string} name - Module name
     * @param {(object|function)} props - A set of modules or one module
     * @param {boolean} isOverride flag - What if module already define, override or not
     * @returns {(object|function)} Defined namespace
     * @memberof ne.util
     * @example
     * var neComp = defineNamespace('ne.component');
     * neComp.listMenu = ne.util.defineClass({
     *      init: function() {
     *          // code
     *      }
     * });
     */
    var defineNamespace = function(name, props, isOverride) {
        var namespace,
            lastspace,
            result,
            module = getNamespace(name);

        if (!isOverride && isValidType(module)) {
            return module;
        }

        namespace = name.split('.');
        lastspace = namespace.pop();
        namespace.unshift(window);

        result = ne.util.reduce(namespace, function(obj, name) {
            obj[name] = obj[name] || {};
            return obj[name];
        });

        result[lastspace] = isValidType(props) ? props : {};

        return result[lastspace];

    };

    /**
     * Get namespace
     * @param {string} name - namespace
     * @returns {*}
     */
    var getNamespace = function(name) {
        var namespace,
            result;

        namespace = name.split('.');
        namespace.unshift(window);

        result = ne.util.reduce(namespace, function(obj, name) {
            return obj && obj[name];
        });
        return result;
    };

    /**
     * Check valid type
     * @param {*} module
     * @returns {boolean}
     */
    var isValidType = function(module) {
        return (ne.util.isObject(module) || ne.util.isFunction(module));
    };

    ne.util.defineNamespace = defineNamespace;

})(window.ne);
/**********
 * enum.js
 **********/

/**
 * @fileoverview This module provides a Enum Constructor.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency type, collection.js
 */

(function(ne) {

'use strict';

/* istanbul ignore if */
if (!ne) {
    ne = window.ne = {};
}
if (!ne.util) {
    ne.util = window.ne.util = {};
}

/**
 * Check whether the defineProperty() method is supported.
 * @type {boolean}
 */
var isSupportDefinedProperty = (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) {
        return false;
    }
}());

/**
 * A unique value of a constant.
 * @type {number}
 */
var enumValue = 0;

/**
 * Make a constant-list that has unique values.<br>
 * In modern browsers (except IE8 and lower),<br>
 *  a value defined once can not be changed.
 *
 * @param {...string | string[]} itemList Constant-list (An array of string is available)
 * @exports Enum
 * @constructor
 * @class
 * @memberof ne.util
 * @examples
 *  //create
 *  var MYENUM = new Enum('TYPE1', 'TYPE2');
 *  var MYENUM2 = new Enum(['TYPE1', 'TYPE2']);
 *
 *  //usage
 *  if (value === MYENUM.TYPE1) {
 *       ....
 *  }
 *
 *  //add (If a duplicate name is inputted, will be disregarded.)
 *  MYENUM.set('TYPE3', 'TYPE4');
 *
 *  //get name of a constant by a value
 *  MYENUM.getName(MYENUM.TYPE1); // 'TYPE1'이 리턴된다.
 *
 *  // In modern browsers (except IE8 and lower), a value can not be changed in constants.
 *  var originalValue = MYENUM.TYPE1;
 *  MYENUM.TYPE1 = 1234; // maybe TypeError
 *  MYENUM.TYPE1 === originalValue; // true
 *
 **/
function Enum(itemList) {
    if (itemList) {
        this.set.apply(this, arguments);
    }
}

/**
 * Define a constants-list
 * @param {...string| string[]} itemList Constant-list (An array of string is available)
 */
Enum.prototype.set = function(itemList) {
    var self = this;

    if (!ne.util.isArray(itemList)) {
        itemList = ne.util.toArray(arguments);
    }

    ne.util.forEach(itemList, function itemListIteratee(item) {
        self._addItem(item);
    });
};

/**
 * Return a key of the constant.
 * @param {number} value A value of the constant.
 * @returns {string|undefined} Key of the constant.
 */
Enum.prototype.getName = function(value) {
    var foundedKey,
        self = this;

    ne.util.forEach(this, function(itemValue, key) {
        if (self._isEnumItem(key) && value === itemValue) {
            foundedKey = key;
            return false;
        }
    });

    return foundedKey;
};

/**
 * Create a constant.
 * @private
 * @param {string} name Constant name. (It will be a key of a constant)
 */
Enum.prototype._addItem = function(name) {
    var value;

    if (!this.hasOwnProperty(name)) {
        value = this._makeEnumValue();

        if (isSupportDefinedProperty) {
            Object.defineProperty(this, name, {
                enumerable: true,
                configurable: false,
                writable: false,
                value: value
            });
        } else {
            this[name] = value;
        }
    }
};

/**
 * Return a unique value for assigning to a constant.
 * @private
 * @returns {number} A unique value
 */
Enum.prototype._makeEnumValue = function() {
    var value;

    value = enumValue;
    enumValue += 1;

    return value;
};

/**
 * Return whether a constant from the given key is in instance or not.
 * @param {string} key - A constant key
 * @returns {boolean} Result
 * @private
 */
Enum.prototype._isEnumItem = function(key) {
    return ne.util.isNumber(this[key]);
};

ne.util.Enum = Enum;

})(window.ne);

/**********
 * exMap.js
 **********/

/**
 * @fileoverview
 *  Implements the ExMap (Extended Map) object.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency Map.js, collection.js
 */

(function(ne) {
    'use strict';

    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    // Caching ne.util for performance enhancing
    var util = ne.util,
        mapAPIsForRead = ['get', 'has', 'forEach', 'keys', 'values', 'entries'],
        mapAPIsForDelete = ['delete', 'clear'];

    /**
     * The ExMap object is Extended Version of the ne.util.Map object.<br>
     * and added some useful feature to make it easy to manage the Map object.
     * @constructor
     * @param {Array} initData - Array of key-value pairs (2-element Arrays).
     *      Each key-value pair will be added to the new Map
     * @memberof ne.util
     */
    function ExMap(initData) {
        this._map = new util.Map(initData);
        this.size = this._map.size;
    }

    util.forEachArray(mapAPIsForRead, function(name) {
        ExMap.prototype[name] = function() {
            return this._map[name].apply(this._map, arguments);
        };
    });

    util.forEachArray(mapAPIsForDelete, function(name) {
        ExMap.prototype[name] = function() {
            var result = this._map[name].apply(this._map, arguments);
            this.size = this._map.size;
            return result;
        };
    });

    ExMap.prototype.set = function() {
        this._map.set.apply(this._map, arguments);
        this.size = this._map.size;
        return this;
    };

    /**
     * Sets all of the key-value pairs in the specified object to the Map object.
     * @param  {Object} object - Plain object that has a key-value pair
     */
    ExMap.prototype.setObject = function(object) {
        util.forEachOwnProperties(object, function(value, key) {
            this.set(key, value);
        }, this);
    };

    /**
     * Removes the elements associated with keys in the specified array.
     * @param  {Array} keys - Array that contains keys of the element to remove
     */
    ExMap.prototype.deleteByKeys = function(keys) {
        util.forEachArray(keys, function(key) {
            this['delete'](key);
        }, this);
    };

    /**
     * Sets all of the key-value pairs in the specified Map object to this Map object.
     * @param  {Map} map - Map object to be merged into this Map object
     */
    ExMap.prototype.merge = function(map) {
        map.forEach(function(value, key) {
            this.set(key, value);
        }, this);
    };

    /**
     * Looks through each key-value pair in the map and returns the new ExMap object of
     * all key-value pairs that pass a truth test implemented by the provided function.
     * @param  {function} predicate - Function to test each key-value pair of the Map object.<br>
     *      Invoked with arguments (value, key). Return true to keep the element, false otherwise.
     * @return {ExMap} A new ExMap object
     */
    ExMap.prototype.filter = function(predicate) {
        var filtered = new ExMap();

        this.forEach(function(value, key) {
            if (predicate(value, key)) {
                filtered.set(key, value);
            }
        });

        return filtered;
    };

    util.ExMap = ExMap;
})(window.ne);

/**********
 * formatDate.js
 **********/

/**
 * @fileoverview This module has a function for date format.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency type.js
 */

(function(ne) {
    'use strict';

    var tokens = /[\\]*YYYY|[\\]*YY|[\\]*MMMM|[\\]*MMM|[\\]*MM|[\\]*M|[\\]*DD|[\\]*D|[\\]*HH|[\\]*H|[\\]*A/gi,
        MONTH_STR = ["Invalid month", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        MONTH_DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        replaceMap = {
            M: function(date) {
                return Number(date.month);
            },
            MM: function(date) {
                var month = date.month;
                return (Number(month) < 10) ? '0' + month : month;
            },
            MMM: function(date) {
                return MONTH_STR[Number(date.month)].substr(0, 3);
            },
            MMMM: function(date) {
                return MONTH_STR[Number(date.month)];
            },
            D: function(date) {
                return Number(date.date);
            },
            d: function(date) {
                return replaceMap.D(date);
            },
            DD: function(date) {
                var dayInMonth = date.date;
                return (Number(dayInMonth) < 10) ? '0' + dayInMonth : dayInMonth;
            },
            dd: function(date) {
                return replaceMap.DD(date);
            },
            YY: function(date) {
                return Number(date.year) % 100;
            },
            yy: function(date) {
                return replaceMap.YY(date);
            },
            YYYY: function(date) {
                var prefix = '20',
                    year = date.year;
                if (year > 69 && year < 100) {
                    prefix = '19';
                }
                return (Number(year) < 100) ? prefix + String(year) : year;
            },
            yyyy: function(date) {
                return replaceMap.YYYY(date);
            },
            A: function(date) {
                return date.meridian;
            },
            a: function(date) {
                return date.meridian.toLowerCase();
            },
            hh: function(date) {
                var hour = date.hour;
                return (Number(hour) < 10) ? '0' + hour : hour;
            },
            HH: function(date) {
                return replaceMap.hh(date);
            },
            h: function(date) {
                return String(Number(date.hour));
            },
            H: function(date) {
                return replaceMap.h(date);
            },
            m: function(date) {
                return String(Number(date.minute));
            },
            mm: function(date) {
                var minute = date.minute;
                return (Number(minute) < 10) ? '0' + minute : minute;
            }
        };

    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    /* istanbul ignore if */
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * Check whether the given variables are valid date or not.
     * @param {number} year - Year
     * @param {number} month - Month
     * @param {number} date - Day in month.
     * @returns {boolean} Is valid?
     */
    function isValidDate(year, month, date) {
        var isValidYear,
            isValidMonth,
            isValid,
            lastDayInMonth;

        year = Number(year);
        month = Number(month);
        date = Number(date);

        isValidYear = (year > -1 && year < 100) || (year > 1969) && (year < 2070);
        isValidMonth = (month > 0) && (month < 13);

        if (!isValidYear || !isValidMonth) {
            return false;
        }

        lastDayInMonth = MONTH_DAYS[month];
        if (month === 2 && year % 4 === 0) {
            if (year % 100 !== 0 || year % 400 === 0) {
                lastDayInMonth = 29;
            }
        }

        isValid = (date > 0) && (date <= lastDayInMonth);
        return isValid;
    }

    /**
     * Return a string that transformed from the given form and date.
     * @param {string} form - Date form
     * @param {Date|Object} date - Date object
     * @returns {boolean|string} A transformed string or false.
     * @memberOf ne.util
     * @example
     *  // key         | Shorthand
     *  // ------------|-----------------------
     *  // years       | YY / YYYY / yy / yyyy
     *  // months(n)   | M / MM
     *  // months(str) | MMM / MMMM
     *  // days        | D / DD / d / dd
     *  // hours       | H / HH / h / hh
     *  // minutes     | m / mm
     *  // AM/PM       | A / a
     *
     *  var dateStr1 = formatDate('yyyy-MM-dd', {
     *      year: 2014,
     *      month: 12,
     *      date: 12
     *  });
     *  alert(dateStr1); // '2014-12-12'
     *
     *  var dateStr2 = formatDate('MMM DD YYYY HH:mm', {
     *      year: 1999,
     *      month: 9,
     *      date: 9,
     *      hour: 0,
     *      minute: 2
     *  })
     *  alert(dateStr2); // 'Sep 09 1999 00:02'
     *
     *  var dt = new Date(2010, 2, 13),
     *      dateStr3 = formatDate('yyyy년 M월 dd일', dt);
     *
     *  alert(dateStr3); // '2010년 3월 13일'
     */
    function formatDate(form, date) {
        var meridian,
            nDate,
            resultStr;

        if (ne.util.isDate(date)) {
            nDate = {
                year: date.getFullYear(),
                month: date.getMonth() + 1,
                date: date.getDate(),
                hour: date.getHours(),
                minute: date.getMinutes()
            };
        } else {
            nDate = {
                year: date.year,
                month: date.month,
                date: date.date,
                hour: date.hour,
                minute: date.minute
            };
        }

        if (!isValidDate(nDate.year, nDate.month, nDate.date)) {
            return false;
        }

        nDate.meridian = '';
        if (/[^\\][aA]\b/g.test(form)) {
            meridian = (nDate.hour > 12) ? 'PM' : 'AM';
            nDate.hour %= 12;
            nDate.meridian = meridian;
        }

        resultStr = form.replace(tokens, function(key) {
            if (key.indexOf('\\') > -1) {
                return key.replace(/\\/g, '');
            } else {
                return replaceMap[key](nDate) || '';
            }
        });
        return resultStr;
    }

    ne.util.formatDate = formatDate;
})(window.ne);


/**********
 * func.js
 **********/

/**
 * @fileoverview This module provides a bind() function for context binding.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 */

(function(ne) {
    'use strict';

    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * Create a new function that, when called, has its this keyword set to the provided value.
     * @param {function} fn A original function before binding
     * @param {*} obj context of function in arguments[0]
     * @return {function()} A new bound function with context that is in arguments[1]
     * @memberof ne.util
     */
    function bind(fn, obj) {
        var slice = Array.prototype.slice;

        if (fn.bind) {
            return fn.bind.apply(fn, slice.call(arguments, 1));
        }

        /* istanbul ignore next */
        var args = slice.call(arguments, 2);

        /* istanbul ignore next */
        return function() {
            /* istanbul ignore next */
            return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
        };
    }

    ne.util.bind = bind;

})(window.ne);

/**********
 * hashMap.js
 **********/

/**
 * @fileoverview This module provides the HashMap constructor.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency type, collection.js
 */

(function(ne) {
    'use strict';

    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * All the data in hashMap begin with _MAPDATAPREFIX;
     * @type {string}
     * @private
     */
    var _MAPDATAPREFIX = 'å';

    /**
     * HashMap can handle the key-value pairs.<br>
     * Caution:<br>
     *  HashMap instance has a length property but is not an instance of Array.
     * @param {Object} [obj] A initial data for creation.
     * @constructor
     * @memberof ne.util
     * @example
     *  var hm = new ne.util.HashMap({
     *      'mydata': {
     *           'hello': 'imfine'
     *       },
     *      'what': 'time'
     *  });
     */
    function HashMap(obj) {
        /**
         * size
         * @type {number}
         */
        this.length = 0;

        if (obj) {
            this.setObject(obj);
        }
    }

    /**
     * Set a data from the given key with value or the given object.
     * @param {string|Object} key A string or object for key
     * @param {*} [value] A data
     * @example
     *  var hm = new HashMap();
     *
     *  hm.set('key', 'value');
     *  hm.set({
     *      'key1': 'data1',
     *      'key2': 'data2'
     *  });
     */
    HashMap.prototype.set = function(key, value) {
        if(arguments.length === 2) {
            this.setKeyValue(key, value);
        } else {
            this.setObject(key);
        }
    };

    /**
     * Set a data from the given key with value.
     * @param {string} key A string for key
     * @param {*} value A data
     * @example
     *  var hm = new HashMap();
     *  hm.setKeyValue('key', 'value');
     */
    HashMap.prototype.setKeyValue = function(key, value) {
        if (!this.has(key)) {
            this.length += 1;
        }
        this[this.encodeKey(key)] = value;
    };

    /**
     * Set a data from the given object.
     * @param {Object} obj A object for data
     * @example
     *  var hm = new HashMap();
     *
     *  hm.setObject({
     *      'key1': 'data1',
     *      'key2': 'data2'
     *  });
     */
    HashMap.prototype.setObject = function(obj) {
        var self = this;

        ne.util.forEachOwnProperties(obj, function(value, key) {
            self.setKeyValue(key, value);
        });
    };

    /**
     * Merge with the given another hashMap.
     * @param {HashMap} hashMap Another hashMap instance
     */
    HashMap.prototype.merge = function(hashMap) {
        var self = this;

        hashMap.each(function(value, key) {
            self.setKeyValue(key, value);
        });
    };

    /**
     * Encode the given key for hashMap.
     * @param {string} key A string for key
     * @returns {string} A encoded key
     * @private
     */
    HashMap.prototype.encodeKey = function(key) {
        return _MAPDATAPREFIX + key;
    };

    /**
     * Decode the given key in hashMap.
     * @param {string} key A string for key
     * @returns {string} A decoded key
     * @private
     */
    HashMap.prototype.decodeKey = function(key) {
        var decodedKey = key.split(_MAPDATAPREFIX);
        return decodedKey[decodedKey.length-1];
    };

    /**
     * Return the value from the given key.
     * @param {string} key A string for key
     * @returns {*} The value from a key
     * @example
     *  var hm = new HashMap();
     *  hm.set('key', 'value');
     *
     *  hm.get('key') // value
     */
    HashMap.prototype.get = function(key) {
        return this[this.encodeKey(key)];
    };

    /**
     * Check the existence of a value from the key.
     * @param {string} key A string for key
     * @returns {boolean} Indicating whether a value exists or not.
     * @example
     *  var hm = new HashMap();
     *  hm.set('key', 'value');
     *
     *  hm.has('key') // true
     */
    HashMap.prototype.has = function(key) {
        return this.hasOwnProperty(this.encodeKey(key));
    };

    /**
     * Remove a data(key-value pairs) from the given key or the given key-list.
     * @param {...string|string[]} key A string for key
     * @returns {string|string[]} A removed data
     * @example
     *  var hm = new HashMap();
     *  hm.set('key', 'value');
     *  hm.set('key2', 'value');
     *
     *  //ex1
     *  hm.remove('key');
     *
     *  //ex2
     *  hm.remove('key', 'key2');
     *
     *  //ex3
     *  hm.remove(['key', 'key2']);
     */
    HashMap.prototype.remove = function(key) {
        if (arguments.length > 1) {
            key = ne.util.toArray(arguments);
        }

        return ne.util.isArray(key) ? this.removeByKeyArray(key) : this.removeByKey(key);
    };

    /**
     * Remove data(key-value pair) from the given key.
     * @param {string} key A string for key
     * @returns {*|null} A removed data
     * @example
     *  var hm = new HashMap();
     *  hm.set('key', 'value');
     *
     *  hm.removeByKey('key')
     */
    HashMap.prototype.removeByKey = function(key) {
        var data = this.has(key) ? this.get(key) : null;

        if (data !== null) {
            delete this[this.encodeKey(key)];
            this.length -= 1;
        }

        return data;
    };

    /**
     * Remove a data(key-value pairs) from the given key-list.
     * @param {string[]} keyArray An array of keys
     * @returns {string[]} A removed data
     * @example
     *  var hm = new HashMap();
     *  hm.set('key', 'value');
     *  hm.set('key2', 'value');
     *
     *  hm.removeByKeyArray(['key', 'key2']);
     */
    HashMap.prototype.removeByKeyArray = function(keyArray) {
        var data = [],
            self = this;

        ne.util.forEach(keyArray, function(key) {
            data.push(self.removeByKey(key));
        });

        return data;
    };

    /**
     * Remove all the data
     */
    HashMap.prototype.removeAll = function() {
        var self = this;

        this.each(function(value, key) {
            self.remove(key);
        });
    };

    /**
     * Execute the provided callback once for each all the data.
     * @param {Function} iteratee Callback function
     * @example
     *  var hm = new HashMap();
     *  hm.set('key', 'value');
     *  hm.set('key2', 'value');
     *
     *  hm.each(function(value, key) {
     *      //do something...
     *  });
     */
    HashMap.prototype.each = function(iteratee) {
        var self = this,
            flag;

        ne.util.forEachOwnProperties(this, function(value, key) {
            if (key.charAt(0) === _MAPDATAPREFIX) {
                flag = iteratee(value, self.decodeKey(key));
            }

            if (flag === false) {
                return flag;
            }
        });
    };

    /**
     * Return the key-list stored.
     * @returns {Array} A key-list
     * @example
     *  var hm = new HashMap();
     *  hm.set('key', 'value');
     *  hm.set('key2', 'value');
     *
     *  hm.keys();  //['key', 'key2');
     */
    HashMap.prototype.keys = function() {
        var keys = [],
            self = this;

        this.each(function(value, key) {
            keys.push(self.decodeKey(key));
        });

        return keys;
    };

    /**
     * Work similarly to Array.prototype.map().<br>
     * It executes the provided callback that checks conditions once for each element of hashMap,<br>
     *  and returns a new array having elements satisfying the conditions
     * @param {Function} condition A function that checks conditions
     * @returns {Array} A new array having elements satisfying the conditions
     * @example
     *  //ex1
     *  var hm = new HashMap();
     *  hm.set('key', 'value');
     *  hm.set('key2', 'value');
     *
     *  hm.find(function(value, key) {
     *      return key === 'key2';
     *  }); // ['value']
     *
     *  //ex2
     *  var hm = new HashMap({
     *      'myobj1': {
     *           visible: true
     *       },
     *      'mybobj2': {
     *           visible: false
     *       }
     *  });
     *
     *  hm.find(function(obj, key) {
     *      return obj.visible === true;
     *  }); // [{visible: true}];
     */
    HashMap.prototype.find = function(condition) {
        var founds = [];

        this.each(function(value, key) {
            if (condition(value, key)) {
                founds.push(value);
            }
        });

        return founds;
    };

    /**
     * Return a new Array having all values.
     * @returns {Array} A new array having all values
     */
    HashMap.prototype.toArray = function() {
        var result = [];

        this.each(function(v) {
            result.push(v);
        });

        return result;
    };

    ne.util.HashMap = HashMap;

})(window.ne);

/**********
 * inheritance.js
 **********/

/**
 * @fileoverview This module provides some simple function for inheritance.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 */

(function(ne) {
    'use strict';
    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    /* istanbul ignore if */
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }



    /**
     * Create a new object with the specified prototype object and properties.
     * @param {Object} obj This object will be a prototype of the newly-created object.
     * @return {Object}
     * @memberof ne.util
     */
    function createObject() {
        function F() {}

        return function(obj) {
            F.prototype = obj;
            return new F();
        };
    }

    /**
     * Provide a simple inheritance in prototype-oriented.
     * Caution :
     *  Don't overwrite the prototype of child constructor.
     *
     * @param {function} subType Child constructor
     * @param {function} superType Parent constructor
     * @memberof ne.util
     * @example
     *  // Parent constructor
     *  function Animal(leg) {
     *      this.leg = leg;
     *  }
     *
     *  Animal.prototype.growl = function() {
     *      // ...
     *  };
     *
     *  // Child constructor
     *  function Person(name) {
     *      this.name = name;
     *  }
     *
     *  // Inheritance
     *  core.inherit(Person, Animal);
     *
     *  // After this inheritance, please use only the extending of property.
     *  // Do not overwrite prototype.
     *  Person.prototype.walk = function(direction) {
     *      // ...
     *  };
     */
    function inherit(subType, superType) {
        var prototype = ne.util.createObject(superType.prototype);
        prototype.constructor = subType;
        subType.prototype = prototype;
    }

    ne.util.createObject = createObject();
    ne.util.inherit = inherit;

})(window.ne);

/**********
 * map.js
 **********/

/**
 * @fileoverview
 *  Implements the Map object.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency type.js, collection.js
 */

(function(ne) {
    'use strict';

    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }


    // Caching ne.util for performance enhancing
    var util = ne.util,

    /**
     * Using undefined for a key can be ambiguous if there's deleted item in the array,<br>
     * which is also undefined when accessed by index.<br>
     * So use this unique object as an undefined key to distinguish it from deleted keys.
     * @private
     * @constant
     */
    _KEY_FOR_UNDEFINED = {},

    /**
     * For using NaN as a key, use this unique object as a NaN key.<br>
     * This makes it easier and faster to compare an object with each keys in the array<br>
     * through no exceptional comapring for NaN.
     */
    _KEY_FOR_NAN = {};

    /**
     * Constructor of MapIterator<br>
     * Creates iterator object with new keyword.
     * @constructor
     * @param  {Array} keys - The array of keys in the map
     * @param  {function} valueGetter - Function that returns certain value,
     *      taking key and keyIndex as arguments.
     */
    function MapIterator(keys, valueGetter) {
        this._keys = keys;
        this._valueGetter = valueGetter;
        this._length = this._keys.length;
        this._index = -1;
        this._done = false;
    }

    /**
     * Implementation of Iterator protocol.
     * @return {{done: boolean, value: *}} Object that contains done(boolean) and value.
     */
    MapIterator.prototype.next = function() {
        var data = {};
        do {
           this._index += 1;
       } while (util.isUndefined(this._keys[this._index]) && this._index < this._length);

        if (this._index >= this._length) {
            data.done = true;
        } else {
            data.done = false;
            data.value = this._valueGetter(this._keys[this._index], this._index);
        }
        return data;
    };

    /**
     * The Map object implements the ES6 Map specification as closely as possible.<br>
     * For using objects and primitive values as keys, this object uses array internally.<br>
     * So if the key is not a string, get(), set(), has(), delete() will operates in O(n),<br>
     * and it can cause performance issues with a large dataset.
     *
     * Features listed below are not supported. (can't be implented without native support)
     * - Map object is iterable<br>
     * - Iterable object can be used as an argument of constructor
     *
     * If the browser supports full implementation of ES6 Map specification, native Map obejct
     * will be used internally.
     * @constructor
     * @param  {Array} initData - Array of key-value pairs (2-element Arrays).
     *      Each key-value pair will be added to the new Map
     * @memberof ne.util
     */
    function Map(initData) {
        this._valuesForString = {};
        this._valuesForIndex = {};
        this._keys = [];

        if (initData) {
            this._setInitData(initData);
        }

        this.size = 0;
    }

    /**
     * Add all elements in the initData to the Map object.
     * @private
     * @param  {Array} initData - Array of key-value pairs to add to the Map object
     */
    Map.prototype._setInitData = function(initData) {
        if (!util.isArray(initData)) {
            throw new Error('Only Array is supported.');
        }
        util.forEachArray(initData, function(pair) {
            this.set(pair[0], pair[1]);
        }, this);
    };

    /**
     * Returns true if the specified value is NaN.<br>
     * For unsing NaN as a key, use this method to test equality of NaN<br>
     * because === operator doesn't work for NaN.
     * @private
     * @param {*} value - Any object to be tested
     * @return {boolean} True if value is NaN, false otherwise.
     */
    Map.prototype._isNaN = function(value) {
        return typeof value === 'number' && value !== value;
    };

    /**
     * Returns the index of the specified key.
     * @private
     * @param  {*} key - The key object to search for.
     * @return {number} The index of the specified key
     */
    Map.prototype._getKeyIndex = function(key) {
        var result = -1,
            value;

        if (util.isString(key)) {
            value = this._valuesForString[key];
            if (value) {
                result = value.keyIndex;
            }
        } else {
            result = util.inArray(key, this._keys);
        }
        return result;
    };

    /**
     * Returns the original key of the specified key.
     * @private
     * @param  {*} key - key
     * @return {*} Original key
     */
    Map.prototype._getOriginKey = function(key) {
        var originKey = key;
        if (key === _KEY_FOR_UNDEFINED) {
            originKey = undefined;
        } else if (key === _KEY_FOR_NAN) {
            originKey = NaN;
        }
        return originKey;
    };

    /**
     * Returns the unique key of the specified key.
     * @private
     * @param  {*} key - key
     * @return {*} Unique key
     */
    Map.prototype._getUniqueKey = function(key) {
        var uniqueKey = key;
        if (util.isUndefined(key)) {
            uniqueKey = _KEY_FOR_UNDEFINED;
        } else if (this._isNaN(key)) {
            uniqueKey = _KEY_FOR_NAN;
        }
        return uniqueKey;
    };

    /**
     * Returns the value object of the specified key.
     * @private
     * @param  {*} key - The key of the value object to be returned
     * @param  {number} keyIndex - The index of the key
     * @return {{keyIndex: number, origin: *}} Value object
     */
    Map.prototype._getValueObject = function(key, keyIndex) {
        if (util.isString(key)) {
            return this._valuesForString[key];
        } else {
            if (util.isUndefined(keyIndex)) {
                keyIndex = this._getKeyIndex(key);
            }
            if (keyIndex >= 0) {
                return this._valuesForIndex[keyIndex];
            }
        }
    };

    /**
     * Returns the original value of the specified key.
     * @private
     * @param  {*} key - The key of the value object to be returned
     * @param  {number} keyIndex - The index of the key
     * @return {*} Original value
     */
    Map.prototype._getOriginValue = function(key, keyIndex) {
        return this._getValueObject(key, keyIndex).origin;
    };

    /**
     * Returns key-value pair of the specified key.
     * @private
     * @param  {*} key - The key of the value object to be returned
     * @param  {number} keyIndex - The index of the key
     * @return {Array} Key-value Pair
     */
    Map.prototype._getKeyValuePair = function(key, keyIndex) {
        return [this._getOriginKey(key), this._getOriginValue(key, keyIndex)];
    };

    /**
     * Creates the wrapper object of original value that contains a key index
     * and returns it.
     * @private
     * @param  {type} origin - Original value
     * @param  {type} keyIndex - Index of the key
     * @return {{keyIndex: number, origin: *}} Value object
     */
    Map.prototype._createValueObject = function(origin, keyIndex) {
        return {
            keyIndex: keyIndex,
            origin: origin
        };
    };

    /**
     * Sets the value for the key in the Map object.
     * @param  {*} key - The key of the element to add to the Map object
     * @param  {*} value - The value of the element to add to the Map object
     * @return {Map} The Map object
     */
    Map.prototype.set = function(key, value) {
        var uniqueKey = this._getUniqueKey(key),
            keyIndex = this._getKeyIndex(uniqueKey),
            valueObject;

        if (keyIndex < 0) {
            keyIndex = this._keys.push(uniqueKey) - 1;
            this.size += 1;
        }
        valueObject = this._createValueObject(value, keyIndex);

        if (util.isString(key)) {
            this._valuesForString[key] = valueObject;
        } else {
            this._valuesForIndex[keyIndex] = valueObject;
        }
        return this;
    };

    /**
     * Returns the value associated to the key, or undefined if there is none.
     * @param  {*} key - The key of the element to return
     * @return {*} Element associated with the specified key
     */
    Map.prototype.get = function(key) {
        var uniqueKey = this._getUniqueKey(key),
            value = this._getValueObject(uniqueKey);

        return value && value.origin;
    };

    /**
     * Returns a new Iterator object that contains the keys for each element
     * in the Map object in insertion order.
     * @return {Iterator} A new Iterator object
     */
    Map.prototype.keys = function() {
        return new MapIterator(this._keys, util.bind(this._getOriginKey, this));
    };

    /**
     * Returns a new Iterator object that contains the values for each element
     * in the Map object in insertion order.
     * @return {Iterator} A new Iterator object
     */
    Map.prototype.values = function() {
        return new MapIterator(this._keys, util.bind(this._getOriginValue, this));
    };

    /**
     * Returns a new Iterator object that contains the [key, value] pairs
     * for each element in the Map object in insertion order.
     * @return {Iterator} A new Iterator object
     */
    Map.prototype.entries = function() {
        return new MapIterator(this._keys, util.bind(this._getKeyValuePair, this));
    };

    /**
     * Returns a boolean asserting whether a value has been associated to the key
     * in the Map object or not.
     * @param  {*} key - The key of the element to test for presence
     * @return {boolean} True if an element with the specified key exists;
     *          Otherwise false
     */
    Map.prototype.has = function(key) {
        return !!this._getValueObject(key);
    };

    /**
     * Removes the specified element from a Map object.
     * @param {*} key - The key of the element to remove
     */
     // cannot use reserved keyword as a property name in IE8 and under.
    Map.prototype['delete'] = function(key) {
        var keyIndex;

        if (util.isString(key)) {
            if (this._valuesForString[key]) {
                keyIndex = this._valuesForString[key].keyIndex;
                delete this._valuesForString[key];
            }
        } else {
            keyIndex = this._getKeyIndex(key);
            if (keyIndex >= 0) {
                delete this._valuesForIndex[keyIndex];
            }
        }

        if (keyIndex >= 0) {
            delete this._keys[keyIndex];
            this.size -= 1;
        }
    };

    /**
     * Executes a provided function once per each key/value pair in the Map object,
     * in insertion order.
     * @param  {function} callback - Function to execute for each element
     * @param  {thisArg} thisArg - Value to use as this when executing callback
     */
    Map.prototype.forEach = function(callback, thisArg) {
        thisArg = thisArg || this;
        util.forEachArray(this._keys, function(key) {
            if (!util.isUndefined(key)) {
                callback.call(thisArg, this._getValueObject(key).origin, key, this);
            }
        }, this);
    };

    /**
     * Removes all elements from a Map object.
     */
    Map.prototype.clear = function() {
        Map.call(this);
    };

    // Use native Map object if exists.
    // But only latest versions of Chrome and Firefox support full implementation.
    (function() {
        var browser = util.browser;
        if (window.Map && (
            (browser.firefox && browser.version >= 37) ||
            (browser.chrome && browser.version >= 42) )) {
            Map = window.Map;
        }
    })();

    util.Map = Map;
})(window.ne);

/**********
 * object.js
 **********/

/**
 * @fileoverview This module has some functions for handling a plain object, json.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency type.js, collection.js
 */

(function(ne) {
    'use strict';
    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * Extend the target object from other objects.
     * @param {object} target - Object that will be extended
     * @param {...object} objects - Objects as sources
     * @return {object} Extended object
     * @memberOf ne.util
     */
    function extend(target, objects) {
        var source,
            prop,
            hasOwnProp = Object.prototype.hasOwnProperty,
            i,
            len;

        for (i = 1, len = arguments.length; i < len; i++) {
            source = arguments[i];
            for (prop in source) {
                if (hasOwnProp.call(source, prop)) {
                    target[prop] = source[prop];
                }
            }
        }
        return target;
    }

    /**
     * The last id of stamp
     * @type {number}
     */
    var lastId = 0;

    /**
     * Assign a unique id to an object
     * @param {object} obj - Object that will be assigned id.
     * @return {number} Stamped id
     * @memberOf ne.util
     */
    function stamp(obj) {
        obj.__fe_id = obj.__fe_id || ++lastId;
        return obj.__fe_id;
    }

    /**
     * Verify whether an object has a stamped id or not.
     * @param {object} obj
     * @returns {boolean}
     * @memberOf ne.util
     */
    function hasStamp(obj) {
        return ne.util.isExisty(ne.util.pick(obj, '__fe_id'));
    }

    /**
     * Reset the last id of stamp
     */
    function resetLastId() {
        lastId = 0;
    }

    /**
     * Return a key-list(array) of a given object
     * @param {object} obj - Object from which a key-list will be extracted
     * @returns {Array} A key-list(array)
     * @memberOf ne.util
     */
    function keys(obj) {
        var keys = [],
            key;

        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                keys.push(key);
            }
        }

        return keys;
    }

    /**
     * Return the equality for multiple objects(jsonObjects).<br>
     *  See {@link http://stackoverflow.com/questions/1068834/object-comparison-in-javascript}
     * @param {...object} object - Multiple objects for comparing.
     * @return {boolean} Equality
     * @example
     *
     *  var jsonObj1 = {name:'milk', price: 1000},
     *      jsonObj2 = {name:'milk', price: 1000},
     *      jsonObj3 = {name:'milk', price: 1000};
     *
     *  ne.util.compareJSON(jsonObj1, jsonObj2, jsonObj3);   // true
     *
     *
     *  var jsonObj4 = {name:'milk', price: 1000},
     *      jsonObj5 = {name:'beer', price: 3000};
     *
     *      ne.util.compareJSON(jsonObj4, jsonObj5); // false

     * @memberOf ne.util
     */
    function compareJSON(object) {
        var leftChain,
            rightChain,
            argsLen = arguments.length,
            i;

        function isSameObject(x, y) {
            var p;

            // remember that NaN === NaN returns false
            // and isNaN(undefined) returns true
            if (isNaN(x) &&
                isNaN(y) &&
                ne.util.isNumber(x) &&
                ne.util.isNumber(y)) {
                return true;
            }

            // Compare primitives and functions.
            // Check if both arguments link to the same object.
            // Especially useful on step when comparing prototypes
            if (x === y) {
                return true;
            }

            // Works in case when functions are created in constructor.
            // Comparing dates is a common scenario. Another built-ins?
            // We can even handle functions passed across iframes
            if ((ne.util.isFunction(x) && ne.util.isFunction(y)) ||
                (x instanceof Date && y instanceof Date) ||
                (x instanceof RegExp && y instanceof RegExp) ||
                (x instanceof String && y instanceof String) ||
                (x instanceof Number && y instanceof Number)) {
                return x.toString() === y.toString();
            }

            // At last checking prototypes as good a we can
            if (!(x instanceof Object && y instanceof Object)) {
                return false;
            }

            if (x.isPrototypeOf(y) ||
                y.isPrototypeOf(x) ||
                x.constructor !== y.constructor ||
                x.prototype !== y.prototype) {
                return false;
            }

            // check for infinitive linking loops
            if (ne.util.inArray(x, leftChain) > -1 ||
                ne.util.inArray(y, rightChain) > -1) {
                return false;
            }

            // Quick checking of one object beeing a subset of another.
            for (p in y) {
                if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                    return false;
                }
                else if (typeof y[p] !== typeof x[p]) {
                    return false;
                }
            }

            //This for loop executes comparing with hasOwnProperty() and typeof for each property in 'x' object,
            //and verifying equality for x[property] and y[property].
            for (p in x) {
                if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                    return false;
                }
                else if (typeof y[p] !== typeof x[p]) {
                    return false;
                }

                if (typeof(x[p]) === 'object' || typeof(x[p]) === 'function') {
                    leftChain.push(x);
                    rightChain.push(y);

                    if (!isSameObject(x[p], y[p])) {
                        return false;
                    }

                    leftChain.pop();
                    rightChain.pop();
                } else if (x[p] !== y[p]) {
                    return false;
                }
            }

            return true;
        }

        if (argsLen < 1) {
            return true;
        }

        for (i = 1; i < argsLen; i++) {
            leftChain = [];
            rightChain = [];

            if (!isSameObject(arguments[0], arguments[i])) {
                return false;
            }
        }

        return true;
    }

    /**
     * Retrieve a nested item from the given object/array
     * @param {object|Array} obj - Object for retrieving
     * @param {...string|number} paths - Paths of property
     * @returns {*} Value
     * @example
     *  var obj = {
     *      'key1': 1,
     *      'nested' : {
     *          'key1': 11,
     *          'nested': {
     *              'key1': 21
     *          }
     *      }
     *  };
     *  ne.util.pick(obj, 'nested', 'nested', 'key1'); // 21
     *  ne.util.pick(obj, 'nested', 'nested', 'key2'); // undefined
     *
     *  var arr = ['a', 'b', 'c'];
     *  ne.util.pick(arr, 1); // 'b'
     */
    function pick(obj, paths) {
        var args = arguments,
            target = args[0],
            length = args.length,
            i;
        try {
            for (i = 1; i < length; i++) {
                target = target[args[i]];
            }
            return target;
        } catch(e) {
            return;
        }
    }

    ne.util.extend = extend;
    ne.util.stamp = stamp;
    ne.util.hasStamp = hasStamp;
    ne.util._resetLastId = resetLastId;
    ne.util.keys = Object.keys || keys;
    ne.util.compareJSON = compareJSON;
    ne.util.pick = pick;
})(window.ne);

/**********
 * string.js
 **********/

/**
 * @fileoverview This module has some functions for handling the string.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 */

(function(ne) {
    'use strict';

    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * Transform the given HTML Entity string into plain string
     * @param {String} htmlEntity - HTML Entity type string
     * @return {String} Plain string
     * @memberof ne.util
     * @example
     *  var htmlEntityString = "A &#39;quote&#39; is &lt;b&gt;bold&lt;/b&gt;"
     *  var result = decodeHTMLEntity(htmlEntityString); //"A 'quote' is <b>bold</b>"
     */
    function decodeHTMLEntity(htmlEntity) {
        var entities = {'&quot;' : '"', '&amp;' : '&', '&lt;' : '<', '&gt;' : '>', '&#39;' : '\'', '&nbsp;' : ' '};
        return htmlEntity.replace(/&amp;|&lt;|&gt;|&quot;|&#39;|&nbsp;/g, function(m0) {
            return entities[m0] ? entities[m0] : m0;
        });
    }

    /**
     * Transform the given string into HTML Entity string
     * @param {String} html - String for encoding
     * @return {String} HTML Entity
     * @memberof ne.util
     * @example
     *  var htmlEntityString = "<script> alert('test');</script><a href='test'>";
     *  var result = encodeHTMLEntity(htmlEntityString); //"&lt;script&gt; alert(&#39;test&#39;);&lt;/script&gt;&lt;a href=&#39;test&#39;&gt;"
     */
    function encodeHTMLEntity(html) {
        var entities = {'"': 'quot', '&': 'amp', '<': 'lt', '>': 'gt', '\'': '#39'};
        return html.replace(/[<>&"']/g, function(m0) {
            return entities[m0] ? '&' + entities[m0] + ';' : m0;
        });
    }

    /**
     * Return whether the string capable to transform into plain string is in the given string or not.
     * @param {String} string
     * @memberof ne.util
     * @return {boolean}
     */
    function hasEncodableString(string) {
        return /[<>&"']/.test(string);
    }

    /**
     * Return duplicate charters
     * @param {string} operandStr1 The operand string
     * @param {string} operandStr2 The operand string
     * @private
     * @memberof ne.util
     * @returns {string}
     * @example
     * ne.util.getDuplicatedChar('fe dev', 'nhn entertainment');
     * => 'e'
     * ne.util.getDuplicatedChar('fdsa', 'asdf');
     * => 'asdf'
     */
    function getDuplicatedChar(operandStr1, operandStr2) {
        var dupl,
            key,
            i = 0,
            len = operandStr1.length,
            pool = {};

        for (; i < len; i += 1) {
            key = operandStr1.charAt(i);
            pool[key] = 1;
        }

        for (i = 0, len = operandStr2.length; i < len; i += 1) {
            key = operandStr2.charAt(i);
            if(pool[key]) {
                pool[key] += 1;
            }
        }

        pool = ne.util.filter(pool, function(item) {
            return item > 1;
        });

        pool = ne.util.keys(pool).sort();
        dupl = pool.join('');

        return dupl;
    }

    ne.util.decodeHTMLEntity = decodeHTMLEntity;
    ne.util.encodeHTMLEntity = encodeHTMLEntity;
    ne.util.hasEncodableString = hasEncodableString;
    ne.util.getDuplicatedChar = getDuplicatedChar;

})(window.ne);

/**********
 * tricks.js
 **********/

/**
 * @fileoverview collections of some technic methods.
 * @author NHN Ent. FE Development Team <e0242.nhnent.com>
 */

/** @namespace ne */
/** @namespace ne.util */

(function(ne) {
    'use strict';
    var aps = Array.prototype.slice;

    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    /* istanbul ignore if */
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * Creates a debounced function that delays invoking fn until after delay milliseconds has elapsed
     * since the last time the debouced function was invoked.
     * @param {function} fn The function to debounce.
     * @param {number} [delay=0] The number of milliseconds to delay
     * @memberof ne.util
     * @returns {function} debounced function.
     * @example
     *
     * function someMethodToInvokeDebounced() {}
     *
     * var debounced = ne.util.debounce(someMethodToInvokeDebounced, 300);
     *
     * // invoke repeatedly
     * debounced();
     * debounced();
     * debounced();
     * debounced();
     * debounced();
     * debounced();    // last invoke of debounced()
     *
     * // invoke someMethodToInvokeDebounced() after 300 milliseconds.
     */
    function debounce(fn, delay) {
        var timer,
            args;

        /* istanbul ignore next */
        delay = delay || 0;

        function debounced() {
            args = arguments;

            window.clearTimeout(timer);
            timer = window.setTimeout(function() {
                fn.apply(null, args);
            }, delay);
        }

        return debounced;
    }

    /**
     * return timestamp
     * @memberof ne.util
     * @returns {number} The number of milliseconds from Jan. 1970 00:00:00 (GMT)
     */
    function timestamp() {
        return +(new Date());
    }

    /**
     * Creates a throttled function that only invokes fn at most once per every interval milliseconds.
     *
     * You can use this throttle short time repeatedly invoking functions. (e.g MouseMove, Resize ...)
     *
     * if you need reuse throttled method. you must remove slugs (e.g. flag variable) related with throttling.
     * @param {function} fn function to throttle
     * @param {number} [interval=0] the number of milliseconds to throttle invocations to.
     * @memberof ne.util
     * @returns {function} throttled function
     * @example
     *
     * function someMethodToInvokeThrottled() {}
     *
     * var throttled = ne.util.throttle(someMethodToInvokeThrottled, 300);
     *
     * // invoke repeatedly
     * throttled();    // invoke (leading)
     * throttled();
     * throttled();    // invoke (near 300 milliseconds)
     * throttled();
     * throttled();
     * throttled();    // invoke (near 600 milliseconds)
     * // ...
     * // invoke (trailing)
     *
     * // if you need reuse throttled method. then invoke reset()
     * throttled.reset();
     */
    function throttle(fn, interval) {
        var base,
            _timestamp = ne.util.timestamp,
            debounced,
            isLeading = true,
            stamp,
            args,
            tick = function(_args) {
                fn.apply(null, _args);
                base = null;
            };

        /* istanbul ignore next */
        interval = interval || 0;

        debounced = ne.util.debounce(tick, interval);

        function throttled() {
            args = aps.call(arguments);

            if (isLeading) {
                tick(args);
                isLeading = false;
                return;
            }

            stamp = _timestamp();

            base = base || stamp;

            debounced();

            if ((stamp - base) >= interval) {
                tick(args);
            }
        }

        function reset() {
            isLeading = true;
            base = null;
        }

        throttled.reset = reset;
        return throttled;
    }

    ne.util.timestamp = timestamp;
    ne.util.debounce = debounce;
    ne.util.throttle = throttle;
})(window.ne);


/**********
 * type.js
 **********/

/**
 * @fileoverview This module provides some functions to check the type of variable
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency collection.js
 */

(function(ne) {
    'use strict';
    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * Check whether the given variable is existing or not.<br>
     *  If the given variable is not null and not undefined, returns true.
     * @param {*} param - Target for checking
     * @returns {boolean} Is existy?
     * @memberOf ne.util
     * @example
     *  ne.util.isExisty(''); //true
     *  ne.util.isExisty(0); //true
     *  ne.util.isExisty([]); //true
     *  ne.util.isExisty({}); //true
     *  ne.util.isExisty(null); //false
     *  ne.util.isExisty(undefined); //false
    */
    function isExisty(param) {
        return param != null;
    }

    /**
     * Check whether the given variable is undefined or not.<br>
     *  If the given variable is undefined, returns true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is undefined?
     * @memberOf ne.util
     */
    function isUndefined(obj) {
        return obj === undefined;
    }

    /**
     * Check whether the given variable is null or not.<br>
     *  If the given variable(arguments[0]) is null, returns true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is null?
     * @memberOf ne.util
     */
    function isNull(obj) {
        return obj === null;
    }

    /**
     * Check whether the given variable is truthy or not.<br>
     *  If the given variable is not null or not undefined or not false, returns true.<br>
     *  (It regards 0 as true)
     * @param {*} obj - Target for checking
     * @return {boolean} Is truthy?
     * @memberOf ne.util
     */
    function isTruthy(obj) {
        return isExisty(obj) && obj !== false;
    }

    /**
     * Check whether the given variable is falsy or not.<br>
     *  If the given variable is null or undefined or false, returns true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is falsy?
     * @memberOf ne.util
     */
    function isFalsy(obj) {
        return !isTruthy(obj);
    }


    var toString = Object.prototype.toString;

    /**
     * Check whether the given variable is an arguments object or not.<br>
     *  If the given variable is an arguments object, return true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is arguments?
     * @memberOf ne.util
     */
    function isArguments(obj) {
        var result = isExisty(obj) &&
            ((toString.call(obj) === '[object Arguments]') || !!obj.callee);

        return result;
    }

    /**
     * Check whether the given variable is an instance of Array or not.<br>
     *  If the given variable is an instance of Array, return true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is array instance?
     * @memberOf ne.util
     */
    function isArray(obj) {
        return obj instanceof Array;
    }

    /**
     * Check whether the given variable is an object or not.<br>
     *  If the given variable is an object, return true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is object?
     * @memberOf ne.util
     */
    function isObject(obj) {
        return obj === Object(obj);
    }

    /**
     * Check whether the given variable is a function or not.<br>
     *  If the given variable is a function, return true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is function?
     * @memberOf ne.util
     */
    function isFunction(obj) {
        return obj instanceof Function;
    }

    /**
     * Check whether the given variable is a number or not.<br>
     *  If the given variable is a number, return true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is number?
     * @memberOf ne.util
     */
    function isNumber(obj) {
        return typeof obj === 'number' || obj instanceof Number;
    }

    /**
     * Check whether the given variable is a string or not.<br>
     *  If the given variable is a string, return true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is string?
     * @memberOf ne.util
     */
    function isString(obj) {
        return typeof obj === 'string' || obj instanceof String;
    }

    /**
     * Check whether the given variable is a boolean or not.<br>
     *  If the given variable is a boolean, return true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is boolean?
     * @memberOf ne.util
     */
    function isBoolean(obj) {
        return typeof obj === 'boolean' || obj instanceof Boolean;
    }


    /**
     * Check whether the given variable is an instance of Array or not.<br>
     *  If the given variable is an instance of Array, return true.<br>
     *  (It is used for multiple frame environments)
     * @param {*} obj - Target for checking
     * @return {boolean} Is an instance of array?
     * @memberOf ne.util
     */
    function isArraySafe(obj) {
        return toString.call(obj) === '[object Array]';
    }

    /**
     * Check whether the given variable is a function or not.<br>
     *  If the given variable is a function, return true.<br>
     *  (It is used for multiple frame environments)
     * @param {*} obj - Target for checking
     * @return {boolean} Is a function?
     * @memberOf ne.util
     */
    function isFunctionSafe(obj) {
        return toString.call(obj) === '[object Function]';
    }

    /**
     * Check whether the given variable is a number or not.<br>
     *  If the given variable is a number, return true.<br>
     *  (It is used for multiple frame environments)
     * @param {*} obj - Target for checking
     * @return {boolean} Is a number?
     * @memberOf ne.util
     */
    function isNumberSafe(obj) {
        return toString.call(obj) === '[object Number]';
    }

    /**
     * Check whether the given variable is a string or not.<br>
     *  If the given variable is a string, return true.<br>
     *  (It is used for multiple frame environments)
     * @param {*} obj - Target for checking
     * @return {boolean} Is a string?
     * @memberOf ne.util
     */
    function isStringSafe(obj) {
        return toString.call(obj) === '[object String]';
    }

    /**
     * Check whether the given variable is a boolean or not.<br>
     *  If the given variable is a boolean, return true.<br>
     *  (It is used for multiple frame environments)
     * @param {*} obj - Target for checking
     * @return {boolean} Is a boolean?
     * @memberOf ne.util
     */
    function isBooleanSafe(obj) {
        return toString.call(obj) === '[object Boolean]';
    }

    /**
     * Check whether the given variable is a instance of HTMLNode or not.<br>
     *  If the given variables is a instance of HTMLNode, return true.
     * @param {*} html - Target for checking
     * @return {boolean} Is HTMLNode ?
     * @memberOf ne.util
     */
    function isHTMLNode(html) {
        if (typeof(HTMLElement) === 'object') {
            return (html && (html instanceof HTMLElement || !!html.nodeType));
        }
        return !!(html && html.nodeType);
    }

    /**
     * Check whether the given variable is a HTML tag or not.<br>
     *  If the given variables is a HTML tag, return true.
     * @param {*} html - Target for checking
     * @return {Boolean} Is HTML tag?
     * @memberOf ne.util
     */
    function isHTMLTag(html) {
        if (typeof(HTMLElement) === 'object') {
            return (html && (html instanceof HTMLElement));
        }
        return !!(html && html.nodeType && html.nodeType === 1);
    }

    /**
     * Check whether the given variable is empty(null, undefined, or empty array, empty object) or not.<br>
     *  If the given variables is empty, return true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is empty?
     * @memberOf ne.util
     */
    function isEmpty(obj) {
        var hasKey = false;

        if (!isExisty(obj)) {
            return true;
        }

        if (isString(obj) && obj === '') {
            return true;
        }

        if (isArray(obj) || isArguments(obj)) {
            return obj.length === 0;
        }

        if (isObject(obj) && !isFunction(obj)) {
            ne.util.forEachOwnProperties(obj, function() {
                hasKey = true;
                return false;
            });

            return !hasKey;
        }

        return true;

    }

    /**
     * Check whether the given variable is not empty(not null, not undefined, or not empty array, not empty object) or not.<br>
     *  If the given variables is not empty, return true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is not empty?
     * @memberOf ne.util
     */
    function isNotEmpty(obj) {
        return !isEmpty(obj);
    }

    /**
     * Check whether the given variable is an instance of Date or not.<br>
     *  If the given variables is an instance of Date, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is an instance of Date?
     * @memberOf ne.util
     */
    function isDate(obj) {
        return obj instanceof Date;
    }

    /**
     * Check whether the given variable is an instance of Date or not.<br>
     *  If the given variables is an instance of Date, return true.<br>
     *  (It is used for multiple frame environments)
     * @param {*} obj - Target for checking
     * @returns {boolean} Is an instance of Date?
     * @memberOf ne.util
     */
    function isDateSafe(obj) {
        return toString.call(obj) === '[object Date]';
    }


    ne.util.isExisty = isExisty;
    ne.util.isUndefined = isUndefined;
    ne.util.isNull = isNull;
    ne.util.isTruthy = isTruthy;
    ne.util.isFalsy = isFalsy;
    ne.util.isArguments = isArguments;
    ne.util.isArray = Array.isArray || isArray;
    ne.util.isArraySafe = Array.isArray || isArraySafe;
    ne.util.isObject = isObject;
    ne.util.isFunction = isFunction;
    ne.util.isFunctionSafe = isFunctionSafe;
    ne.util.isNumber = isNumber;
    ne.util.isNumberSafe = isNumberSafe;
    ne.util.isDate = isDate;
    ne.util.isDateSafe = isDateSafe;
    ne.util.isString = isString;
    ne.util.isStringSafe = isStringSafe;
    ne.util.isBoolean = isBoolean;
    ne.util.isBooleanSafe = isBooleanSafe;
    ne.util.isHTMLNode = isHTMLNode;
    ne.util.isHTMLTag = isHTMLTag;
    ne.util.isEmpty = isEmpty;
    ne.util.isNotEmpty = isNotEmpty;

})(window.ne);

/**********
 * window.js
 **********/

/**
 * @fileoverview This module has some methods for handling popup-window
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency browser.js, type.js, object.js, collection.js, func.js, window.js
 */

(function(ne) {
    'use strict';
    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    var popup_id = 0;

    /**
     * Popup management class
     * @constructor
     * @memberof ne.util
     */
    function Popup() {

        /**
         * Caching the window-contexts of opened popups
         * @type {Object}
         */
        this.openedPopup = {};

        /**
         * In IE7, an error occurs when the closeWithParent property attaches to window object.<br>
         * So, It is for saving the value of closeWithParent instead of attaching to window object.
         * @type {Object}
         */
        this.closeWithParentPopup = {};

        /**
         * Post data bridge for IE11 popup
         * @type {string}
         */
        this.postDataBridgeUrl = '';
    }

    /**********
     * public methods
     **********/

    /**
     * Returns a popup-list administered by current window.
     * @param {string} [key] The key of popup.
     * @returns {Object} popup window list object
     */
    Popup.prototype.getPopupList = function(key) {
        var target;
        if (ne.util.isExisty(key)) {
            target = this.openedPopup[key];
        } else {
            target = this.openedPopup;
        }
        return target;
    };

    /**
     * Open popup
     * Caution:
     *  In IE11, when transfer data to popup by POST, must set the postDataBridgeUrl.
     *
     * @param {string} url - popup url
     * @param {Object} options
     *     @param {string} [options.popupName] - Key of popup window.<br>
     *      If the key is set, when you try to open by this key, the popup of this key is focused.<br>
     *      Or else a new popup window having this key is opened.
     *
     *     @param {string} [options.popupOptionStr=""] - Option string of popup window<br>
     *      It is same with the third parameter of window.open() method.<br>
     *      See {@link http://www.w3schools.com/jsref/met_win_open.asp}
     *
     *     @param {boolean} [options.closeWithParent=true] - Is closed when parent window closed?
     *
     *     @param {boolean} [options.useReload=false] - This property indicates whether reload the popup or not.<br>
     *      If true, the popup will be reloaded when you try to re-open the popup that has been opened.<br>
     *      When transmit the POST-data, some browsers alert a message for confirming whether retransmit or not.
     *
     *     @param {string} [options.postDataBridgeUrl=''] - Use this url to avoid a certain bug occuring when transmitting POST data to the popup in IE11.<br>
     *      This specific buggy situation is known to happen because IE11 tries to open the requested url not in a new popup window as intended, but in a new tab.<br>
     *      See {@link http://wiki.nhnent.com/pages/viewpage.action?pageId=240562844}
     *
     *     @param {string} [options.method=get] - The method of transmission when the form-data is transmitted to popup-window.
     *
     *     @param {Object} [options.param=null] - Using as parameters for transmission when the form-data is transmitted to popup-window.
     */
    Popup.prototype.openPopup = function(url, options) {
        options = ne.util.extend({
            popupName: 'popup_' + popup_id + '_' + (+new Date()),
            popupOptionStr: '',
            useReload: true,
            closeWithParent: true,
            method: 'get',
            param: {}
        }, options || {});

        options.method = options.method.toUpperCase();

        this.postDataBridgeUrl = options.postDataBridgeUrl || this.postDataBridgeUrl;

        var popup,
            formElement,
            useIEPostBridge = options.method === 'POST' && options.param &&
                ne.util.browser.msie && ne.util.browser.version === 11;

        if (!ne.util.isExisty(url)) {
            throw new Error('Popup#open() 팝업 URL이 입력되지 않았습니다');
        }

        popup_id += 1;

        /*
         * In form-data transmission
         * 1. Create a form before opening a popup.
         * 2. Transmit the form-data.
         * 3. Remove the form after transmission.
         */
        if (options.param) {
            if (options.method === 'GET') {
                url = url + (/\?/.test(url) ? '&' : '?') + this._parameterize(options.param);
            } else if (options.method === 'POST') {
                if (!useIEPostBridge) {
                    formElement = this.createForm(url, options.param, options.method, options.popupName);
                    url = 'about:blank';
                }
            }
        }

        popup = this.openedPopup[options.popupName];

        if (!ne.util.isExisty(popup)) {
            this.openedPopup[options.popupName] = popup = this._open(useIEPostBridge, options.param,
                url, options.popupName, options.popupOptionStr);

        } else {
            if (popup.closed) {
                this.openedPopup[options.popupName] = popup = this._open(useIEPostBridge, options.param,
                    url, options.popupName, options.popupOptionStr);

            } else {
                if (options.useReload) {
                    popup.location.replace(url);
                }
                popup.focus();
            }
        }

        this.closeWithParentPopup[options.popupName] = options.closeWithParent;

        if (!popup || popup.closed || ne.util.isUndefined(popup.closed)) {
            alert('브라우저에 팝업을 막는 기능이 활성화 상태이기 때문에 서비스 이용에 문제가 있을 수 있습니다. 해당 기능을 비활성화 해 주세요');
        }

        if (options.param && options.method === 'POST' && !useIEPostBridge) {
            if (popup) {
                formElement.submit();
            }
            if (formElement.parentNode) {
                formElement.parentNode.removeChild(formElement);
            }
        }

        window.onunload = ne.util.bind(this.closeAllPopup, this);
    };

    /**
     * Close the popup
     * @param {boolean} [skipBeforeUnload] - If true, the 'window.onunload' will be null and skip unload event.
     * @param {Window} [popup] - Window-context of popup for closing. If omit this, current window-context will be closed.
     */
    Popup.prototype.close = function(skipBeforeUnload, popup) {
        skipBeforeUnload = ne.util.isExisty(skipBeforeUnload) ? skipBeforeUnload : false;

        var target = popup || window;

        if (skipBeforeUnload) {
            window.onunload = null;
        }

        if (!target.closed) {
            target.opener = window.location.href;
            target.close();
        }
    };

    /**
     * Close all the popups in current window.
     * @param {boolean} closeWithParent - If true, popups having the closeWithParentPopup property as true will be closed.
     */
    Popup.prototype.closeAllPopup = function(closeWithParent) {
        var hasArg = ne.util.isExisty(closeWithParent);

        ne.util.forEachOwnProperties(this.openedPopup, function(popup, key) {
            if ((hasArg && this.closeWithParentPopup[key]) || !hasArg) {
                this.close(false, popup);
            }
        }, this);
    };

    /**
     * Activate(or focus) the popup of the given name.
     * @param {string} popupName - Name of popup for activation
     */
    Popup.prototype.focus = function(popupName) {
        this.getPopupList(popupName).focus();
    };

    /**
     * Return an object made of parsing the query string.
     * @return {Object} An object having some information of the query string.
     * @private
     */
    Popup.prototype.parseQuery = function() {
        var search,
            pair,
            param = {};

        search = window.location.search.substr(1);
        ne.util.forEachArray(search.split('&'), function(part) {
            pair = part.split('=');
            param[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
        });

        return param;
    };

    /**
     * Create a hidden form from the given arguments and return this form.
     * @param {string} action - URL for form transmission
     * @param {Object} [data] - Data for form transmission
     * @param {string} [method] - Method of transmission
     * @param {string} [target] - Target of transmission
     * @param {HTMLElement} [container] - Container element of form.
     * @returns {HTMLElement} Form element
     */
    Popup.prototype.createForm = function(action, data, method, target, container) {
        var form = document.createElement('form'),
            input;

        container = container || document.body;

        form.method = method || 'POST';
        form.action = action || '';
        form.target = target || '';
        form.style.display = 'none';

        ne.util.forEachOwnProperties(data, function(value, key) {
            input = document.createElement('input');
            input.name = key;
            input.type = 'hidden';
            input.value = value;
            form.appendChild(input);
        });

        container.appendChild(form);

        return form;
    };

    /**********
     * private methods
     **********/

    /**
     * Return an query string made by parsing the given object
     * @param {Object} object - An object that has information for query string
     * @returns {string} - Query string
     * @private
     */
    Popup.prototype._parameterize = function(object) {
        var query = [];

        ne.util.forEachOwnProperties(object, function(value, key) {
            query.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
        });

        return query.join('&');
    };

    /**
     * Open popup
     * @param {boolean} useIEPostBridge - A switch option whether to use alternative of tossing POST data to the popup window in IE11
     * @param {Object} param - A data for tossing to popup
     * @param {string} url - Popup url
     * @param {string} popupName - Popup name
     * @param {string} optionStr - Setting for popup, ex) 'width=640,height=320,scrollbars=yes'
     * @returns {Window} Window context of popup
     * @private
     */
    Popup.prototype._open = function(useIEPostBridge, param, url, popupName, optionStr) {
        var popup;

        if (useIEPostBridge) {
            url = this.postDataBridgeUrl + '?storageKey=' + encodeURIComponent(popupName) +
            '&redirectUrl=' + encodeURIComponent(url);
            if (!window.localStorage) {
                alert('IE11브라우저의 문제로 인해 이 기능은 브라우저의 LocalStorage 기능을 활성화 하셔야 이용하실 수 있습니다');
            } else {
                localStorage.removeItem(popupName);
                localStorage.setItem(popupName, JSON.stringify(param));

                popup = window.open(url, popupName, optionStr);
            }
        } else {
            popup = window.open(url, popupName, optionStr);
        }

        return popup;
    };

    ne.util.popup = new Popup();

})(window.ne);

},{}],3:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _handlebarsBase = require('./handlebars/base');

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)

var base = _interopRequireWildcard(_handlebarsBase);

var _handlebarsSafeString = require('./handlebars/safe-string');

var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

var _handlebarsException = require('./handlebars/exception');

var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

var _handlebarsUtils = require('./handlebars/utils');

var Utils = _interopRequireWildcard(_handlebarsUtils);

var _handlebarsRuntime = require('./handlebars/runtime');

var runtime = _interopRequireWildcard(_handlebarsRuntime);

var _handlebarsNoConflict = require('./handlebars/no-conflict');

// For compatibility and usage outside of module systems, make the Handlebars object a namespace

var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

function create() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = _handlebarsSafeString2['default'];
  hb.Exception = _handlebarsException2['default'];
  hb.Utils = Utils;
  hb.escapeExpression = Utils.escapeExpression;

  hb.VM = runtime;
  hb.template = function (spec) {
    return runtime.template(spec, hb);
  };

  return hb;
}

var inst = create();
inst.create = create;

_handlebarsNoConflict2['default'](inst);

inst['default'] = inst;

exports['default'] = inst;
module.exports = exports['default'];


},{"./handlebars/base":4,"./handlebars/exception":7,"./handlebars/no-conflict":17,"./handlebars/runtime":18,"./handlebars/safe-string":19,"./handlebars/utils":20}],4:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.HandlebarsEnvironment = HandlebarsEnvironment;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _helpers = require('./helpers');

var _decorators = require('./decorators');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var VERSION = '4.0.3';
exports.VERSION = VERSION;
var COMPILER_REVISION = 7;

exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '== 1.x.x',
  5: '== 2.0.0-alpha.x',
  6: '>= 2.0.0-beta.1',
  7: '>= 4.0.0'
};

exports.REVISION_CHANGES = REVISION_CHANGES;
var objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials, decorators) {
  this.helpers = helpers || {};
  this.partials = partials || {};
  this.decorators = decorators || {};

  _helpers.registerDefaultHelpers(this);
  _decorators.registerDefaultDecorators(this);
}

HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: _logger2['default'],
  log: _logger2['default'].log,

  registerHelper: function registerHelper(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple helpers');
      }
      _utils.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn;
    }
  },
  unregisterHelper: function unregisterHelper(name) {
    delete this.helpers[name];
  },

  registerPartial: function registerPartial(name, partial) {
    if (_utils.toString.call(name) === objectType) {
      _utils.extend(this.partials, name);
    } else {
      if (typeof partial === 'undefined') {
        throw new _exception2['default']('Attempting to register a partial as undefined');
      }
      this.partials[name] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name) {
    delete this.partials[name];
  },

  registerDecorator: function registerDecorator(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple decorators');
      }
      _utils.extend(this.decorators, name);
    } else {
      this.decorators[name] = fn;
    }
  },
  unregisterDecorator: function unregisterDecorator(name) {
    delete this.decorators[name];
  }
};

var log = _logger2['default'].log;

exports.log = log;
exports.createFrame = _utils.createFrame;
exports.logger = _logger2['default'];


},{"./decorators":5,"./exception":7,"./helpers":8,"./logger":16,"./utils":20}],5:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultDecorators = registerDefaultDecorators;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _decoratorsInline = require('./decorators/inline');

var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

function registerDefaultDecorators(instance) {
  _decoratorsInline2['default'](instance);
}


},{"./decorators/inline":6}],6:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerDecorator('inline', function (fn, props, container, options) {
    var ret = fn;
    if (!props.partials) {
      props.partials = {};
      ret = function (context, options) {
        // Create a new partials stack frame prior to exec.
        var original = container.partials;
        container.partials = _utils.extend({}, original, props.partials);
        var ret = fn(context, options);
        container.partials = original;
        return ret;
      };
    }

    props.partials[options.args[0]] = options.fn;

    return ret;
  });
};

module.exports = exports['default'];


},{"../utils":20}],7:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var loc = node && node.loc,
      line = undefined,
      column = undefined;
  if (loc) {
    line = loc.start.line;
    column = loc.start.column;

    message += ' - ' + line + ':' + column;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  /* istanbul ignore else */
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, Exception);
  }

  if (loc) {
    this.lineNumber = line;
    this.column = column;
  }
}

Exception.prototype = new Error();

exports['default'] = Exception;
module.exports = exports['default'];


},{}],8:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultHelpers = registerDefaultHelpers;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _helpersBlockHelperMissing = require('./helpers/block-helper-missing');

var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

var _helpersEach = require('./helpers/each');

var _helpersEach2 = _interopRequireDefault(_helpersEach);

var _helpersHelperMissing = require('./helpers/helper-missing');

var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

var _helpersIf = require('./helpers/if');

var _helpersIf2 = _interopRequireDefault(_helpersIf);

var _helpersLog = require('./helpers/log');

var _helpersLog2 = _interopRequireDefault(_helpersLog);

var _helpersLookup = require('./helpers/lookup');

var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

var _helpersWith = require('./helpers/with');

var _helpersWith2 = _interopRequireDefault(_helpersWith);

function registerDefaultHelpers(instance) {
  _helpersBlockHelperMissing2['default'](instance);
  _helpersEach2['default'](instance);
  _helpersHelperMissing2['default'](instance);
  _helpersIf2['default'](instance);
  _helpersLog2['default'](instance);
  _helpersLookup2['default'](instance);
  _helpersWith2['default'](instance);
}


},{"./helpers/block-helper-missing":9,"./helpers/each":10,"./helpers/helper-missing":11,"./helpers/if":12,"./helpers/log":13,"./helpers/lookup":14,"./helpers/with":15}],9:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('blockHelperMissing', function (context, options) {
    var inverse = options.inverse,
        fn = options.fn;

    if (context === true) {
      return fn(this);
    } else if (context === false || context == null) {
      return inverse(this);
    } else if (_utils.isArray(context)) {
      if (context.length > 0) {
        if (options.ids) {
          options.ids = [options.name];
        }

        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      if (options.data && options.ids) {
        var data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
        options = { data: data };
      }

      return fn(context, options);
    }
  });
};

module.exports = exports['default'];


},{"../utils":20}],10:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('../utils');

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('each', function (context, options) {
    if (!options) {
      throw new _exception2['default']('Must pass iterator to #each');
    }

    var fn = options.fn,
        inverse = options.inverse,
        i = 0,
        ret = '',
        data = undefined,
        contextPath = undefined;

    if (options.data && options.ids) {
      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
    }

    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    if (options.data) {
      data = _utils.createFrame(options.data);
    }

    function execIteration(field, index, last) {
      if (data) {
        data.key = field;
        data.index = index;
        data.first = index === 0;
        data.last = !!last;

        if (contextPath) {
          data.contextPath = contextPath + field;
        }
      }

      ret = ret + fn(context[field], {
        data: data,
        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
      });
    }

    if (context && typeof context === 'object') {
      if (_utils.isArray(context)) {
        for (var j = context.length; i < j; i++) {
          if (i in context) {
            execIteration(i, i, i === context.length - 1);
          }
        }
      } else {
        var priorKey = undefined;

        for (var key in context) {
          if (context.hasOwnProperty(key)) {
            // We're running the iterations one step out of sync so we can detect
            // the last iteration without have to scan the object twice and create
            // an itermediate keys array.
            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1);
            }
            priorKey = key;
            i++;
          }
        }
        if (priorKey !== undefined) {
          execIteration(priorKey, i - 1, true);
        }
      }
    }

    if (i === 0) {
      ret = inverse(this);
    }

    return ret;
  });
};

module.exports = exports['default'];


},{"../exception":7,"../utils":20}],11:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('helperMissing', function () /* [args, ]options */{
    if (arguments.length === 1) {
      // A missing field in a {{foo}} construct.
      return undefined;
    } else {
      // Someone is actually trying to call something, blow up.
      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    }
  });
};

module.exports = exports['default'];


},{"../exception":7}],12:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('if', function (conditional, options) {
    if (_utils.isFunction(conditional)) {
      conditional = conditional.call(this);
    }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function (conditional, options) {
    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
  });
};

module.exports = exports['default'];


},{"../utils":20}],13:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('log', function () /* message, options */{
    var args = [undefined],
        options = arguments[arguments.length - 1];
    for (var i = 0; i < arguments.length - 1; i++) {
      args.push(arguments[i]);
    }

    var level = 1;
    if (options.hash.level != null) {
      level = options.hash.level;
    } else if (options.data && options.data.level != null) {
      level = options.data.level;
    }
    args[0] = level;

    instance.log.apply(instance, args);
  });
};

module.exports = exports['default'];


},{}],14:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('lookup', function (obj, field) {
    return obj && obj[field];
  });
};

module.exports = exports['default'];


},{}],15:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('with', function (context, options) {
    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    var fn = options.fn;

    if (!_utils.isEmpty(context)) {
      var data = options.data;
      if (options.data && options.ids) {
        data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
      }

      return fn(context, {
        data: data,
        blockParams: _utils.blockParams([context], [data && data.contextPath])
      });
    } else {
      return options.inverse(this);
    }
  });
};

module.exports = exports['default'];


},{"../utils":20}],16:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('./utils');

var logger = {
  methodMap: ['debug', 'info', 'warn', 'error'],
  level: 'info',

  // Maps a given level value to the `methodMap` indexes above.
  lookupLevel: function lookupLevel(level) {
    if (typeof level === 'string') {
      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
      if (levelMap >= 0) {
        level = levelMap;
      } else {
        level = parseInt(level, 10);
      }
    }

    return level;
  },

  // Can be overridden in the host environment
  log: function log(level) {
    level = logger.lookupLevel(level);

    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
      var method = logger.methodMap[level];
      if (!console[method]) {
        // eslint-disable-line no-console
        method = 'log';
      }

      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        message[_key - 1] = arguments[_key];
      }

      console[method].apply(console, message); // eslint-disable-line no-console
    }
  }
};

exports['default'] = logger;
module.exports = exports['default'];


},{"./utils":20}],17:[function(require,module,exports){
(function (global){
/* global window */
'use strict';

exports.__esModule = true;

exports['default'] = function (Handlebars) {
  /* istanbul ignore next */
  var root = typeof global !== 'undefined' ? global : window,
      $Handlebars = root.Handlebars;
  /* istanbul ignore next */
  Handlebars.noConflict = function () {
    if (root.Handlebars === Handlebars) {
      root.Handlebars = $Handlebars;
    }
  };
};

module.exports = exports['default'];


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],18:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.checkRevision = checkRevision;
exports.template = template;
exports.wrapProgram = wrapProgram;
exports.resolvePartial = resolvePartial;
exports.invokePartial = invokePartial;
exports.noop = noop;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _utils = require('./utils');

var Utils = _interopRequireWildcard(_utils);

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _base = require('./base');

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = _base.COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
    }
  }
}

function template(templateSpec, env) {
  /* istanbul ignore next */
  if (!env) {
    throw new _exception2['default']('No environment passed to template');
  }
  if (!templateSpec || !templateSpec.main) {
    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
  }

  templateSpec.main.decorator = templateSpec.main_d;

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  env.VM.checkRevision(templateSpec.compiler);

  function invokePartialWrapper(partial, context, options) {
    if (options.hash) {
      context = Utils.extend({}, context, options.hash);
      if (options.ids) {
        options.ids[0] = true;
      }
    }

    partial = env.VM.resolvePartial.call(this, partial, context, options);
    var result = env.VM.invokePartial.call(this, partial, context, options);

    if (result == null && env.compile) {
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, options);
    }
    if (result != null) {
      if (options.indent) {
        var lines = result.split('\n');
        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }

          lines[i] = options.indent + lines[i];
        }
        result = lines.join('\n');
      }
      return result;
    } else {
      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    }
  }

  // Just add water
  var container = {
    strict: function strict(obj, name) {
      if (!(name in obj)) {
        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
      }
      return obj[name];
    },
    lookup: function lookup(depths, name) {
      var len = depths.length;
      for (var i = 0; i < len; i++) {
        if (depths[i] && depths[i][name] != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === 'function' ? current.call(context) : current;
    },

    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,

    fn: function fn(i) {
      var ret = templateSpec[i];
      ret.decorator = templateSpec[i + '_d'];
      return ret;
    },

    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams, depths) {
      var programWrapper = this.programs[i],
          fn = this.fn(i);
      if (data || depths || blockParams || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      }
      return programWrapper;
    },

    data: function data(value, depth) {
      while (value && depth--) {
        value = value._parent;
      }
      return value;
    },
    merge: function merge(param, common) {
      var obj = param || common;

      if (param && common && param !== common) {
        obj = Utils.extend({}, common, param);
      }

      return obj;
    },

    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };

  function ret(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var data = options.data;

    ret._setup(options);
    if (!options.partial && templateSpec.useData) {
      data = initData(context, data);
    }
    var depths = undefined,
        blockParams = templateSpec.useBlockParams ? [] : undefined;
    if (templateSpec.useDepths) {
      if (options.depths) {
        depths = context !== options.depths[0] ? [context].concat(options.depths) : options.depths;
      } else {
        depths = [context];
      }
    }

    function main(context /*, options*/) {
      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    }
    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    return main(context, options);
  }
  ret.isTop = true;

  ret._setup = function (options) {
    if (!options.partial) {
      container.helpers = container.merge(options.helpers, env.helpers);

      if (templateSpec.usePartial) {
        container.partials = container.merge(options.partials, env.partials);
      }
      if (templateSpec.usePartial || templateSpec.useDecorators) {
        container.decorators = container.merge(options.decorators, env.decorators);
      }
    } else {
      container.helpers = options.helpers;
      container.partials = options.partials;
      container.decorators = options.decorators;
    }
  };

  ret._child = function (i, data, blockParams, depths) {
    if (templateSpec.useBlockParams && !blockParams) {
      throw new _exception2['default']('must pass block params');
    }
    if (templateSpec.useDepths && !depths) {
      throw new _exception2['default']('must pass parent depths');
    }

    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
  };
  return ret;
}

function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
  function prog(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var currentDepths = depths;
    if (depths && context !== depths[0]) {
      currentDepths = [context].concat(depths);
    }

    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
  }

  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}

function resolvePartial(partial, context, options) {
  if (!partial) {
    if (options.name === '@partial-block') {
      partial = options.data['partial-block'];
    } else {
      partial = options.partials[options.name];
    }
  } else if (!partial.call && !options.name) {
    // This is a dynamic partial that returned a string
    options.name = partial;
    partial = options.partials[partial];
  }
  return partial;
}

function invokePartial(partial, context, options) {
  options.partial = true;
  if (options.ids) {
    options.data.contextPath = options.ids[0] || options.data.contextPath;
  }

  var partialBlock = undefined;
  if (options.fn && options.fn !== noop) {
    options.data = _base.createFrame(options.data);
    partialBlock = options.data['partial-block'] = options.fn;

    if (partialBlock.partials) {
      options.partials = Utils.extend({}, options.partials, partialBlock.partials);
    }
  }

  if (partial === undefined && partialBlock) {
    partial = partialBlock;
  }

  if (partial === undefined) {
    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
  } else if (partial instanceof Function) {
    return partial(context, options);
  }
}

function noop() {
  return '';
}

function initData(context, data) {
  if (!data || !('root' in data)) {
    data = data ? _base.createFrame(data) : {};
    data.root = context;
  }
  return data;
}

function executeDecorators(fn, prog, container, depths, data, blockParams) {
  if (fn.decorator) {
    var props = {};
    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
    Utils.extend(prog, props);
  }
  return prog;
}


},{"./base":4,"./exception":7,"./utils":20}],19:[function(require,module,exports){
// Build out our basic SafeString type
'use strict';

exports.__esModule = true;
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
  return '' + this.string;
};

exports['default'] = SafeString;
module.exports = exports['default'];


},{}],20:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.extend = extend;
exports.indexOf = indexOf;
exports.escapeExpression = escapeExpression;
exports.isEmpty = isEmpty;
exports.createFrame = createFrame;
exports.blockParams = blockParams;
exports.appendContextPath = appendContextPath;
var escape = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;',
  '=': '&#x3D;'
};

var badChars = /[&<>"'`=]/g,
    possible = /[&<>"'`=]/;

function escapeChar(chr) {
  return escape[chr];
}

function extend(obj /* , ...source */) {
  for (var i = 1; i < arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }

  return obj;
}

var toString = Object.prototype.toString;

// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
/* eslint-disable func-style */
exports.toString = toString;
var isFunction = function isFunction(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
/* istanbul ignore next */
if (isFunction(/x/)) {
  exports.isFunction = isFunction = function (value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
exports.isFunction = isFunction;

/* eslint-enable func-style */

/* istanbul ignore next */
var isArray = Array.isArray || function (value) {
  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
};

// Older IE versions do not directly support indexOf so we must implement our own, sadly.
exports.isArray = isArray;

function indexOf(array, value) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
}

function escapeExpression(string) {
  if (typeof string !== 'string') {
    // don't escape SafeStrings, since they're already safe
    if (string && string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return '';
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = '' + string;
  }

  if (!possible.test(string)) {
    return string;
  }
  return string.replace(badChars, escapeChar);
}

function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

function createFrame(object) {
  var frame = extend({}, object);
  frame._parent = object;
  return frame;
}

function blockParams(params, ids) {
  params.path = ids;
  return params;
}

function appendContextPath(contextPath, id) {
  return (contextPath ? contextPath + '.' : '') + id;
}


},{}],21:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime')['default'];

},{"./dist/cjs/handlebars.runtime":3}],22:[function(require,module,exports){
module.exports = require("handlebars/runtime")["default"];

},{"handlebars/runtime":21}],23:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Module for full management of requesting AJAX from server.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;

/**
 * @constructor
 */
function AJAX() {}

AJAX.ERROR = {
    NOT_SUPPORT: '사용하시는 브라우저가 서비스 이용에 필요한 필수 기능을 지원하지 않습니다. 최신 버전의 브라우저를 사용해 주세요.'
};

/**********
 * ajax
 **********/

/**
 * 비동기 요청을 위한 객체를 만들어 반환한다
 * @return {(XMLHttpRequest|ActiveXObject)} 비동기 통신 지원 객체
 */
AJAX.prototype._createXHR = function() {
    if (util.isExisty(util.pick(window, 'XMLHttpRequest'))) {
        return new XMLHttpRequest();
    } else if (util.isExisty(util.pick(window, 'ActiveXObject'))) {
        return new ActiveXObject('Microsoft.XMLHTTP'); // jshint ignore:line
    }

    window.alert(AJAX.ERROR.NOT_SUPPORT);
};

/**
 * 타입에 따라 데이터를 추가 가공한다
 *
 * TODO: 현재는 JSON데이터만 처리중이고 필요에 따라 늘어나야 한다
 * @param {string} dataType 데이터 타입
 * @param {*} data 가공할 데이터
 * @return {*} 가공된 데이터
 */
AJAX.prototype._processRawData = function(dataType, data) {
    var result = data;
    if (dataType === 'json') {
        try {
            result = JSON.parse(data);
        } catch (e) {
            result = data;
        }
    }

    return result;
};

/**
 * XHR의 응답 데이터를 처리한다
 * @param {object} options - ajax옵션 객체
 * @param {(XMLHttpRequest|ActiveXObject)} xhr - 비동기 요청 객체
 */
AJAX.prototype._onReadyStateChange = function(options, xhr) {
    var status,
        response,
        responseHeader;

    if (xhr.readyState !== 4) {
        return;
    }

    status = xhr.status;

    if ((status >= 200 && status < 300) || status === 304) {
        response = this._processRawData(options.dataType, xhr.responseText);
        responseHeader = util.pick(response, 'header');

        if (!responseHeader) {
            options.error();
        } else if (responseHeader.isSuccessful) {
            options.success(response);
        } else {
            options.fail(response);
        }
    } else if (status !== 0) {
        options.error();
    }

    options.complete();
};


/**
 * ajax 요청을 수행한다.
 * 
 * 요청 타입에 따른 추가 데이터 처리는 따로 하지 않으므로 사전에 미리 준비해야 한다
 * 예를 들어, get요청은 QueryString으로 url을 설정해야 하고, post등의 data를 사용하
 * 는 요청은 미리 stringfy된 값을 data옵션으로 전달해야 한다.
 *
 * @param {string} url ajax요청 할 url
 * @param {Object} options 옵션
 * @param {string} [options.method='POST'] 요청 시 사용할 http methods
 * @param {boolean} [options.async=true] 비동기 요청 사용 여부
 * @param {string} [options.type='application/json; charset=utf-8'] type 헤더 값
 * @param {string} [options.contentType='application/json'] Content-Type 헤더 값
 * @param {string} [options.dataType='json'] 서버에서 응답받기 바라는 결과의 타입
 * @param {function} [optoins.success] - isSuccessful true에 대한 콜백
 * @param {function} [options.fail] - isSuccessful false 에 대한 콜백
 * @param {function} [options.error] 요청에 대한 에러 발생 시 수행할 콜백
 * @param {function} [options.complete] 요청이 끝났을 때 (성공, 실패 여부와 무관) 수행하는 콜백
 * @param {bollean} [options.cache=true] - false 일 경우 timestamp 파라미터를 url에 붙여 캐시를 무시
 */
AJAX.prototype.ajax = function(url, options) {
    var xhr,
        data,
        separator,
        defaultOptions = {
            method: 'GET',
            async: true,
            type: 'application/json; charset=utf-8',
            contentType: 'application/json',
            dataType: 'json',
            success: function() {},
            fail: function() {},
            error: function() {},
            complete: function() {},
            cache: true
        };

    options = util.extend(defaultOptions, options);
    data = util.pick(options, 'data');
    if (!options.cache) {
        separator = ~url.indexOf('?') ? '&' : '?';
        url = url + separator + '_=' + +(new Date());
    }

    xhr = this._createXHR();
    xhr.open(options.method, url, options.async);
    xhr.setRequestHeader('type', options.type);
    xhr.setRequestHeader('content-type', options.contentType);
    xhr.onreadystatechange = util.bind(this._onReadyStateChange, this, options, xhr);
    xhr.send(data ? data : null);
};

module.exports = AJAX;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],24:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Utility module for array sort, binary search.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../common/datetime');

/**
 * A module for sorting array.
 * @module array
 */

/**********
 * Search
 **********/

/**
 * search item index using binary search algorithm.
 *
 * the array must be sorted.
 * @param {array} arr array to search.
 * @param {(string|number|boolean)} search value to search.
 * @param {function} [fn] iteratee for retrieve each element's value to search.
 * @param {function} [compare] compare function for specific sort status. default is string ascending.
 * @returns {number} The number of item index searched. return negative number when no exist that item.
 * It can use insert index after Math.abs()
 * @example
 *
 * var arr = [1, 3, 7, 11, 15, 23];
 *
 * function sortNumber(a, b) {
 *     return a - b;
 * }
 *
 * bsearch(arr, 15, null, sortNumber);    // 4
 * bsearch(arr, 21, null, sortNumber);    // -5
 *
 * arr.splice(Math.abs(bsearch(arr, 21, null, sortNumber)), 0, 21);
 * // [1, 2, 7, 11, 15, 21, 23]
 */
function bsearch(arr, search, fn, compare) {
    var minIndex = 0,
        maxIndex = arr.length - 1,
        currentIndex,
        value,
        comp;

    compare = compare || stringASC;

    while (minIndex <= maxIndex) {
        currentIndex = (minIndex + maxIndex) / 2 | 0;    // Math.floor
        value = fn ? fn(arr[currentIndex]) : arr[currentIndex];
        comp = compare(value, search);

        if (comp < 0) {
            minIndex = currentIndex + 1;
        } else if (comp > 0) {
            maxIndex = currentIndex - 1;
        } else {
            return currentIndex;
        }
    }

    return ~maxIndex;
}

/**********
 * Compare Functions
 **********/

/**
 * compare function for array sort.
 *
 * sort array by ascending.
 * @param {boolean} a The boolean to compare
 * @param {boolean} b The boolean to compare.
 * @returns {number} Result of comparison.
 */
function booleanASC(a, b) {
    if (a !== b) {
        return a ? -1 : 1;
    }
    return 0;
}

/**
 * compare function for array sort.
 *
 * sort array by descending.
 * @param {boolean} a The boolean to compare
 * @param {boolean} b The boolean to compare.
 * @returns {number} Result of comparison.
 */
function booleanDESC(a, b) {
    if (a !== b) {
        return a ? 1 : -1;
    }
    return 0;
}

/**
 * compare function for array sort.
 *
 * sort array by number ascending.
 * @param {number} _a The number to compare.
 * @param {number} _b The number to compare.
 * @returns {number} Result of comparison.
 */
function numberASC(_a, _b) {
    var a = +_a,
        b = +_b;

    return a - b;
}

/**
 * compare function for array sort.
 *
 * sort array by number descending.
 * @param {number} _a The number to compare.
 * @param {number} _b The number to compare.
 * @returns {number} Result of comparison.
 */
function numberDESC(_a, _b) {
    var a = +_a,
        b = +_b;

    return b - a;
}

/**
 * compare function for array sort.
 *
 * sort array by string ascending
 * @param {string} _a The string to compare.
 * @param {string} _b The string to compare.
 * @returns {number} Result of comparison.
 */
function stringASC(_a, _b) {
    var a = _a + '',
        b = _b + '';

    if (a > b) {
        return 1;
    } else if (a < b) {
        return -1;
    }

    return 0;
}

/**
 * compare function for array sort.
 *
 * sort array by string descending
 * @param {string} _a The string to compare.
 * @param {string} _b The string to compare.
 * @returns {number} Result of comparison.
 */
function stringDESC(_a, _b) {
    var a = _a + '',
        b = _b + '';

    if (a > b) {
        return -1;
    } else if (a < b) {
        return 1;
    }

    return 0;
}

/**
 * compare function for array sort.
 *
 * sort array by string ascending with ignore case.
 * @param {string} _a The string to compare.
 * @param {string} _b The string to compare.
 * @returns {number} Result of comparison.
 */
function stringASCIgnoreCase(_a, _b) {
    var a = (_a + '').toLowerCase(),
        b = (_b + '').toLowerCase();

    if (a > b) {
        return 1;
    } else if (a < b) {
        return -1;
    }

    return 0;
}

/**
 * compare function for array sort.
 *
 * sort array by string descending with ignore case.
 * @param {string} _a The string to compare.
 * @param {string} _b The string to compare.
 * @returns {number} Result of comparison.
 */
function stringDESCIgnoreCase(_a, _b) {
    var a = (_a + '').toLowerCase(),
        b = (_b + '').toLowerCase();

    if (a > b) {
        return -1;
    } else if (a < b) {
        return 1;
    }

    return 0;
}

/**
 * Compare event models for sort.
 *
 * 1. all day event first.
 * 2. early starts.
 * 3. longest duration.
 * 4. early created.
 * @param {(Event|EventViewModel)} a The object event instance.
 * @param {(Event|EventViewModel)} b The object event instance.
 * @returns {number} Result of comparison.
 */
function eventASC(a, b) {
    var durationA,
        durationB,
        allDayCompare,
        startsCompare;

    a = a.valueOf();
    b = b.valueOf();

    allDayCompare = booleanASC(a.isAllDay, b.isAllDay);

    if (allDayCompare) {
        return allDayCompare;
    }

    startsCompare = datetime.compare(a.getStarts(), b.getStarts());

    if (startsCompare) {
        return startsCompare;
    }

    durationA = a.duration().getTime();
    durationB = b.duration().getTime();

    if (durationA < durationB) {
        return 1;
    } else if (durationA > durationB) {
        return -1;
    }

    return util.stamp(a) - util.stamp(b);
}


module.exports = {
    bsearch: bsearch,
    compare: {
        event: {
            asc: eventASC
        },
        bool: {
            asc: booleanASC,
            desc: booleanDESC
        },
        num: {
            asc: numberASC,
            desc: numberDESC
        },
        str: {
            asc: stringASC,
            desc: stringDESC,
            ascIgnoreCase: stringASCIgnoreCase,
            descIgnoreCase: stringDESCIgnoreCase
        }
    }
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/datetime":28}],25:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Add autoscroll feature to elements that prevented text selection.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domevent = require('../common/domevent');
var domutil = require('../common/domutil');
var Point = require('../common/point');

var SCROLL_INTERVAL = 30;
var SCROLL_MAX = 15;
var SCROLL_CLICK_INCREASED = 2;    // IE에서 스크롤 바 클릭 시 실제 UI pixel 보다 넓게 잡히는 현상 offset.

/**
 * Add autoscroll feature to elements that prevented text selection.
 * @constructor
 * @param {HTMLElement} container - HTMLElement to add autoscroll features.
 */
function AutoScroll(container) {
    /**
     * @type {HTMLElement}
     */
    this.container = container;

    /**
     * @type {AutoScroll.DIRECTION}
     */
    this._direction = AutoScroll.DIRECTION.INSIDE;

    /**
     * @type {number}
     */
    this._offset = 0;

    /**
     * interval to scrolling
     * @type {number}
     */
    this._intervalID = 0;

    domevent.on(container, {
        'mousedown': this._onMouseDown
    }, this);
}

/**
 * @enum
 */
AutoScroll.DIRECTION = {
    INSIDE: 0,
    TOP: 1,
    RIGHT: 2,
    BOTTOM: 3,
    LEFT: 4
};

/**
 * Instance destroy method.
 */
AutoScroll.prototype.destroy = function() {
    domevent.off(this.container, {
        'mousedown': this._onMouseDown,
        'mousemove': this._onMouseMove,
        'mouseup': this._onMouseUp
    }, this);

    window.clearInterval(this._intervalID);
    this._intervalID = this._direction = this.container = null;
};

/**
 * Normalize ClientRect and calculate each position of edges.
 * @param {ClientRect} clientRect - ClientRect object of element.
 * @returns {object} edges.
 */
AutoScroll.prototype._getEdgePositions = function(clientRect) {
    return {
        top: clientRect.top,
        right: clientRect.left + clientRect.width,
        bottom: clientRect.bottom,
        left: clientRect.left
    };
};

/**
 * Get element real size ("real size" -> size without scrollbar)
 * @param {HTMLElement} el - element want to know real size ("real size" -> size without scrollbar)
 * @returns {number[]} real size [width, height]
 */
AutoScroll.prototype.getRealSize = function(el) {
    var computed = domutil.getComputedStyle(el),
        border,
        padding;

    border = parseFloat(computed.getPropertyValue('border-top-width')) +
        parseFloat(computed.getPropertyValue('border-bottom-width'));
    padding = parseFloat(computed.getPropertyValue('padding-top')) +
        parseFloat(computed.getPropertyValue('padding-bottom'));

    return [el.clientWidth + border + padding, el.clientHeight + border + padding];
};

/**
 * Check supplied element has scrollbar.
 * @param {HTMLElement} el - element want to know has scrollbar.
 * @returns {boolean[]} has scrollbar? [horizontal, vertical]
 */
AutoScroll.prototype.hasScrollbar = function(el) {
    var realSize = this.getRealSize(el);

    return [
        el.offsetWidth > Math.ceil(realSize[0]),
        el.offsetHeight > Math.ceil(realSize[1])
    ];
};

/**
 * @param {HTMLElement} el - element want to know.
 * @param {MouseEvent} mouseEvent - mouse event object.
 * @returns {boolean} mouse pointer is on the scrollbar?
 */
AutoScroll.prototype.isOnScrollbar = function(el, mouseEvent) {
    var realSize = this.getRealSize(el),
        pos = domevent.getMousePosition(mouseEvent, el),
        mouseInScrollbar = false;

    mouseInScrollbar = (realSize[0] - SCROLL_CLICK_INCREASED < pos[0] ||
                        realSize[1] - SCROLL_CLICK_INCREASED < pos[1]);

    return mouseInScrollbar;
};

/**
 * MouseDown event handler
 * @param {MouseEvent} mouseDownEvent - mouse down event
 */
AutoScroll.prototype._onMouseDown = function(mouseDownEvent) {
    // only primary button can start drag.
    if (domevent.getMouseButton(mouseDownEvent) !== 0) {
        return;
    }

    // deactivate autoscroll feature when mouse is on the scrollbar. (IE)
    if (util.browser.msie && this.isOnScrollbar(this.container, mouseDownEvent)) {
        return;
    }

    window.clearInterval(this._intervalID);
    this._intervalID = window.setInterval(util.bind(this._onTick, this), SCROLL_INTERVAL);

    domevent.on(global, {
        'mousemove': this._onMouseMove,
        'mouseup': this._onMouseUp
    }, this);
};

/**
 * MouseMove event handler
 * @param {MouseEvent} mouseEvent - mouse move event object.
 */
AutoScroll.prototype._onMouseMove = function(mouseEvent) {
    var edge = this._getEdgePositions(this.container.getBoundingClientRect()),
        pos = Point.n(domevent.getMousePosition(mouseEvent));

    if (pos.y >= edge.top && pos.y <= edge.bottom &&
        pos.x >= edge.left && pos.x <= edge.right) {
        this._direction = AutoScroll.DIRECTION.INSIDE;
        return;
    }

    if (pos.y < edge.top) {
        this._direction = AutoScroll.DIRECTION.TOP;
        this._offset = edge.top - pos.y;
        return;
    }

    if (pos.y > edge.bottom) {
        this._direction = AutoScroll.DIRECTION.BOTTOM;
        this._offset = pos.y - edge.bottom;
        return;
    }

    if (pos.x < edge.left) {
        this._direction = AutoScroll.DIRECTION.LEFT;
        this._offset = edge.left - pos.x;
        return;
    }

    this._direction = AutoScroll.DIRECTION.RIGHT;
    this._offset = pos.x - edge.right;
    return;
};

/**
 * MouseUp event handler.
 */
AutoScroll.prototype._onMouseUp = function() {
    window.clearInterval(this._intervalID);
    this._intervalID = 0;
    this._direction = AutoScroll.DIRECTION.INSIDE;
    this._offset = 0;

    domevent.off(global, {
        'mousemove': this._onMouseMove,
        'mouseup': this._onMouseUp
    }, this);
};

/**
 * Interval tick event handler
 */
AutoScroll.prototype._onTick = function() {
    var direction = this._direction,
        container,
        factor;

    if (!direction) {
        return;
    }

    container = this.container;
    factor = Math.min(this._offset, SCROLL_MAX);

    switch (direction) {
        case AutoScroll.DIRECTION.TOP:
            container.scrollTop -= factor;
            break;
        case AutoScroll.DIRECTION.RIGHT:
            container.scrollLeft += factor;
            break;
        case AutoScroll.DIRECTION.BOTTOM:
            container.scrollTop += factor;
            break;
        default:
            container.scrollLeft -= factor;
            break;
    }
};

module.exports = AutoScroll;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/domevent":30,"../common/domutil":31,"../common/point":33}],26:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Common collections.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util,
    forEachProp = util.forEachOwnProperties,
    forEachArr = util.forEachArray,
    isFunc = util.isFunction,
    isObj = util.isObject;

var aps = Array.prototype.slice;

/**
 * Common collection.
 *
 * It need function for get model's unique id.
 *
 * if the function is not supplied then it use default function {@link Collection#getItemID}
 * @constructor
 * @param {function} [getItemIDFn] function for get model's id.
 */
function Collection(getItemIDFn) {
    /**
     * @type {object.<string, *>}
     */
    this.items = {};

    /**
     * @type {number}
     */
    this.length = 0;

    if (isFunc(getItemIDFn)) {
        /**
         * @type {function}
         */
        this.getItemID = getItemIDFn;
    }
}

/**********
 * static props
 **********/

Collection.filter = {
    /**
     * return AND operate all of function's return value
     * @param {array} arr filters
     * @param {...*} [params] support filter parameters
     * @return {boolean} AND operated value
     */
    and: function(arr, params) {    // eslint-disable-line
        var args = aps.call(arguments, 1),
            i = 0,
            cnt = arr.length;

        for (; i < cnt; i += 1) {
            if (!arr[i].apply(null, args)) {
                return false;
            }
        }

        return true;
    },

    /**
     * return OR operate all of function's return value
     * @param {array} arr filters
     * @param {...*} [params] support filter parameters
     * @return {boolean} OR operated value
     */
    or: function(arr, params) {    // eslint-disable-line
        var args = aps.call(arguments, 1),
            tmp,
            result;

        forEachArr(arr, function(filter) {
            tmp = filter.apply(null, args);

            if (util.isUndefined(result)) {
                result = tmp;
            }

            result = (result || tmp);
        });

        return result;
    }
};

/**
 * Merge several collections.
 *
 * You can\'t merge collections different _getEventID functions. Take case of use.
 * @param {...Collection} collections collection arguments to merge
 * @returns {Collection} merged collection.
 */
Collection.merge = function(collections) {    // eslint-disable-line
    var cols = aps.call(arguments),
        newItems = {},
        length = 0,
        merged = new Collection(cols[0].getItemID),
        extend = util.extend;

    forEachArr(cols, function(col) {
        extend(newItems, col.items);
        length += col.length;
    });

    merged.items = newItems;
    merged.length = length;

    return merged;
};

/**********
 * prototype props
 **********/

/**
 * get model's unique id.
 * @param {object} item model instance.
 * @returns {number} model unique id.
 */
Collection.prototype.getItemID = function(item) {
    return item._id + '';
};

/**
 * add models.
 * @param {...*} item models to add this collection.
 */
Collection.prototype.add = function(item) {
    var id,
        ownItems;

    if (arguments.length > 1) {
        forEachArr(aps.call(arguments), function(o) {
            this.add(o);
        }, this);

        return;
    }

    id = this.getItemID(item);
    ownItems = this.items;

    if (!ownItems[id]) {
        this.length += 1;
    }
    ownItems[id] = item;
};

/**
 * remove models.
 * @param {...(object|string|number)} id model instance or unique id to delete.
 * @returns {array} deleted model list.
 */
Collection.prototype.remove = function(id) {
    var removed = [],
        ownItems,
        itemToRemove;

    if (!this.length) {
        return removed;
    }

    if (arguments.length > 1) {
        removed = util.map(aps.call(arguments), function(id) {
            return this.remove(id);
        }, this);

        return removed;
    }

    ownItems = this.items;

    if (isObj(id)) {
        id = this.getItemID(id);
    }

    if (!ownItems[id]) {
        return removed;
    }

    this.length -= 1;
    itemToRemove = ownItems[id];
    delete ownItems[id];

    return itemToRemove;
};

/**
 * remove all models in collection.
 */
Collection.prototype.clear = function() {
    this.items = {};
    this.length = 0;
};

/**
 * check collection has specific model.
 * @param {(object|string|number|function)} id model instance or id or filter function to check
 * @returns {boolean} is has model?
 */
Collection.prototype.has = function(id) {
    var isFilter,
        has;

    if (!this.length) {
        return false;
    }

    isFilter = isFunc(id);
    has = false;

    if (isFilter) {
        this.each(function(item) {
            if (id(item) === true) {
                has = true;
                return false;
            }
        });
    } else {
        id = isObj(id) ? this.getItemID(id) : id;
        has = util.isExisty(this.items[id]);
    }

    return has;
};

/**
 * invoke callback when model exist in collection.
 * @param {(string|number)} id model unique id.
 * @param {function} fn the callback.
 * @param {*} [context] callback context.
 */
Collection.prototype.doWhenHas = function(id, fn, context) {
    var item = this.items[id];

    if (!util.isExisty(item)) {
        return;
    }

    fn.call(context || this, item);
};

/**
 * Search model. and return new collection.
 * @param {function} filter filter function.
 * @returns {Collection} new collection with filtered models.
 * @example
 * collection.find(function(item) {
 *     return item.edited === true;
 * });
 *
 * function filter1(item) {
 *     return item.edited === false;
 * }
 *
 * function filter2(item) {
 *     return item.disabled === false;
 * }
 *
 * collection.find(function(item) {
 *     return Collection.filter.and([filter1, filter2], item);
 * });
 *
 * collection.find(function(item) {
 *     return Collection.filter.or([filter1, filter2], item);
 * });
 */
Collection.prototype.find = function(filter) {
    var result = new Collection();

    if (this.hasOwnProperty('getItemID')) {
        result.getItemID = this.getItemID;
    }

    this.each(function(item) {
        if (filter(item) === true) {
            result.add(item);
        }
    });

    return result;
};

/**
 * Group element by specific key values.
 *
 * if key parameter is function then invoke it and use returned value.
 * @param {(string|number|function|array)} key key property or getter function. if string[] supplied, create each collection before grouping.
 * @param {function} [groupFunc] - function that return each group's key
 * @returns {object.<string, Collection>} grouped object
 * @example
 * 
 * // pass `string`, `number`, `boolean` type value then group by property value.
 * collection.groupBy('gender');    // group by 'gender' property value.
 * collection.groupBy(50);          // group by '50' property value.
 * 
 * // pass `function` then group by return value. each invocation `function` is called with `(item)`.
 * collection.groupBy(function(item) {
 *     if (item.score > 60) {
 *         return 'pass';
 *     }
 *     return 'fail';
 * });
 *
 * // pass `array` with first arguments then create each collection before grouping.
 * collection.groupBy(['go', 'ruby', 'javascript']);
 * // result: { 'go': empty Collection, 'ruby': empty Collection, 'javascript': empty Collection }
 *
 * // can pass `function` with `array` then group each elements.
 * collection.groupBy(['go', 'ruby', 'javascript'], function(item) {
 *     if (item.isFast) {
 *         return 'go';
 *     }
 *
 *     return item.name;
 * });
 */
Collection.prototype.groupBy = function(key, groupFunc) {
    var result = {},
        collection,
        baseValue,
        isFunc = util.isFunction,
        keyIsFunc = isFunc(key),
        getItemIDFn = this.getItemID;

    if (util.isArray(key)) {
        util.forEachArray(key, function(k) {
            result[k + ''] = new Collection(getItemIDFn);
        });

        if (!groupFunc) {
            return result;
        }

        key = groupFunc;
        keyIsFunc = true;
    }

    this.each(function(item) {
        if (keyIsFunc) {
            baseValue = key(item);
        } else {
            baseValue = item[key];

            if (isFunc(baseValue)) {
                baseValue = baseValue.apply(item);
            }
        }

        collection = result[baseValue];

        if (!collection) {
            collection = result[baseValue] = new Collection(getItemIDFn);
        }

        collection.add(item);
    });

    return result;
};

/**
 * Return single item in collection.
 *
 * Returned item is inserted in this collection firstly.
 * @returns {object} item.
 */
Collection.prototype.single = function() {
    var result;

    this.each(function(item) {
        result = item;
        return false;
    }, this);

    return result;
};

/**
 * sort a basis of supplied compare function.
 * @param {function} compareFunction compareFunction
 * @returns {array} sorted array.
 */
Collection.prototype.sort = function(compareFunction) {
    var arr = [];

    this.each(function(item) {
        arr.push(item);
    });

    if (isFunc(compareFunction)) {
        arr = arr.sort(compareFunction);
    }

    return arr;
};

/**
 * iterate each model element.
 *
 * when iteratee return false then break the loop.
 * @param {function} iteratee iteratee(item, index, items)
 * @param {*} [context] context
 */
Collection.prototype.each = function(iteratee, context) {
    forEachProp(this.items, iteratee, context || this);
};

/**
 * return new array with collection items.
 * @returns {array} new array.
 */
Collection.prototype.toArray = function() {
    if (!this.length) {
        return [];
    }

    return util.map(this.items, function(item) {
        return item;
    });
};

module.exports = Collection;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],27:[function(require,module,exports){
(function (global){
/**
 * @fileoverview common/general utilities.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var Collection = require('../common/collection');
var aps = Array.prototype.slice;

function eventIDGetter(event) {
    return event.id();
}

module.exports = {
    /**
     * @param {...*} initItems - items to add newly created collection.
     * @returns {Collection} new collection for event models.
     */
    createEventCollection: function(initItems) {    // eslint-disable-line
        var collection = new Collection(eventIDGetter);

        if (arguments.length) {
            collection.add.apply(collection, arguments);
        }

        return collection;
    },

    /**
     * Get ratio value.
     *
     * a : b = y : X;
     *
     * =
     *
     * X = (b * y) / a;
     * @param {number} a - a
     * @param {number} b - b
     * @param {number} y - y
     * @returns {number} ratio value
     */
    ratio: function(a, b, y) {
        // a : b = y : x;
        return (b * y) / a;
    },

    /**
     * Find nearest value from supplied params.
     * @param {number} value - value to find.
     * @param {array} nearest - nearest array.
     * @returns {number} nearest value
     */
    nearest: function(value, nearest) {
        var diff = util.map(nearest, function(v) {
                return Math.abs(value - v);
            }),
            nearestIndex = util.inArray(Math.min.apply(null, diff), diff);

        return nearest[nearestIndex];
    },

    /**
     * pick value from object then return utility object to treat it.
     * @param {object} obj - object to search supplied path property.
     * @param {...string} paths - rest parameter that string value to search property in object.
     * @returns {object} pick object.
     */
    pick2: function(obj, paths) {    // eslint-disable-line
        var result = util.pick.apply(null, arguments),
            pick;

        pick = {
            /**
             * @returns {*} picked value.
             */
            val: function() {
                return result;
            },

            /**
             * invoke supplied function in picked object.
             *
             * the callback context is set picked object.
             * @param {string|function} fn - function to invoke in picked object.
             * @returns {*} result of invoke.
             */
            then: function(fn) {
                var args;

                if (!result) {
                    return undefined;    //eslint-disable-line
                }

                args = aps.call(arguments, 1);

                if (util.isString(fn)) {
                    return (util.pick(result, fn) || function() {}).apply(result, args);
                }

                return fn.call(result, result);
            }
        };

        return pick;
    },

    /**
     * Mixin method.
     *
     * (extend methods except property name 'mixin')
     * @param {object} from - mixin object.
     * @param {object} to - object to mixin.
     */
    mixin: function(from, to) {
        util.extend(to.prototype, from);
    }
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/collection":26}],28:[function(require,module,exports){
(function (global){
/**
 * @fileoverview datetime utility module
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util,
    opt = Object.prototype.toString;

var dateFormatRx = /^(\d{4}[-|\/]*\d{2}[-|\/]*\d{2})\s?(\d{2}:\d{2}:\d{2})?$/;

var datetime,
    tokenFunc;

var memo = {
    millisecondsTo: {},
    millisecondsFrom: {}
};

tokenFunc = {
    /**
     * @param {Date} date date object.
     * @returns {string} YYYYMMDD
     */
    'YYYYMMDD': function(date) {
        return [
            date.getFullYear(),
            datetime.leadingZero(date.getMonth() + 1, 2),
            datetime.leadingZero(date.getDate(), 2)
        ].join('');
    },
    /**
     * @param {Date} date date object
     * @returns {string} four digit year number
     */
    'YYYY': function(date) {
        return date.getFullYear() + '';
    },

    /**
     * @param {Date} date date object
     * @returns {string} two digit month number
     */
    'MM': function(date) {
        return datetime.leadingZero(date.getMonth() + 1, 2);
    },

    /**
     * @param {Date} date date object
     * @returns {string} two digit date number
     */
    'DD': function(date) {
        return datetime.leadingZero(date.getDate(), 2);
    },

    /**
     * @param {Date} date date object
     * @returns {string} HH:mm
     */
    'HH:mm': function(date) {
        var hour = date.getHours(),
            minutes = date.getMinutes();

        return datetime.leadingZero(hour, 2) + ':' +
            datetime.leadingZero(minutes, 2);
    },

    /**
     * format to local date
     * @param {Date} date date object
     * @returns {string} 1988-09-25T09:00:00+09:00
     */
    'LOCAL': function(date) {
        var timeZoneOffset = -date.getTimezoneOffset(),
            diff = timeZoneOffset >= 0 ? '+' : '-',
            pad = function(num) {
                return datetime.leadingZero(num, 2);
            };

        return date.getFullYear() 
            + '-' + pad(date.getMonth() + 1)
            + '-' + pad(date.getDate())
            + 'T' + pad(date.getHours())
            + ':' + pad(date.getMinutes()) 
            + ':' + pad(date.getSeconds()) 
            + diff + pad(timeZoneOffset / 60) 
            + ':' + pad(timeZoneOffset % 60);
    }
};

datetime = {
    /**
     * The number of milliseconds one day.
     * @type {number}
     */
    MILLISECONDS_PER_DAY: 86400000,

    /**
     * The number of milliseconds one hour.
     * @type {number}
     */
    MILLISECONDS_PER_HOUR: 3600000,

    /**
     * convert milliseconds
     * @param {string} type - type of value.
     * @param {number} value - value to convert.
     * @param {function} iteratee - iteratee function to use reduce.
     * @returns {number} converted value.
     */
    _convMilliseconds: function(type, value, iteratee) {
        var conv = [60, 60, 1000],
            index = {
                hour: 0,
                minutes: 1,
                seconds: 2
            };

        if (!(type in index) || global.isNaN(value)) {
            return false;
        }

        return util.reduce([value].concat(conv.slice(index[type])), iteratee);
    },

    /**
     * Convert milliseconds value to other type
     * @param {type} type convert to type want to. support "hour", "minutes", "seconds" only.
     * @param {value} value - value to convert.
     * @returns {number} converted value.
     */
    millisecondsTo: function(type, value) {
        var cache = memo.millisecondsTo,
            key = type + value;

        if (cache[key]) {
            return cache[key];
        }

        cache[key] = datetime._convMilliseconds(type, value, function(memo, v) {
            return memo / v;
        });

        return cache[key];
    },

    /**
     * Convert value to milliseconds
     * @param {type} type - type of supplied value. support "hour", "minutes", "seconds" only.
     * @param {value} value - value to convert.
     * @returns {number} converted value.
     */
    millisecondsFrom: function(type, value) {
        var cache = memo.millisecondsFrom,
            key = type + value;

        if (cache[key]) {
            return cache[key];
        }

        cache[key] = datetime._convMilliseconds(type, value, function(memo, v) {
            return memo * v;
        });

        return cache[key];
    },

    /**
     * Make date array from supplied paramters.
     * @param {Date} start Start date.
     * @param {Date} end End date.
     * @param {number} step The number of milliseconds to use increment.
     * @returns {array} Date array.
     */
    range: function(start, end, step) {
        var cursor = new Date(start.getTime()),
            result = [];

        while (cursor <= end) {
            result.push(cursor);
            cursor = new Date(cursor.getTime() + step);
        }

        return result;
    },

    /**
     * Clone supplied date.
     * @param {Date} date date object to clone.
     * @returns {Date} Cloned date object
     */
    clone: function(date) {
        return new Date(date.getTime());
    },

    /**
     * Compare two dates.
     *
     * when first date is latest then seconds then return -1.
     *
     * return +1 reverse, and return 0 is same.
     * @param {Date} d1 Date object to compare.
     * @param {Date} d2 Date object to compare.
     * @returns {number} result of compare
     */
    compare: function(d1, d2) {
        var _d1 = d1.getTime(),
            _d2 = d2.getTime();

        if (_d1 < _d2) {
            return -1;
        } else if (_d1 > _d2) {
            return 1;
        }
        return 0;
    },

    /**
     * Check supplied parameter is valid date object.
     * @param {*} d Object to validate.
     * @returns {boolean} return true when parameter is valid date object.
     */
    isValid: function(d) {
        if (opt.call(d) === '[object Date]') {
            return !window.isNaN(d.getTime());
        }
        return false;
    },

    /**
     * convert non local date to UTC date.
     * @param {Date} d Date to convert UTC.
     * @returns {Date} The UTC Date.
     */
    toUTC: function(d) {
        var l = d.getTime(),
            offset = datetime.millisecondsFrom('minutes', new Date().getTimezoneOffset());

        return new Date(l + offset);
    },

    /**
     * pad left zero characters.
     * @param {number} number number value to pad zero.
     * @param {number} length pad length to want.
     * @returns {string} padded string.
     */
    leadingZero: function(number, length) {
        var zero = '',
            i = 0;

        if ((number + '').length > length) {
            return number + '';
        }

        for (; i < (length - 1); i += 1) {
            zero += '0';
        }

        return (zero + number).slice(length * -1);
    },

    /**
     * Convert date string to date object.
     *
     * Only listed below formats avaliable.
     *
     * - YYYYMMDD
     * - YYYY/MM/DD
     * - YYYY-MM-DD
     * - YYYY/MM/DD HH:mm:SS
     * - YYYY-MM-DD HH:mm:SS
     *
     * @param {string} str Formatted string.
     * @param {number} [fixMonth=-1] - number for fix month calculating.
     * @returns {(Date|boolean)} Converted Date object. when supplied str is not available then return false.
     */
    parse: function(str, fixMonth) {
        var separator,
            matches = str.match(dateFormatRx),
            ymd,
            hms;

        if (util.isUndefined(fixMonth)) {
            fixMonth = -1;
        }

        if (!matches) {
            return false;
        }

        if (str.length > 8) {
            // YYYY/MM/DD
            // YYYY-MM-DD
            // YYYY/MM/DD HH:mm:SS
            // YYYY-MM-DD HH:mm:SS
            separator = ~str.indexOf('/') ? '/' : '-';
            matches = matches.splice(1);

            ymd = matches[0].split(separator);
            hms = matches[1] ? matches[1].split(':') : [0, 0, 0];
        } else {
            // YYYYMMDD
            matches = matches[0];
            ymd = [matches.substr(0, 4), matches.substr(4, 2), matches.substr(6, 2)];
            hms = [0, 0, 0];
        }

        return new Date(+ymd[0], +ymd[1] + fixMonth, +ymd[2], +hms[0], +hms[1], +hms[2]);
    },

    /**
     * Return date object from Date.
     * @param {Date} date date
     * @returns {object} Date object.
     */
    raw: function(date) {
        return {
            y: date.getFullYear(),
            M: date.getMonth(),
            d: date.getDate(),
            h: date.getHours(),
            m: date.getMinutes(),
            s: date.getSeconds(),
            ms: date.getMilliseconds()
        };
    },

    /**
     * Return 00:00:00 supplied date.
     * @param {Date} date date.
     * @returns {Date} start date.
     */
    start: function(date) {
        var d = new Date(date.getTime());
        d.setHours(0, 0, 0, 0);

        return d;
    },

    /**
     * Return 23:59:59 supplied date.
     * @param {Date} date date.
     * @returns {Date} end date.
     */
    end: function(date) {
        var d = new Date(date.getTime());
        d.setHours(23, 59, 59, 0);

        return d;
    },

    /**
     * Return formatted string as basis of supplied string.
     *
     * Supported Token Lists.
     *
     * - YYYY => 1988
     * - MM => 01 ~ 12
     * - DD => 01 ~ 31
     * - YYYYMMDD => 19880925
     * @param {Date} date String want to formatted.
     * @param {string} format format str.
     * @returns {string}  Formatted date string.
     */
    format: function(date, format) {
        var result = format;
        util.forEachOwnProperties(tokenFunc, function(converter, token) {
            result = result.replace(token, converter(date));
        });

        return result;
    },

    /**
     * Return 2-dimensional array month calendar
     *
     * dates that different month with given date are negative values
     * @param {Date} month - date want to calculate month calendar
     * @param {number} [startDayOfWeek=0] - start day of week
     * @param {function} [iteratee] - iteratee for customizing calendar object
     * @returns {Array.<string[]>} calendar 2d array
     */
    arr2dCalendar: function(month, startDayOfWeek, iteratee) {
        var weekArr,
            starts, ends,
            startIndex, endIndex,
            afterDates,
            cursor, week,
            calendar = [];

        starts = new Date(new Date(+month).setDate(1));
        ends = new Date(new Date(+starts).setMonth(starts.getMonth() + 1));
        ends = new Date(new Date(+ends).setDate(ends.getDate() - 1));

        // create day number array by startDayOfWeek number
        // 4 -> [4, 5, 6, 0, 1, 2, 3]
        // 2 -> [2, 3, 4, 5, 6, 0, 1]
        weekArr = util.range(startDayOfWeek, 7).concat(util.range(7)).slice(0, 7);
        startIndex = util.inArray(starts.getDay(), weekArr);
        endIndex = util.inArray(ends.getDay(), weekArr);
        // free dates after last date of this month
        afterDates = 7 - (endIndex + 1);

        cursor = new Date(new Date(+starts).setDate(starts.getDate() - startIndex));
        // iteratee all dates to render
        util.forEachArray(util.range(startIndex + ends.getDate() + afterDates), function(i) {
            var date;

            if (!(i % 7)) {
                // group each date by week
                week = calendar[i / 7] = [];
            }

            date = new Date(+cursor);
            date = iteratee ? iteratee(date) : date;
            week.push(date);

            // add date
            cursor = new Date(cursor.setDate(cursor.getDate() + 1));
        });

        return calendar;
    }
};

module.exports = datetime;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],29:[function(require,module,exports){
/**
 * @fileoverview Dirty flagging module for objects.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var common = ne.util,
    existy = common.isExisty,
    pick = common.pick,
    isFunc = common.isFunction;

/**
 * Mixin module for dirty flagging on specific objects.
 * @mixin
 * @example
 * var obj = { hello: 'good', test: '123' };
 * dirty.mixin(obj);
 *
 * obj.set('hello', 'world');
 * obj.isDirty();    // true
 * obj.isPropChanged('hello');    // true
 * obj.isPropChanged('test');    // false
 * obj.dirty(false);
 *
 * obj.isDirty();    // false
 * obj.isPropChanged('hello');    // false
 */
var dirty = {
    /**
     * Set property value with dirty flagging.
     * @param {string} propName Property name.
     * @param {*} value Proprty value.
     */
    set: function(propName, value) {
        var originValue = this[propName];

        if (originValue === value) {
            return;
        }

        this[propName] = value;

        if (!this._changed) {
            /**
             * Save changed properties.
             * @memberof dirty
             * @name _changed
             * @type {Object}
             */
            this._changed = {};
        }

        this._changed[propName] = true;

        /**
         * Dirty flag
         * @type {Boolean}
         * @name _dirty
         * @memberof dirty
         */
        this._dirty = true;
    },

    /**
     * Check dirty flag.
     * @returns {boolean} Property is changed.
     */
    isDirty: function() {
        return !!this._dirty;
    },

    /**
     * Set dirty flag manually.
     * @param {Boolean} [toDirty=true] This will set dirty flag directly.
     */
    dirty: function(toDirty) {
        toDirty = existy(toDirty) ? toDirty : true;

        /* istanbul ignore else */
        if (!toDirty) {
            this._changed = {};
        }

        this._dirty = toDirty;
    },

    /**
     * Delete property safety.
     * @param {String} propName The name of property.
     */
    deleteProp: function(propName) {
        delete this[propName];

        if (this._changed) {
            delete this._changed[propName];
        }
    },

    /**
     * Check the changes with specific property.
     * @param {String} propName The name of property you want.
     * @returns {boolean} Is property changed?
     */
    isPropChanged: function(propName) {
        if (!this._changed) {
            return false;
        }

        return this._changed[propName] === true;
    },

    /**
     * Mixin to specific objects.
     * @param {Object} target The object to mix this module.
     * @memberof module:util/dirty
     * @example
     * function Animal() {}
     * dirty.mixin(Animal.prototype);
     */
    mixin: function(target) {
        var methodFilterR = /(^_|mixin|wrap)/;

        common.forEachOwnProperties(dirty, function(o, k) {
            if (!methodFilterR.test(k)) {
                target[k] = dirty[k];
            }
        });
    },

    /**
     * Wrapper method for dirty flagging.
     *
     * This method invoke after invoked specific method that added by you.
     *
     * The method want to add are must exist before add.
     * @param {object} target Target object to method wrap.
     * @param {(string|object)} methodName
     *  Method name to wrap or methodName: flag objects.
     * @param {boolean} [flag=true]
     *  this will used to flagging by dirty flagger after invoke the methods added by you.
     * @memberof module:util/dirty
     * @example
     * function Animal(name) {
     *     this.name = name;
     * }
     * Animal.prototype.growl = jasmine.createSpy('growl');
     * Animal.prototype.test = function() {
     *     return this.name;
     * };
     *
     * dirty.mixin(Animal.prototype);
     * // single
     * dirty.wrap(Animal.prototype, 'growl', true);
     * // multiple
     * dirty.wrap(Animap.prototype, {
     *     growl: true,
     *     test: false
     * });
     *
     */
    wrap: function(target, methodName, flag) {
        var wrap = dirty.wrap,
            fn;

        if (common.isObject(methodName)) {
            common.forEachOwnProperties(methodName, function(flag, methodName) {
                wrap(target, methodName, flag);
            });
            return;
        }

        flag = existy(flag) ? flag : true;

        if (!target._wrapper) {
            /**
             * @param {function} fn Original method to wrap.
             * @param {boolean} flagToSet The boolean value to using dirty flagging.
             * @returns {*} The result value of original method.
             * @name _wrapper
             * @memberof dirty
             */
            target._wrapper = function(fn, flagToSet) {
                return function() {
                    var args = Array.prototype.slice.call(arguments);
                    var result = fn.apply(this, args);
                    this._dirty = flagToSet;
                    return result;
                };
            };
        }

        if (existy(pick(target, methodName)) &&
            isFunc(target[methodName]) &&
            !existy(pick(target, methodName, '_wrapped'))) {
            fn = target[methodName];
            target[methodName] = target._wrapper(fn, flag);
            target[methodName]._wrapped = true;
        }
    }
};

module.exports = dirty;


},{}],30:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Utility module for handling DOM events.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util,
    browser = util.browser,
    eventKey = '_evt',
    DRAG = {
        START: ['touchstart', 'mousedown'],
        END: {
            mousedown: 'mouseup',
            touchstart: 'touchend',
            pointerdown: 'touchend',
            MSPointerDown: 'touchend'
        },
        MOVE: {
            mousedown: 'mousemove',
            touchstart: 'touchmove',
            pointerdown: 'touchmove',
            MSPointerDown: 'touchmove'
        }
    };

var domevent = {
    /**
     * Bind dom events.
     * @param {HTMLElement} obj HTMLElement to bind events.
     * @param {(string|object)} types Space splitted events names or eventName:handler object.
     * @param {*} fn handler function or context for handler method.
     * @param {*} [context] context object for handler method.
     */
    on: function(obj, types, fn, context) {
        if (util.isString(types)) {
            util.forEach(types.split(' '), function(type) {
                domevent._on(obj, type, fn, context);
            });

            return;
        }

        util.forEachOwnProperties(types, function(handler, type) {
            domevent._on(obj, type, handler, fn);
        });
    },

    /**
     * DOM event binding.
     * @param {HTMLElement} obj HTMLElement to bind events.
     * @param {String} type The name of events.
     * @param {*} fn handler function
     * @param {*} [context] context object for handler method.
     * @private
     */
    _on: function(obj, type, fn, context) {
        var id,
            handler,
            originHandler;

        id = type + util.stamp(fn) + (context ? '_' + util.stamp(context) : '');

        if (obj[eventKey] && obj[eventKey][id]) {
            return;
        }

        handler = function(e) {
            fn.call(context || obj, e || window.event);
        };

        originHandler = handler;

        if ('addEventListener' in obj) {
            if (type === 'mouseenter' || type === 'mouseleave') {
                handler = function(e) {
                    e = e || window.event;
                    if (!domevent._checkMouse(obj, e)) {
                        return;
                    }
                    originHandler(e);
                };
                obj.addEventListener((type === 'mouseenter') ?
                    'mouseover' : 'mouseout', handler, false);
            } else {
                if (type === 'mousewheel') {
                    obj.addEventListener('DOMMouseScroll', handler, false);
                }

                obj.addEventListener(type, handler, false);
            }
        } else if ('attachEvent' in obj) {
            obj.attachEvent('on' + type, handler);
        }

        obj[eventKey] = obj[eventKey] || {};
        obj[eventKey][id] = handler;
    },

    /**
     * Unbind DOM Event handler.
     * @param {HTMLElement} obj HTMLElement to unbind.
     * @param {(string|object)} types Space splitted events names or eventName:handler object.
     * @param {*} fn handler function or context for handler method.
     * @param {*} [context] context object for handler method.
     */
    off: function(obj, types, fn, context) {
        if (util.isString(types)) {
            util.forEach(types.split(' '), function(type) {
                domevent._off(obj, type, fn, context);
            });

            return;
        }

        util.forEachOwnProperties(types, function(handler, type) {
            domevent._off(obj, type, handler, fn);
        });
    },

    /**
     * Unbind DOM event handler.
     * @param {HTMLElement} obj HTMLElement to unbind.
     * @param {String} type The name of event to unbind.
     * @param {function()} fn Event handler that supplied when binding.
     * @param {*} context context object that supplied when binding.
     * @private
     */
    _off: function(obj, type, fn, context) {
        var id = type + util.stamp(fn) + (context ? '_' + util.stamp(context) : ''),
            handler = obj[eventKey] && obj[eventKey][id];

        if (!handler) {
            return;
        }

        if ('removeEventListener' in obj) {
            if (type === 'mouseenter' || type === 'mouseleave') {
                obj.removeEventListener((type === 'mouseenter') ?
                    'mouseover' : 'mouseout', handler, false);
            } else {
                if (type === 'mousewheel') {
                    obj.removeEventListener('DOMMouseScroll', handler, false);
                }

                obj.removeEventListener(type, handler, false);
            }
        } else if ('detachEvent' in obj) {
            try {
                obj.detachEvent('on' + type, handler);
            } catch (e) {}    //eslint-disable-line
        }

        delete obj[eventKey][id];

        if (util.keys(obj[eventKey]).length) {
            return;
        }

        delete obj[eventKey];
    },

    /**
     * Bind DOM event. this event will unbind after invokes.
     * @param {HTMLElement} obj HTMLElement to bind events.
     * @param {(string|object)} types Space splitted events names or eventName:handler object.
     * @param {*} fn handler function or context for handler method.
     * @param {*} [context] context object for handler method.
     */
    once: function(obj, types, fn, context) {
        var that = this;

        if (util.isObject(types)) {
            util.forEachOwnProperties(types, function(handler, type) {
                domevent.once(obj, type, handler, fn);
            });
            return;
        }

        function onceHandler() {
            fn.apply(context || obj, arguments);
            that._off(obj, types, onceHandler, context);
        }

        domevent.on(obj, types, onceHandler, context);
    },

    /**
     * Cancel event bubbling.
     * @param {Event} e Event object.
     */
    stopPropagation: function(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
        } else {
            e.cancelBubble = true;
        }
    },

    /**
     * Cancel browser default actions.
     * @param {Event} e Event object.
     */
    preventDefault: function(e) {
        if (e.preventDefault) {
            e.preventDefault();
        } else {
            e.returnValue = false;
        }
    },

    /**
     * Syntatic sugar of stopPropagation and preventDefault
     * @param {Event} e Event object.
     */
    stop: function(e) {
        domevent.preventDefault(e);
        domevent.stopPropagation(e);
    },

    /**
     * Stop scroll events.
     * @param {HTMLElement} el HTML element to prevent scroll.
     */
    disableScrollPropagation: function(el) {
        domevent.on(el, 'mousewheel MozMousePixelScroll', domevent.stopPropagation);
    },

    /**
     * Stop all events related with click.
     * @param {HTMLElement} el HTML element to prevent all event related with click.
     */
    disableClickPropagation: function(el) {
        domevent.on(el, DRAG.START.join(' ') + ' click dblclick', domevent.stopPropagation);
    },

    /**
     * Get mouse position from mouse event.
     *
     * If supplied relatveElement parameter then return relative position based on element.
     * @param {Event} mouseEvent Mouse event object
     * @param {HTMLElement} relativeElement HTML element that calculate relative position.
     * @returns {number[]} mouse position.
     */
    getMousePosition: function(mouseEvent, relativeElement) {
        var rect;

        if (!relativeElement) {
            return [mouseEvent.clientX, mouseEvent.clientY];
        }

        rect = relativeElement.getBoundingClientRect();

        return [
            mouseEvent.clientX - rect.left - relativeElement.clientLeft,
            mouseEvent.clientY - rect.top - relativeElement.clientTop
        ];
    },

    /**
     * Normalize mouse wheel event that different each browsers.
     * @param {MouseEvent} e Mouse wheel event.
     * @returns {Number} delta
     */
    getWheelDelta: function(e) {
        var delta = 0;

        if (e.wheelDelta) {
            delta = e.wheelDelta / 120;
        }

        if (e.detail) {
            delta = -e.detail / 3;
        }

        return delta;
    },

    /**
     * prevent firing mouseleave event when mouse entered child elements.
     * @param {HTMLElement} el HTML element
     * @param {MouseEvent} e Mouse event
     * @returns {Boolean} leave?
     * @private
     */
    _checkMouse: function(el, e) {
        var related = e.relatedTarget;

        if (!related) {
            return true;
        }

        try {
            while (related && (related !== el)) {
                related = related.parentNode;
            }
        } catch (err) {
            return false;
        }

        return (related !== el);
    },

    /**
     * Trigger specific events to html element.
     * @param {HTMLElement} obj HTMLElement
     * @param {string} type Event type name
     * @param {object} [eventData] Event data
     */
    trigger: function(obj, type, eventData) {
        var rMouseEvent = /(mouse|click)/;
        if (util.isUndefined(eventData) && rMouseEvent.exec(type)) {
            eventData = domevent.mouseEvent(type);
        }

        if (obj.dispatchEvent) {
            obj.dispatchEvent(eventData);
        } else if (obj.fireEvent) {
            obj.fireEvent('on' + type, eventData);
        }
    },

    /**
     * Create virtual mouse event.
     *
     * Tested at
     *
     * - IE7 ~ IE11
     * - Chrome
     * - Firefox
     * - Safari
     * @param {string} type Event type
     * @param {object} [eventObj] Event data
     * @returns {MouseEvent} Virtual mouse event.
     */
    mouseEvent: function(type, eventObj) {
        var evt,
            e;

        e = util.extend({
            bubbles: true,
            cancelable: (type !== 'mousemove'),
            view: window,
            wheelDelta: 0,
            detail: 0,
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            button: 0,
            relatedTarget: undefined  // eslint-disable-line
        }, eventObj);

        // prevent throw error when inserting wheelDelta property to mouse event on below IE8
        if (browser.msie && browser.version < 9) {
            delete e.wheelDelta;
        }

        if (typeof document.createEvent === 'function') {
            evt = document.createEvent('MouseEvents');
            evt.initMouseEvent(type,
                e.bubbles, e.cancelable, e.view, e.detail,
                e.screenX, e.screenY, e.clientX, e.clientY,
                e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
                e.button, document.body.parentNode
            );
        } else if (document.createEventObject) {
            evt = document.createEventObject();

            util.forEach(e, function(value, propName) {
                evt[propName] = value;
            }, this);
            evt.button = {0: 1, 1: 4, 2: 2}[evt.button] || evt.button;
        }
        return evt;
    },

    /**
     * Normalize mouse event's button attributes.
     *
     * Can detect which button is clicked by this method.
     *
     * Meaning of return numbers
     *
     * - 0: primary mouse button
     * - 1: wheel button or center button
     * - 2: secondary mouse button
     * @param {MouseEvent} mouseEvent - The mouse event object want to know.
     * @returns {number} - The value of meaning which button is clicked?
     */
    getMouseButton: function(mouseEvent) {
        var button,
            primary = '0,1,3,5,7',
            secondary = '2,6',
            wheel = '4';

        /* istanbul ignore else */
        if (document.implementation.hasFeature('MouseEvents', '2.0')) {
            return mouseEvent.button;
        }

        button = mouseEvent.button + '';
        if (~primary.indexOf(button)) {
            return 0;
        } else if (~secondary.indexOf(button)) {
            return 2;
        } else if (~wheel.indexOf(button)) {
            return 1;
        }
    }
};

module.exports = domevent;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],31:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Utility modules for manipulate DOM elements.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var domevent = require('./domevent');
var Collection = require('./collection');

var util = global.ne.util,
    posKey = '_pos',
    domutil;

var CSS_AUTO_REGEX = /^auto$|^$|%/;

function trim(str) {
    return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
}

domutil = {
    /**
     * Create DOM element and return it.
     * @param {string} tagName Tag name to append.
     * @param {HTMLElement} [container] HTML element will be parent to created element.
     * if not supplied, will use **document.body**
     * @param {string} [className] Design class names to appling created element.
     * @returns {HTMLElement} HTML element created.
     */
    appendHTMLElement: function(tagName, container, className) {
        var el;

        className = className || '';

        el = document.createElement(tagName);
        el.className = className;

        if (container) {
            container.appendChild(el);
        } else {
            document.body.appendChild(el);
        }

        return el;
    },

    /**
     * Remove element from parent node.
     * @param {HTMLElement} el - element to remove.
     */
    remove: function(el) {
        if (el && el.parentNode) {
            el.parentNode.removeChild(el);
        }
    },

    /**
     * Get element by id
     * @param {string} id element id attribute
     * @returns {HTMLElement} element
     */
    get: function(id) {
        return document.getElementById(id);
    },

    /**
     * Check supplied element is matched selector.
     * @param {HTMLElement} el - element to check
     * @param {string} selector - selector string to check
     * @return {boolean} match?
     */
    _matcher: function(el, selector) {
        var cssClassSelector = /^\./,
            idSelector = /^#/;

        if (cssClassSelector.test(selector)) {
            return domutil.hasClass(el, selector.replace('.', ''));
        } else if (idSelector.test(selector)) {
            return el.id === selector.replace('#', '');
        }

        return el.nodeName.toLowerCase() === selector.toLowerCase();
    },

    /**
     * Find DOM element by specific selectors.
     * below three selector only supported.
     *
     * 1. css selector
     * 2. id selector
     * 3. nodeName selector
     * @param {string} selector selector
     * @param {(HTMLElement|string)} [root] You can assign root element to find. if not supplied, document.body will use.
     * @param {boolean|function} [multiple=false] - set true then return all elements that meet condition, if set function then use it filter function.
     * @returns {HTMLElement} HTML element finded.
     */
    find: function(selector, root, multiple) {
        var result = [],
            found = false,
            isFirst = util.isUndefined(multiple) || multiple === false,
            isFilter = util.isFunction(multiple);

        if (util.isString(root)) {
            root = domutil.get(root);
        }
        
        root = root || window.document.body;

        function recurse(el, selector) {
            var childNodes = el.childNodes,
                i = 0,
                len = childNodes.length,
                cursor;

            for (; i < len; i += 1) {
                cursor = childNodes[i];

                if (cursor.nodeName === '#text') {
                    continue;
                }

                if (domutil._matcher(cursor, selector)) {
                    if ((isFilter && multiple(cursor)) || !isFilter) {
                        result.push(cursor);
                    }

                    if (isFirst) {
                        found = true;
                        break;
                    }
                } else if (cursor.childNodes.length > 0) {
                    recurse(cursor, selector);
                    if (found) {
                        break;
                    }
                }
            }
        }

        recurse(root, selector);

        return isFirst ? (result[0] || null) : result;
    },

    /**
     * Find parent element recursively.
     * @param {HTMLElement} el - base element to start find.
     * @param {string} selector - selector string for find
     * @returns {HTMLElement} - element finded or undefined.
     */
    closest: function(el, selector) {
        var parent = el.parentNode;

        if (domutil._matcher(el, selector)) {
            return el;
        }

        while (parent && parent !== window.document.body) {
            if (domutil._matcher(parent, selector)) {
                return parent;
            }

            parent = parent.parentNode;
        }
    },

    /**
     * Return texts inside element.
     * @param {HTMLElement} el target element
     * @return {string} text inside node
     */
    text: function(el) {
        var ret = '',
            i = 0,
            nodeType = el.nodeType;

        if (nodeType) {
            if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                // nodes that available contain other nodes
                if (typeof el.textContent === 'string') {
                    return el.textContent;
                }

                for (el = el.firstChild; el; el = el.nextSibling) {
                    ret += domutil.text(el);
                }
            } else if (nodeType === 3 || nodeType === 4) {
                // TEXT, CDATA SECTION
                return el.nodeValue;
            }
        } else {
            for (; el[i]; i += 1) {
                ret += domutil.text(el[i]);
            }
        }
        return ret;
    },

    setData: function(el, key, data) {
        if ('dataset' in el) {
            el.dataset[key] = data;
            return;
        }

        el.setAttribute('data-' + key, data);
    },

    getData: function(el, key) {
        if ('dataset' in el) {
            return el.dataset[key];
        }

        return el.getAttribute('data-' + key);
    },

    /**
     * Check element has specific design class name.
     * @param {HTMLElement} el target element
     * @param {string} name css class
     * @returns {boolean} return true when element has that css class name
     */
    hasClass: function(el, name) {
        var className;

        if (!util.isUndefined(el.classList)) {
            return el.classList.contains(name);
        }

        className = domutil.getClass(el);

        return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
    },

    /**
     * Add design class to HTML element.
     * @param {HTMLElement} el target element
     * @param {string} name css class name
     */
    addClass: function(el, name) {
        var className;

        if (!util.isUndefined(el.classList)) {
            util.forEachArray(name.split(' '), function(value) {
                el.classList.add(value);
            });
        } else if (!domutil.hasClass(el, name)) {
            className = domutil.getClass(el);
            domutil.setClass(el, (className ? className + ' ' : '') + name);
        }
    },

    /**
     *
     * Overwrite design class to HTML element.
     * @param {HTMLElement} el target element
     * @param {string} name css class name
     */
    setClass: function(el, name) {
        if (util.isUndefined(el.className.baseVal)) {
            el.className = name;
        } else {
            el.className.baseVal = name;
        }
    },

    /**
     * Element에 cssClass속성을 제거하는 메서드
     * Remove specific design class from HTML element.
     * @param {HTMLElement} el target element
     * @param {string} name class name to remove
     */
    removeClass: function(el, name) {
        var removed = '';

        if (!util.isUndefined(el.classList)) {
            el.classList.remove(name);
        } else {
            removed = (' ' + domutil.getClass(el) + ' ').replace(' ' + name + ' ', ' ');
            domutil.setClass(el, trim(removed));
        }
    },

    /**
     * Get HTML element's design classes.
     * @param {HTMLElement} el target element
     * @returns {string} element css class name
     */
    getClass: function(el) {
        if (!el || !el.className) {
            return '';
        }

        return util.isUndefined(el.className.baseVal) ? el.className : el.className.baseVal;
    },

    /**
     * Get specific CSS style value from HTML element.
     * @param {HTMLElement} el target element
     * @param {string} style css attribute name
     * @returns {(string|null)} css style value
     */
    getStyle: function(el, style) {
        var value = el.style[style] || (el.currentStyle && el.currentStyle[style]),
            css;

        if ((!value || value === 'auto') && document.defaultView) {
            css = document.defaultView.getComputedStyle(el, null);
            value = css ? css[style] : null;
        }

        return value === 'auto' ? null : value;
    },

    /**
     * get element's computed style values.
     *
     * in lower IE8. use polyfill function that return object. it has only one function 'getPropertyValue'
     * @param {HTMLElement} el - element want to get style.
     * @returns {object} virtual CSSStyleDeclaration object.
     */
    getComputedStyle: function(el) {
        var defaultView = document.defaultView;

        if (!defaultView || !defaultView.getComputedStyle) {
            return {
                getPropertyValue: function(prop) {
                    var re = /(\-([a-z]){1})/g;
                    if (prop === 'float') {
                        prop = 'styleFloat';
                    }

                    if (re.test(prop)) {
                        prop = prop.replace(re, function () {
                            return arguments[2].toUpperCase();
                        });
                    }

                    return el.currentStyle[prop] ? el.currentStyle[prop] : null;
                }
            };
        }

        return document.defaultView.getComputedStyle(el);
    },

    /**
     * Set position CSS style.
     * @param {HTMLElement} el target element
     * @param {number} [x=0] left pixel value.
     * @param {number} [y=0] top pixel value.
     */
    setPosition: function(el, x, y) {
        x = util.isUndefined(x) ? 0 : x;
        y = util.isUndefined(y) ? 0 : y;

        el[posKey] = [x, y];

        el.style.left = x + 'px';
        el.style.top = y + 'px';
    },

    /**
     * Get position from HTML element.
     * @param {HTMLElement} el target element
     * @param {boolean} [clear=false] clear cache before calculating position.
     * @returns {number[]} point
     */
    getPosition: function(el, clear) {
        var left,
            top,
            bound;

        if (clear) {
            el[posKey] = null;
        }

        if (el[posKey]) {
            return el[posKey];
        }

        left = 0;
        top = 0;

        if ((CSS_AUTO_REGEX.test(el.style.left) || CSS_AUTO_REGEX.test(el.style.top)) &&
            'getBoundingClientRect' in el) {
            // 엘리먼트의 left또는 top이 'auto'일 때 수단
            bound = el.getBoundingClientRect();

            left = bound.left;
            top = bound.top;
        } else {
            left = parseFloat(el.style.left || 0);
            top = parseFloat(el.style.top || 0);
        }

        return [left, top];
    },

    /**
     * Return element's size
     * @param {HTMLElement} el target element
     * @return {number[]} width, height
     */
    getSize: function(el) {
        var bound,
            width = domutil.getStyle(el, 'width'),
            height = domutil.getStyle(el, 'height');

        if ((CSS_AUTO_REGEX.test(width) || CSS_AUTO_REGEX.test(height)) &&
            'getBoundingClientRect' in el) {
            bound = el.getBoundingClientRect();
            width = bound.width;
            height = bound.height;
        } else {
            width = parseFloat(width || 0);
            height = parseFloat(height || 0);
        }

        return [width, height];
    },

    /**
     * Check specific CSS style is available.
     * @param {array} props property name to testing
     * @return {(string|boolean)} return true when property is available
     * @example
     * var props = ['transform', '-webkit-transform'];
     * domutil.testProp(props);    // 'transform'
     */
    testProp: function(props) {
        var style = document.documentElement.style,
            i = 0,
            len = props.length;

        for (; i < len; i += 1) {
            if (props[i] in style) {
                return props[i];
            }
        }
        return false;
    },

    /**
     * Get form data
     * @param {HTMLFormElement} formElement - form element to extract data
     * @returns {object} form data
     */
    getFormData: function(formElement) {
        var groupedByName = new Collection(function() { return this.length; }),
            noDisabledFilter = function(el) { return !el.disabled; },
            output = {};
            
        groupedByName.add.apply(
            groupedByName, 
            domutil.find('input', formElement, noDisabledFilter)
                .concat(domutil.find('select', formElement, noDisabledFilter))
                .concat(domutil.find('textarea', formElement, noDisabledFilter))
        );

        groupedByName = groupedByName.groupBy(function(el) {
            return el && el.getAttribute('name') || '_other';
        });

        util.forEach(groupedByName, function(elements, name) {
            if (name === '_other') {
                return;
            }

            elements.each(function(el) {
                var nodeName = el.nodeName.toLowerCase(),
                    type = el.type,
                    result = [];

                if (type === 'radio' || type === 'checkbox') {
                    result = elements.find(function(el) { return el.checked; }).toArray();
                } else if (nodeName === 'select') {
                    elements.find(function(el) { return !!el.childNodes.length; })
                        .each(function(el) {
                            result = result.concat(domutil.find('option', el, function(opt) {
                                return opt.selected;
                            }));
                        });
                } else {
                    result = elements.find(function(el) { return el.value !== ''; }).toArray();
                }

                result = util.map(result, function(el) { return el.value; });

                if (!result.length) {
                    result = '';
                } else if (result.length === 1) {
                    result = result[0];
                }

                output[name] = result;
            });
        });

        return output;
    }
};

/*eslint-disable*/
var userSelectProperty = domutil.testProp([
    'userSelect', 
    'WebkitUserSelect', 
    'OUserSelect', 
    'MozUserSelect', 
    'msUserSelect'
]);
var supportSelectStart = 'onselectstart' in document;
var prevSelectStyle = '';
/*eslint-enable*/

/**
 * Disable browser's text selection behaviors.
 * @method
 */
domutil.disableTextSelection = (function() {
    if (supportSelectStart) {
        return function() {
            domevent.on(window, 'selectstart', domevent.preventDefault);
        };
    }

    return function() {
        var style = document.documentElement.style;
        prevSelectStyle = style[userSelectProperty];
        style[userSelectProperty] = 'none';
    };
})();

/**
 * Enable browser's text selection behaviors.
 * @method
 */
domutil.enableTextSelection = (function() {
    if (supportSelectStart) {
        return function() {
            domevent.off(window, 'selectstart', domevent.preventDefault);
        };
    }

    return function() {
        document.documentElement.style[userSelectProperty] = prevSelectStyle;
    };
})();

/**
 * Disable browser's image drag behaviors.
 */
domutil.disableImageDrag = function() {
    domevent.on(window, 'dragstart', domevent.preventDefault);
};

/**
 * Enable browser's image drag behaviors.
 */
domutil.enableImageDrag = function() {
    domevent.off(window, 'dragstart', domevent.preventDefault);
};

module.exports = domutil;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./collection":26,"./domevent":30}],32:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Mixin module for models.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util,
    spaceRx = /^\s*|\s*$/g,
    model;

var datetime = require('../common/datetime');

/**
 * Mixin module for models.
 * @mixin
 */
model = {
    /**
     * string trim
     * @param {string} str string to trim
     * @returns {string} trimed string
     */
    trim: function(str) {
        return str.replace(spaceRx, '');
    },
    /**
     * The collections of validator functions.
     */
    validators: {
        /**
         * check all of supplied fields(property) is not undefined or empty string.
         * @param {object} instance model instance.
         * @param {string[]} fields property names to check.
         * @returns {boolean} return true when supplied fields are not undefined or empty string.
         */
        required: function(instance, fields) {
            var valid = true,
                isValid = function(obj) {
                    return !util.isUndefined(obj) && model.trim(obj) !== '';
                };

            util.forEach(fields, function(fieldName) {
                valid = isValid(instance[fieldName]);
                return valid;
            });

            return valid;
        },

        /**
         * check supplied fields are valid dates and valid date ranges.
         * @param {object} instance model instance.
         * @param {Date[]} fields array of date range (starts, ends)
         * @returns {boolean} is valid date range?
         */
        dateRange: function(instance, fields) {
            var starts,
                ends;

            if (!util.isExisty(instance) || fields.length !== 2) {
                return true;
            }

            starts = new Date(instance[fields[0]]);
            ends = new Date(instance[fields[1]]);

            if (!datetime.isValid(starts) || !datetime.isValid(ends)) {
                return false;
            }

            if (datetime.compare(starts, ends) === 1) {
                return false;
            }

            return true;
        }
    },

    /**
     * Check validate for model instance.
     *
     * The validate are works on a basis of constructor's "schema" property.
     *
     * You can customize validators add some method to model#validators.
     * @returns {Boolean} model is valid?
     */
    isValid: function() {
        var that = this,
            schema = this.constructor.schema,
            validators = model.validators,
            validator,
            valid = true;

        if (!schema) {
            return true;
        }

        util.forEach(schema, function(values, validatorName) {
            validator = validators[validatorName];

            if (validator) {
                valid = validator(that, values);
                return valid;
            }
        });

        return valid;
    },

    /**
     * Make data object form instance.
     *
     * It return object fill with all owned properties but exclude functions.
     * @returns {object} Data object
     */
    parameterize: function() {
        var param = {},
            isFunc = util.isFunction;

        util.forEach(this, function(value, propName) {
            if (!isFunc(value)) {
                param[propName] = value;
            }
        });

        return param;
    },

    /**
     * Mixin model module to supplied target.
     * @param {Object} target The object of want to mixed.
     * @example
     * function Man() {
     *     this.name = 'john';
     * }
     * model.mixin(Man.prototype);
     */
    mixin: function(target) {
        util.forEach(model, function(method, name) {
            if (name !== 'mixin') {
                target[name] = method;
            }
        });
    }
};

module.exports = model;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/datetime":28}],33:[function(require,module,exports){
(function (global){
/**
 * @fileoverview
 * Class for represent two dimensional x, y coordinates.
 *
 * It suppliy a group of functions for manipulate coordinates.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 * @example
 * var p = point(10, 10);
 * var r1 = p.add(Point(5, 5));
 * console.log(p.toString())    // "Point(10, 10)"
 * console.log(r1.toString())    // "Point(15, 15)"
 *
 * var p2 = new Point(10, 10);
 * p2._add(point(5, 5));
 * console.log(p2.toString())   // "Point(15, 15)"
 */
'use strict';

var util = global.ne.util;

/**
 * Class for represent two dimentional x, y coordinates.
 * @constructor
 * @param {number} x The number of X coordinates.
 * @param {number} y The number of Y coordinates.
 * @param {boolean} [useRound=false] set true when each coordinates are rounded before initialize.
 * @example
 * var t = new Point(13, 5);
 */
function Point(x, y, useRound) {
    /**
     * @type {number}
     */
    this.x = (useRound ? Math.round(x) : x);

    /**
     * @type {number}
     */
    this.y = (useRound ? Math.round(y) : y);
}

/**********
 * static props
 **********/

/**
 * Calculate point ratio.
 * @param {Point} point The instance of point.
 * @param {number} factor From factor
 * @param {number} toFactor To factor
 * @returns {Point} Point instance calculated.
 */
Point.getRatio = function(point, factor, toFactor) {
    if (factor === toFactor) {
        return point.clone();
    }

    return point.multiplyBy(toFactor)._divideBy(factor);
};

/**
 * Syntatic sugar of new Point()
 * @param {(Point|number|number[])} x X coordinate value.
 * @param {(number|boolean)} [y] Y coordinate value or boolean value for coordinates round.
 * @param {boolean} [useRound] Set true then round initial coordinate values.
 * @returns {Point} The instance of point.
 * @example
 * var p1 = point(10, 15);
 * var p2 = point([10, 15]);
 */
Point.n = function(x, y, useRound) {
    if (x instanceof Point) {
        return x;
    }

    if (util.isArray(x)) {
        return new Point(x[0], x[1], y);
    }

    return new Point(x, y, useRound);
};

/**********
 * prototype props
 **********/

/**
 * Clone points
 * @returns {Point} The point instance cloned.
 */
Point.prototype.clone = function() {
    return new Point(this.x, this.y);
};

/**
 * Add points.
 * @param {Point} point The point instance to add.
 * @return {Point} Point calculated.
 */
Point.prototype.add = function(point) {
    return this.clone()._add(Point.n(point));
};

/**
 * Add self points.
 * @param {Point} point The point instance to add.
 * @return {Point} Point calculated.
 */
Point.prototype._add = function(point) {
    this.x += point.x;
    this.y += point.y;
    return this;
};

/**
 * Subtract points.
 * @param {Point} point The point instance to subtract.
 * @return {Point} Point calculated.
 */
Point.prototype.subtract = function(point) {
    return this.clone()._subtract(Point.n(point));
};

/**
 * Subtract points. (manipulate self)
 * @param {Point} point The point instance to subtract.
 * @returns {Point} Point calculated.
 */
Point.prototype._subtract = function(point) {
    this.x -= point.x;
    this.y -= point.y;
    return this;
};

/**
 * Divide points.
 * @param {number} num The number to divide.
 * @returns {Point} Point calculated.
 */
Point.prototype.divideBy = function(num) {
    return this.clone()._divideBy(num);
};

/**
 * Divide points. (manipulate self)
 * @param {number} num The number to divide.
 * @returns {Point} Point calculated.
 */
Point.prototype._divideBy = function(num) {
    this.x /= num;
    this.y /= num;
    return this;
};

/**
 * Multiply coordinates.
 * @param {number} num Thyen number to multiply
 * @return {Point} Point calculated.
 */
Point.prototype.multiplyBy = function(num) {
    return this.clone()._multiplyBy(num);
};

/**
 * Multiply self coordinates.
 * @param {number} num The number to multiply.
 * @returns {Point} Point calculated.
 */
Point.prototype._multiplyBy = function(num) {
    this.x *= num;
    this.y *= num;
    return this;
};

/**
 * Round coordinates.
 * @returns {Point} Point calculated.
 */
Point.prototype.round = function() {
    return this.clone()._round();
};

/**
 * Round self coordinates.
 * @returns {Point} Point calculated.
 */
Point.prototype._round = function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
};

/**
 * Reverse values between positive and negative.
 * @returns {Point} Point calculated.
 */
Point.prototype.reverse = function() {
    return this.clone()._reverse();
};

/**
 * Reverse self values between positive and negative.
 * @returns {Point} Point calculated.
 */
Point.prototype._reverse = function() {
    this.x *= -1;
    this.y *= -1;
    return this;
};

/**
 * Floor coordinates.
 * @returns {Point} Point calculated.
 */
Point.prototype.floor = function() {
    return this.clone()._floor();
};

/**
 * Floor self coordinates.
 * @returns {Point} Point calculated.
 */
Point.prototype._floor = function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
};

/**
 * Ceil coordinates.
 * @returns {Point} Point calculated.
 */
Point.prototype.ceil = function() {
    return this.clone()._ceil();
};

/**
 * Ceil self coodinates.
 * @returns {Point} Point calculated.
 */
Point.prototype._ceil = function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
};

/**
 * Rotate point.
 * @param {number} deg The number of rotate degree.
 * @param {Point} [center=this] Center point instance to use rotate center. use own when not supplied.
 * @param {number} [cos] Cosine values for rotate. it useful when multi point rotate.
 * @param {number} [sin] Sine values for rotate. it useful when multi point rotate.
 * @returns {Point} The point instance rotated.
 */
Point.prototype.rotate = function(deg, center, cos, sin) {
    return this.clone()._rotate(deg, center, cos, sin);
};

/**
 * Rotate self.
 * @param {number} deg The number of rotate degree.
 * @param {Point} [center=this] Center point instance to use rotate center. use own when not supplied.
 * @param {number} [cos] Cosine values for rotate. it useful when multi point rotate.
 * @param {number} [sin] Sine values for rotate. it useful when multi point rotate.
 * @returns {Point} The point instance rotated.
 */
Point.prototype._rotate = function(deg, center, cos, sin) {
    var rad = deg * (Math.PI / 180),
        x,
        y;

    cos = cos || parseFloat(Math.cos(rad).toFixed(8));
    sin = sin || parseFloat(Math.sin(rad).toFixed(8));

    this._subtract(center);

    x = this.x;
    y = this.y;

    this.x = x * cos - y * sin;
    this.y = x * sin + y * cos;

    this._add(center);

    return this;
};

/**
 * Calculate distance between two points.
 * @param {Point} point Point instance.
 * @returns {number} The number of distance between two points.
 */
Point.prototype.distanceTo = function(point) {
    var x,
        y;

    point = Point.n(point);

    x = point.x - this.x;
    y = point.y - this.y;

    return Math.sqrt(x * x + y * y);
};

/**
 * Check point equals.
 * @param {Point} point Point instance to compare
 * @returns {boolean} equality
 */
Point.prototype.equals = function(point) {
    point = Point.n(point);
    return point.x === this.x && point.y === this.y;
};

/**
 * Return formatted string. 'Point(x, y)'
 * @returns {string} string
 */
Point.prototype.toString = function() {
    return 'Point(' + this.x + ', ' + this.y + ')';
};

/**
 * Return coodinates to array. [x, y]
 * @returns {number[]} coordinate array.
 */
Point.prototype.toArray = function() {
    return [this.x, this.y];
};

module.exports = Point;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],34:[function(require,module,exports){
(function (global){
/**
 * @fileoverview RequestAnimFrame
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var requestFn,
    cancelFn;

function getPrefixed(name) {
    return global['webkit' + name] || global['moz' + name] || global['ms' + name];
}

requestFn = global.requestAnimationFrame ||
    getPrefixed('RequestAnimationFrame') ||
    function(fn, context) {
        fn.call(context);
    };

cancelFn = global.cancelAnimationFrame ||
    getPrefixed('CancelAnimationFrame') ||
    getPrefixed('CancelRequestAnimationFrame') ||
    function() {};

/**
 * @module module:reqAnimFrame
 */

module.exports = {
    /**
     * Shim of requestAnimationFrame
     * @param {function} fn callback function
     * @param {*} context context for callback
     * @returns {number} Unique id
     */
    requestAnimFrame: function(fn, context) {
        return requestFn.call(global, util.bind(fn, context));
    },

    /**
     * Shim of cancelAnimationFrame
     * @param {number} id requestAnimationFrame id
     */
    cancelAnimFrame: function(id) {
        if (!id) {
            return;
        }

        cancelFn.call(global, id);
    }
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],35:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Base calendar controller
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var Event = require('../model/event');
var EventViewModel = require('../model/viewModel/event');
var datetime = require('../common/datetime');
var common = require('../common/common');

/**
 * @constructor
 * @param {object} options - options for base controller
 * @param {function} [options.groupFunc] - function for group each models {@see Collection#groupBy}
 * @mixes util.CustomEvents
 */
function Base(options) {
    options = options || {};

    /**
     * function for group each event models.
     * @type {function}
     * @param {EventViewModel} viewModel - view model instance
     * @return {string} group key
     */
    this.groupFunc = options.groupFunc || function(viewModel) {
        if (viewModel.model.isAllDay) {
            return 'allday';
        }
        return 'time';
    }

    /**
     * events collection.
     * @type {Collection}
     */
    this.events = common.createEventCollection();

    /**
     * Matrix for multidate events.
     * @type {object.<string, array>}
     */
    this.dateMatrix = {};
}

/**
 * Calculate contain dates in event.
 * @private
 * @param {Event} event The instance of event.
 * @returns {array} contain dates.
 */
Base.prototype._getContainDatesInEvent = function(event) {
    var range = datetime.range(
        datetime.start(event.getStarts()),
        datetime.start(event.getEnds()),
        datetime.MILLISECONDS_PER_DAY
    );

    return range;
};

/**********
 * CRUD
 **********/

/**
 * Create an event instance from raw data.
 * @emits Base#createdEvent
 * @param {object} options Data object to create event.
 * @param {boolean} silent - set true then don't fire events.
 * @returns {Event} The instance of Event that created.
 */
Base.prototype.createEvent = function(options, silent) {
    var event = this.addEvent(Event.create(options));

    if (!silent) {
        /**
         * @event Base#createdEvent
         * @type {Event}
         */
        this.fire('createdEvent', event);
    }

    return event;
};

/**
 * Set date matrix to supplied event instance.
 * @param {Event} event - instance of event.
 */
Base.prototype._addToMatrix = function(event) {
    var ownMatrix = this.dateMatrix,
        containDates = this._getContainDatesInEvent(event);

    util.forEach(containDates, function(date) {
        var ymd = datetime.format(date, 'YYYYMMDD'),
            matrix = ownMatrix[ymd] = ownMatrix[ymd] || [];

        matrix.push(util.stamp(event));
    });
};

/**
 * Remove event's id from matrix.
 * @param {Event} event - instance of event
 */
Base.prototype._removeFromMatrix = function(event) {
    var modelID = util.stamp(event);

    util.forEach(this.dateMatrix, function(matrix) {
        var index = util.inArray(modelID, matrix);

        if (~index) {
            matrix.splice(index, 1);
        }
    }, this);
};

/**
 * Add an event instance.
 * @emits Base#addedEvent
 * @param {Event} event The instance of Event.
 * @param {boolean} silent - set true then don't fire events.
 * @returns {Event} The instance of Event that added.
 */
Base.prototype.addEvent = function(event, silent) {
    this.events.add(event);
    this._addToMatrix(event);

    if (!silent) {
        /**
         * @event Base#addedEvent
         * @type {object}
         */
        this.fire('addedEvent', event);
    }

    return event;
};

/**
 * split event model by ymd.
 * @param {Date} starts - start date
 * @param {Date} ends - end date
 * @param {Collection} eventCollection - collection of event model.
 * @returns {object.<string, Collection>} splitted event model collections.
 */
Base.prototype.splitEventByDateRange = function(starts, ends, eventCollection) {
    var range = datetime.range(
            datetime.start(starts),
            datetime.start(ends),
            datetime.MILLISECONDS_PER_DAY
        ),
        ownMatrix = this.dateMatrix,
        result = {};

    util.forEachArray(range, function(date) {
        var ymd = datetime.format(date, 'YYYYMMDD'),
            matrix = ownMatrix[ymd],
            collection;

        collection = result[ymd] = common.createEventCollection();

        if (matrix && matrix.length) {
            util.forEachArray(matrix, function(id) {
                eventCollection.doWhenHas(id, function(event) {
                    collection.add(event);
                });
            });
        }
    });

    return result;
};

/**
 * Return events in supplied date range.
 *
 * available only YMD.
 * @param {Date} starts start date.
 * @param {Date} ends end date.
 * @returns {object.<string, Collection>} event collection grouped by dates.
 */
Base.prototype.findByDateRange = function(starts, ends) {
    var range = datetime.range(
            datetime.start(starts),
            datetime.start(ends),
            datetime.MILLISECONDS_PER_DAY
        ),
        ownEvents = this.events.items,
        ownMatrix = this.dateMatrix,
        dformat = datetime.format,
        result = {},
        matrix,
        ymd,
        viewModels;

    util.forEachArray(range, function(date) {
        ymd = dformat(date, 'YYYYMMDD');
        matrix = ownMatrix[ymd];
        viewModels = result[ymd] = common.createEventCollection();

        if (matrix && matrix.length) {
            viewModels.add.apply(viewModels, util.map(matrix, function(id) {
                return EventViewModel.create(ownEvents[id]);
            }));
        }
    });

    return result;
};

// Update
/**
 * Update an event.
 * @emits Base#updateEvent
 * @param {number} id The unique id of Event instance.
 * @param {object} options updated object data.
 * @returns {Event|boolean} updated event instance, when it fail then return false.
 */
Base.prototype.updateEvent = function(id, options) {
    var result = false;

    this.events.doWhenHas(id, function(event) {
        options = options || {};

        if (options.title) {
            event.set('title', options.title);
        }

        if (options.isAllDay) {
            event.set('isAllDay', options.isAllDay);
        }

        if (options.starts) {
            event.set('starts', new Date(options.starts));
        }

        if (options.ends) {
            event.set('ends', new Date(options.ends));
        }

        this._removeFromMatrix(event);
        this._addToMatrix(event);

        result = event;
    }, this);

    /**
     * @event Base#updateEvent
     */
    this.fire('updateEvent');

    return result;
};

// Delete
/**
 * Delete event instance from controller.
 * @param {number} id - unique id of model instance.
 * @returns {Event} deleted model instance.
 */
Base.prototype.deleteEvent = function(id) {
    var result = false;

    this.events.doWhenHas(id, function(event) {
        result = event;
        this._removeFromMatrix(event);
        this.events.remove(event);
    }, this);

    return result;
};

/**********
 * API
 **********/

Base.prototype.sync = function() {};
Base.prototype.fetch = function(query) {};

// mixin
util.CustomEvents.mixin(Base);

module.exports = Base;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/common":27,"../common/datetime":28,"../model/event":74,"../model/viewModel/event":75}],36:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Controller mixin modules for day views.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../../common/datetime');
var common = require('../../common/common');
var array = require('../../common/array');
var EventViewModel = require('../../model/viewModel/event');
var aps = Array.prototype.slice;

/**
 * @mixin Base.Week
 */
var Week = {
    /**********
     * COMMON
     **********/

    /**
     * Calculate collision group.
     * @this Base.Week
     * @param {array} viewModels List of viewmodels.
     * @returns {array} Collision Group.
     */
    getCollisionGroup: function(viewModels) {
        var collisionGroups = [],
            foundPrevCollisionEvent = false,
            previousEventList;

        if (!viewModels.length) {
            return collisionGroups;
        }

        collisionGroups[0] = [util.stamp(viewModels[0].valueOf())];
        util.forEachArray(viewModels.slice(1), function(event, index) {
            foundPrevCollisionEvent = false;
            previousEventList = aps.apply(viewModels, [0, index + 1]).reverse();

            util.forEachArray(previousEventList, function(previous) {
                if (event.collidesWith(previous)) {
                    // 이전 일정들과 겹치는 경우 겹치는 일정의 Collision Group을
                    // 찾아 이 일정을 추가한다
                    foundPrevCollisionEvent = true;

                    util.forEachArray(collisionGroups.slice(0).reverse(), function(group) {
                        if (~util.inArray(util.stamp(previous.valueOf()), group)) {
                            // 겹치는 이전 일정을 찾은 경우 그 일정이 속한
                            // Collision Group에 이 일정을 포함시킨다.
                            group.push(util.stamp(event.valueOf()));
                            return false;
                        }
                    });

                    return false;
                }
            });

            if (!foundPrevCollisionEvent) {
                // 이 일정은 이전일정과 겹치지 않는 일정이므로
                // 새 Collision Group을 구성한다.
                collisionGroups.push([util.stamp(event.valueOf())]);
            }
        });

        return collisionGroups;
    },

    /**
     * Get row length by column index in 2d matrix.
     * @this Base.Week
     * @param {array[]} arr2d Matrix
     * @param {number} col Column index.
     * @return {number} Last row number in column.
     */
    getLastRowInColumn: function(arr2d, col) {
        var row = arr2d.length;

        while (row > 0) {
            row -= 1;
            if (!util.isUndefined(arr2d[row][col])) {
                return row;
            }
        }

        return false;
    },

    /**
     * Calculate matrix for appointment block element placing.
     * @this Base.Week
     * @param {Collection} collection model collection.
     * @param {array[]} collisionGroups Collision groups for event set.
     * @returns {array} matrices
     */
    getMatrices: function(collection, collisionGroups) {
        var result = [],
            getLastRowInColumn = Week.getLastRowInColumn;

        util.forEachArray(collisionGroups, function(group) {
            var matrix = [[]];

            util.forEachArray(group, function(eventID) {
                var event = collection.items[eventID],
                    col = 0,
                    found = false,
                    nextRow,
                    lastRowInColumn;

                while (!found) {
                    lastRowInColumn = getLastRowInColumn(matrix, col);

                    if (lastRowInColumn === false) {
                        matrix[0].push(event);
                        found = true;
                    } else if (!event.collidesWith(matrix[lastRowInColumn][col])) {
                        nextRow = lastRowInColumn + 1;
                        if (util.isUndefined(matrix[nextRow])) {
                            matrix[nextRow] = [];
                        }
                        matrix[nextRow][col] = event;
                        found = true;
                    }

                    col += 1;
                }
            });

            result.push(matrix);
        });

        return result;
    },

    /**********
     * TIME GRID VIEW
     **********/

    /**
     * Make array with start and end times on events.
     * @this Base.Week
     * @param {array[]} matrix - matrix from controller.
     * @returns {array[]} starttime, endtime array (exclude first row's events)
     */
    generateTimeArrayInRow: function(matrix) {
        var row,
            col,
            event,
            map = [],
            cursor = [],
            maxColLen = Math.max.apply(null, util.map(matrix, function(col) {
                return col.length;
            }));

        for (col = 1; col < maxColLen; col += 1) {
            row = 0;
            event = util.pick(matrix, row, col);

            while (event) {
                cursor.push([event.getStarts().getTime(), event.getEnds().getTime()]);

                row += 1;
                event = util.pick(matrix, row, col);
            }

            map.push(cursor);
            cursor = [];
        }

        return map;
    },

    /**
     * Get collision information from list
     * @this Base.Week
     * @param {array.<number[]>} arr - list to detecting collision. [[start, end], [start, end]]
     * @param {number} start - event start time that want to detect collisions.
     * @param {number} end - event end time that want to detect collisions.
     * @returns {boolean} target has collide in supplied array?
     */
    hasCollide: function(arr, start, end) {
        var startStart,
            startEnd,
            endStart,
            endEnd,
            getFunc = function(index) {
                return function(block) {
                    return block[index];
                };
            },
            abs = Math.abs,
            compare = array.compare.num.asc,
            hasCollide;

        if (!arr.length) {
            return false;
        }

        startStart = abs(array.bsearch(arr, start, getFunc(0), compare));
        startEnd = abs(array.bsearch(arr, start, getFunc(1), compare));
        endStart = abs(array.bsearch(arr, end, getFunc(0), compare));
        endEnd = abs(array.bsearch(arr, end, getFunc(1), compare));
        hasCollide = !(startStart === startEnd && startEnd === endStart && endStart === endEnd);

        return hasCollide;
    },

    /**
     * Initialize values to viewmodels for detect real collision at rendering phase.
     * @this Base.Week
     * @param {array[]} matrices - Matrix data.
     */
    getCollides: function(matrices) {
        util.forEachArray(matrices, function(matrix) {
            var binaryMap,
                maxRowLength;

            binaryMap = Week.generateTimeArrayInRow(matrix);
            maxRowLength = Math.max.apply(null, util.map(matrix, function(row) {
                return row.length;
            }));

            util.forEachArray(matrix, function(row) {
                util.forEachArray(row, function(viewModel, col) {
                    var startTime,
                        endTime,
                        hasCollide,
                        i;

                    if (!viewModel) {
                        return;
                    }

                    startTime = viewModel.getStarts().getTime() + 1;
                    endTime = viewModel.getEnds().getTime() - 1;

                    for (i = (col + 1); i < maxRowLength; i += 1) {
                        hasCollide = Week.hasCollide(binaryMap[i - 1], startTime, endTime);

                        if (hasCollide) {
                            viewModel.hasCollide = true;
                            break;
                        }

                        viewModel.extraSpace += 1;
                    }
                });
            });
        });
    },

    /**
     * @this Base
     * @param {Date} starts - start date.
     * @param {Date} ends - end date.
     * @param {Collection} time - view model collection.
     * @returns {object} view model for time part.
     */
    getViewModelForTimeView: function(starts, ends, time) {
        var ymdSplitted = this.splitEventByDateRange(starts, ends, time),
            result = {};

        util.forEach(ymdSplitted, function(collection, ymd) {
            var viewModels = collection.sort(array.compare.event.asc),
                collisionGroups,
                matrices;

            collisionGroups = this.getCollisionGroup(viewModels);
            matrices = this.getMatrices(collection, collisionGroups);
            this.getCollides(matrices);

            result[ymd] = matrices;
        }, Week);

        return result;
    },

    /**********
     * ALLDAY VIEW
     **********/

    /**
     * create view model for allday view part.
     * @param {Date} starts start date.
     * @param {Date} ends end date.
     * @param {Collection} viewModels - allday event viewModel viewModels.
     * @returns {object} allday viewModel.
     */
    getViewModelForAlldayView: function(starts, ends, viewModels) {
        var list,
            ymdsToRender,
            collisionGroups,
            matrices;

        if (!viewModels || !viewModels.length) {
            return [];
        }

        ymdsToRender = util.map(
            datetime.range(starts, ends, datetime.MILLISECONDS_PER_DAY),
            function(date) {
                return datetime.format(date, 'YYYYMMDD');
            }
        );

        list = viewModels.sort(array.compare.event.asc);
        collisionGroups = Week.getCollisionGroup(list);
        matrices = Week.getMatrices(viewModels, collisionGroups);

        util.forEachArray(matrices, function(matrix) {
            util.forEachArray(matrix, function(column) {
                util.forEachArray(column, function(viewModel, index) {
                    var ymd, dateLength;

                    if (!viewModel) {
                        return;
                    }

                    ymd = datetime.format(viewModel.getStarts(), 'YYYYMMDD');
                    dateLength = datetime.range(
                        viewModel.getStarts(),
                        viewModel.getEnds(),
                        datetime.MILLISECONDS_PER_DAY
                    ).length;

                    viewModel.top = index;
                    viewModel.left = util.inArray(ymd, ymdsToRender);
                    viewModel.width = dateLength;
                });
            });
        });

        return matrices;
    },

    /**********
     * READ
     **********/

    /**
     * Populate events in date range.
     * @this Base
     * @param {Date} starts start date.
     * @param {Date} ends end date.
     * @returns {object} events grouped by dates.
     */
    findByDateRange: function(starts, ends) {
        var that = this,
            events,
            viewModels;

        // QUERY EVENTS
        events = this.events.find(function(model) {
            var ownStarts = model.getStarts(),
                ownEnds = model.getEnds();

            return (ownStarts >= starts && ownEnds <= ends) ||
                (ownStarts < starts && ownEnds >= starts) ||
                (ownEnds > ends && ownStarts <= ends);
        });

        // CONVERT TO VIEWMODEL
        viewModels = common.createEventCollection.apply(
            null,
            util.map(events.items, function(event) {
                return EventViewModel.create(event);
            })
        ).groupBy(['allday', 'time'], this.groupFunc);

        // CUSTOMIZE VIEWMODEL FOR EACH VIEW
        util.forEach(viewModels, function(coll, key, obj) {
            if (key === 'allday') {
                coll.each(function(viewModel) {
                    var ownStarts = viewModel.getStarts(),
                        ownEnds = viewModel.getEnds();

                    if (ownStarts < starts) {
                        viewModel.renderStarts = new Date(starts.getTime());
                    }

                    if (ownEnds > ends) {
                        viewModel.renderEnds = new Date(ends.getTime());
                    }
                });

                obj.allday = util.bind(Week.getViewModelForAlldayView, that)(starts, ends, coll);
            } else if (key === 'time') {
                obj.time = util.bind(Week.getViewModelForTimeView, that)(starts, ends, coll);
            }
        });

        return viewModels;
    }
};

module.exports = Week;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/array":24,"../../common/common":27,"../../common/datetime":28,"../../model/viewModel/event":75}],37:[function(require,module,exports){
/**
 * @fileoverview Module for manage calendar REST API requests.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var Ajax = require('../common/ajax');

// 캘린더 API 기본 PATH
var ROOT_PATH = '/wapi/task-tracker';

/**********
 * CALENDAR
 **********/

/**
 * 해당 프로젝트의 캘린더 목록 확인
 * @memberof CalendarAPI
 * @param {string} [projectCode='*'] - 프로젝트 코드 '*' 사용가능
 * @param {object} ajaxOptions - ajax 모듈에 사용할 옵션 객체
 */ 
function getCalendars(projectCode, ajaxOptions) {
    var url = 'projects/{{ projectCode }}/calendars';
    projectCode = projectCode || '*';
    url = ROOT_PATH + '/' + url.replace('{{ projectCode }}', projectCode);

    ajaxOptions = ajaxOptions || {};

    new Ajax().ajax(url, ajaxOptions);
}

/**
 * 캘린더 만들기
 * @memberof CalendarAPI
 * @param {string} projectCode - 프로젝트 코드
 * @param {service/model/calendar} data - 캘린더 생성 관련 데이터
 * @param {object} ajaxOptions - ajax 모듈에 사용할 옵션 객체
 */
function postCalendars(projectCode, data, ajaxOptions) {
    var url = 'projects/{{ projectCode }}/calendars';
    projectCode = projectCode || '*';
    url = ROOT_PATH + '/' + url.replace('{{ projectCode }}', projectCode);

    ajaxOptions = ajaxOptions || {};
    ajaxOptions.data = JSON.stringify([data]);
    ajaxOptions.method = 'POST';

    new Ajax().ajax(url, ajaxOptions);
}

/**********
 * TASK
 **********/

/**
 * 일정 목록 조회
 * @memberof CalendarAPI
 * @param {string} [projectCode='*'] - 프로젝트 코드
 * @param {string} [calendarId='*'] - 캘린더 ID
 * @param {string} [timeMin] - 조회시작일자
 * @param {string} [timeMax] - 조회 종료일자
 * @param {object} [ajaxOptions] - ajax 모듈에 사용할 옵션 객체
 */
function getCalendarTasks(projectCode, calendarId, timeMin, timeMax, ajaxOptions) {
    var url = 'projects/{{ projectCode }}/calendars/{{ calendarId }}/tasks' +
        '?calendars={{ calendars }}&timeMin={{ timeMin }}&timeMax={{ timeMax }}';

    calendarId = calendarId.replace(/\s/g, '');

    url = ROOT_PATH + '/' + url.replace('{{ projectCode }}', projectCode || '*')
        .replace('{{ calendarId }}', ~calendarId.indexOf(',') ? '*' : calendarId || '*')
        .replace('{{ calendars }}', ~calendarId.indexOf(',') ? calendarId : '')
        .replace('{{ timeMin }}', timeMin || '')
        .replace('{{ timeMax }}', timeMax || '');

    new Ajax().ajax(url, ajaxOptions || {});
}

/**
 * 캘린더에 관련된 API호출 기능을 모아둔 믹스인 모듈. service/calendar 모듈에서 사용한다.
 * @mixin CalendarAPI
 */
module.exports = /** @lends CalendarAPI */ {
    getCalendars: getCalendars,
    postCalendars: postCalendars,
    getCalendarTasks: getCalendarTasks
};

},{"../common/ajax":23}],38:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Interface for DoorayBase controller to allow talk with dooray API server
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var common = require('../../common/common');
var datetime = require('../../common/datetime');
var calendarAPI = require('../calendarAPI');
var Collection = require('../../common/collection');
var noop = (function() {});

// model
var DoorayEvent = require('../model/event');
var CalendarReference = require('../model/calendar');

/**
 * @constructor
 * @param {object} options - options for API module
 * @param {function} [options.beforeRequest] - function invoke before all request sending
 * @param {function} [options.afterResponse] - function invoke after all request reponded
 */
function API(options) {
    /**
     * @type {object}
     */
    this.options = util.extend({
        member: null,
        beforeRequest: noop,
        afterResponse: noop
    }, options);
}

/**
 * 모든 API통신이 실패했을 때 동작하는 콜백 핸들러 반환
 * @param {function} callback - 사용자 콜백 함수
 * @returns {function} - API실패 핸들러 함수
 */
API.prototype._onFailFunc = function(callback) {
    return function() {
        callback(true, null);
    };
};

/**
 * 캘린더 목록 조회 함수 캘린더 목록을 콜렉션 형태로 반환한다
 * @param {string} [projectCode='*'] - 조회할 프로젝트
 * @param {function} callback - common nodejs collback function. 첫 번째 인자는 오류, 두 번째 인자는 캘린더 콜렉션을 반환한다
 */
API.prototype.getCalendars = function(projectCode, callback) {
    var options = this.options,
        onFail = this._onFailFunc(callback),
        calendars = new Collection(function(calendarRef) {
            return calendarRef.id + '';
        });

    calendarAPI.getCalendars(projectCode, {
        success: function(res) {
            var dataObject = util.pick(res, 'result', 'calendars');

            if (dataObject && dataObject.length) {
                calendars.add.apply(calendars, util.map(dataObject, function(data) {
                    var inst = new CalendarReference();
                    inst.unmarshal(data);
                    return inst;
                }));
            }

            callback(false, calendars);
        },
        error: onFail,
        fail: onFail,
        complete: options.afterResponse
    });

    options.beforeRequest();
};

API.prototype.postCalendar = function(data, callback) {
    var options = this.options,
        member = options.member,
        onFail = this._onFailFunc(callback),
        projectCode;

    if (data.type === 'private') {
        // 개인 캘린더의 경우 projectCode는 @userCode
        projectCode = '@' + member.userCode;
        data.delegation = [];
        // data.delegation = data.delegation || [];
        data.delegation.push({
            user: {
                id: member.orgMemberId 
            },
            permission: 'read_write'
        });
    }

    calendarAPI.postCalendars(projectCode, data, {
        success: function(res) {
            callback(false, res);
        },
        error: onFail,
        fail: onFail,
        complete: options.afterResponse
    });

    options.beforeRequest();
};

/**
 * 일정 목록을 조회한다
 * @param {string} [projectCode='*'] - 프로젝트 코드
 * @param {string} [calendarId='*'] - 캘린더 ID
 * @param {string|Date} [timeMin] - 조회시작일자 Timezone offset 을 포함한 UTC필요
 * @param {string|Date} [timeMax] - 조회 종료일자 Timezone offset 을 포함한 UTC필요
 * @param {function} callback - 콜백 함수. 첫 번째 인자는 오류 여부, 두 번째 인자는 일정 콜렉션
 */
API.prototype.getTasks = function(projectCode, calendarId, timeMin, timeMax, callback) {
    var options = this.options,
        onFail = this._onFailFunc(callback),
        tasks = common.createEventCollection();

    timeMin = util.isDateSafe(timeMin) ? datetime.format(timeMin, 'LOCAL') : timeMin;
    timeMax = util.isDateSafe(timeMax) ? datetime.format(timeMax, 'LOCAL') : timeMax;

    calendarAPI.getCalendarTasks(projectCode, calendarId, timeMin, timeMax, {
        success: function(res) {
            var dataObject = util.pick(res, 'result', 'tasks');

            if (dataObject && dataObject.length) {
                tasks.add.apply(tasks, util.map(dataObject, function(data) {
                    var inst = new DoorayEvent();
                    inst.unmarshal(data);
                    return inst;
                }));
            }

            callback(false, tasks);
        },
        error: onFail,
        fail: onFail,
        complete: options.afterResponse
    });

    options.beforeRequest();
};

module.exports = API;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/collection":26,"../../common/common":27,"../../common/datetime":28,"../calendarAPI":37,"../model/calendar":43,"../model/event":44}],39:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Base controller for Dooray service project.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var Base = require('../../controller/base');
var DoorayEvent = require('../model/event');

/**
 * @constructor
 * @param {object} options - options for base controller
 * @param {function} [options.groupFunc] - function for group each models {@see Collection#groupBy}
 * @extends {Base}
 */
function DoorayBase(options) {
    Base.call(this, options);
}

util.inherit(DoorayBase, Base);

/**********
 * CRUD override
 **********/

/**
 * Create an event instance from raw data.
 * @override
 * @emits Base#createdEvent
 * @param {object} options Data object to create event.
 * @param {boolean} silent - set true then don't fire events.
 * @returns {Event} The instance of Event that created.
 */
DoorayBase.prototype.createEvent = function(options, silent) {
    var event = this.addEvent(DoorayEvent.create(options));

    if (!silent) {
        /**
         * @event Base#createdEvent
         * @type {Event}
         */
        this.fire('createdEvent', event);
    }

    return event;
};

module.exports = DoorayBase;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../controller/base":35,"../model/event":44}],40:[function(require,module,exports){
/**
 * @fileoverview Configuration module for dooray project.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

/**
 * 일정 카테고리
 * @readonly
 * @enum {string}
 */
var EVENT_CATEGORY = {
    GENERAL: 'general',
    TASK: 'task',
    MILESTONE: 'milestone'
};

/**
 * 태스크 마감시간 분류
 * @readonly
 * @enum {string}
 */
var DUE_DATE_CLASS = {
    MORNING: 'morning',
    LUNCH: 'lunch',
    EVENING: 'evening'
};

/**
 * 캘린더 아이템의 타입
 * @readonly
 * @enum {string}
 */
var CALENDAR_ITEM_TYPE = {
    PRIVATE: 'private',    // 개인 캘린더
    SHARED: 'shared'       // 공유 캘린더
};

/**
 * 캘린더에 대한 사용자의 권한
 * @readonly
 * @enum {string}
 */
var CALENDAR_ITEM_PERMISSION = {
    OWNER: 'owner',
    OPAQUE_VIEW: 'opaque_view',
    VIEW: 'view',
    READ_WRITE: 'read_write',
    ALL: 'all'
};

module.exports = {
    model: {
        EVENT_CATEGORY: EVENT_CATEGORY,
        DUE_DATE_CLASS: DUE_DATE_CLASS,
        CALENDAR_ITEM_TYPE: CALENDAR_ITEM_TYPE,
        CALENDAR_ITEM_PERMISSION: CALENDAR_ITEM_PERMISSION
    }
};

},{}],41:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Calendar for service.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../../common/datetime');

// FACTORY
var Calendar = require('../../factory/calendar');

// CONTROLLER
var DoorayBase = require('../controller/base');
var Week = require('../../controller/viewMixin/week');

// VIEW
var serviceWeekViewFactory = require('./weekView');

// API
// var calendarAPI = require('../calendarAPI');
var API = require('../controller/api');

var enums = require('../enums');

/**
 * Calendar factor module for service (dooray)
 * @constructor
 * @extends {Calendar}
 * @mixed {CalendarAPI}
 * @param {object} options - options for calendar
 * @param {function} [options.groupFunc] - function for group event models {@see Collection#groupBy}
 * @param {function} [options.controller] - controller instance
 * @param {string} [options.defaultView='week'] - default view of calendar
 * @param {object} options.member - member information from dooray server.
 * @param {string} options.member.orgMemberId - user id
 * @param {string} options.member.userCode - user code
 * @param {object} [options.week] - options for week view
 * @param {string} options.week.renderStartDate - YYYY-MM-DD render start date
 * @param {string} options.week.renderEndDate - YYYY-MM-DD render end date
 * @param {object} [options.month] - options for month view
 * @param {string} options.month.renderMonth - YYYY-MM render month
 * @param {HTMLDivElement} container = container element for calendar
 */
function ServiceCalendar(options, container) {
    /**
     * 서비스에서 사용되는 모델 구분용 옵션 함수
     * @param {EventViewModel} viewModel - DoorayEvent를 래핑한 뷰 모델
     * @returns {string} 구분 키 값
     */
    options.groupFunc = function(viewModel) {
        var model = viewModel.model,
            category = model.category,
            isAllDay = model.isAllDay;

        if (category === enums.model.EVENT_CATEGORY.TASK) {
            return 'task';
        } else if (category === enums.model.EVENT_CATEGORY.GENERAL) {
            return isAllDay ? 'allday' : 'time';
        }

        return 'milestone';
    };

    // 컨트롤러 만들기
    options.controller = (function() {
        var controller = new DoorayBase(options),
            originFindByDateRange;

        controller.Week = {};
        util.forEach(Week, function(method, methodName) {
            controller.Week[methodName] = util.bind(method, controller);
        });

        // 마일스톤, 업무 뷰 용 뷰모델 처리기 추가
        originFindByDateRange = controller.Week.findByDateRange;
        controller.Week.findByDateRange = function(starts, ends) {
            var dateRange = util.map(datetime.range(
                    datetime.start(starts),
                    datetime.end(ends),
                    datetime.MILLISECONDS_PER_DAY
                ), function(d) { return datetime.format(d, 'YYYY-MM-DD'); }),
                viewModel = originFindByDateRange(starts, ends);

            util.forEach(viewModel, function(coll, key, obj) {
                var groupedByYMD;

                // 마일스톤, 업무 뷰 뷰모델 가공
                if (key === 'task' || key === 'milestone') {
                    groupedByYMD = coll.groupBy(dateRange, function(viewModel) {
                        return datetime.format(viewModel.model.ends, 'YYYY-MM-DD');
                    });

                    if (key === 'task') {
                        util.forEach(groupedByYMD, function(coll, ymd, obj) {
                            obj[ymd] = coll.groupBy(function(viewModel) {
                                return viewModel.model.dueDateClass;
                            });
                        });
                    }

                    obj[key] = groupedByYMD;
                }
            });

            return viewModel;
        };

        return controller;
    })();

    Calendar.call(this, options, container);

    this.api = new API({
        member: options.member,
        beforeRequest: function() {
            console.log('before');
        },
        afterResponse: function() {
            console.log('after');
        }
    });
}

util.inherit(ServiceCalendar, Calendar);

/**
 * @override
 */
ServiceCalendar.prototype.toggleView = function(viewName, force) {
    var view = this.view,
        controller = this.controller,
        dragHandler = this.dragHandler,
        options = this.options;

    if (!force && this.currentViewName === viewName) {
        return;
    }

    this.currentViewName = viewName;
    view.clear();

    if (viewName === 'week') {
        view.addChild(function() {
            return serviceWeekViewFactory(controller, view.container, dragHandler, options);
        });
    }
};

module.exports = ServiceCalendar;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../controller/viewMixin/week":36,"../../factory/calendar":56,"../controller/api":38,"../controller/base":39,"../enums":40,"./weekView":42}],42:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Factory module for WeekView (customized for service)
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../../common/domutil');

// Parent views
var Week = require('../../view/week/week');

// Sub views
var DayName = require('../../view/week/dayname');
var Milestone = require('../view/milestone');
var TaskView = require('../view/taskview');
var TimeGrid = require('../../view/week/timeGrid');
var Allday = require('../../view/week/allday');


// Handlers
var AlldayCreation = require('../../handler/allday/creation');
var AlldayMove = require('../../handler/allday/move');
var AlldayResize = require('../../handler/allday/resize');
var TimeCreation = require('../../handler/time/creation');
var TimeMove = require('../../handler/time/move');
var TimeResize = require('../../handler/time/resize');

// Base Templates
var weekViewTmpl = require('../../dooray/view/template/factory/weekView.hbs');

module.exports = function(baseController, layoutContainer, dragHandler, options) {
    var weekView,
        dayNameView,
        milestoneView,
        taskView,
        alldayView,
        timeGridView,
        alldayOptions,
        alldayCreationHandler,
        alldayMoveHandler,
        alldayResizeHandler,
        timeCreationHandler,
        timeMoveHandler,
        timeResizeHandler;

    weekView = new Week(null, options.week, layoutContainer);

    weekView.container.innerHTML = weekViewTmpl();

    // Dayname
    dayNameView = new DayName(null, domutil.find('.schedule-view-dayname-layout', weekView.container));
    weekView.addChild(dayNameView);

    /**********
     * AllDay View
     **********/
    alldayOptions = util.extend({
        title: null,
        height: 20
    }, options.week);

    function getViewModelFunc(key) {
        return function(viewModel) {
            return viewModel.eventsInDateRange[key];
        };
    }
    
    // 마일스톤 뷰
    milestoneView = new Milestone(options.week, domutil.find('.schedule-view-milestone-layout'));
    weekView.addChild(milestoneView);

    // 업무 뷰
    taskView = new TaskView(options.week, domutil.find('.schedule-view-milestone-layout'));
    weekView.addChild(taskView);

    // Allday - wholeDay
    alldayOptions.title = '종일일정';
    alldayOptions._getViewModelFunc = getViewModelFunc('allday');
    alldayView = new Allday(options.week, domutil.find('.schedule-view-allday-layout', weekView.container));
    alldayCreationHandler = new AlldayCreation(dragHandler, alldayView, baseController);
    alldayMoveHandler = new AlldayMove(dragHandler, alldayView, baseController);
    alldayResizeHandler = new AlldayResize(dragHandler, alldayView, baseController);
    weekView.addChild(alldayView);

    /**********
     * TimeGrid View
     **********/
    timeGridView = new TimeGrid(options.week, domutil.find('.schedule-view-timegrid-layout', weekView.container));
    timeCreationHandler = new TimeCreation(dragHandler, timeGridView, baseController);
    timeMoveHandler = new TimeMove(dragHandler, timeGridView, baseController);
    timeResizeHandler = new TimeResize(dragHandler, timeGridView, baseController);

    weekView.handlers = {
        allday: {
            creation: alldayCreationHandler,
            move: alldayMoveHandler,
            resize: alldayResizeHandler
        },
        time: {
            creation: timeCreationHandler,
            move: timeMoveHandler,
            resize: timeResizeHandler
        }
    };

    weekView.addChild(timeGridView);

    // add controller
    weekView.controller = baseController.Week;

    // add destroy
    weekView._beforeDestroy = function() {
        timeCreationHandler.off();
        timeMoveHandler.off();
        timeResizeHandler.off();
        timeCreationHandler.destroy();
        timeMoveHandler.destroy();
        timeResizeHandler.destroy();

        alldayCreationHandler.off();
        alldayMoveHandler.off();
        alldayResizeHandler.off();
        alldayCreationHandler.destroy();
        alldayMoveHandler.destroy();
        alldayResizeHandler.destroy();

        delete weekView.handlers.time;
        delete weekView.handlers.allday;

        timeCreationHandler = timeMoveHandler = timeResizeHandler = null;
    };

    return weekView;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/domutil":31,"../../dooray/view/template/factory/weekView.hbs":55,"../../handler/allday/creation":60,"../../handler/allday/move":62,"../../handler/allday/resize":64,"../../handler/time/creation":68,"../../handler/time/move":70,"../../handler/time/resize":72,"../../view/week/allday":87,"../../view/week/dayname":88,"../../view/week/timeGrid":90,"../../view/week/week":91,"../view/milestone":50,"../view/taskview":54}],43:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Calndar reference model for Dooray Calendar service
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.ne.util;
var enums = require('../enums');

/**
 * @constructor
 */
function CalendarReference() {
    /**
     * @type {string}
     */
    this.id = '';

    /**
     * @type {string}
     */
    this.name = '';

    /**
     * 캘린더 타입 (기본값: private)
     * @type {string}
     */
    this.type = enums.model.CALENDAR_ITEM_TYPE.PRIVATE;

    /**
     * 캘린더에 대한 사용자의 권한 (기본값: owner)
     * @type {string}
     */
    this.permission = enums.model.CALENDAR_ITEM_PERMISSION.OWNER;

    /**
     * 기본 캘린더 여부
     * @type {boolean}
     */
    this.isDefault = false;

    /**
     * 캘린더 색상 #을 제외한 6자리 hex코드 값
     * @type {string}
     */
    this.color = '';

    /**
     * @type {object}
     */
    this.raw = null;
}

/**
 * Unmarshal object from server API response data
 * @param {object} dataObject - data object from server API response
 */
CalendarReference.prototype.unmarshal = function(dataObject) {
    this.id = dataObject.id || '';

    this.name = dataObject.name || '';
    this.type = dataObject.type || '';
    this.permission = dataObject.permission || '';
    this.isDefault = dataObject['default'] ? true : false;
    this.color = dataObject.color || 'ffffff';
    this.raw = dataObject;
};

/**
 * Marshal object to communicate with dooray task tracker API server
 * @returns {object} data object can dooray server acceptable
 */
CalendarReference.prototype.marshal = function() {
    var result = util.extend({}, this.raw);

    result.name = this.name;
    result.type = this.type;
    result.permission = this.permission;
    result['default'] = this.isDefault;
    result.color = this.color;

    return result;
};

module.exports = CalendarReference;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../enums":40}],44:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Extend model class for Dooray Calendar project.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var Event = require('../../model/event');
var enums = require('../enums');

/**
 * Event class for dooray project
 * @constructor
 * @extends {Event}
 */
function DoorayEvent() {
    Event.call(this);

    /**
     * 일정 카테고리 (마일스톤, 업무, 일반일정)
     * @type {string}
     */
    this.category = '';

    /**
     * 업무 일정의 경우 구분 (출근전, 점심전, 퇴근전)
     * @type {string}
     */
    this.dueDateClass = '';

    /**
     * 일정 내용 본문 정보
     * @type {object}
     */
    this.body = {
        mimeType: '',
        content: ''
    }; 

    /**
     * 상세정보 url
     * @type {string}
     */
    this.detailUrl = '';

    /**
     * 장소정보
     * @type {string}
     */
    this.location = '';

    /**
     * 기타정보
     * @type {object}
     */
    this.raw = null;
}

util.inherit(DoorayEvent, Event);

/**
 * @override
 */
DoorayEvent.create = function(data) {
    var inst = new DoorayEvent();
    inst.init(data);

    return inst;
};

/**
 * @override
 * @param {object} options options.
 */
DoorayEvent.prototype.init = function(options) {
    options = options || {};

    Event.prototype.init.call(this, options);

    this.category = options.category || enums.model.EVENT_CATEGORY.GENERAL;
    this.dueDateClass = options.dueDateClass || '';
};

/**
 * Marshal data to communicate with dooray API server
 * @returns {object} - data object that accept from dooray API server
 */
DoorayEvent.prototype.marshal = function() {
    var result = util.extend({}, this.raw);

    result.subject = this.title;
    result.category = this.category;
    result.dueDateClass = this.dueDateClass;
    result.wholeDayFlag = this.isAllDay;
    result.startedAt = this.starts.toISOString();
    result.endedAt = this.ends.toISOString();
    result.body = this.body;
    result.detailUrl = this.detailUrl;
    result.location = this.location;

    return result;
};

/**
 * Unmarshal data from server response data object
 * @param {object} dataObject - data object from dooray API server
 */
DoorayEvent.prototype.unmarshal = function(dataObject) {
    var starts,
        ends,
        body;

    dataObject = dataObject || {};

    this.title = dataObject.subject;
    this.category = dataObject.category;
    this.dueDateClass = dataObject.dueDateClass;
    this.isAllDay = util.isExisty(dataObject.wholeDayFlag) ? dataObject.wholeDayFlag : false;
    this.detailUrl = dataObject.detailUrl || '';
    this.location = dataObject.location || '';

    if (this.category === enums.model.EVENT_CATEGORY.GENERAL) {
        starts = new Date(dataObject.startedAt);
        ends = new Date(dataObject.endedAt);
    } else {
        // 마일스톤, 업무 일정은 종료일 기준으로 계산
        starts = new Date(dataObject.dueDate);
        ends = new Date(+starts)

        // 일정 시작시간을 종료시간 30분 전으로 지정
        starts.setMinutes(starts.getMinutes() - 30);
    }

    this.starts = starts;
    this.ends = ends;

    body = util.pick(dataObject, 'body');
    if (body) {
        this.body.mimeType = body.mimeType;
        this.body.content = body.content;
    }

    this.raw = dataObject;
};

module.exports = DoorayEvent;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../model/event":74,"../enums":40}],45:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "            <li><label><input type=\"checkbox\" data-id=\""
    + alias4(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"id","hash":{},"data":data}) : helper)))
    + "\" "
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.isDefault : depth0),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "/>&nbsp;"
    + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
    + "</label></li>\n";
},"2":function(container,depth0,helpers,partials,data) {
    return "checked";
},"4":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "            <li><label><input type=\"checkbox\" data-id=\""
    + alias4(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"id","hash":{},"data":data}) : helper)))
    + "\"/>&nbsp;"
    + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
    + "</label></li>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {};

  return "<div class=\"schedule-view-calendars\">\n    <div class=\"schedule-view-calendars-general\">\n        <h6>일반 캘린더</h6>\n        <ol>\n"
    + ((stack1 = helpers.each.call(alias1,((stack1 = (depth0 != null ? depth0.general : depth0)) != null ? stack1.items : stack1),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "        </ol>\n    </div>\n    <div class=\"schedule-view-calendars-project\">\n        <h6>프로젝트 캘린더</h6>\n        <ol>\n"
    + ((stack1 = helpers.each.call(alias1,((stack1 = (depth0 != null ? depth0.project : depth0)) != null ? stack1.items : stack1),{"name":"each","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "        </ol>\n    </div>\n</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],46:[function(require,module,exports){
(function (global){
/**
 * @fileoverview 서비스 좌측 캘린더 목록 뷰
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var View = require('../../view/view');
var domutil = require('../../common/domutil');
var domevent = require('../../common/domevent');
var tmpl = require('./calendars.hbs');

/**
 * @constructor
 * @extends {View}
 * @param {HTMLDivElement} container - view container
 */
function Calendars(container) {
    View.call(this, null, container);

    // bind event
    domevent.on(container, 'change', this._onChange, this);

    this.render();
}

util.inherit(Calendars, View);

/**
 * @param {Collection} viewModel - collection for CalendarReference
 * @returns {object} view model
 */
Calendars.prototype._getViewModel = function(viewModel) {
    // 일반 캘린더와 프로젝트 캘린더를 나눈다
    var grouped = viewModel.groupBy(function(calendarRef) {
        var raw = calendarRef.raw;

        if (raw.owner) {
            return 'general';
        }

        return 'project'
    });

    return grouped;
};

/**
 * @override
 * @param {Collection} viewModel - collection for CalendarReference
 */
Calendars.prototype.render = function(viewModel) {
    if (viewModel) {
        viewModel = this._getViewModel(viewModel);
    }

    this.container.innerHTML = tmpl(viewModel);
};

/**
 * 현재 뷰를 참조해 체크된 캘린더 ID배열을 반환한다.
 * @returns {string[]} 선택된 캘린더 id 배열
 */
Calendars.prototype.getSelectedCalendarID = function() {
    var container = this.container,
        inputs = domutil.find('input', container, function(el) {
            return el.checked;
        });

    return util.map(inputs, function(el) {
        return domutil.getData(el, 'id');
    });
};

/**
 * calendar checkbox onchange event handler
 * @emits Calendars#changeCalendarSelection
 * @param {Event} changeEventData - input event
 */
Calendars.prototype._onChange = function() {
    /**
     * @events Calendars#changeCalendarSelection
     * @type {string[]} calendar id list
     */
    this.fire('changeCalendarSelection', this.getSelectedCalendarID());
};

util.CustomEvents.mixin(Calendars);

module.exports = Calendars;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/domevent":30,"../../common/domutil":31,"../../view/view":86,"./calendars.hbs":45}],47:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    return "만들기";
},"3":function(container,depth0,helpers,partials,data) {
    return "수정하기";
},"5":function(container,depth0,helpers,partials,data,blockParams,depths) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<p>\n        <label class=\"schedule-view-form-title\" for=\"projectName\">프로젝트</label>\n        <input type=\"text\" name=\"projectName\" placeholder=\"프로젝트명\" value=\""
    + alias4(((helper = (helper = helpers.projectName || (depth0 != null ? depth0.projectName : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"projectName","hash":{},"data":data}) : helper)))
    + "\" />\n        <input type=\"hidden\" name=\"projectCode\" value=\""
    + alias4(((helper = (helper = helpers.projectCode || (depth0 != null ? depth0.projectCode : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"projectCode","hash":{},"data":data}) : helper)))
    + "\" />\n    </p>\n    <p>\n        <label class=\"schedule-view-form-title\" for=\"name\">이름</label>\n        <input type=\"text\" name=\"name\" placeholder=\"캘린더 이름\" value=\""
    + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
    + "\" />\n    </p>\n    <p>\n        <label class=\"schedule-view-form-title\" for=\"color\">색상</label>\n        <span class=\"schedule-view-calendar-form-colors\">\n            "
    + ((stack1 = (helpers.radioCalendarColor || (depth0 && depth0.radioCalendarColor) || alias2).call(alias1,"color",((stack1 = (data && data.root)) && stack1.colorList),(depth0 != null ? depth0.color : depth0),{"name":"radioCalendarColor","hash":{},"data":data})) != null ? stack1 : "")
    + "\n            <input type=\"text\" name=\"colorHex\" placeholder=\"HEX value\" value=\""
    + alias4(((helper = (helper = helpers.colorHex || (depth0 != null ? depth0.colorHex : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"colorHex","hash":{},"data":data}) : helper)))
    + "\" maxlength=\"6\" />\n        </span>\n    </p>\n    <p>\n        <label class=\"schedule-view-form-title\" for=\"type\">유형</label>\n        "
    + ((stack1 = (helpers.selectbox || (depth0 && depth0.selectbox) || alias2).call(alias1,"type",((stack1 = (data && data.root)) && stack1.calendarList),(depth0 != null ? depth0.type : depth0),{"name":"selectbox","hash":{},"data":data})) != null ? stack1 : "")
    + "\n    </p>\n    <div>\n        <label class=\"schedule-view-form-title\">공유설정<input type=\"button\" class=\"schedule-view-createcalendar-addshare\" value=\"+\" /></label>\n        <table>\n            <colgroup><col span=\"1\" style=\"width:60%\" /><col span=\"1\" style=\"width:40%\" /></colgroup>\n            <tbody>\n            <tr class=\"schedule-view-createcalendar-master\"><td>나</td><td>마스터</td></tr>\n"
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.share : depth0),{"name":"each","hash":{},"fn":container.program(6, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "            </tbody>\n        </table>\n    </div>\n";
},"6":function(container,depth0,helpers,partials,data,blockParams,depths) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing;

  return "            <tr>\n                <td>\n                    <input type=\"text\" name=\"userId[]\" placeholder=\"사용자명\" value=\""
    + container.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : alias2),(typeof helper === "function" ? helper.call(alias1,{"name":"id","hash":{},"data":data}) : helper)))
    + "\"/>\n                </td>\n                <td>\n"
    + ((stack1 = (helpers.fi || (depth0 && depth0.fi) || alias2).call(alias1,(depths[1] != null ? depths[1].type : depths[1]),"===","private",{"name":"fi","hash":{},"fn":container.program(7, data, 0, blockParams, depths),"inverse":container.program(9, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
    + "</td>\n            </tr>\n";
},"7":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = (helpers.selectbox || (depth0 && depth0.selectbox) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"authority[]",((stack1 = (data && data.root)) && stack1.privateList),(depth0 != null ? depth0.authority : depth0),{"name":"selectbox","hash":{},"data":data})) != null ? stack1 : "")
    + "\n";
},"9":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = (helpers.selectbox || (depth0 && depth0.selectbox) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"authority[]",((stack1 = (data && data.root)) && stack1.shareList),(depth0 != null ? depth0.authority : depth0),{"name":"selectbox","hash":{},"data":data})) != null ? stack1 : "")
    + "\n";
},"11":function(container,depth0,helpers,partials,data) {
    return "<input type=\"submit\" value=\"만들기\" />\n";
},"13":function(container,depth0,helpers,partials,data) {
    return "<input type=\"submit\" value=\"수정하기\" />\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data,blockParams,depths) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<form name=\"create-calendar\" method=\""
    + alias4(((helper = (helper = helpers.method || (depth0 != null ? depth0.method : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"method","hash":{},"data":data}) : helper)))
    + "\" action=\""
    + alias4(((helper = (helper = helpers.action || (depth0 != null ? depth0.action : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"action","hash":{},"data":data}) : helper)))
    + "\">\n    <legend>캘린더 "
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.isCreateMode : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0, blockParams, depths),"inverse":container.program(3, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
    + "</legend>\n"
    + ((stack1 = helpers["with"].call(alias1,(depth0 != null ? depth0.formData : depth0),{"name":"with","hash":{},"fn":container.program(5, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "<p>\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.isCreateMode : depth0),{"name":"if","hash":{},"fn":container.program(11, data, 0, blockParams, depths),"inverse":container.program(13, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
    + "</p>\n</form>\n";
},"useData":true,"useDepths":true});

},{"hbsfy/runtime":22}],48:[function(require,module,exports){
(function (global){
/**
 * @fileoverview 캘린더 생성/수정 폼 컴포넌트
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../../../common/domutil');
var domevent = require('../../../common/domevent');
var View = require('../../../view/view');
var tmpl = require('./calendar.hbs');

// 캘린더 유형 셀렉트박스 리스트
var CALENDAR_TYPE_LIST = [{
    value: 'private',
    label: '개인 캘린더'
}, {
    value: 'shared',
    label: '공유 캘린더'
}];

// 개인 캘린더 공유 시 사용자 권한 리스트
var PRIVATE_LIST = [{
    value: 'opaque_view',
    label: '단순 조회'
}, {
    value: 'view',
    label: '조회'
}, {
    value: 'read_write',
    label: '위임'
}];

// 공유 캘린더 공유 시 사용자 권한 리스트
var SHARE_LIST = [{
    value: 'view',
    label: '조회'
}, {
    value: 'read_write',
    label: '수정/삭제'
}, {
    value: 'all',
    label: '모든권한'
}];

// 라디오박스 리스트 프리셋
var COLOR_LIST = [{
    value: 'ed2327',
    label: 'ed2327'
}, {
    value: 'ee5307',
    label: 'ee5307'
}, {
    value: 'f4c30a',
    label: 'f4c30a'
}, {
    value: '55d72b',
    label: '55d72b'
}, {
    value: '3d9af6',
    label: '3d9af6'
}, {
    value: 'be55da',
    label: 'be55da'
}, {
    value: '946651',
    label: '946651'
}];

/**
 * @constructor
 * @extends {View}
 * @param {ServiceCalendar} calendar - instance of DoorayCalendar
 * @param {object} options - options
 *  @param {string} [options.projectCode] - project code for creation
 *  @param {boolean} [options.isCreateMode=true] - mode. set true then `creation`, false then `modify`
 *  @param {boolean} [options.isPrivate] - 개인 캘린더 여부
 *  @param {string} [options.method=POST] - http method
 *  @param {string} [options.action] - url
 *  @param {object} [options.formData] - 미리 채워 둘 폼 데이터 (없어도 무방)
 * @param {HTMLElenent} container - container element
 */
function CalendarForm(calendar, options, container) {
    options = options || {};
    container = domutil.appendHTMLElement(
        'div', container, 'schedule-view-calendar-form');

    View.call(this, options, container);

    /**
     * @type {API}
     */
    this.api = calendar.api;

    /**
     * @type {object}
     */
    this.options = util.extend({
        projectCode: '*',
        isCreateMode: true,
        method: 'POST',
        action: '/wapi/task-tracker/projects/{{projectCode}}/calendars',
        
        calendarList: CALENDAR_TYPE_LIST,
        privateList : PRIVATE_LIST,
        shareList: SHARE_LIST,
        colorList: COLOR_LIST,
        formData: {
            type: 'private'
        } 
    }, options);

    domevent.on(container, {
        'submit': this._onSubmit,
        'change': this._onChange,
        'click': this._onClick
    }, this);

    this.render();
}

util.inherit(CalendarForm, View);

/**
 * @override
 */
CalendarForm.prototype._beforeDestroy = function() {
    domevent.off(this.container, {
        'submit': this._onSubmit,
        'change': this._onChange,
        'click': this._onClick
    }, this);

    this.api = this.options = null;
};

/**
 * 캘린더 폼으로부터 객체 형태의 데이터를 추출함
 * @returns {object} 폼 데이터
 */
CalendarForm.prototype.getFormData = function() {
    var formData = domutil.getFormData(domutil.find('form', this.container)),
        userId = formData['userId[]'] || [],
        authority = formData['authority[]'] || [],
        result = {
            projectName: formData.projectName,
            projectCode: formData.projectCode,
            name: formData.name,
            color: formData.color,
            colorHex: formData.colorHex,
            type: formData.type,
            share: []
        };

    userId = util.isArray(userId) ? userId : [userId];
    authority = util.isArray(authority) ? authority : [authority];

    util.forEach(userId, function(id, index) {
        result.share.push({
            id: id,
            authority: authority[index]
        });
    });

    return result;
};

/**
 * @override
 * @param {object} [formData] - 폼 데이터를 넘기면 렌더링 시 적용한다
 */
CalendarForm.prototype.render = function(formData) {
    var options = this.options;

    if (formData) {
        options.formData = formData;
    }

    this.container.innerHTML = tmpl(options);
};

/**
 * 캘린더 유형 변경 시 핸들러
 * @param {Event} e - 캘린더 유형 셀렉트박스 변경 이벤트 객체
 */
CalendarForm.prototype._onChange = function(e) {
    var that = this,
        target = e.target,
        newAction,
        form;

    if (target.name === 'type') {
        this.render(this.getFormData());

        util.debounce(function() {
            var select = domutil.find('select', that.container);
            if (select) {
                select.focus();
            }
        }, 0)();
    }

    // 프로젝트 코드 변경 시 처리
    if (target.name === 'projectName') {
        form = domutil.find('form', that.container);
        if (form) {
            //TODO: 프로젝트 코드 받아와야 함
            newAction = that.options.action.replace('{{projectCode}}', window.encodeURIComponent(target.value));
            form.setAttribute('action', newAction);
        }
    }
};

/**
 * 공유설정 추가 버튼 클릭 핸들러
 * @param {Event} e - 버튼 클릭 이벤트
 */
CalendarForm.prototype._onClick = function(e) {
    var that = this,
        formData;

    if (e.target.type === 'button') {
        formData = that.getFormData();
        formData.share.push({id: '', authority: ''});
        that.render(formData);

        util.debounce(function() {
            domutil.find('input', that.container, function(el) {
                return el.name === 'userId[]';
            }).pop().focus();
        }, 0)();
    }
};

/**
 * 생성/수정 버튼 클릭 시 핸들러
 * @param {Event} e - 전송 이벤트 객체
 */
CalendarForm.prototype._onSubmit = function(e) {
    domevent.stop(e);
    //TODO: submit data to API server.
    console.log(this.getFormData());
};

module.exports = CalendarForm;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../../common/domevent":30,"../../../common/domutil":31,"../../../view/view":86,"./calendar.hbs":47}],49:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : {};

  return "<div class=\"schedule-view-milestone-day\" \n        style=\"width:"
    + alias2(alias1(((stack1 = (data && data.root)) && stack1.width), depth0))
    + "%;left:"
    + alias2((helpers.multiply || (depth0 && depth0.multiply) || helpers.helperMissing).call(alias3,((stack1 = (data && data.root)) && stack1.width),(data && data.index),{"name":"multiply","hash":{},"data":data}))
    + "%;min-height:"
    + alias2(alias1(((stack1 = (data && data.root)) && stack1.height), depth0))
    + "px\">\n        <ul class=\"schedule-view-milestone-list\">\n"
    + ((stack1 = helpers.each.call(alias3,(depth0 != null ? depth0.items : depth0),{"name":"each","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</ul>\n    </div>\n";
},"2":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=container.lambda, alias2=container.escapeExpression;

  return "<li data-title=\""
    + alias2(alias1(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.title : stack1), depth0))
    + "\" class=\"schedule-view-milestone-item\">"
    + alias2(alias1(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.title : stack1), depth0))
    + "</li>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<div class=\"schedule-view-milestone-left\">\n    <span>마일스톤</span>\n</div>\n<div class=\"schedule-view-milestone-right\">\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.events : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],50:[function(require,module,exports){
(function (global){
/**
 * @fileoverview 마일스톤 뷰
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var View = require('../../view/view');
var tmpl = require('./milestone.hbs');

/**
 * @constructor
 * @extends {View}
 * @param {object} options - options
 * @param {string} options.renderStartDate - start date of allday view's render date. YYYY-MM-DD
 * @param {string} options.renderEndDate - end date of allday view's render date. YYYY-MM-DD
 * @param {number} [options.minHeight=40] - min-height of milestone view 
 * @param {HTMLElement} container - container element
 */
function Milestone(options, container) {
    container = domutil.appendHTMLElement(
        'div',
        container,
        'schedule-view-milestone-container'
    );

    View.call(this, options, container);

    /**
     * @type {object}
     */
    this.options = util.extend({
        renderStartDate: '',
        renderEndDate: '',
        minHeight: 40
    }, options);
}

util.inherit(Milestone, View);

/**
 * Get base viewmodel for task view
 * @param {object} [viewModel] - view model from parent view
 * @returns {object} view model for task view
 */
Milestone.prototype._getBaseViewModel = function(viewModel) {
    var options = this.options,
        events = {},
        range = datetime.range(
            datetime.start(datetime.parse(options.renderStartDate)),
            datetime.end(datetime.parse(options.renderEndDate)),
            datetime.MILLISECONDS_PER_DAY
        );

    util.forEach(range, function(d) {
        events[datetime.format(d, 'YYYY-MM-DD')] = {};
    });

    util.extend(events, viewModel);

    return {
        events: events,
        width: 100 / range.length,
        height: options.minHeight
    };
};

/**
 * 마일스톤 뷰 렌더링
 * @override
 */
Milestone.prototype.render = function(viewModel) {
    var container = this.container,
        baseViewModel = this._getBaseViewModel(util.pick(viewModel.eventsInDateRange, 'milestone'));

    container.style.minHeight = this.options.minHeight + 'px';
    container.innerHTML = tmpl(baseViewModel);

    util.forEach(domutil.find('li', container, true), function(el) {
        if (el.offsetWidth < el.scrollWidth) {
            el.setAttribute('title', domutil.getData(el, 'title'));
        }
    });
};

module.exports = Milestone;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../../view/view":86,"./milestone.hbs":49}],51:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    return "<th>"
    + container.escapeExpression(container.lambda(depth0, depth0))
    + "</th>\n";
},"3":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<tr>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},depth0,{"name":"each","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</tr>\n";
},"4":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<td class=\""
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.isOtherDate : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.focused : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.today : depth0),{"name":"if","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.hasEvents : depth0),{"name":"if","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.weekend : depth0),{"name":"if","hash":{},"fn":container.program(13, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\" data-y=\""
    + alias4(((helper = (helper = helpers.y || (depth0 != null ? depth0.y : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"y","hash":{},"data":data}) : helper)))
    + "\" data-m=\""
    + alias4(((helper = (helper = helpers.m || (depth0 != null ? depth0.m : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"m","hash":{},"data":data}) : helper)))
    + "\" data-d=\""
    + alias4(((helper = (helper = helpers.d || (depth0 != null ? depth0.d : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"d","hash":{},"data":data}) : helper)))
    + "\">\n<button type=\"button\" tabindex=\"-1\" class=\"schedule-view-minicalendar-date\">\n    <div class=\"schedule-view-minicalendar-label\"><span>"
    + alias4(((helper = (helper = helpers.d || (depth0 != null ? depth0.d : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"d","hash":{},"data":data}) : helper)))
    + "</span></div>\n</button>\n</td>\n";
},"5":function(container,depth0,helpers,partials,data) {
    return "schedule-view-minicalendar-other ";
},"7":function(container,depth0,helpers,partials,data) {
    return "schedule-view-minicalendar-focused ";
},"9":function(container,depth0,helpers,partials,data) {
    return "schedule-view-minicalendar-today ";
},"11":function(container,depth0,helpers,partials,data) {
    return "schedule-view-minicalendar-has-events ";
},"13":function(container,depth0,helpers,partials,data) {
    return "schedule-view-minicalendar-weekend ";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {};

  return "<table>\n<caption>\n    <button type=\"button\" class=\"schedule-view-minicalendar-nav schedule-view-minicalendar-prev\"><span>&lt;</span></button>\n    <span class=\"schedule-view-minicalendar-title\">"
    + container.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
    + "</span>\n    <button type=\"button\" class=\"schedule-view-minicalendar-nav schedule-view-minicalendar-next\"><span>&gt;</span></button>\n</caption>\n<thead><tr>\n"
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.dayname : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</tr></thead>\n<tbody>\n"
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.calendar : depth0),{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</tbody>\n</table>\n";
},"useData":true});

},{"hbsfy/runtime":22}],52:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Minicalendar view.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var View = require('../../view/view');
var domutil = require('../../common/domutil');
var domevent = require('../../common/domevent');
var datetime = require('../../common/datetime');
var tmpl = require('./minicalendar.hbs');

/**
 * @constructor
 * @extends {View}
 * @param {object} options - options for minicalendar view
 * @param {number} [options.startDayOfWeek=0] - start day of week. default 0 (sunday)
 * @param {string} [options.renderMonth] - YYYY-MM formatted date to render. 
 * if not supplied use current month
 * @param {HTMLDivElement} container - element to use container
 */
function MiniCalendar(options, container) {
    var defaultMonth;

    View.call(this, options, container);

    domutil.addClass(container, 'schedule-view-minicalendar');

    defaultMonth = util.pick(options, 'renderMonth');
    if (defaultMonth) {
        defaultMonth = datetime.parse(defaultMonth + '-01');
    } else {
        defaultMonth = new Date();
    }
    defaultMonth.setHours(0, 0, 0);

    domevent.on(this.container, 'click', this._onClick, this);

    /**
     * @type {object}
     */
    this.options = util.extend({
        startDayOfWeek: 0,
        daynames: ['일', '월', '화', '수', '목', '금', '토']
    }, options);

    this.options.renderMonth = defaultMonth;
}

util.inherit(MiniCalendar, View);

/**
 * Next, Prev button event handler
 * @param {HTMLButtonElement} buttonElement - next, prev button from _onClick event handler
 */
MiniCalendar.prototype.nav = function(buttonElement) {
    var isNext = domutil.hasClass(buttonElement, 'schedule-view-minicalendar-next'),
        options = this.options,
        offset = isNext ? 1 : -1;

    options.renderMonth.setMonth(options.renderMonth.getMonth() + offset);

    this.render();
};

/**
 * Date button event handler
 * @param {HTMLButtonElement} buttonElement - date button from _onClick event handler
 */
MiniCalendar.prototype.date = function(buttonElement) {
    var td = domutil.closest(buttonElement, 'td'),
        previous;

    if (td) {
        previous = domutil.find('.schedule-view-minicalendar-focused', this.container);

        if (previous) {
            domutil.removeClass(previous, 'schedule-view-minicalendar-focused');
        }

        domutil.addClass(td, 'schedule-view-minicalendar-focused');
    }
};

/**
 * Click event handler
 * @param {MouseEvent} clickEvent - click mouse event object
 */
MiniCalendar.prototype._onClick = function(clickEvent) {
    var target = clickEvent.srcElement || clickEvent.target,
        button = domutil.closest(target, 'button');

    if (!button) {
        return;
    }

    if (domutil.hasClass(button, 'schedule-view-minicalendar-date')) {
        this.date(button);
        return;
    }

    if (domutil.hasClass(button, 'schedule-view-minicalendar-nav')) {
        this.nav(button);
        return;
    }
};

/**
 * Get selected data
 * @returns {Date} selected date
 */
MiniCalendar.prototype.getSelectedDate = function() {
    var selected = domutil.find('.schedule-view-minicalendar-focused', this.container),
        y, m, d;

    if (!selected) {
        return null;
    }

    y = domutil.getData(selected, 'y');
    m = domutil.getData(selected, 'm');
    d = domutil.getData(selected, 'd');

    return new Date(y, m, d);
};

/**
 * Get minicalendar view model
 * @param {Date} renderDate - Date to render minicalendar
 * @param {number} startDayOfWeek - number of start of week (0:sun ...)
 * @param {Date} today - today Date object
 * @param {Object.<string, array>} eventsInMonth - events array to represent dots in minicalendar
 * @returns {object} viewmodel
 */
MiniCalendar.prototype._getViewModel = function(renderDate, startDayOfWeek, today, eventsInMonth) {
    var viewModel = {
            title: datetime.format(renderDate, 'YYYY.MM'),
            startDayOfWeek: startDayOfWeek,
            dayname: null,
            calendar: null
        },
        daynames = this.options.daynames,
        renderMonth = renderDate.getMonth(),
        renderYear = renderDate.getFullYear(),
        todayDate = today.getDate(),
        todayMonth = today.getMonth(),
        todayYear = today.getFullYear(),
        todayIsRenderedMonth = (renderYear === todayYear && renderMonth === todayMonth);

    viewModel.dayname = util.map(
        util.range(startDayOfWeek, 7).concat(util.range(7)).slice(0, 7), 
        function(i) { return daynames[i]; }
    );

    viewModel.calendar = datetime.arr2dCalendar(renderDate, startDayOfWeek, function(d) {
        var month = d.getMonth(),
            year = d.getFullYear(),
            date = d.getDate(),
            day = d.getDay(),
            isOtherDate = year !== renderYear || month !== renderMonth,
            result = {
                y: year,
                m: month,
                d: d.getDate(),
                isOtherDate: isOtherDate
            };

        if (!isOtherDate) {
            // dates in rendered month
            if (todayIsRenderedMonth && date === todayDate) {
                result.today = true;

                // today is include in rendered month then autoselect today date
                result.focused = true;
            }
            
            if (!todayIsRenderedMonth && date === 1) {
                // today is not include in rendered month then autoselect first date of month
                result.focused = true;
            }
        }

        if (day === 0 || day === 6) {
            result.weekend = true;
        }

        if (eventsInMonth && ~util.inArray(datetime.format(d, 'YYYY-MM-DD'), eventsInMonth)) {
            result.hasEvents = true;
        }

        return result;
    });

    return viewModel;
};

/**
 * Render view
 */
MiniCalendar.prototype.render = function() {
    var container = this.container,
        options = this.options,
        renderDate = options.renderMonth,
        startDayOfWeek = options.startDayOfWeek,
        //TODO: this will provide by controller
        events = ['2015-10-02', '2015-10-18'],
        viewModel;

    viewModel = this._getViewModel(renderDate, startDayOfWeek, new Date(), events);

    container.innerHTML = tmpl(viewModel);
};

util.CustomEvents.mixin(MiniCalendar);

module.exports = MiniCalendar;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domevent":30,"../../common/domutil":31,"../../view/view":86,"./minicalendar.hbs":51}],53:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : {};

  return "<div class=\"schedule-view-task-day\" style=\"width:"
    + alias2(alias1(((stack1 = (data && data.root)) && stack1.width), depth0))
    + "%;left:"
    + alias2((helpers.multiply || (depth0 && depth0.multiply) || helpers.helperMissing).call(alias3,((stack1 = (data && data.root)) && stack1.width),(data && data.index),{"name":"multiply","hash":{},"data":data}))
    + "%;min-height:"
    + alias2(alias1(((stack1 = (data && data.root)) && stack1.height), depth0))
    + "px\">\n    <div class=\"schedule-view-task-day-wrap\">\n"
    + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.morning : depth0),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.lunch : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.evening : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</div>\n</div>\n";
},"2":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<h6>출근 전</h6>\n        <ul>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},((stack1 = (depth0 != null ? depth0.morning : depth0)) != null ? stack1.items : stack1),{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</ul>\n";
},"3":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=container.lambda, alias2=container.escapeExpression;

  return "<li data-title=\""
    + alias2(alias1(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.title : stack1), depth0))
    + "\" class=\"schedule-view-task-item\">"
    + alias2(alias1(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.title : stack1), depth0))
    + "</li>\n";
},"5":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<h6>점심 전</h6>\n        <ul>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},((stack1 = (depth0 != null ? depth0.lunch : depth0)) != null ? stack1.items : stack1),{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</ul>\n";
},"7":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<h6>퇴근 전</h6>\n        <ul>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},((stack1 = (depth0 != null ? depth0.evening : depth0)) != null ? stack1.items : stack1),{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</ul>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<div class=\"schedule-view-task-left\">\n    <span>업무</span>\n</div>\n<div class=\"schedule-view-task-right\">\n\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.events : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],54:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Task view for upper area of Week view.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var View = require('../../view/view');
var tmpl = require('./taskview.hbs');

/**
 * @constructor
 * @extends {View}
 * @param {object} options - options for TaskView
 * @param {string} options.renderStartDate - start date of allday view's render date. YYYY-MM-DD
 * @param {string} options.renderEndDate - end date of allday view's render date. YYYY-MM-DD
 * @param {number} [options.minHeight=40] - min-height of taskview
 * @param {HTMLElement} container - container element
 */
function TaskView(options, container) {
    container = domutil.appendHTMLElement(
        'div',
        container,
        'schedule-view-task-container'
    );

    View.call(this, options, container);

    /**
     * @type {object}
     */
    this.options = util.extend({
        renderStartDate: '',
        renderEndDate: '',
        minHeight: 40
    }, options);
}

util.inherit(TaskView, View);

/**
 * Get base viewmodel for task view
 * @param {object} [viewModel] - view model from parent view
 * @returns {object} view model for task view
 */
TaskView.prototype._getBaseViewModel = function(viewModel) {
    var options = this.options,
        events = {},
        range = datetime.range(
            datetime.start(datetime.parse(options.renderStartDate)),
            datetime.end(datetime.parse(options.renderEndDate)),
            datetime.MILLISECONDS_PER_DAY
        );

    util.forEach(range, function(d) {
        events[datetime.format(d, 'YYYY-MM-DD')] = {};
    });

    util.extend(events, viewModel);

    return {
        events: events,
        width: 100 / range.length,
        height: options.minHeight
    };
};

/**
 * 업무 뷰 렌더링
 * @override
 */
TaskView.prototype.render = function(viewModel) {
    var container = this.container,
        baseViewModel = this._getBaseViewModel(util.pick(viewModel.eventsInDateRange, 'task'));

    container.style.minHeight = this.options.minHeight + 'px';
    container.innerHTML = tmpl(baseViewModel);

    util.forEach(domutil.find('li', container, true), function(el) {
        if (el.offsetWidth < el.scrollWidth) {
            el.setAttribute('title', domutil.getData(el, 'title'));
        }
    });
};

module.exports = TaskView;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../../view/view":86,"./taskview.hbs":53}],55:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<div class=\"schedule-view-display-table\">\n    <div class=\"schedule-view-display-table-row\">\n        <div class=\"schedule-view-display-table-cell\">\n            <div class=\"schedule-view-scroll-y schedule-view-dayname-layout\"></div>\n        </div>\n    </div>\n\n    <div class=\"schedule-view-display-table-row\">\n        <div class=\"schedule-view-display-table-cell\">\n            <div class=\"schedule-view-scroll-y schedule-view-milestone-layout\" style=\"min-height:80px;max-height:100px\"></div>\n        </div>\n    </div>\n\n    <div class=\"schedule-view-display-table-row\">\n        <div class=\"schedule-view-display-table-cell\">\n            <div class=\"schedule-view-scroll-y schedule-view-allday-layout\"></div>\n        </div>\n    </div>\n    <div class=\"schedule-view-display-table-row\">\n        <div class=\"schedule-view-display-table-cell schedule-view-timegrid-layout\"></div>\n    </div>\n</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],56:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Factory module for control all other factory.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../common/datetime');
var Layout = require('../view/layout');
var Drag = require('../handler/drag');
var controllerFactory = require('./controller');
var weekViewFactory = require('./weekView');

/**
 * Calendar class
 * @constructor
 * @param {object} options - options for calendar
 * @param {function} [options.groupFunc] - function for group event models {@see Collection#groupBy}
 * @param {function} [options.controller] - controller instance
 * @param {string} [options.defaultView='week'] - default view of calendar
 * @param {object} [options.week] - options for week view
 * @param {string} options.week.renderStartDate - YYYY-MM-DD render start date
 * @param {string} options.week.renderEndDate - YYYY-MM-DD render end date
 * @param {object} [options.month] - options for month view
 * @param {string} options.month.renderMonth - YYYY-MM render month
 * @param {HTMLDivElement} container = container element for calendar
 */
function Calendar(options, container) {
    /**
     * base date of view (today() will use this property)
     * @type {Date}
     */
    this.baseDate = datetime.start(new Date());

    /**
     * default option from service page
     * @type {object}
     */
    this.options = this.setOptions(options);

    /**
     * original options for reference when ui reset
     * @type {object}
     */
    this.originOptions = JSON.parse(JSON.stringify(this.options));

    /**
     * base controller
     * @type {Base}
     */
    this.controller = options.controller || controllerFactory(options);

    /**
     * layout view (layout manager)
     * @type {Layout}
     */
    this.view = new Layout(container);

    /**
     * global drag handler
     * @type {Drag}
     */
    this.dragHandler = new Drag(this.view);

    /**
     * current rendered view name.
     * @type {string}
     */
    this.currentViewName = options.defaultView || 'week';

    /**********
     * SETTING
     **********/
    this.view.controller = this.controller;

    function refresh() {
        this.refreshChildView();
    }

    this.controller.on({
        updateEvent: refresh,
        createdEvent: refresh
    }, this);

    this.toggleView(options.defaultView, true);
}

/**
 * Delete all data and clear view.
 */
Calendar.prototype.clear = function() {
    this.controller.dateMatrix = {};
    this.controller.events.clear();
    this.view.render();
};

/**
 * Move next.
 */
Calendar.prototype.next = function() {
    this.move(1);
};

/**
 * Move previous.
 */
Calendar.prototype.prev = function() {
    this.move(-1);
};

/**
 * Move to today.
 */
Calendar.prototype.today = function() {
    var currentView = this.getCurrentView(),
        originOptions = this.originOptions;

    if (currentView.viewName === 'week') {
        originOptions = originOptions.week;
        this.options.week = {
            renderStartDate: originOptions.renderStartDate,
            renderEndDate: originOptions.renderEndDate 
        };
        currentView.recursive(function(view) {
            if (!view.options) {
                return;
            }

            view.options.renderStartDate = originOptions.renderStartDate;
            view.options.renderEndDate = originOptions.renderEndDate;
        });
    }

    this.refreshChildView(currentView.viewName);
};

/**
 * Move calendar by direction
 * @param {number} direction - the number that want to move (+1, -1)
 */
Calendar.prototype.move = function(direction) {
    var currentView = this.getCurrentView(),
        options = this.options,

        dateOffset,
        newStart,
        newEnd;

    if (currentView.viewName === 'week') {
        newStart = datetime.start(datetime.parse(options.week.renderStartDate));
        newEnd = datetime.end(datetime.parse(options.week.renderEndDate));
        dateOffset = datetime.range(newStart, newEnd, datetime.MILLISECONDS_PER_DAY).length * direction;
        newStart = datetime.format(new Date(newStart.setDate(newStart.getDate() + dateOffset)), 'YYYY-MM-DD');
        newEnd = datetime.format(new Date(newEnd.setDate(newEnd.getDate() + dateOffset)), 'YYYY-MM-DD');

        options.week = {
            renderStartDate: newStart,
            renderEndDate: newEnd
        };
        currentView.recursive(function(view) {
            if (!view.options) {
                return;
            }

            view.options.renderStartDate = newStart;
            view.options.renderEndDate = newEnd;
        });
    }

    this.refreshChildView(currentView.viewName);
}

/**
 * Return current rendered view.
 * @returns {View} current view instance
 */
Calendar.prototype.getCurrentView = function() {
    return util.pick(this.view.childs.items, this.currentViewName);
}

/**
 * Toggle current view
 * @param {string} viewName - the name of view.
 * @param {boolean} force - force render despite of current view and new view are equal
 */
Calendar.prototype.toggleView = function(viewName, force) {
    var view = this.view,
        controller = this.controller,
        dragHandler = this.dragHandler,
        options = this.options;

    if (!force && this.currentViewName === viewName) {
        return;
    }

    this.currentViewName = viewName;
    view.clear();

    if (viewName === 'week') {
        view.addChild(function() {
            return weekViewFactory(controller, view.container, dragHandler, options);
        });
    }
}

/**
 * Destroy calendar instance.
 */
Calendar.prototype.destory = function() {
    this.dragHandler.destroy();
    this.controller.off();
    this.view.clear();

    this.options = this.baseDate = this.controller =
        this.view = this.dragHandler = null;
}

/**
 * Refresh child views
 * @param {string} [viewName] - the name of view to render. if not supplied then refresh all.
 */
Calendar.prototype.refreshChildView = function(viewName) {
    if (!viewName) {
        this.view.render();
        return;
    }

    this.view.childs.items[viewName].render();
};

/**
 * Create default option
 * @param {object} options - option from service page
 * @returns {object} default option. 
 */
Calendar.prototype.setOptions = function(options) {
    var today = this.baseDate,
        dateRange;

    options = util.extend({
        defaultView: 'week',    // 기본 주간 뷰 설정
        week: null,
        month: null 
    }, options);

    if (!options.week) {
        dateRange = datetime.range(
            datetime.start(new Date(new Date(today).setDate(today.getDate() - 3))),
            datetime.end(new Date(new Date(today).setDate(today.getDate() + 3))),
            datetime.MILLISECONDS_PER_DAY
        );

        options.week = {
            renderStartDate: datetime.format(dateRange[0], 'YYYY-MM-DD'),
            renderEndDate: datetime.format(dateRange[6], 'YYYY-MM-DD')
        };
    }

    if (!options.month) {
        options.month = {
            renderMonth: datetime.format(today, 'YYYY-MM')
        };
    }

    return options;
};

module.exports = Calendar;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/datetime":28,"../handler/drag":66,"../view/layout":76,"./controller":57,"./weekView":58}],57:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Controller factory module.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var Base = require('../controller/base');
var Week = require('../controller/viewMixin/week');

/**
 * @param {object} options - options for base controller
 * @param {function} [options.groupFunc] - function for group each models {@see Collection#groupBy}
 * @returns {Base} The controller instance.
 */
module.exports = function(options) {
    var controller = new Base(options);

    controller.Week = {};
    util.forEach(Week, function(method, methodName) {
        controller.Week[methodName] = util.bind(method, controller);
    });

    return controller;
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../controller/base":35,"../controller/viewMixin/week":36}],58:[function(require,module,exports){
/**
 * @fileoverview Factory module for WeekView
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var domutil = require('../common/domutil');

// Parent views
var Week = require('../view/week/week');

// Sub views
var DayName = require('../view/week/dayname');
var TimeGrid = require('../view/week/timeGrid');
var Allday = require('../view/week/allday');

// Handlers
var AlldayCreation = require('../handler/allday/creation');
var AlldayMove = require('../handler/allday/move');
var AlldayResize = require('../handler/allday/resize');
var TimeCreation = require('../handler/time/creation');
var TimeMove = require('../handler/time/move');
var TimeResize = require('../handler/time/resize');

// Base Templates
var weekViewTmpl = require('../view/template/factory/weekView.hbs');

module.exports = function(baseController, layoutContainer, dragHandler, options) {
    var weekView,
        dayNameView,
        alldayView,
        timeGridView,
        alldayCreationHandler,
        alldayMoveHandler,
        alldayResizeHandler,
        timeCreationHandler,
        timeMoveHandler,
        timeResizeHandler;

    weekView = new Week(null, options.week, layoutContainer);

    weekView.container.innerHTML = weekViewTmpl();

    // Dayname
    dayNameView = new DayName(null, domutil.find('.schedule-view-dayname-layout', weekView.container));
    weekView.addChild(dayNameView);

    // Allday
    alldayView = new Allday(options.week, domutil.find('.schedule-view-allday-layout', weekView.container));
    alldayCreationHandler = new AlldayCreation(dragHandler, alldayView, baseController);
    alldayMoveHandler = new AlldayMove(dragHandler, alldayView, baseController);
    alldayResizeHandler = new AlldayResize(dragHandler, alldayView, baseController);

    weekView.addChild(alldayView);

    // TimeGrid
    timeGridView = new TimeGrid(options.week, domutil.find('.schedule-view-timegrid-layout', weekView.container));
    timeCreationHandler = new TimeCreation(dragHandler, timeGridView, baseController);
    timeMoveHandler = new TimeMove(dragHandler, timeGridView, baseController);
    timeResizeHandler = new TimeResize(dragHandler, timeGridView, baseController);

    weekView.handlers = {
        allday: {
            creation: alldayCreationHandler,
            move: alldayMoveHandler,
            resize: alldayResizeHandler
        },
        time: {
            creation: timeCreationHandler,
            move: timeMoveHandler,
            resize: timeResizeHandler
        }
    };

    weekView.addChild(timeGridView);

    // add controller
    weekView.controller = baseController.Week;

    // add destroy
    weekView._beforeDestroy = function() {
        timeCreationHandler.off();
        timeMoveHandler.off();
        timeResizeHandler.off();
        timeCreationHandler.destroy();
        timeMoveHandler.destroy();
        timeResizeHandler.destroy();

        alldayCreationHandler.off();
        alldayMoveHandler.off();
        alldayResizeHandler.off();
        alldayCreationHandler.destroy();
        alldayMoveHandler.destroy();
        alldayResizeHandler.destroy();

        delete weekView.handlers.time;
        delete weekView.handlers.allday;

        timeCreationHandler = timeMoveHandler = timeResizeHandler = null;
    };

    return weekView;
};

},{"../common/domutil":31,"../handler/allday/creation":60,"../handler/allday/move":62,"../handler/allday/resize":64,"../handler/time/creation":68,"../handler/time/move":70,"../handler/time/resize":72,"../view/template/factory/weekView.hbs":78,"../view/week/allday":87,"../view/week/dayname":88,"../view/week/timeGrid":90,"../view/week/week":91}],59:[function(require,module,exports){
/**
 * @fileoverview Base mixin object for handler/allday
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var domutil = require('../../common/domutil');
var domevent = require('../../common/domevent');
var datetime = require('../../common/datetime');
var common = require('../../common/common');

var mmax = Math.max,
    mmin = Math.min,
    CONTAINER_PADDING_LEFT = 60;

/**
 * @mixin Allday.Core
 */
var alldayCore = {
    /**
     * @param {Allday} alldayView - view instance of allday.
     * @param {MouseEvent} mouseEvent - mouse event object.
     * @returns {function} function that return event data by mouse events.
     */
    _retriveEventData: function(alldayView, mouseEvent) {
        var container = alldayView.container,
            renderStartDate,
            renderEndDate,
            datesInRange,
            containerWidth,
            mousePos,
            dragStartXIndex;

        renderStartDate = datetime.parse(alldayView.options.renderStartDate);
        renderEndDate = datetime.end(datetime.parse(alldayView.options.renderEndDate));
        datesInRange = datetime.range(renderStartDate, renderEndDate, datetime.MILLISECONDS_PER_DAY).length;
        containerWidth = domutil.getSize(container)[0] - CONTAINER_PADDING_LEFT;    // subtract container left padding.

        mousePos = domevent.getMousePosition(mouseEvent, container);
        dragStartXIndex = common.ratio(containerWidth, datesInRange, mousePos[0] - CONTAINER_PADDING_LEFT) | 0;

        /**
         * @param {MouseEvent} mouseEvent - mouse event in drag actions.
         * @returns {object} event data.
         */
        return function(mouseEvent) {
            var pos = domevent.getMousePosition(mouseEvent, container),
                mouseX = pos[0] - CONTAINER_PADDING_LEFT,
                xIndex = common.ratio(containerWidth, datesInRange, mouseX) | 0;

            // apply limitation of creation event X index.
            xIndex = mmax(xIndex, 0);
            xIndex = mmin(xIndex, datesInRange - 1);

            return {
                relatedView: alldayView,
                dragStartXIndex: dragStartXIndex,
                datesInRange: datesInRange,
                xIndex: xIndex
            };
        };
    }
};

module.exports = alldayCore;


},{"../../common/common":27,"../../common/datetime":28,"../../common/domevent":30,"../../common/domutil":31}],60:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Handler module for MonthWeek view's creation actions.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.ne.util;
var datetime = require('../../common/datetime');
var common = require('../../common/common');
var domutil = require('../../common/domutil');
var alldayCore = require('./core');
var AlldayCreationGuide = require('./creationGuide');

var parseViewIDRx = /^schedule-view-allday-monthweek[\s]schedule-view-(\d+)/;

/**
 * @constructor
 * @implements {Handler}
 * @mixes AlldayCore
 * @mixes CutomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {Allday} [alldayView] - MonthWeek view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function AlldayCreation(dragHandler, alldayView, baseController) {    // eslint-disable-line
    /**
     * Drag handler instance.
     * @type {Drag}
     */
    this.dragHandler = null;

    /**
     * allday view instance.
     * @type {Allday}
     */
    this.alldayView = null;

    /**
     * Base controller instance.
     * @type {Base}
     */
    this.baseController = null;

    /**
     * @type {function}
     */
    this.getEventDataFunc = null;

    if (arguments.length) {
        this.connect.apply(this, arguments);
    }

    /**
     * @type {AlldayCreationGuide}
     */
    this.guide = new AlldayCreationGuide(this);
}

/**
 * Destroy method
 */
AlldayCreation.prototype.destroy = function() {
    this.guide.destroy();
    this.dragHandler.off(this);
    this.dragHandler = this.alldayView = this.baseController =
        this.getEventDataFunc = null;
};

/**
 * Check dragstart target is expected conditions for this handler.
 * @param {HTMLElement} target - dragstart event handler's target element.
 * @returns {boolean|MonthWeek} return MonthWeek view instance when satiate condition.
 */
AlldayCreation.prototype.checkExpectedCondition = function(target) {
    var cssClass = domutil.getClass(target),
        matches;

    if (cssClass !== 'schedule-view-monthweek-events') {
        return false;
    }

    target = target.parentNode;
    cssClass = domutil.getClass(target);
    matches = cssClass.match(parseViewIDRx);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.alldayView.childs.items, matches[1]);
};

/**
 * Connect handler, view, controller.
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {Allday} [alldayView] - MonthWeek view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
AlldayCreation.prototype.connect = function(dragHandler, alldayView, baseController) {
    this.dragHandler = dragHandler;
    this.alldayView = alldayView;
    this.baseController = baseController;

    dragHandler.on({
        dragStart: this._onDragStart
    }, this);
};

/**
 * Request event model creation to controller by custom events.
 * @param {object} eventData - event data from AlldayCreation module.
 */
AlldayCreation.prototype._createEvent = function(eventData) {
    var title = window.prompt('Name of event to create:'),
        ctrl = this.baseController,
        viewOptions = eventData.relatedView.options,
        dateRange = datetime.range(
            datetime.start(datetime.parse(viewOptions.renderStartDate)),
            datetime.end(datetime.parse(viewOptions.renderEndDate)),
            datetime.MILLISECONDS_PER_DAY
        ),
        startXIndex = eventData.dragStartXIndex,
        xIndex = eventData.xIndex,
        newStarts,
        newEnds;

    this.guide.clearGuideElement();

    if (!title) {
        return;
    }

    // when inverse start, end then change it.
    if (xIndex < startXIndex) {
        startXIndex = xIndex + startXIndex;
        xIndex = startXIndex - xIndex;
        startXIndex = startXIndex - xIndex;
    }

    newStarts = new Date(dateRange[startXIndex].getTime());
    newEnds = datetime.end(dateRange[xIndex]);

    // request event creation to "base" controller.
    ctrl.createEvent({
        title: title,
        isAllDay: true,
        starts: newStarts,
        ends: newEnds
    });
};

/**
 * DragStart event handler method.
 * @emits AlldayCreation#allday_creation_dragstart
 * @param {object} dragStartEventData - Drag#dragStart event handler event data.
 */
AlldayCreation.prototype._onDragStart = function(dragStartEventData) {
    var target = dragStartEventData.target,
        result = this.checkExpectedCondition(target),
        getEventDataFunc,
        eventData;

    if (!result) {
        return;
    }

    this.dragHandler.on({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    getEventDataFunc = this.getEventDataFunc = this._retriveEventData(this.alldayView, dragStartEventData.originEvent);
    eventData = getEventDataFunc(dragStartEventData.originEvent);

    /**
     * @event AlldayCreation#allday_creation_dragstart
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire('allday_creation_dragstart', eventData);
};

/**
 * Drag event handler method.
 * @emits AlldayCreation#allday_creation_drag
 * @param {object} dragEventData - Drag#drag event handler eventdata.
 */
AlldayCreation.prototype._onDrag = function(dragEventData) {
    var getEventDataFunc = this.getEventDataFunc,
        eventData;

    if (!getEventDataFunc) {
        return;
    }

    eventData = getEventDataFunc(dragEventData.originEvent);

    /**
     * @event AlldayCreation#allday_creation_drag
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire('allday_creation_drag', eventData);
};

/**
 * DragEnd event hander method.
 * @emits AlldayCreation#allday_creation_dragend
 * @param {object} dragEndEventData - Drag#DragEnd event handler data.
 * @param {string} [overrideEventName] - override emitted event name when supplied.
 */
AlldayCreation.prototype._onDragEnd = function(dragEndEventData, overrideEventName) {
    var getEventDataFunc = this.getEventDataFunc,
        eventData;

    if (!getEventDataFunc) {
        return;
    }

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    eventData = getEventDataFunc(dragEndEventData.originEvent);

    this._createEvent(eventData);

    /**
     * @event AlldayCreation#allday_creation_dragend
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire(overrideEventName || 'allday_creation_dragend', eventData);

    this.getEventDataFunc = null;
};

/**
 * Click event handler method.
 * @emits AlldayCreation#allday_creation_click
 * @param {object} clickEventData - Drag#Click event handler data.
 */
AlldayCreation.prototype._onClick = function(clickEventData) {
    /**
     * @event AlldayCreation#allday_creation_click
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this._onDragEnd(clickEventData, 'allday_creation_click');
};

common.mixin(alldayCore, AlldayCreation);
util.CustomEvents.mixin(AlldayCreation);

module.exports = AlldayCreation;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/datetime":28,"../../common/domutil":31,"./core":59,"./creationGuide":61}],61:[function(require,module,exports){
/**
 * @fileoverview Guide element for Allday.Creation
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var domutil = require('../../common/domutil');
var reqAnimFrame = require('../../common/reqAnimFrame');

var CREATE_NEW_LABEL = '새 일정';

/**
 * Class for Allday.Creation dragging effect.
 * @constructor
 * @param {AlldayCreation} alldayCreation - instance of AlldayCreation.
 */
function AlldayCreationGuide(alldayCreation) {
    /**
     * @type {AlldayCreation}
     */
    this.alldayCreation = alldayCreation;

    /**
     * @type {HTMLDIVElement}
     */
    this.eventContainer = null;

    /**
     * @type {HTMLDIVElement}
     */
    this.guideElement = document.createElement('div');

    this.initializeGuideElement();

    alldayCreation.on({
        'allday_creation_dragstart': this._onDragStart,
        'allday_creation_drag': this._onDrag,
        // 'allday_creation_dragend': this.clearGuideElement,
        'allday_creation_click': this.clearGuideElement
    }, this);
}

/**
 * Destroy method
 */
AlldayCreationGuide.prototype.destroy = function() {
    this.clearGuideElement();
    this.alldayCreation.off(this);
    this.alldayCreation = this.eventContainer =
        this.guideElement = null;
};

/**
 * initialize guide element's default style.
 */
AlldayCreationGuide.prototype.initializeGuideElement = function() {
    var guideElement = this.guideElement,
        alldayView = this.alldayCreation.alldayView,
        eventBlockHeight = alldayView.options.eventBlockHeight,
        spanElement;

    domutil.addClass(guideElement, 'schedule-view-allday-creation-guide-block');
    domutil.appendHTMLElement('div', guideElement, 'schedule-view-allday-creation-guide');

    spanElement = domutil.appendHTMLElement('span', guideElement);
    spanElement.innerHTML = CREATE_NEW_LABEL;
};

/**
 * Refresh guide element.
 * @param {object} eventData - event data from Allday.Creation handler.
 */
AlldayCreationGuide.prototype._refreshGuideElement = function(eventData) {
    var guideElement = this.guideElement,
        baseWidthPercent = (100 / eventData.datesInRange),
        dragStartXIndex = eventData.dragStartXIndex,
        xIndex = eventData.xIndex,
        length = xIndex - dragStartXIndex,
        leftPercent,
        widthPercent;

    // when revert dragging.
    if (length < 0) {
        dragStartXIndex = xIndex;
        length = Math.abs(length);
    }

    leftPercent = baseWidthPercent * dragStartXIndex;
    widthPercent = baseWidthPercent * (length + 1);

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.display = 'block';
        guideElement.style.left = leftPercent + '%';
        guideElement.style.width = widthPercent + '%';
    });
};

/**
 * Clear guide element.
 */
AlldayCreationGuide.prototype.clearGuideElement = function() {
    var guideElement = this.guideElement;

    domutil.remove(guideElement);

    guideElement.style.display = 'none';
    guideElement.style.left = '';
    guideElement.style.width = '';
};

/**
 * DragStart event handler.
 * @param {object} dragStartEventData - event data object of Allday.Creation.
 */
AlldayCreationGuide.prototype._onDragStart = function(dragStartEventData) {
    var alldayCreation = this.alldayCreation,
        alldayView = alldayCreation.alldayView,
        alldayContainerElement = alldayView.container,
        eventContainer = domutil.find('.schedule-view-monthweek-events', alldayContainerElement);

    eventContainer.appendChild(this.guideElement);
    this._refreshGuideElement(dragStartEventData);
};

/**
 * Drag event handler.
 * @param {object} dragEventData - event data object of Allday.Creation.
 */
AlldayCreationGuide.prototype._onDrag = function(dragEventData) {
    this._refreshGuideElement(dragEventData);
};

module.exports = AlldayCreationGuide;


},{"../../common/domutil":31,"../../common/reqAnimFrame":34}],62:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Move handler for Allday view.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.ne.util;
var common = require('../../common/common');
var domutil = require('../../common/domutil');
var AlldayCore = require('./core');
var AlldayMoveGuide = require('./moveGuide');

var checkExpectedConditionIDRx = /^schedule-view-allday-event(-title)?$/;
var parseViewIDRx = /^schedule-view-allday-monthweek[\s]schedule-view-(\d+)/;

/**
 * @constructor
 * @implements {Handler}
 * @mixes AlldayCore
 * @mixes CustomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {Allday} [alldayView] - MonthWeek view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function AlldayMove(dragHandler, alldayView, baseController) {
    /**
     * Drag handler instance.
     * @type {Drag}
     */
    this.dragHandler = dragHandler;

    /**
     * allday view instance.
     * @type {Allday}
     */
    this.alldayView = alldayView;

    /**
     * Base controller instance.
     * @type {Base}
     */
    this.baseController = baseController;

    /**
     * Temporary variable for dragstart event data.
     * @type {object}
     */
    this._dragStart = null;

    dragHandler.on({
        dragStart: this._onDragStart
    }, this);

    /**
     * @type {AlldayMoveGuide}
     */
    this.guide = new AlldayMoveGuide(this);
}

AlldayMove.prototype.destroy = function() {
    this.guide.destroy();
    this.dragHandler.off(this);
    this.dragHandler = this.alldayView = this.baseController =
        this.guide = this._dragStart = null;
};

/**
 * Check dragstart target is expected conditions for this handler.
 * @param {HTMLElement} target - dragstart event handler's target element.
 * @returns {boolean|MonthWeek} return MonthWeek view instance when satiate condition.
 */
AlldayMove.prototype.checkExpectedCondition = function(target) {
    var cssClass = domutil.getClass(target),
        parentView,
        matches;

    if (!checkExpectedConditionIDRx.test(cssClass)) {
        return false;
    }

    parentView = domutil.closest(target, '.schedule-view-allday-monthweek');

    if (!parentView) {
        return false;
    }

    cssClass = domutil.getClass(parentView);
    matches = cssClass.match(parseViewIDRx);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.alldayView.childs.items, matches[1]);
};

/**
 * DragStart event handler method.
 * @emits AlldayMove#allday_move_dragstart
 * @param {object} dragStartEventData - Drag#dragStart event handler event data.
 */
AlldayMove.prototype._onDragStart = function(dragStartEventData) {
    var target = dragStartEventData.target,
        result = this.checkExpectedCondition(target),
        controller = this.baseController,
        eventBlockElement,
        modelID,
        targetModel,
        getEventDataFunc,
        eventData;

    if (!result) {
        return;
    }

    eventBlockElement = domutil.closest(target, '.schedule-view-allday-event-block');
    modelID = domutil.getData(eventBlockElement, 'id');
    targetModel = controller.events.items[modelID];

    if (!targetModel) {
        return;
    }

    getEventDataFunc = this.getEventDataFunc = this._retriveEventData(this.alldayView, dragStartEventData.originEvent);
    eventData = this._dragStart = getEventDataFunc(dragStartEventData.originEvent);

    util.extend(eventData, {
        eventBlockElement: eventBlockElement,
        model: targetModel
    });

    this.dragHandler.on({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    /**
     * @event AlldayMove#allday_move_dragstart
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     * @property {Event} model - data object of model isntance.
     * @property {HTMLDivElement} eventBlockElement - target event block element.
     */
    this.fire('allday_move_dragstart', eventData);
};


/**
 * Drag event handler method.
 * @emits AlldayMove#allday_move_drag
 * @param {object} dragEventData - Drag#drag event handler eventdata.
 */
AlldayMove.prototype._onDrag = function(dragEventData) {
    var getEventDataFunc = this.getEventDataFunc;

    if (!getEventDataFunc) {
        return;
    }

    /**
     * @event AlldayMove#allday_move_drag
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire('allday_move_drag', getEventDataFunc(dragEventData.originEvent));
};

/**
 * Request update event model to base controller.
 * @param {object} eventData - event data from AlldayMove handler module.
 */
AlldayMove.prototype._updateEvent = function(eventData) {
    var ctrl = this.baseController,
        model = eventData.targetModel,
        dateOffset = eventData.xIndex - eventData.dragStartXIndex,
        newStarts = new Date(model.starts.getTime()),
        newEnds = new Date(model.ends.getTime());

    newStarts = new Date(newStarts.setDate(newStarts.getDate() + dateOffset));
    newEnds = new Date(newEnds.setDate(newEnds.getDate() + dateOffset));

    ctrl.updateEvent(model.id(), {
        starts: newStarts,
        ends: newEnds
    });
};

/**
 * DragEnd event hander method.
 * @emits AlldayMove#allday_move_dragend
 * @param {object} dragEndEventData - Drag#DragEnd event handler data.
 * @param {string} [overrideEventName] - override emitted event name when supplied.
 * @param {?boolean} skipUpdate - true then skip update event model.
 */
AlldayMove.prototype._onDragEnd = function(dragEndEventData, overrideEventName, skipUpdate) {
    var getEventDataFunc = this.getEventDataFunc,
        dragStart = this._dragStart,
        eventData;

    if (!getEventDataFunc || !dragStart) {
        return;
    }

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    eventData = getEventDataFunc(dragEndEventData.originEvent);
    util.extend(eventData, {
        targetModel: dragStart.model
    });
    
    if (!skipUpdate) {
        this._updateEvent(eventData);
    }

    /**
     * @event AlldayMove#allday_move_dragend
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire(overrideEventName || 'allday_move_dragend', eventData);

    this.getEventDataFunc = this._dragStart = null;
};

/**
 * Click event handler method.
 * @emits AlldayMove#allday_move_click
 * @param {object} clickEventData - Drag#Click event handler data.
 */
AlldayMove.prototype._onClick = function(clickEventData) {
    /**
     * @event AlldayMove#allday_move_click
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this._onDragEnd(clickEventData, 'allday_move_click', true);
};

common.mixin(AlldayCore, AlldayMove);
util.CustomEvents.mixin(AlldayMove);

module.exports = AlldayMove;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/domutil":31,"./core":59,"./moveGuide":63}],63:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Effect module for Allday.Move
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.ne.util;
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var reqAnimFrame = require('../../common/reqAnimFrame');

/**
 * Class for Allday.Move dragging effect.
 * @constructor
 * @param {AlldayMove} alldayMove - instance of AlldayMove.
 */
function AlldayMoveGuide(alldayMove) {
    /**
     * @type {AlldayMove}
     */
    this.alldayMove = alldayMove;

    /**
     * 실제로 이벤트 엘리먼트를 담는 엘리먼트
     * @type {HTMLDIVElement}
     */
    this.eventContainer = null;

    /**
     * @type {number}
     */
    this._dragStartXIndex = null;

    /**
     * @type {HTMLDIVElement}
     */
    this.guideElement = null;

    alldayMove.on({
        'allday_move_dragstart': this._onDragStart,
        'allday_move_drag': this._onDrag,
        'allday_move_dragend': this._clearGuideElement,
        'allday_move_click': this._clearGuideElement
    }, this);
}

/**
 * Destroy method
 */
AlldayMoveGuide.prototype.destroy = function() {
    this._clearGuideElement();
    this.alldayMove.off(this);
    this.alldayMove = this.eventContainer = this._dragStartXIndex =
        this.guideElement = null;
};

/**
 * Clear guide element.
 */
AlldayMoveGuide.prototype._clearGuideElement = function() {
    domutil.remove(this.guideElement);

    if (!util.browser.msie) {
        domutil.removeClass(global.document.body, 'schedule-view-dragging');
    }

    this._dragStartXIndex = this.getEventDataFunc = this.guideElement = null;
};

/**
 * Refresh guide element.
 * @param {number} leftPercent - left percent of guide element.
 * @param {number} widthPercent - width percent of guide element.
 * @param {boolean} isExceededLeft - event starts is faster then render start date?
 * @param {boolean} isExceededRight - event ends is later then render end date?
 */
AlldayMoveGuide.prototype.refreshGuideElement = function(leftPercent, widthPercent, isExceededLeft, isExceededRight) {
    var guideElement = this.guideElement;

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.left = leftPercent + '%';
        guideElement.style.width = widthPercent + '%';

        if (isExceededLeft) {
            domutil.addClass(guideElement, 'schedule-view-allday-exceed-left');
        } else {
            domutil.removeClass(guideElement, 'schedule-view-allday-exceed-left');
        }

        if (isExceededRight) {
            domutil.addClass(guideElement, 'schedule-view-allday-exceed-right');
        } else {
            domutil.removeClass(guideElement, 'schedule-view-allday-exceed-right');
        }
    });
};

/**
 * Get event block information from event data.
 *
 * For example, there is single event has 10 length. but render range in view is 5 then
 * rendered block must be cut out to render properly. in this case, this method return
 * how many block are cut before rendering.
 * 
 * 이벤트 데이터에서 이벤트 블록 엘리먼트 렌더링에 대한 필요 정보를 추출한다.
 *
 * ex) 렌더링 된 블록의 길이는 5지만 실제 이 이벤트는 10의 길이를 가지고 있을 때
 * 좌 우로 몇 만큼 잘려있는지에 관한 정보를 반환함.
 * @param {object} dragStartEventData - event data from Allday.Move handler.
 * @returns {function} function that return event block information.
 */
AlldayMoveGuide.prototype._getEventBlockDataFunc = function(dragStartEventData) {
    var model = dragStartEventData.model,
        datesInRange = dragStartEventData.datesInRange,
        baseWidthPercent = (100 / datesInRange),
        originEventStarts = datetime.start(model.starts),
        originEventEnds = datetime.end(model.ends),
        viewOptions = this.alldayMove.alldayView.options,
        renderStartDate = datetime.start(datetime.parse(viewOptions.renderStartDate)),
        renderEndDate = datetime.end(datetime.parse(viewOptions.renderEndDate)),
        fromLeft = (new Date(originEventStarts.getTime() - renderStartDate.getTime())) / datetime.MILLISECONDS_PER_DAY | 0,
        fromRight = (new Date(originEventEnds.getTime() - renderEndDate.getTime())) / datetime.MILLISECONDS_PER_DAY | 0;

    return function(indexOffset) {
        return {
            baseWidthPercent: baseWidthPercent,
            fromLeft: fromLeft + indexOffset,
            fromRight: fromRight + indexOffset
        };
    };
};

/**
 * DragStart event handler.
 * @param {object} dragStartEventData - event data.
 */
AlldayMoveGuide.prototype._onDragStart = function(dragStartEventData) {
    var alldayViewContainer = this.alldayMove.alldayView.container,
        guideElement = this.guideElement = dragStartEventData.eventBlockElement.cloneNode(true),
        eventContainer;

    if (!util.browser.msie) {
        domutil.addClass(global.document.body, 'schedule-view-dragging');
    }

    eventContainer = domutil.find('.schedule-view-monthweek-events', alldayViewContainer);
    domutil.addClass(guideElement, 'schedule-view-allday-move-guide');
    eventContainer.appendChild(guideElement);

    this._dragStartXIndex = dragStartEventData.xIndex;
    this.getEventDataFunc = this._getEventBlockDataFunc(dragStartEventData);
};

/**
 * Drag event handler.
 * @param {object} dragEventData - event data.
 */
AlldayMoveGuide.prototype._onDrag = function(dragEventData) {
    var getEventDataFunc = this.getEventDataFunc,
        dragStartXIndex = this._dragStartXIndex,
        datesInRange = dragEventData.datesInRange,
        eventData,
        isExceededLeft,
        isExceededRight,
        originLength,
        newLeft,
        newWidth;

    if (!getEventDataFunc) {
        return;
    }

    eventData = getEventDataFunc(dragEventData.xIndex - dragStartXIndex);
    isExceededLeft = eventData.fromLeft < 0;
    isExceededRight = eventData.fromRight > 0;

    newLeft = Math.max(0, eventData.fromLeft);
    originLength = (eventData.fromLeft * -1) + (datesInRange + eventData.fromRight);
    newWidth = isExceededLeft ? (originLength + eventData.fromLeft) : originLength;
    newWidth = isExceededRight ? (newWidth - eventData.fromRight) : newWidth;

    newLeft *= eventData.baseWidthPercent;
    newWidth *= eventData.baseWidthPercent;

    this.refreshGuideElement(newLeft, newWidth, isExceededLeft, isExceededRight);
};

module.exports = AlldayMoveGuide;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../../common/reqAnimFrame":34}],64:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Resize handler module for Allday view.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.ne.util;
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var common = require('../../common/common');
var AlldayCore = require('./core');
var AlldayResizeGuide = require('./resizeGuide');

var parseViewIDRx = /^schedule-view-allday-monthweek[\s]schedule-view-(\d+)/;

/**
 * @constructor
 * @implements {Handler}
 * @mixes AlldayCore
 * @mixes CustomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {Allday} [alldayView] - MonthWeek view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function AlldayResize(dragHandler, alldayView, baseController) {
    /**
     * Drag handler instance.
     * @type {Drag}
     */
    this.dragHandler = dragHandler;

    /**
     * allday view instance.
     * @type {Allday}
     */
    this.alldayView = alldayView;

    /**
     * Base controller instance.
     * @type {Base}
     */
    this.baseController = baseController;

    /**
     * Temporary variable for dragStart event data.
     * @type {object}
     */
    this._dragStart = null;

    dragHandler.on({
        dragStart: this._onDragStart
    }, this);

    /**
     * @type {AlldayResizeGuide}
     */
    this.guide = new AlldayResizeGuide(this);
}

/**
 * Destroy method
 */
AlldayResize.prototype.destroy = function() {
    this.guide.destroy();
    this.dragHandler.off(this);
    this.dragHandler = this.alldayView = this.baseController =
        this.guide = this._dragStart = null;
};

/**
 * Check dragstart target is expected conditions for this handler.
 * @param {HTMLElement} target - dragstart event handler's target element.
 * @returns {boolean|MonthWeek} return MonthWeek view instance when satiate condition.
 */
AlldayResize.prototype.checkExpectedCondition = function(target) {
    var cssClass = domutil.getClass(target),
        matches;

    if (!~cssClass.indexOf('schedule-view-allday-resize-handle')) {
        return false;
    }

    target = domutil.closest(target, '.schedule-view-allday-monthweek');

    if (!target) {
        return false;
    }

    cssClass = domutil.getClass(target);
    matches = cssClass.match(parseViewIDRx);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.alldayView.childs.items, matches[1]);
};

/**
 * DragStart event handler.
 * @emits AlldayResize#allday_resize_dragstart
 * @param {object} dragStartEventData - event data.
 */
AlldayResize.prototype._onDragStart = function(dragStartEventData) {
    var target = dragStartEventData.target,
        result = this.checkExpectedCondition(target),
        controller = this.baseController,
        eventBlockElement,
        modelID,
        targetModel,
        getEventDataFunc,
        eventData;

    if (!result) {
        return;
    }

    eventBlockElement = domutil.closest(target, '.schedule-view-allday-event-block');
    modelID = domutil.getData(eventBlockElement, 'id');
    targetModel = controller.events.items[modelID];

    if (!targetModel) {
        return;
    }

    getEventDataFunc = this.getEventDataFunc = this._retriveEventData(this.alldayView, dragStartEventData.originEvent);
    eventData = this._dragStart = getEventDataFunc(dragStartEventData.originEvent);

    util.extend(eventData, {
        eventBlockElement: eventBlockElement,
        model: targetModel
    });

    this.dragHandler.on({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    /**
     * @event AlldayResize#allday_resize_dragstart
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     * @property {Event} model - data object of model isntance.
     * @property {HTMLDivElement} eventBlockElement - target event block element.
     */
    this.fire('allday_resize_dragstart', eventData);
};

/**
 * Drag event handler method.
 * @emits AlldayResize#allday_resize_drag
 * @param {object} dragEventData - Drag#drag event handler eventdata.
 */
AlldayResize.prototype._onDrag = function(dragEventData) {
    var getEventDataFunc = this.getEventDataFunc;

    if (!getEventDataFunc) {
        return;
    }

    /**
     * @event AlldayResize#allday_resize_drag
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire('allday_resize_drag', getEventDataFunc(dragEventData.originEvent));
};

/**
 * Request update event instance to base controller.
 * @param {object} eventData - event data from AlldayResize handler.
 */
AlldayResize.prototype._updateEvent = function(eventData) {
    var ctrl = this.baseController,
        model = eventData.targetModel,
        dateOffset = eventData.xIndex - eventData.dragStartXIndex,
        newEnds = new Date(model.ends.getTime());

    newEnds = new Date(newEnds.setDate(newEnds.getDate() + dateOffset));
    newEnds = new Date(Math.max(datetime.end(model.starts).getTime(), newEnds.getTime()));

    ctrl.updateEvent(model.id(), {
        ends: newEnds
    });
};

/**
 * DragEnd event hander method.
 * @emits AlldayResize#allday_resize_dragend
 * @param {object} dragEndEventData - Drag#DragEnd event handler data.
 * @param {string} [overrideEventName] - override emitted event name when supplied.
 * @param {?boolean} skipUpdate - true then skip update event model.
 */
AlldayResize.prototype._onDragEnd = function(dragEndEventData, overrideEventName, skipUpdate) {
    var getEventDataFunc = this.getEventDataFunc,
        dragStart = this._dragStart,
        eventData;

    if (!getEventDataFunc || !dragStart) {
        return;
    }

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    eventData = getEventDataFunc(dragEndEventData.originEvent);
    util.extend(eventData, {
        targetModel: dragStart.model
    });

    if (!skipUpdate) {
        this._updateEvent(eventData);
    }

    /**
     * @event AlldayResize#allday_resize_dragend
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire(overrideEventName || 'allday_resize_dragend', eventData);

    this.getEventDataFunc = this._dragStart = null;
};

/**
 * Click event handler method.
 * @emits AlldayResize#allday_resize_click
 * @param {object} clickEventData - Drag#Click event handler data.
 */
AlldayResize.prototype._onClick = function(clickEventData) {
    /**
     * @event AlldayResize#allday_resize_click
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this._onDragEnd(clickEventData, 'allday_resize_click', true);
};

common.mixin(AlldayCore, AlldayResize);
util.CustomEvents.mixin(AlldayResize);

module.exports = AlldayResize;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/datetime":28,"../../common/domutil":31,"./core":59,"./resizeGuide":65}],65:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Resize Guide module.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = window.ne.util;
var domutil = require('../../common/domutil');
var datetime = require('../../common/datetime');
var reqAnimFrame = require('../../common/reqAnimFrame');


/**
 * @constructor
 * @param {AlldayResize} alldayResize - instance of AlldayResize
 */
function AlldayResizeGuide(alldayResize) {
    /**
     * @type {AlldayResize}
     */
    this.alldayResize = alldayResize;

    /**
     * 실제로 이벤트 엘리먼트를 담는 엘리먼트
     * @type {HTMLDIVElement}
     */
    this.eventContainer = null;

    /**
     * @type {function}
     */
    this.getEventDataFunc = null;

    /**
     * @type {HTMLDIVElement}
     */
    this.guideElement = null;

    alldayResize.on({
        'allday_resize_dragstart': this._onDragStart,
        'allday_resize_drag': this._onDrag,
        'allday_resize_dragend': this._clearGuideElement,
        'allday_resize_click': this._clearGuideElement
    }, this);
}

/**
 * Destroy method
 */
AlldayResizeGuide.prototype.destroy = function() {
    this._clearGuideElement();
    this.alldayResize.off(this);
    this.alldayResize = this.eventContainer = this.getEventDataFunc =
        this.guideElement = null;
};

/**
 * Clear guide element.
 */
AlldayResizeGuide.prototype._clearGuideElement = function() {
    domutil.remove(this.guideElement);

    if (!util.browser.msie) {
        domutil.removeClass(global.document.body, 'schedule-view-resizing-x');
    }

    this.getEventDataFunc = null;
};

/**
 * Refresh guide element
 * @param {number} newWidth - new width percentage value to resize guide element.
 */
AlldayResizeGuide.prototype.refreshGuideElement = function(newWidth) {
    var guideElement = this.guideElement;

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.width = newWidth + '%';
    });
};

/**
 * Return function that calculate guide element's new width percentage value.
 * @param {object} dragStartEventData - dragstart event data.
 * @returns {function} return function that calculate guide element new width percentage.
 */
AlldayResizeGuide.prototype.getGuideElementWidthFunc = function(dragStartEventData) {
    var model = dragStartEventData.model,
        viewOptions = this.alldayResize.alldayView.options,
        startDate = datetime.start(new Date(Math.max(model.starts.getTime(), datetime.parse(viewOptions.renderStartDate).getTime()))),
        endDate = datetime.end(new Date(Math.min(model.ends.getTime(), datetime.parse(viewOptions.renderEndDate).getTime()))),
        originLength = datetime.range(startDate, endDate, datetime.MILLISECONDS_PER_DAY).length,
        baseWidthPercent = 100 / dragStartEventData.datesInRange,
        dragStartIndex = dragStartEventData.xIndex;

    return function(xIndex) {
        var offset = xIndex - dragStartIndex,
            newLength = originLength + offset;

        newLength = Math.max(1, newLength);

        return newLength * baseWidthPercent;
    }
};

/**
 * DragStart event handler.
 * @param {object} dragStartEventData - event data.
 */
AlldayResizeGuide.prototype._onDragStart = function(dragStartEventData) {
    var alldayViewContainer = this.alldayResize.alldayView.container,
        guideElement = this.guideElement = dragStartEventData.eventBlockElement.cloneNode(true),
        eventContainer;

    if (!util.browser.msie) {
        domutil.addClass(global.document.body, 'schedule-view-resizing-x');
    }

    eventContainer = domutil.find('.schedule-view-monthweek-events', alldayViewContainer);
    domutil.addClass(guideElement, 'schedule-view-allday-move-guide');
    eventContainer.appendChild(guideElement);

    this.getEventDataFunc = this.getGuideElementWidthFunc(dragStartEventData);
};

/**
 * Drag event handler.
 * @param {object} dragEventData - event data.
 */
AlldayResizeGuide.prototype._onDrag = function(dragEventData) {
    var func = this.getEventDataFunc;

    if (!func) {
        return;
    }

    this.refreshGuideElement(func(dragEventData.xIndex));
};

module.exports = AlldayResizeGuide;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../../common/reqAnimFrame":34}],66:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Drag handler for calendar.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../common/domutil');
var domevent = require('../common/domevent');

/**
 * @constructor
 * @mixes CustomEvents
 * @param {LayoutView} layoutView Layout view instance.
 */
function Drag(layoutView) {
    var container = layoutView.container;

    domevent.on(container, 'mousedown', this._onMouseDown, this);

    /**
     * @type {HTMLElement}
     */
    this.container = container;

    /**
     * @type {boolean}
     */
    this._isMoved = false;
}

/**
 * Destroy method.
 */
Drag.prototype.destroy = function() {
    domevent.off(this.container, 'mousedown', this._onMouseDown, this);
    this._isMoved = null;
    this.container = null;
};

/**
 * Toggle events for mouse dragging.
 * @param {boolean} toBind - bind events related with dragging when supplied "true"
 */
Drag.prototype._toggleDragEvent = function(toBind) {
    var container = this.container,
        domMethod,
        method;

    if (toBind) {
        domMethod = 'on';
        method = 'disable';
    } else {
        domMethod = 'off';
        method = 'enable';
    }

    domutil[method + 'TextSelection'](container);
    domutil[method + 'ImageDrag'](container);
    domevent[domMethod](global, {
        mousemove: this._onMouseMove,
        mouseup: this._onMouseUp
    }, this);
};

/**
 * Normalize mouse event object.
 * @param {MouseEvent} mouseEvent - mouse event object.
 * @returns {object} normalized mouse event data.
 */
Drag.prototype._getEventData = function(mouseEvent) {
    return {
        target: mouseEvent.target || mouseEvent.srcElement,
        originEvent: mouseEvent
    };
};

/**
 * MouseDown DOM event handler.
 * @param {MouseEvent} mouseDownEvent MouseDown event object.
 * @emits Drag#dragStart
 */
Drag.prototype._onMouseDown = function(mouseDownEvent) {
    // only primary button can start drag.
    if (domevent.getMouseButton(mouseDownEvent) !== 0) {
        return;
    }

    /**
     * Drag starts events. cancelable.
     * @event Drag#dragStart
     * @type {object}
     * @property {HTMLElement} target - target element in this event.
     * @property {MouseEvent} originEvent - original mouse event object.
     */
    if (!this.invoke('dragStart', this._getEventData(mouseDownEvent))) {
        return;
    }

    this._toggleDragEvent(true);
};

/**
 * MouseMove DOM event handler.
 * @param {MouseEvent} mouseMoveEvent MouseMove event object.
 * @emits Drag#drag
 */
Drag.prototype._onMouseMove = function(mouseMoveEvent) {
    // prevent automatic scrolling.
    domevent.preventDefault(mouseMoveEvent);

    this._isMoved = true;

    /**
     * Events while dragging.
     * @event Drag#drag
     * @type {object}
     * @property {HTMLElement} target - target element in this event.
     * @property {MouseEvent} originEvent - original mouse event object.
     */
    this.fire('drag', this._getEventData(mouseMoveEvent));
};

/**
 * MouseUp DOM event handler.
 * @param {MouseEvent} mouseUpEvent MouseUp event object.
 * @emits Drag#dragEnd
 * @emits Drag#click
 */
Drag.prototype._onMouseUp = function(mouseUpEvent) {
    this._toggleDragEvent(false);

    // emit "click" event when not emitted drag event between mousedown and mouseup.
    if (this._isMoved) {
        this._isMoved = false;

        /**
         * Drag end events.
         * @event Drag#dragEnd
         * @type {MouseEvent}
         * @property {HTMLElement} target - target element in this event.
         * @property {MouseEvent} originEvent - original mouse event object.
         */
        this.fire('dragEnd', this._getEventData(mouseUpEvent));
        return;
    }

    /**
     * Click events.
     * @event Drag#click
     * @type {MouseEvent}
     * @property {HTMLElement} target - target element in this event.
     * @property {MouseEvent} originEvent - original mouse event object.
     */
    this.fire('click', this._getEventData(mouseUpEvent));
};

util.CustomEvents.mixin(Drag);

module.exports = Drag;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/domevent":30,"../common/domutil":31}],67:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Core methods for dragging actions
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var common = require('../../common/common');
var datetime = require('../../common/datetime');
var domevent = require('../../common/domevent');
var Point = require('../../common/point');

/**
 * @mixin Time.Core
 */
var timeCore = {
    /**
     * Get Y index ratio(hour) in time grids by supplied parameters.
     * @param {number} baseMil - base milliseconds number for supplied height.
     * @param {number} height - container element height.
     * @param {number} y - Y coordinate to calculate hour ratio.
     * @returns {number} hour index ratio value.
     */
    _calcGridYIndex: function(baseMil, height, y) {
        // get ratio from right expression > point.y : x = session.height : baseMil
        // and convert milliseconds value to hours.
        var result = datetime.millisecondsTo('hour', (y * baseMil) / height),
            floored = result | 0,
            nearest = common.nearest(result - floored, [0, 1]);

        return floored + (nearest ? 0.5 : 0);
    },

    /**
     * Get function to makes event data from Time and mouseEvent
     * @param {Time} timeView - Instance of time view.
     * @returns {function} - Function that return event data from mouse event.
     */
    _retriveEventData: function(timeView) {
        var container = timeView.container,
            options = timeView.options,
            viewHeight = timeView.getViewBound().height,
            viewTime = +timeView.getDate(),
            hourLength = options.hourEnd - options.hourStart,
            baseMil = datetime.millisecondsFrom('hour', hourLength);

        /**
         * @param {MouseEvent} mouseEvent - mouse event object to get common event data.
         * @param {object} [extend] - object to extend event data before return.
         * @returns {object} - common event data for time.*
         */
        return util.bind(function(mouseEvent, extend) {
            var mouseY = Point.n(domevent.getMousePosition(mouseEvent, container)).y,
                gridY = common.ratio(viewHeight, hourLength, mouseY),
                timeY = viewTime + datetime.millisecondsFrom('hour', gridY),
                nearestGridY = this._calcGridYIndex(baseMil, viewHeight, mouseY),
                nearestGridTimeY = viewTime + datetime.millisecondsFrom('hour', nearestGridY + options.hourStart);

            return util.extend({
                target: mouseEvent.target || mouseEvent.srcElement,
                relatedView: timeView,
                originEvent: mouseEvent,
                mouseY: mouseY,
                gridY: gridY,
                timeY: timeY,
                nearestGridY: nearestGridY,
                nearestGridTimeY: nearestGridTimeY
            }, extend);
        }, this);
    },

    /**
     * Mixin method.
     * @param {(TimeCreation|TimeMove)} obj - Constructor functions
     */
    mixin: function(obj) {
        var proto = obj.prototype;
        util.forEach(timeCore, function(method, methodName) {
            if (methodName === 'mixin') {
                return;
            }

            proto[methodName] = method;
        });
    }
};

module.exports = timeCore;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/datetime":28,"../../common/domevent":30,"../../common/point":33}],68:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Handling creation events from drag handler and time grid view
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var array = require('../../common/array');
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var TimeCreationGuide = require('./creationGuide');
var timeCore = require('./core');

var parseViewIDRx = /^schedule-view-time-date[\s]schedule-view-(\d+)/;

/**
 * @constructor
 * @implements {Handler}
 * @mixes timeCore
 * @mixes CustomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function TimeCreation(dragHandler, timeGridView, baseController) {
    /**
     * Drag handler instance.
     * @type {Drag}
     */
    this.dragHandler = null;

    /**
     * TimeGrid view instance.
     * @type {TimeGrid}
     */
    this.timeGridView = null;

    /**
     * Base controller instance.
     * @type {Base}
     */
    this.baseController = null;

    /**
     * @type {TimeCreationGuide}
     */
    this.guide = new TimeCreationGuide(this);

    /**
     * Temporary function for single drag session's calc.
     * @type {function}
     */
    this._getEventDataFunc = null;

    /**
     * Temporary function for drag start data cache.
     * @type {object}
     */
    this._dragStart = null;

    if (arguments.length) {
        this.connect.apply(this, arguments);
    }
}

/**
 * Destroy method
 */
TimeCreation.prototype.destroy = function() {
    this.guide.destroy();
    this.dragHandler.off(this);
    this.dragHandler = this.timeGridView = this.baseController =
        this._getEventDataFunc = this._dragStart = this.guide = null;
};

/**
 * Connect handler, view, controllers for event creations.
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
TimeCreation.prototype.connect = function(dragHandler, timeGridView, baseController) {
    this.dragHandler = dragHandler;
    this.timeGridView = timeGridView;
    this.baseController = baseController;

    dragHandler.on({
        dragStart: this._onDragStart
    }, this);
};

/**
 * Check target element is expected condition for activate this plugins.
 * @param {HTMLElement} target - The element to check
 * @returns {(boolean|Time)} - return Time view instance when satiate condition.
 */
TimeCreation.prototype.checkExpectedCondition = function(target) {
    var cssClass = domutil.getClass(target),
        matches;

    if (cssClass === 'schedule-view-time-date-event-block') {
        target = target.parentNode;
        cssClass = domutil.getClass(target);
    }

    matches = cssClass.match(parseViewIDRx);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.timeGridView.childs.items, matches[1]);
};

/**
 * Drag#dragStart event handler.
 * @emits TimeCreation#time_creation_dragstart
 * @param {object} dragStartEventData - Drag#dragStart event data.
 * @param {string} [overrideEventName] - override emitted event name when supplied.
 * @param {function} [revise] - supply function for revise event data before emit.
 */
TimeCreation.prototype._onDragStart = function(dragStartEventData, overrideEventName, revise) {
    var target = dragStartEventData.target,
        result = this.checkExpectedCondition(target),
        getEventDataFunc,
        eventData;

    if (!result) {
        return;
    }

    getEventDataFunc = this._getEventDataFunc = this._retriveEventData(result);
    eventData = this._dragStart = getEventDataFunc(dragStartEventData.originEvent);

    if (revise) {
        revise(eventData);
    }

    this.dragHandler.on({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    /**
     * @event TimeCreation#time_creation_dragstart
     * @type {object}
     * @property {Time} relatedView - time view instance related with mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     */
    this.fire(overrideEventName || 'time_creation_dragstart', eventData);
};

/**
 * Drag#drag event handler
 * @emits TimeCreation#time_creation_drag
 * @param {object} dragEventData - event data from Drag#drag.
 * @param {string} [overrideEventName] - override emitted event name when supplied.
 * @param {function} [revise] - supply function for revise event data before emit.
 */
TimeCreation.prototype._onDrag = function(dragEventData, overrideEventName, revise) {
    var getEventDataFunc = this._getEventDataFunc,
        eventData;

    if (!getEventDataFunc) {
        return;
    }

    eventData = getEventDataFunc(dragEventData.originEvent);

    if (revise) {
        revise(eventData);
    }

    /**
     * @event TimeCreation#time_creation_drag
     * @type {object}
     * @property {Time} relatedView - time view instance related with mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     */
    this.fire(overrideEventName || 'time_creation_drag', eventData);
};

/**
 * @param {object} eventData - event data object from TimeCreation#time_creation_dragend
 * or TimeCreation#time_creation_click
 */
TimeCreation.prototype._createEvent = function(eventData) {
    var title = window.prompt('Name of event to create:'),
        ctrl = this.baseController,
        relatedView = eventData.relatedView,
        createRange = eventData.createRange,
        nearestGridTimeY = eventData.nearestGridTimeY,
        baseDate,
        dateStart,
        dateEnd,
        newStarts,
        newEnds;

    this.guide.clearGuideElement();

    if (!title) {
        return;
    }

    if (!createRange) {
        createRange = [
            nearestGridTimeY,
            nearestGridTimeY + datetime.millisecondsFrom('minutes', 30)
        ];
    }

    baseDate = new Date(relatedView.getDate());
    dateStart = datetime.start(baseDate);
    dateEnd = datetime.end(baseDate);
    newStarts = Math.max(dateStart.getTime(), createRange[0]);
    newEnds = Math.min(dateEnd.getTime(), createRange[1]);

    ctrl.createEvent({
        title: title,
        isAllDay: false,
        starts: new Date(newStarts),
        ends: new Date(newEnds)
    });
};

/**
 * Drag#dragEnd event handler
 * @emits TimeCreation#time_creation_dragend
 * @param {object} dragEndEventData - event data from Drag#dragend
 */
TimeCreation.prototype._onDragEnd = function(dragEndEventData) {
    var dragStart = this._dragStart;

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    function reviseFunc(eventData) {
        var range = [
            dragStart.nearestGridTimeY,
            eventData.nearestGridTimeY
        ].sort(array.compare.num.asc);
        range[1] += datetime.millisecondsFrom('hour', 0.5);

        eventData.createRange = range;

        this._createEvent(eventData);
    }

    /**
     * @event TimeCreation#time_creation_dragend
     * @type {object}
     * @property {Time} relatedView - time view instance related with mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {number[]} createRange - milliseconds range between drag start and end to create.
     */
    this._onDrag(dragEndEventData, 'time_creation_dragend', util.bind(reviseFunc, this));

    this._dragStart = this._getEventDataFunc = null;
};

/**
 * Drag#click event handler
 * @emits TimeCreation#time_creation_click
 * @param {object} clickEventData - event data from Drag#click.
 */
TimeCreation.prototype._onClick = function(clickEventData) {
    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    function reviseFunc(eventData) {
        this._createEvent(eventData);
    }

    /**
     * @event TimeCreation#time_creation_click
     * @type {object}
     * @property {Time} relatedView - time view instance related with mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     */
    this._onDrag(clickEventData, 'time_creation_click', util.bind(reviseFunc, this));

    this._dragStart = this._getEventDataFunc = null;
};

timeCore.mixin(TimeCreation);
util.CustomEvents.mixin(TimeCreation);

module.exports = TimeCreation;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/array":24,"../../common/datetime":28,"../../common/domutil":31,"./core":67,"./creationGuide":69}],69:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Module for Time.Creation effect while dragging.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../../common/domutil');
var reqAnimFrame = require('../../common/reqAnimFrame');

var ratio = require('../../common/common').ratio;

/**
 * Class for Time.Creation dragging effect.
 * @constructor
 * @param {TimeCreation} timeCreation - instance of TimeCreation.
 */
function TimeCreationGuide(timeCreation) {
    /**
     * Guide element for creation effect.
     * @type {HTMLElement}
     */
    this.guideElement = global.document.createElement('div');

    /**
     * @type {TimeCreation}
     */
    this.timeCreation = timeCreation;

    /**
     * @type {number}
     */
    this._startGridY = 0;

    /**
     * @type {function}
     */
    this._getTopFunc = null;

    domutil.addClass(this.guideElement, 'schedule-view-time-creation-guide');

    timeCreation.on({
        'time_creation_dragstart': this._onDragStart,
        'time_creation_drag': this._onDrag,
        // 'time_creation_dragend': this.clearGuideElement,
        'time_creation_click': this.clearGuideElement
    }, this);
}

/**
 * Destroy method.
 */
TimeCreationGuide.prototype.destroy = function() {
    this.clearGuideElement();
    this.timeCreation.off(this);
    this.guideElement = this.timeCreation = this._startGridY =
        this._getTopFunc = null;
};

/**
 * Clear guide element.
 */
TimeCreationGuide.prototype.clearGuideElement = function() {
    var guideElement = this.guideElement;

    domutil.remove(guideElement);

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.display = 'none';
        guideElement.style.top = '';
        guideElement.style.height = '';
    });
};

/**
 * Refresh guide element
 * @param {number} top - The number of guide element's style top.
 * @param {number} height - The number of guide element's style height.
 */
TimeCreationGuide.prototype._refreshGuideElement = function(top, height) {
    var guideElement = this.guideElement;

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.top = top + 'px';
        guideElement.style.height = height + 'px';
        guideElement.style.display = 'block';
    });
};

/**
 * DragStart event handler
 * @param {object} dragStartEventData - dragStart event data.
 */
TimeCreationGuide.prototype._onDragStart = function(dragStartEventData) {
    var timeView = dragStartEventData.relatedView,
        viewOptions = timeView.options,
        viewHeight = timeView.getViewBound().height,
        hourLength = viewOptions.hourEnd - viewOptions.hourStart,
        getTopFunc;

    getTopFunc = this._getTopFunc = util.bind(function(indexY) {
        // memo
        if (getTopFunc[indexY]) {
            return getTopFunc[indexY];
        }

        getTopFunc[indexY] = ratio(hourLength, viewHeight, indexY);

        return getTopFunc[indexY];
    }, this);

    this._startGridY = getTopFunc(dragStartEventData.nearestGridY);

    this._refreshGuideElement(
        this._startGridY,
        getTopFunc(0.5)
    );

    timeView.container.appendChild(this.guideElement);
};

/**
 * Drag event handler
 * @param {object} dragEventData - drag event data.
 */
TimeCreationGuide.prototype._onDrag = function(dragEventData) {
    var getTopFunc = this._getTopFunc,
        startGridY = this._startGridY,
        endGridY;

    if (!getTopFunc) {
        return;
    }

    // drawing guide from start point to at least 30min points.
    endGridY = getTopFunc(dragEventData.nearestGridY) + getTopFunc(0.5);

    if (endGridY > startGridY) {
        this._refreshGuideElement(startGridY, endGridY - startGridY);
        return;
    }

    this._refreshGuideElement(
        endGridY - getTopFunc(0.5),
        (startGridY + getTopFunc(1)) - endGridY
    );
};

module.exports = TimeCreationGuide;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/domutil":31,"../../common/reqAnimFrame":34}],70:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Handling move events from drag handler and time grid view
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var timeCore = require('./core');
var TimeMoveGuide = require('./moveGuide');

var parseTimeViewIDRx = /^schedule-view-time-date[\s]schedule-view-(\d+)/;

/**
 * @constructor
 * @implements {Handler}
 * @mixes timeCore
 * @mixes util.CustomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function TimeMove(dragHandler, timeGridView, baseController) {
    /**
     * @type {Drag}
     */
    this.dragHandler = null;

    /**
     * @type {TimeGrid}
     */
    this.timeGridView = null;

    /**
     * @type {Base}
     */
    this.baseController = null;

    /**
     * @type {function}
     */
    this._getEventDataFunc = null;

    /**
     * @type {object}
     */
    this._dragStart = null;

    /**
     * @type {TimeMoveGuide}
     */
    this._guide = new TimeMoveGuide(this);

    if (arguments.length) {
        this.connect.apply(this, arguments);
    }
}

/**
 * Destroy method.
 */
TimeMove.prototype.destroy = function() {
    this._guide.destroy();
    this.dragHandler.off(this);
    this.dragHandler = this.timeGridView = this.baseController =
        this._getEventDataFunc = this._dragStart = this._guide = null;
};

/**
 * Connect handler, view, controllers for event creations.
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
TimeMove.prototype.connect = function(dragHandler, timeGridView, baseController) {
    this.dragHandler = dragHandler;
    this.timeGridView = timeGridView;
    this.baseController = baseController;

    dragHandler.on({
        dragStart: this._onDragStart
    }, this);
};

/**
 * Check target element is expected condition for activate this plugins.
 * @param {HTMLElement} target - The element to check
 * @returns {boolean|object} - return object when satiate condition.
 */
TimeMove.prototype.checkExpectCondition = function(target) {
    if (domutil.getClass(target) !== 'schedule-view-time-event') {
        return false;
    }

    return this._getTimeView(target);
};

/**
 * Get Time view container from supplied element.
 * @param {HTMLElement} target - element to find time view container.
 * @returns {object|boolean} - return time view instance when finded.
 */
TimeMove.prototype._getTimeView = function(target) {
    var container = domutil.closest(target, '.schedule-view-time-date'),
        matches;

    if (!container) {
        return false;
    }

    matches = domutil.getClass(container).match(parseTimeViewIDRx);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.timeGridView.childs.items, +matches[1]);
};

/**
 * @emits TimeMove#time_move_dragstart
 * @param {object} dragStartEventData - Drag#dragStart event data.
 */
TimeMove.prototype._onDragStart = function(dragStartEventData) {
    var target = dragStartEventData.target,
        timeView = this.checkExpectCondition(target),
        blockElement = domutil.closest(target, '.schedule-view-time-date-event-block'),
        getEventDataFunc,
        eventData;

    if (!timeView || !blockElement) {
        return;
    }

    getEventDataFunc = this._getEventDataFunc = this._retriveEventData(timeView);
    eventData = this._dragStart = getEventDataFunc(
        dragStartEventData.originEvent, {
            targetModelID: domutil.getData(blockElement, 'id')
        }
    );

    this.dragHandler.on({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    /**
     * @event TimeMove#time_move_dragstart
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {string} targetModelID - The model unique id emitted move event.
     */
    this.fire('time_move_dragstart', eventData);
};

/**
 * @emits TimeMove#time_move_drag
 * @param {MouseEvent} dragEventData - mousemove event object
 * @param {string} [overrideEventName] - name of emitting event to override.
 * @param {function} [revise] - supply function for revise event data before emit.
 */
TimeMove.prototype._onDrag = function(dragEventData, overrideEventName, revise) {
    var getEventDataFunc = this._getEventDataFunc,
        timeView = this._getTimeView(dragEventData.target),
        dragStart = this._dragStart,
        eventData;

    if (!timeView || !getEventDataFunc || !dragStart) {
        return;
    }

    eventData = getEventDataFunc(dragEventData.originEvent, {
        currentView: timeView,
        targetModelID: dragStart.targetModelID
    });

    if (revise) {
        revise(eventData);
    }

    /**
     * @event TimeMove#time_move_drag
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with drag start position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {Time} currentView - time view instance related with current mouse position.
     * @property {string} targetModelID - The model unique id emitted move event.
     */
    this.fire(overrideEventName || 'time_move_drag', eventData);
};

/**
 * Update model instance by dragend event results.
 * @param {object} eventData - event data from TimeMove#time_move_dragend
 */
TimeMove.prototype._updateEvent = function(eventData) {
    var ctrl = this.baseController,
        modelID = eventData.targetModelID,
        range = eventData.nearestRange,
        timeDiff = range[1] - range[0],
        dateDiff = 0,
        model = ctrl.events.items[modelID],
        relatedView = eventData.relatedView,
        currentView = eventData.currentView,
        eventDuration,
        dateStart,
        dateEnd,
        newStarts,
        newEnds,
        baseDate;

    if (!model || !currentView) {
        return;
    }

    timeDiff -= datetime.millisecondsFrom('minutes', 30);
    baseDate = new Date(relatedView.getDate());
    dateStart = datetime.start(baseDate);
    dateEnd = datetime.end(baseDate);
    newStarts = new Date(model.getStarts().getTime() + timeDiff);
    newEnds = new Date(model.getEnds().getTime() + timeDiff);
    eventDuration = model.duration();

    if (currentView) {
        dateDiff = currentView.getDate() - relatedView.getDate();
    }

    if (newStarts < dateStart) {
        newStarts = new Date(dateStart.getTime());
        newEnds = new Date(newStarts.getTime() + eventDuration.getTime());
    } else if (newEnds > dateEnd) {
        newEnds = new Date(dateEnd.getTime());
        newStarts = new Date(newEnds.getTime() - eventDuration.getTime());
    }

    newStarts = new Date(newStarts.getTime() + dateDiff);
    newEnds = new Date(newEnds.getTime() + dateDiff);

    ctrl.updateEvent(modelID, {
        starts: newStarts,
        ends: newEnds
    });
};

/**
 * @emits TimeMove#time_move_dragend
 * @param {MouseEvent} dragEndEventData - mouseup mouse event object.
 */
TimeMove.prototype._onDragEnd = function(dragEndEventData) {
    var getEventDataFunc = this._getEventDataFunc,
        currentView = this._getTimeView(dragEndEventData.target),
        dragStart = this._dragStart,
        eventData;

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    if (!getEventDataFunc || !dragStart) {
        return;
    }

    eventData = getEventDataFunc(dragEndEventData.originEvent, {
        currentView: currentView,
        targetModelID: dragStart.targetModelID
    });

    eventData.range = [
        dragStart.timeY,
        eventData.timeY + datetime.millisecondsFrom('hour', 0.5)
    ];

    eventData.nearestRange = [
        dragStart.nearestGridTimeY,
        eventData.nearestGridTimeY + datetime.millisecondsFrom('hour', 0.5)
    ];

    this._updateEvent(eventData);

    /**
     * @event TimeMove#time_move_dragend
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with drag start position.
     * @property {Time} currentView - time view instance related with current mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {string} targetModelID - The model unique id emitted move event.
     * @property {number[]} range - milliseconds range between drag start and end.
     * @property {number[]} nearestRange - milliseconds range related with nearestGridY between start and end.
     */
    this.fire('time_move_dragend', eventData);
};

/**
 * @emits TimeMove#time_move_click
 * @param {MouseEvent} clickEventData - click mouse event object.
 */
TimeMove.prototype._onClick = function(clickEventData) {
    var getEventDataFunc = this._getEventDataFunc,
        dragStart = this._dragStart,
        eventData;

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    if (!getEventDataFunc || !dragStart) {
        return;
    }

    eventData = getEventDataFunc(clickEventData.originEvent, {
        targetModelID: dragStart.targetModelID
    });

    /**
     * @event TimeMove#time_move_click
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with drag start position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {string} targetModelID - The model unique id emitted move event.
     */
    this.fire('time_move_click', eventData);
};

timeCore.mixin(TimeMove);
util.CustomEvents.mixin(TimeMove);

module.exports = TimeMove;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"./core":67,"./moveGuide":71}],71:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Module for Time.Move effect while dragging.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../../common/domutil');
var reqAnimFrame = require('../../common/reqAnimFrame');

var ratio = require('../../common/common').ratio;

/**
 * Class for Time.Move effect.
 * @constructor
 * @param {TimeMove} timeMove - The instance of TimeMove.
 */
function TimeMoveGuide(timeMove) {
    /**
     * @type {HTMLElement}
     */
    this.guideElement = null;

    /**
     * @type {TimeMove}
     */
    this.timeMove = timeMove;

    /**
     * @type {HTMLElement}
     */
    this._container = null;

    /**
     * @type {function}
     */
    this._getTopFunc = null;

    /**
     * @type {number}
     */
    this._startGridY = 0;

    /**
     * @type {number}
     */
    this._startTopPixel = 0;

    timeMove.on({
        'time_move_dragstart': this._onDragStart,
        'time_move_drag': this._onDrag,
        'time_move_dragend': this._clearGuideElement,
        'time_move_click': this._clearGuideElement
    }, this);
}

/**
 * Destroy method
 */
TimeMoveGuide.prototype.destroy = function() {
    this._clearGuideElement();
    this.timeMove.off(this);
    this.guideElement = this.timeMove = this._container =
        this._getTopFunc = this._startGridY = this._startTopPixel = null;
};

/**
 * Clear guide element.
 */
TimeMoveGuide.prototype._clearGuideElement = function() {
    var guideElement = this.guideElement;

    if (!util.browser.msie) {
        domutil.removeClass(global.document.body, 'schedule-view-dragging');
    }

    domutil.remove(guideElement);

    this.guideElement = this._getTopFunc =
        this._startGridY = this._startTopPixel = null;
};

/**
 * Refresh guide element
 * @param {string} top - guide element's style top.
 */
TimeMoveGuide.prototype._refreshGuideElement = function(top) {
    var guideElement = this.guideElement;

    if (!guideElement) {
        return;
    }

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.top = top + 'px';
        guideElement.style.display = 'block';
    });
};

/**
 * TimeMove#time_move_dragstart event handler
 * @param {object} dragStartEventData - dragstart event data
 */
TimeMoveGuide.prototype._onDragStart = function(dragStartEventData) {
    var guideElement = domutil.closest(
        dragStartEventData.target,
        '.schedule-view-time-date-event-block'
    );

    if (!guideElement) {
        return;
    }

    guideElement = guideElement.cloneNode(true);
    domutil.addClass(guideElement, 'schedule-view-time-move-guide');

    this._startTopPixel = parseFloat(guideElement.style.top);
    this._startGridY = dragStartEventData.nearestGridY;
    this.guideElement = guideElement;
    this._container = dragStartEventData.relatedView.container;
    this._container.appendChild(guideElement);
};

/**
 * TimeMove#time_move_drag event handler
 * @param {object} dragEventData - drag event data
 */
TimeMoveGuide.prototype._onDrag = function(dragEventData) {
    var timeView = dragEventData.currentView,
        viewOptions = timeView.options,
        viewHeight = timeView.getViewBound().height,
        guideHeight = parseFloat(this.guideElement.style.height),
        hourLength = viewOptions.hourEnd - viewOptions.hourStart,
        gridYOffset = dragEventData.nearestGridY - this._startGridY,
        // hourLength : viewHeight = gridYOffset : X;
        gridYOffsetPixel = ratio(hourLength, viewHeight, gridYOffset),
        bottomLimit,
        top;

    if (!util.browser.msie) {
        domutil.addClass(global.document.body, 'schedule-view-dragging');
    }

    if (this._container !== timeView.container) {
        this._container = timeView.container;
        this._container.appendChild(this.guideElement);
    }

    top = this._startTopPixel + gridYOffsetPixel;
    bottomLimit = viewHeight - guideHeight;

    top = Math.max(top, 0);
    top = Math.min(top, bottomLimit);

    this._refreshGuideElement(top);
};

module.exports = TimeMoveGuide;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/domutil":31,"../../common/reqAnimFrame":34}],72:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Handling resize events from drag handler and time grid view
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.ne.util;
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var timeCore = require('./core');
var TimeResizeGuide = require('./resizeGuide');

var parseTimeViewIDRx = /^schedule-view-time-date[\s]schedule-view-(\d+)/;

/**
 * @constructor
 * @implements {Handler}
 * @mixes timeCore
 * @mixes util.CustomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function TimeResize(dragHandler, timeGridView, baseController) {
    /**
     * @type {Drag}
     */
    this.dragHandler = null;

    /**
     * @type {TimeGrid}
     */
    this.timeGridView = null;

    /**
     * @type {Base}
     */
    this.baseController = null;

    /**
     * @type {function}
     */
    this._getEventDataFunc = null;

    /**
     * @type {object}
     */
    this._dragStart = null;

    /**
     * @type {TimeResizeGuide}
     */
    this._guide = new TimeResizeGuide(this);

    if (arguments.length) {
        this.connect.apply(this, arguments);
    }
}

/**
 * Destroy method
 */
TimeResize.prototype.destroy = function() {
    this._guide.destroy();
    this.dragHandler.off(this);
    this.dragHandler = this.timeGridView = this.baseController =
        this._getEventDataFunc = this._dragStart = this._guide = null;
};

/**
 * Connect handler, view, controllers for event creations.
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
TimeResize.prototype.connect = function(dragHandler, timeGridView, baseController) {
    this.dragHandler = dragHandler;
    this.timeGridView = timeGridView;
    this.baseController = baseController;

    dragHandler.on({
        dragStart: this._onDragStart
    }, this);
};

/**
 * @param {HTMLElement} target - element to check condition.
 * @returns {object|boolean} - return time view instance or false
 */
TimeResize.prototype.checkExpectCondition = function(target) {
    var container,
        matches;

    if (!domutil.hasClass(target, 'schedule-view-time-resize-handle')) {
        return false;
    }

    container = domutil.closest(target, '.schedule-view-time-date');

    if (!container) {
        return false;
    }

    matches = domutil.getClass(container).match(parseTimeViewIDRx);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.timeGridView.childs.items, +matches[1]);
};

/**
 * @emits TimeResize#time_resize_dragstart
 * @param {object} dragStartEventData - event data of Drag#dragstart
 */
TimeResize.prototype._onDragStart = function(dragStartEventData) {
    var target = dragStartEventData.target,
        timeView = this.checkExpectCondition(target),
        blockElement = domutil.closest(target, '.schedule-view-time-date-event-block'),
        getEventDataFunc,
        eventData;

    if (!timeView || !blockElement) {
        return;
    }

    getEventDataFunc = this._getEventDataFunc = this._retriveEventData(timeView);
    eventData = this._dragStart = getEventDataFunc(
        dragStartEventData.originEvent, {
            targetModelID: domutil.getData(blockElement, 'id')
        }
    );

    this.dragHandler.on({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    /**
     * @event TimeResize#time_resize_dragstart
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {string} targetModelID - The model unique id emitted move event.
     */
    this.fire('time_resize_dragstart', eventData);
};

/**
 * Drag#drag event handler
 * @emits TimeResize#time_resize_drag
 * @param {object} dragEventData - event data of Drag#drag custom event.
 * @param {string} [overrideEventName] - override emitted event name when supplied.
 * @param {function} [revise] - supply function for revise event data before emit.
 */
TimeResize.prototype._onDrag = function(dragEventData, overrideEventName, revise) {
    var getEventDataFunc = this._getEventDataFunc,
        startEventData = this._dragStart,
        eventData;

    if (!getEventDataFunc || !startEventData) {
        return;
    }

    eventData = getEventDataFunc(dragEventData.originEvent, {
        targetModelID: startEventData.targetModelID
    });

    if (revise) {
        revise(eventData);
    }

    /**
     * @event TimeResize#time_resize_drag
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with drag start position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {string} targetModelID - The model unique id emitted move event.
     */
    this.fire(overrideEventName || 'time_resize_drag', eventData);
};

/**
 * Update model instance by dragend event results.
 * @param {object} eventData - event data from TimeResize#time_resize_dragend
 */
TimeResize.prototype._updateEvent = function(eventData) {
    var ctrl = this.baseController,
        modelID = eventData.targetModelID,
        range = eventData.nearestRange,
        timeDiff = range[1] - range[0],
        model = ctrl.events.items[modelID],
        relatedView = eventData.relatedView,
        dateEnd,
        newEnds,
        baseDate;

    if (!model) {
        return;
    }

    timeDiff -= datetime.millisecondsFrom('minutes', 30);

    baseDate = new Date(relatedView.getDate());
    dateEnd = datetime.end(baseDate);
    newEnds = new Date(model.getEnds().getTime() + timeDiff);

    if (newEnds > dateEnd) {
        newEnds = new Date(dateEnd.getTime());
    }

    if (newEnds.getTime() - model.getStarts().getTime() < datetime.millisecondsFrom('minutes', 30)) {
        newEnds = new Date(model.getStarts().getTime() + datetime.millisecondsFrom('minutes', 30));
    }

    ctrl.updateEvent(modelID, {
        ends: newEnds
    });
};

/**
 * Drag#dragEnd event handler
 * @emits TimeResize#time_resize_dragend
 * @param {MouseEvent} dragEndEventData - Mouse event of Drag#dragEnd custom event.
 */
TimeResize.prototype._onDragEnd = function(dragEndEventData) {
    var getEventDataFunc = this._getEventDataFunc,
        dragStart = this._dragStart,
        eventData;

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    if (!getEventDataFunc || !dragStart) {
        return;
    }

    eventData = getEventDataFunc(dragEndEventData.originEvent, {
        targetModelID: dragStart.targetModelID
    });

    eventData.range = [
        dragStart.timeY,
        eventData.timeY + datetime.millisecondsFrom('hour', 0.5)
    ];

    eventData.nearestRange = [
        dragStart.nearestGridTimeY,
        eventData.nearestGridTimeY + datetime.millisecondsFrom('hour', 0.5)
    ];

    this._updateEvent(eventData);

    /**
     * @event TimeResize#time_resize_dragend
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with drag start position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {string} targetModelID - The model unique id emitted move event.
     * @property {number[]} range - milliseconds range between drag start and end.
     * @property {number[]} nearestRange - milliseconds range related with nearestGridY between start and end.
     */
    this.fire('time_resize_dragend', eventData);

    this._getEventDataFunc = this._dragStart = null;
};

/**
 * @emits TimeResize#time_resize_click
 */
TimeResize.prototype._onClick = function() {
    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    /**
     * @event TimeResize#time_resize_click
     */
    this.fire('time_resize_click');
};

timeCore.mixin(TimeResize);
util.CustomEvents.mixin(TimeResize);

module.exports = TimeResize;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"./core":67,"./resizeGuide":73}],73:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Module for Time.Resize effect while dragging.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.ne.util;
var domutil = require('../../common/domutil');
var reqAnimFrame = require('../../common/reqAnimFrame');

var ratio = require('../../common/common').ratio;

/**
 * Class for Time.Resize effect.
 * @constructor
 * @param {TimeResize} timeResize - the instance of TimeResize handler.
 */
function TimeResizeGuide(timeResize) {
    /**
     * @type {HTMLElement}
     */
    this.guideElement = null;

    /**
     * @type {TimeResize}
     */
    this.timeResize = timeResize;

    /**
     * @type {function}
     */
    this._getTopFunc = null;

    /**
     * @type {HTMLElement}
     */
    this._originEventElement = null;

    /**
     * @type {number}
     */
    this._startTopPixel = 0;

    /**
     * @type {number}
     */
    this._startHeightPixel = 0;

    /**
     * @type {number}
     */
    this._startGridY = 0;

    timeResize.on({
        'time_resize_dragstart': this._onDragStart,
        'time_resize_drag': this._onDrag,
        'time_resize_dragend': this._clearGuideElement,
        'time_resize_click': this._clearGuideElement
    }, this);
}

/**
 * Destroy method
 */
TimeResizeGuide.prototype.destroy = function() {
    this._clearGuideElement();
    this.timeResize.off(this);
    this.guideElement = this.timeResize = this._getTopFunc =
        this._originEventElement = this._startHeightPixel =
        this._startGridY = this._startTopPixel = null;
};

/**
 * Clear guide element.
 */
TimeResizeGuide.prototype._clearGuideElement = function() {
    var guideElement = this.guideElement,
        originElement = this._originEventElement;

    if (!util.browser.msie) {
        domutil.removeClass(global.document.body, 'schedule-view-resizing');
    }

    if (originElement) {
        originElement.style.display = 'block';
    }

    domutil.remove(guideElement);

    this.guideElement = this._getTopFunc = this._originEventElement =
        this._startHeightPixel = this._startGridY = this._startTopPixel = null;
};

/**
 * Refresh guide element
 * @param {string} height - guide element's style height.
 */
TimeResizeGuide.prototype._refreshGuideElement = function(height) {
    var guideElement = this.guideElement;

    if (!guideElement) {
        return;
    }

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.height = height + 'px';
        guideElement.style.display = 'block';
    });
};


/**
 * TimeMove#time_move_dragstart event handler
 * @param {object} dragStartEventData - dragstart event data
 */
TimeResizeGuide.prototype._onDragStart = function(dragStartEventData) {
    var originElement = domutil.closest(
            dragStartEventData.target,
            '.schedule-view-time-date-event-block'
        ),
        guideElement;

    if (!util.browser.msie) {
        domutil.addClass(global.document.body, 'schedule-view-resizing');
    }

    if (!originElement) {
        return;
    }

    this._startGridY = dragStartEventData.nearestGridY;
    this._startHeightPixel = parseFloat(originElement.style.height);
    this._startTopPixel = parseFloat(originElement.style.top);

    this._originEventElement = originElement;
    guideElement = this.guideElement = originElement.cloneNode(true);
    domutil.addClass(guideElement, 'schedule-view-time-resize-guide');

    originElement.style.display = 'none';
    dragStartEventData.relatedView.container.appendChild(guideElement);
};

/**
 * @param {object} dragEventData - event data from Drag#drag.
 */
TimeResizeGuide.prototype._onDrag = function(dragEventData) {
    var timeView = dragEventData.relatedView,
        viewOptions = timeView.options,
        viewHeight = timeView.getViewBound().height,
        hourLength = viewOptions.hourEnd - viewOptions.hourStart,
        guideElement = this.guideElement,
        guideTop = parseFloat(guideElement.style.top),
        gridYOffset = dragEventData.nearestGridY - this._startGridY,
        // hourLength : viewHeight = gridYOffset : X;
        gridYOffsetPixel = ratio(hourLength, viewHeight, gridYOffset),
        minHeight,
        maxHeight,
        height;

    height = (this._startHeightPixel + gridYOffsetPixel);
    // at least large than 30min from event start time.
    minHeight = guideTop + ratio(hourLength, viewHeight, 0.5);
    minHeight -= this._startTopPixel;
    // smaller than 24h
    maxHeight = viewHeight - guideTop;

    height = Math.max(height, minHeight);
    height = Math.min(height, maxHeight);

    this._refreshGuideElement(height);
};

module.exports = TimeResizeGuide;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/domutil":31,"../../common/reqAnimFrame":34}],74:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Model of event.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../common/datetime');
var dirty = require('../common/dirty');
var model = require('../common/model');

/**
 * The model of calendar events.
 * @constructor
 * @mixes dirty
 * @mixes model
 */
function Event() {
    /**
     * title for event.
     * @type {string}
     */
    this.title = '';

    /**
     * is event is all day event?
     * @type {boolean}
     */
    this.isAllDay = false;

    /**
     * event starts
     * @type {Date}
     */
    this.starts = null;

    /**
     * event ends
     * @type {Date}
     */
    this.ends = null;

    // initialize model id
    util.stamp(this);
}

/**********
 * static props
 **********/

Event.schema = {
    required: ['title'],
    dateRange: ['starts', 'ends']
};

/**
 * create event model from json(object) data.
 * @param {object} data object for model.
 * @returns {Event} Event model instance.
 */
Event.create = function(data) {
    var inst = new Event();
    inst.init(data);

    return inst;
};

/**********
 * prototype props
 **********/

/**
 * Initialize event instance.
 * @param {object} options options.
 */
Event.prototype.init = function(options) {
    options = options || {};

    this.title = options.title || '';
    this.isAllDay = util.isExisty(options.isAllDay) ? options.isAllDay : false;

    if (options.starts) {
        this.starts = new Date(options.starts);
    } else {
        this.starts = new Date();
    }

    if (options.ends) {
        this.ends = new Date(options.ends);
    } else {
        this.ends = new Date(this.starts.getTime());
        this.ends.setMinutes(this.ends.getMinutes() + 30);
    }
};

/**
 * @returns {Date} render start date.
 */
Event.prototype.getStarts = function() {
    return this.starts;
};

/**
 * @returns {Date} render end date.
 */
Event.prototype.getEnds = function() {
    return this.ends;
};

/**
 * @returns {number} instance unique id.
 */
Event.prototype.id = function() {
    return util.stamp(this);
};

/**
 * Check two event are equals (means title, isAllDay, starts, ends are same)
 * @param {Event} event Event model instance to compare.
 * @returns {boolean} Return false when not same.
 */
Event.prototype.equals = function(event) {
    if (this.title !== event.title) {
        return false;
    }

    if (this.isAllDay !== event.isAllDay) {
        return false;
    }

    if (datetime.compare(this.getStarts(), event.getStarts()) !== 0) {
        return false;
    }

    if (datetime.compare(this.getEnds(), event.getEnds()) !== 0) {
        return false;
    }

    return true;
};

/**
 * return duration between starts and ends.
 * @returns {Date} duration (UTC)
 */
Event.prototype.duration = function() {
    var starts = this.getStarts(),
        ends = this.getEnds(),
        duration;

    if (this.isAllDay) {
        duration = new Date(datetime.end(ends) - datetime.start(starts));
    } else {
        duration = new Date(ends - starts);
    }

    return duration;
};

/**
 * Returns true if the given Event coincides with the same time as the
 * calling Event.
 * @param {Event} event The other event to compare with this Event.
 * @returns {boolean} If the other event occurs within the same time as the first object.
 */
Event.prototype.collidesWith = function(event) {
    var ownStarts = this.getStarts(),
        ownEnds = this.getEnds(),
        starts = event.getStarts(),
        ends = event.getEnds();

    if ((starts > ownStarts && starts < ownEnds) ||
        (ends > ownStarts && ends < ownEnds) ||
        (starts <= ownStarts && ends >= ownEnds)) {
        return true;
    }
    return false;
};

model.mixin(Event.prototype);
dirty.mixin(Event.prototype);

module.exports = Event;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/datetime":28,"../common/dirty":29,"../common/model":32}],75:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Model for views
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;

/**
 * Event ViewModel
 * @constructor
 * @param {Event} event Event instance.
 */
function EventViewModel(event) {
    /**
     * The model of event.
     * @type {Event}
     */
    this.model = event;

    /**
     * @type {number}
     */
    this.top = 0;

    /**
     * @type {number}
     */
    this.left = 0;

    /**
     * @type {number}
     */
    this.width = 0;

    /**
     * @type {number}
     */
    this.height = 0;

    /**
     * Represent event has collide with other events when rendering.
     * @type {boolean}
     */
    this.hasCollide = false;

    /**
     * Extra space at rigth side of this event.
     * @type {number}
     */
    this.extraSpace = 0;

    /**
     * represent this event block is not visible after rendered.
     *
     * in month view, some viewmodel in date need to hide when already rendered before dates.
     *
     * set true then it just shows empty space.
     * @type {boolean}
     */
    this.hidden = false;

    /**
     * represent render start date used at rendering.
     *
     * if set null then use model's 'starts' property.
     * @type {Date}
     */
    this.renderStarts = null;

    /**
     * represent render end date used at rendering.
     *
     * if set null then use model's 'ends' property.
     * @type {Date}
     */
    this.renderEnds = null;
}

/**********
 * static props
 **********/

/**
 * EventViewModel factory method.
 * @param {Event} event Event instance.
 * @returns {EventViewModel} EventViewModel instance.
 */
EventViewModel.create = function(event) {
    return new EventViewModel(event);
};


/**********
 * prototype props
 **********/

/**
 * return renderStarts property to render properly when specific event that exceed rendering date range.
 *
 * if renderStarts is not set. return model's starts property.
 * @override
 * @returns {Date} render start date.
 */
EventViewModel.prototype.getStarts = function() {
    if (this.renderStarts) {
        return this.renderStarts;
    }

    return this.model.starts;
};

/**
 * return renderStarts property to render properly when specific event that exceed rendering date range.
 *
 * if renderEnds is not set. return model's ends property.
 * @override
 * @returns {Date} render end date.
 */
EventViewModel.prototype.getEnds = function() {
    if (this.renderEnds) {
        return this.renderEnds;
    }

    return this.model.ends;
};

/**
 * @returns {number} unique number for model.
 */
EventViewModel.prototype.id = function() {
    return util.stamp(this.model);
};

/**
 * Shadowing valueOf method for event sorting.
 * @returns {Event} The model of event.
 */
EventViewModel.prototype.valueOf = function() {
    return this.model;
};

/**
 * Link duration method
 * @returns {number} Event#duration result.
 */
EventViewModel.prototype.duration = function() {
    return this.model.duration();
};

/**
 * Link collidesWith method
 * @param {Event|EventViewModel} viewModel - Model or viewmodel instance of Events.
 * @returns {boolean} Event#collidesWith result.
 */
EventViewModel.prototype.collidesWith = function(viewModel) {
    return this.model.collidesWith(viewModel.valueOf());
};

module.exports = EventViewModel;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],76:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Layout view. wrap all view containers at outside.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../common/domutil');
var Collection = require('../common/collection');
var View = require('./view');

/**
 * Layout view for toggle each child view. It will controlled via navigation UI.
 * @constructor
 * @extends {View}
 * @param {HTMLElement} container Container element to use layout view.
 */
function Layout(container) {
    /*eslint-disable*/
    /**
     * @type {Collection} Child view collection.
     */
    this.childs = new Collection(function(childView) {
        return childView.viewName;
    });
    /*eslint-enable*/

    domutil.addClass(container, 'schedule-view-layout');

    /**
     * @type {HTMLElement}
     */
    this.container = container;
}

util.inherit(Layout, View);

/**
 * Clear child views.
 */
Layout.prototype.clear = function() {
    this.childs.each(function(childView) {
        childView.destroy();
    });

    this.childs.clear();
};

/**
 * Add an view object by creation function **(adderFunc)**.
 *
 * Invocations of adderFunc is called with layout view's container.
 *
 * As result of adderFunc. added it to layout view's childs.
 * @override
 * @param {function} adderFunc The adder function.
 * @returns {View} View instance added.
 */
Layout.prototype.addChild = function(adderFunc) {
    var childView = adderFunc(this.container);
    this.childs.add(childView);
    return childView;
};

/**
 * Remove child view.
 * @override
 * @param {(string|View)} viewName - name of view or instance.
 */
Layout.prototype.removeChild = function(viewName) {
    this.childs.remove(viewName);
};

/**
 * Toggle child views.
 * @param {string} viewName - Name of view.
 */
Layout.prototype.toggleChildView = function(viewName) {
    var container,
        prefix = ['add', 'remove'],
        flag;

    this.childs.each(function(childView) {
        container = childView.container;
        flag = +(childView.viewName === viewName);
        domutil[prefix[flag] + 'Class'](container, 'schedule-view-hidden');
    });
};

module.exports = Layout;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/collection":26,"../common/domutil":31,"./view":86}],77:[function(require,module,exports){
(function (global){
/**
 * @fileoverview View of week event container inside of Week view.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../common/domutil');
var datetime = require('../common/datetime');
var View = require('./view');
var tmpl = require('./template/monthweek.hbs');

/**
 * @constructor
 * @extends {View}
 * @param {object} options - view options.
 * @param {number} [options.containerHeight=40] - minimum height of event container element.
 * @param {number} [options.containerButtonGutter=8] - free space at bottom to make create easy.
 * @param {number} [options.eventHeight=18] - height of each event block.
 * @param {number} [options.eventGutter=2] - gutter height of each event block.
 * @param {function} [options._getViewModelFunc] - function for extract partial view model data from whole view models.
 * @param {HTMLDIVElement} container - DOM element to use container for this view.
 */
function MonthWeek(options, container) {
    container = domutil.appendHTMLElement(
        'div',
        container,
        'schedule-view-allday-monthweek'
    );

    /**
     * @type {object}
     */
    options = this.options = util.extend({
        containerHeight: 40,
        containerBottomGutter: 8,
        eventHeight: 18,
        eventGutter: 2
    }, options);

    options.minHeight = options.containerHeight + options.containerBottomGutter;

    View.call(this, null, container);
}

util.inherit(MonthWeek, View);

/**
 * @param {object} viewModel - viewModel from parent views.
 * @returns {object} viewModel to rendering.
 */
MonthWeek.prototype._getBaseViewModel = function(viewModel) {
    var options = this.options,
        range = datetime.range(
            viewModel.renderStartDate,
            viewModel.renderEndDate,
            datetime.MILLISECONDS_PER_DAY
        ),
        matrices = options._getViewModelFunc(viewModel),
        widthPercent = 100 / range.length;

    return {
        width: widthPercent,
        height: options.containerHeight,
        eventBlockHeight: options.eventHeight + options.eventGutter,
        eventBlockGutter: options.eventGutter,
        eventGrid: util.map(range, function() {
            return widthPercent;
        }),
        matrices: matrices
    };
};

/**
 * @override
 * @param {object} viewModel - viewModel from parent views.
 */
MonthWeek.prototype.render = function(viewModel) {
    var baseViewModel = this._getBaseViewModel(viewModel),
        maxEventInDay = 0;

    maxEventInDay = Math.max.apply(null, util.map(baseViewModel.matrices, function(matrix) {
        return Math.max.apply(null, util.map(matrix, function(row) {
            return row.length;
        }));
    }));

    this.resize(maxEventInDay);

    this.container.innerHTML = tmpl(baseViewModel);
};

/**
 * Resize MonthWeek container and send information to parent views.
 * @override
 * @param {number} maxEventInDay - how largest event block in one day?
 */
MonthWeek.prototype.resize = function(maxEventInDay) {
    var options = this.options,
        newHeight = (maxEventInDay * (options.eventHeight + options.eventGutter)) + options.containerBottomGutter;

    newHeight = Math.max(newHeight, options.minHeight);
    
    this.container.style.height = newHeight + 'px';
};

module.exports = MonthWeek;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/datetime":28,"../common/domutil":31,"./template/monthweek.hbs":80,"./view":86}],78:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<div class=\"schedule-view-display-table\">\n    <div class=\"schedule-view-display-table-row\">\n        <div class=\"schedule-view-display-table-cell\">\n            <div class=\"schedule-view-scroll-y schedule-view-dayname-layout\"></div>\n        </div>\n    </div>\n    <div class=\"schedule-view-display-table-row\">\n        <div class=\"schedule-view-display-table-cell\">\n            <div class=\"schedule-view-scroll-y schedule-view-allday-layout\"></div>\n        </div>\n    </div>\n    <div class=\"schedule-view-display-table-row\">\n        <div class=\"schedule-view-display-table-cell schedule-view-timegrid-layout\"></div>\n    </div>\n</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],79:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Helpers for handlebar templates.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;

function getElSize(value, postfix, prefix) {
    prefix = prefix || '';
    if (util.isNumber(value)) {
        return prefix + ':' + value + postfix;
    }

    return prefix + ':auto';
}

module.exports = {
    'stamp': function(obj) {
        return util.stamp(obj);
    },

    'equal': function(a, b) {
        return a === b;
    },

    'or': function(a, b) {
        return a || b;
    },

    'fi': function(a, oper, b, options) {
        switch (oper) {
            case '==':
                return (a == b) ? options.fn(this) : options.inverse(this);
            case '===':
                return  (a === b) ? options.fn(this) : options.inverse(this);
            default:
                break;
        }
    },

    'common-width': function(width) {
        return getElSize(width, '%', 'width');
    },

    /**
     * Use in time.hbs
     * @param {EventViewModel} eventViewModel viewModel
     * @returns {string} element size css class
     */
    'time-eventBlock': function(eventViewModel) {
        var top = getElSize(eventViewModel.top, 'px', 'top'),
            left = getElSize(eventViewModel.left, '%', 'left'),
            width = getElSize(eventViewModel.width, '%', 'width'),
            height = getElSize(eventViewModel.height, 'px', 'height');

        return [top, left, width, height].join(';');
    },

    /**
     * Use in dayname.hbs
     * @returns {string} css class
     */
    'dayname-isHolliday': function() {
        if (this.day === 0 || this.day === 6) {
            return 'schedule-view-dayname schedule-holliday';
        }

        return 'schedule-view-dayname';
    },

    'multiply': function(a, b) {
        return a * b;
    },

    /**
     * 셀렉트박스 헬퍼
     * @param {string} name - 셀렉트박스 name 속성값
     * @param {{value: string, label: string}} list - 옵션 리스트
     * @param {string} selectedValue - 기본선택처리 원하는 값
     * @returns {string} html tag
     */
    'selectbox': function(name, list, selectedValue) {
        var html = '<select name="' + name + '">';

        util.forEach(list, function(data) {
            html += '<option value="' + data.value + '"' + (selectedValue === data.value ? ' selected' : '') + '>' + data.label + '</option>';
        });

        return html + '</select>';
    },

    'radioCalendarColor': function(name, list, checkedValue) {
        return util.map(list, function(data) {
            return '<label>' + 
                '<input type="radio" name="' + name + '" value="' + data.value + '"' + 
                (data.value === checkedValue ? ' checked' : '') + ' />' + 
                '<span style="background-color:#' + data.value + '">&nbsp;</span>' +
                '</label>';
        }).join('');
    }
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],80:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var alias1=container.escapeExpression;

  return "<div class=\"schedule-view-monthweek-grid-line\" style=\"width:"
    + alias1(container.lambda(depth0, depth0))
    + "%;left:"
    + alias1((helpers.multiply || (depth0 && depth0.multiply) || helpers.helperMissing).call(depth0 != null ? depth0 : {},depth0,(data && data.index),{"name":"multiply","hash":{},"data":data}))
    + "%;\">&nbsp;</div>\n";
},"3":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},depth0,{"name":"each","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"4":function(container,depth0,helpers,partials,data) {
    var stack1;

  return " \n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},depth0,{"name":"each","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"5":function(container,depth0,helpers,partials,data) {
    var stack1;

  return " \n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},depth0,{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"6":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3=container.escapeExpression, alias4=container.lambda;

  return " \n<div data-id=\""
    + alias3((helpers.stamp || (depth0 && depth0.stamp) || alias2).call(alias1,(depth0 != null ? depth0.model : depth0),{"name":"stamp","hash":{},"data":data}))
    + "\" \n    class=\"schedule-view-allday-event-block "
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.renderStarts : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.renderEnds : depth0),{"name":"if","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\"\n    style=\"top:"
    + alias3((helpers.multiply || (depth0 && depth0.multiply) || alias2).call(alias1,(depth0 != null ? depth0.top : depth0),((stack1 = (data && data.root)) && stack1.eventBlockHeight),{"name":"multiply","hash":{},"data":data}))
    + "px;left:"
    + alias3((helpers.multiply || (depth0 && depth0.multiply) || alias2).call(alias1,(depth0 != null ? depth0.left : depth0),((stack1 = (data && data.root)) && stack1.width),{"name":"multiply","hash":{},"data":data}))
    + "%;width:"
    + alias3((helpers.multiply || (depth0 && depth0.multiply) || alias2).call(alias1,(depth0 != null ? depth0.width : depth0),((stack1 = (data && data.root)) && stack1.width),{"name":"multiply","hash":{},"data":data}))
    + "%;height:"
    + alias3(alias4(((stack1 = (data && data.root)) && stack1.eventBlockHeight), depth0))
    + "px;margin-top:"
    + alias3(alias4(((stack1 = (data && data.root)) && stack1.eventBlockGutter), depth0))
    + "px\">\n    <div class=\"schedule-view-allday-event\" style=\"height:"
    + alias3(alias4(((stack1 = (data && data.root)) && stack1.eventHeight), depth0))
    + "px\">\n        <span class=\"schedule-view-allday-event-title\">"
    + alias3(alias4(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.title : stack1), depth0))
    + "</span>\n        <span class=\"schedule-view-allday-resize-handle handle-y\">&nbsp;</span>\n    </div> \n</div>\n";
},"7":function(container,depth0,helpers,partials,data) {
    return " schedule-view-allday-exceed-left";
},"9":function(container,depth0,helpers,partials,data) {
    return " schedule-view-allday-exceed-right";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {};

  return "<div class=\"schedule-view-monthweek-grid\">\n"
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.eventGrid : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</div>\n<div class=\"schedule-view-monthweek-events\">\n"
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.matrices : depth0),{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],81:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Register developed custom handlebars helper.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var helper = require('./helper');
var Handlebars = require('hbsfy/runtime');

util.forEach(helper, function(helper, name) {
    Handlebars.registerHelper(name, helper);
}, this);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./helper":79,"hbsfy/runtime":22}],82:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var helper;

  return "<div class=\"schedule-view-allday-left\">\n    <span>"
    + container.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"title","hash":{},"data":data}) : helper)))
    + "</span>\n</div>\n<div class=\"schedule-view-allday-right\">\n    <div class=\"schedule-view-allday-monthweek-container\"></div>\n</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],83:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<div class=\""
    + alias4(((helper = (helper = helpers["dayname-isHolliday"] || (depth0 != null ? depth0["dayname-isHolliday"] : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"dayname-isHolliday","hash":{},"data":data}) : helper)))
    + "\" style=\""
    + alias4((helpers["common-width"] || (depth0 && depth0["common-width"]) || alias2).call(alias1,(depth0 != null ? depth0.width : depth0),{"name":"common-width","hash":{},"data":data}))
    + "\">\n    <div class=\"schedule-view-dayname-label\">"
    + alias4(((helper = (helper = helpers.dayName || (depth0 != null ? depth0.dayName : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"dayName","hash":{},"data":data}) : helper)))
    + "</div>\n    <div class=\"schedule-view-dayname-date\">"
    + alias4(((helper = (helper = helpers.date || (depth0 != null ? depth0.date : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"date","hash":{},"data":data}) : helper)))
    + "</div>\n</div>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},depth0,{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"useData":true});

},{"hbsfy/runtime":22}],84:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},depth0,{"name":"each","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"2":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},depth0,{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"3":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},depth0,{"name":"if","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n";
},"4":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3=container.escapeExpression;

  return "            <div class=\"schedule-view-time-date-event-block\" data-id=\""
    + alias3((helpers.stamp || (depth0 && depth0.stamp) || alias2).call(alias1,(depth0 != null ? depth0.model : depth0),{"name":"stamp","hash":{},"data":data}))
    + "\" style=\""
    + alias3((helpers["time-eventBlock"] || (depth0 && depth0["time-eventBlock"]) || alias2).call(alias1,depth0,{"name":"time-eventBlock","hash":{},"data":data}))
    + "\">\n                <div class=\"schedule-view-time-event\">"
    + alias3(container.lambda(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.title : stack1), depth0))
    + "</div>\n                <div class=\"schedule-view-time-resize-handle handle-x\">&nbsp;</div>\n            </div>";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.matrices : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"useData":true});

},{"hbsfy/runtime":22}],85:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<li class=\"schedule-view-timegrid-hour-"
    + alias4(((helper = (helper = helpers.hour || (depth0 != null ? depth0.hour : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"hour","hash":{},"data":data}) : helper)))
    + "\"><span>"
    + alias4(((helper = (helper = helpers.hour || (depth0 != null ? depth0.hour : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"hour","hash":{},"data":data}) : helper)))
    + "</span></li>";
},"3":function(container,depth0,helpers,partials,data) {
    return "<div class=\"schedule-view-timegrid-grid\"></div>";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {};

  return "<div class=\"schedule-view-timegrid\">\n    <ul class=\"schedule-view-timegrid-left\">\n        "
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.hours : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n    </ul>\n    <div class=\"schedule-view-timegrid-right\">\n        "
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.hours : depth0),{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n    </div>\n    <div class=\"schedule-view-timegrid-events\">\n        <div class=\"schedule-view-timegrid-events-container\"></div>\n    </div>\n    <div class=\"schedule-view-timegrid-hourmarker\" style=\"display:none;\">\n        <div class=\"schedule-view-timegrid-hourmarker-wrap\">\n            <div class=\"schedule-view-timegrid-hourmarker-line\"></div>\n            <div class=\"schedule-view-timegrid-hourmarker-time\">00:00</div>\n            <div class=\"schedule-view-timegrid-todaymarker\">today</div>\n        </div>\n    </div>\n</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],86:[function(require,module,exports){
(function (global){
/**
 * @fileoverview The base class of views.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../common/domutil');
var Collection = require('../common/collection');

/**
 * Base class of views.
 *
 * All views create own container element inside supplied container element.
 * @constructor
 * @param {options} options The object for describe view's specs.
 * @param {HTMLElement} container Default container element for view. you can use this element for this.container syntax.
 */
function View(options, container) {
    var id = util.stamp(this);

    options = options || {};

    if (util.isUndefined(container)) {
        container = domutil.appendHTMLElement('div');
    }

    domutil.addClass(container, 'schedule-view-' + id);

    /**
     * unique id
     * @type {number}
     */
    this.id = id;

    /**
     * base element of view.
     * @type {HTMLDIVElement}
     */
    this.container = container;

    /*eslint-disable*/
    /**
     * child views.
     * @type {Collection}
     */
    this.childs = new Collection(function(view) {
        return util.stamp(view);
    });
    /*eslint-enable*/

    /**
     * parent view instance.
     * @type {View}
     */
    this.parent = null;
}

/**
 * Add child views.
 * @param {View} view The view instance to add.
 * @param {function} [fn] Function for invoke before add. parent view class is supplied first arguments.
 */
View.prototype.addChild = function(view, fn) {
    if (fn) {
        fn.call(view, this);
    }
    // add parent view
    view.parent = this;

    this.childs.add(view);
};

/**
 * Remove added child view.
 * @param {(number|View)} id View id or instance itself to remove.
 * @param {function} [fn] Function for invoke before remove. parent view class is supplied first arguments.
 */
View.prototype.removeChild = function(id, fn) {
    var view = util.isNumber(id) ? this.childs.items[id] : id;

    id = util.stamp(view);

    if (fn) {
        fn.call(view, this);
    }

    this.childs.remove(id);
};

/**
 * Render view recursively.
 */
View.prototype.render = function() {
    this.childs.each(function(childView) {
        childView.render();
    });
};

/**
 * Invoke function recursively.
 * @param {function} fn - function to invoke child view recursively
 * @param {boolean} [skipThis=false] - set true then skip invoke with this(root) view.
 */
View.prototype.recursive = function(fn, skipThis) {
    if (!util.isFunction(fn)) {
        return;
    }

    if (!skipThis) {
        fn(this);
    }

    this.childs.each(function(childView) {
        childView.recursive(fn);
    });
};

/**
 * Resize view recursively to parent.
 */
View.prototype.resize = function() {
    var args = Array.prototype.slice.call(arguments),
        parent = this.parent;

    while (parent) {
        if (util.isFunction(parent._onResize)) {
            parent._onResize.apply(parent, args);
        }

        parent = parent.parent;
    }
};

/**
 * Invoking method before destroying.
 */
View.prototype._beforeDestroy = function() {};

/**
 * Clear properties
 */
View.prototype._destroy = function() {
    this._beforeDestroy();
    this.childs.clear();
    this.container.innerHTML = '';

    this.id = this.parent = this.childs = this.container = null;
};

/*eslint-disable*/
/**
 * Destroy child view recursively.
 */
View.prototype.destroy = function(isChildView) {
    this.childs.each(function(childView) {
        childView.destroy(true);
        childView._destroy();
    });

    if (isChildView) {
        return;
    }

    this._destroy();
};
/*eslint-enable*/

/**
 * Calculate view's container element bound.
 * @returns {object} The bound of container element.
 */
View.prototype.getViewBound = function() {
    var container = this.container,
        position = domutil.getPosition(container),
        size = domutil.getSize(container);

    return {
        x: position[0],
        y: position[1],
        width: size[0],
        height: size[1]
    };
};

module.exports = View;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/collection":26,"../common/domutil":31}],87:[function(require,module,exports){
(function (global){
/**
 * @fileoverview View of allday event container inside of Week view.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../../common/domutil');
var View = require('../view');
var MonthWeek = require('../monthweek');
var mainTmpl = require('../template/week/allday.hbs');

/**
 * @constructor
 * @extends {View}
 * @param {object} options The object for view customization.
 * @param {string} options.renderStartDate - start date of allday view's render date. YYYY-MM-DD
 * @param {string} options.renderEndDate - end date of allday view's render date. YYYY-MM-DD
 * @param {number} [options.height=60] - minimum height of event container element.
 * @param {number} [options.eventBlockHeight=18] - height of each event block.
 * @param {number} [options.eventBlockGutter=2] - gutter height of each event block.
 * @param {function} [options._getViewModelFunc] - function for extract partial view model data from whole view models.
 * @param {HTMLElement} container Container element.
 */
function Allday(options, container) {
    container = domutil.appendHTMLElement(
        'div',
        container,
        'schedule-view-allday-container'
    );

    /**
     * rendering options.
     * @type {object}
     */
    this.options = util.extend({
        title: '종일일정',
        renderStartDate: '',
        renderEndDate: '',
        containerHeight: 40,
        containerBottomGutter: 8,
        eventHeight: 18,
        eventGutter: 2,
        _getViewModelFunc: function(viewModel) {
            return viewModel.eventsInDateRange.allday;
        }
    }, options);

    View.call(this, null, container);
}

util.inherit(Allday, View);

/**
 * create month week view model for render allday events in top of week views.
 * @override
 * @param {object} viewModel - viewModel from parent views.
 */
Allday.prototype.render = function(viewModel) {
    var container = this.container,
        monthWeekInst;

    container.innerHTML = mainTmpl(this.options);

    this.childs.clear();

    monthWeekInst = new MonthWeek(
        this.options, 
        domutil.find('.schedule-view-allday-monthweek-container', container)
    );

    this.addChild(monthWeekInst);

    this.childs.each(function(childView) {
        childView.render(viewModel);
    });
};

module.exports = Allday;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/domutil":31,"../monthweek":77,"../template/week/allday.hbs":82,"../view":86}],88:[function(require,module,exports){
(function (global){
/**
 * @fileoverview View for rendering daynames
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var View = require('../view');
var daynameTmpl = require('../template/week/daynames.hbs');

/**
 * @constructor
 * @paran {object} options - options for dayname view
 * @param {HTMLElement} container Container element to use.
 * @extends {View}
 */
function DayName(options, container) {
    container = domutil.appendHTMLElement(
        'div',
        container,
        'schedule-view-dayname-container'
    );

    this.options = util.extend({
        daynames: ['일', '월', '화', '수', '목', '금', '토']
    }, options);

    View.call(this, null, container);
}

util.inherit(DayName, View);

/**
 * Get default viewmodels.
 * @param {Date} start The date of start render
 * @param {Date} end The end of end render
 * @returns {array} viewmodel.
 */
DayName.prototype._getBaseViewModel = function(start, end) {
    var daynames = this.options.daynames,
        viewModel;

    viewModel = util.map(datetime.range(
        datetime.start(start),
        datetime.start(end),
        datetime.MILLISECONDS_PER_DAY
    ), function(d, i, arr) {
        var day = d.getDay();

        return {
            day: day,
            dayName: daynames[day],
            date: d.getDate(),
            width: 100 / arr.length
        };
    });

    return viewModel;
};

/**
 * @override
 * @param {object} viewModel View model from parent (WeekView)
 */
DayName.prototype.render = function(viewModel) {
    var _viewModel = this._getBaseViewModel(
        viewModel.renderStartDate,
        viewModel.renderEndDate
    );

    this.container.innerHTML = daynameTmpl(_viewModel);
};

module.exports = DayName;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../template/week/daynames.hbs":83,"../view":86}],89:[function(require,module,exports){
(function (global){
/**
 * @fileoverview View of time.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var View = require('../view');
var timeTmpl = require('../template/week/time.hbs');
var forEachArr = util.forEachArray;

/**
 * @constructor
 * @extends {View}
 * @param {number} width Date element width (percent)
 * @param {object} options Options
 * @param {string} options.ymd YYYMMDD string for this view
 * @param {boolean} options.isToday when set true then assign today design class to container.
 * @param {number} options.hourStart Can limit of render hour start.
 * @param {number} options.hourEnd Can limit of render hour end.
 * @param {HTMLElement} container Element to use container for this view.
 */
function Time(width, options, container) {
    View.call(this, null, container);

    container.style.width = width + '%';

    this.options = util.extend({
        ymd: '',
        isToday: false,
        hourStart: 0,
        hourEnd: 24
    }, options);

    if (this.options.isToday) {
        domutil.addClass(this.container, 'schedule-view-time-date-today');
    }
}

util.inherit(Time, View);

/**
 * Convert YYYYMMDD formatted string date to Date.
 * @param {string} str formatted string.
 * @returns {Date} start of date.
 */
Time.prototype._parseDateGroup = function(str) {
    var y = parseInt(str.substr(0, 4), 10),
        m = parseInt(str.substr(4, 2), 10),
        d = parseInt(str.substr(6, 2), 10);

    return new Date(y, m - 1, d);
};

/**
 * @param {EventViewModel} viewModel - view model instance to calculate bound.
 * @param {object} options - options for calculating event element's bound.
 * @param {Date} options.todayStart - date object represent event date's start (00:00:00)
 * @param {number} options.baseMS - the number of milliseconds to render event blocks.
 * @param {number} options.baseHeight - pixel value related with baseMS options.
 * @param {number[]} options.baseLeft - left position percents for each columns.
 * @param {number} options.baseWidth - the unit of event blocks width percent.
 * @param {number} options.columnIndex - the number index of event blocks.
 * it represent rendering index from left sides in view.
 * @returns {object} bound object for supplied view model.
 */
Time.prototype.getEventViewBound = function(viewModel, options) {
    var baseMS = options.baseMS,
        baseHeight = options.baseHeight,
        offsetStart,
        width,
        height,
        top;

    offsetStart = viewModel.valueOf().starts - options.todayStart;

    // containerHeight : milliseconds in day = x : event's milliseconds
    top = (baseHeight * offsetStart) / baseMS;
    height = (baseHeight * viewModel.duration()) / baseMS;
    width = options.baseWidth * (viewModel.extraSpace + 1);

    // set width auto when has no collisions.
    if (!viewModel.hasCollide) {
        width = null;
    }

    return {
        top: top,
        left: options.baseLeft[options.columnIndex],
        width: width,
        height: height
    };
};

/**
 * Set viewmodels for rendering.
 * @param {string} ymd The date of events. YYYYMMDD format.
 * @param {array} matrices The matrices for event placing.
 */
Time.prototype._getBaseViewModel = function(ymd, matrices) {
    var options = this.options,
        hourStart = options.hourStart,
        hourEnd = options.hourEnd,
        containerHeight,
        todayStart,
        baseMS;

    /**
     * Calculate each event element bounds relative with rendered hour milliseconds and
     * wrap each event model to viewmodels.
     */
    containerHeight = this.getViewBound().height;
    todayStart = this._parseDateGroup(ymd);
    todayStart.setHours(hourStart);
    baseMS = datetime.millisecondsFrom('hour', (hourEnd - hourStart));

    forEachArr(matrices, function(matrix) {
        var maxRowLength,
            widthPercent,
            leftPercents,
            i;

        maxRowLength = Math.max.apply(null, util.map(matrix, function(row) {
            return row.length;
        }));

        widthPercent = 100 / maxRowLength;

        leftPercents = [];
        for (i = 0; i < maxRowLength; i += 1) {
            leftPercents[i] = widthPercent * i;
        }

        forEachArr(matrix, function(row) {
            forEachArr(row, function(viewModel, col) {
                var viewBound;

                if (!viewModel) {
                    return;
                }

                viewBound = this.getEventViewBound(viewModel, {
                    todayStart: todayStart,
                    baseMS: baseMS,
                    baseLeft: leftPercents,
                    baseWidth: widthPercent,
                    baseHeight: containerHeight,
                    columnIndex: col
                });

                util.extend(viewModel, viewBound);
            }, this);
        }, this);
    }, this);
};

/**
 * @returns {Date} - Date of this view.
 */
Time.prototype.getDate = function() {
    return this._parseDateGroup(this.options.ymd);
};


/**
 * @override
 * @param {string} ymd The date of events. YYYYMMDD format
 * @param {array} matrices Matrices for placing events
 */
Time.prototype.render = function(ymd, matrices) {
    this._getBaseViewModel(ymd, matrices);
    this.container.innerHTML = timeTmpl({
        matrices: matrices
    });
};

module.exports = Time;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../template/week/time.hbs":84,"../view":86}],90:[function(require,module,exports){
(function (global){
/**
 * @fileoverview View for rendered events by times.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../../common/domutil');
var datetime = require('../../common/datetime');
var reqAnimFrame = require('../../common/reqAnimFrame');
var View = require('../view');
var Time = require('./time');
var AutoScroll = require('../../common/autoScroll');
var mainTmpl = require('../template/week/timeGrid.hbs');

var PIXEL_RENDER_ERROR = 0.5;
var HOURMARKER_REFRESH_INTERVAL = 1000 * 10;
var INITIAL_AUTOSCROLL_DELAY = util.browser.msie ? 100 : 50;

/**
 * @constructor
 * @extends {View}
 * @param {object} options The object for view customization.
 * @param {number} [options.hourStart=0] You can change view's start hours.
 * @param {number} [options.hourEnd=0] You can change view's end hours.
 * @param {HTMLElement} container Container element.
 */
function TimeGrid(options, container) {
    container = domutil.appendHTMLElement(
        'div',
        container,
        'schedule-view-timegrid-container'
    );

    View.call(this, null, container);

    if (!util.browser.safari) {
        /**
         * @type {AutoScroll}
         */
        this._autoScroll = new AutoScroll(container);
    }

    /**
     * Time view options.
     * @type {object}
     */
    this.options = util.extend({
        hourStart: 0,
        hourEnd: 24
    }, options);

    /**
     * Interval id for hourmarker animation.
     * @type {number}
     */
    this.intervalID = 0;

    /**
     * @type {boolean}
     */
    this._scrolled = false;

    this.attachEvent();
}

util.inherit(TimeGrid, View);

/**********
 * Prototype props
 **********/

/**
 * @type {string}
 */
TimeGrid.prototype.viewName = 'timegrid';

/**
 * Destroy view.
 * @override
 */
TimeGrid.prototype._beforeDestroy = function() {
    window.clearInterval(this.intervalID);

    if (this._autoScroll) {
        this._autoScroll.destroy();
    }

    this._autoScroll = this.hourmarker = null;
};

/**
 * Get base viewModel.
 * @returns {object} ViewModel
 */
TimeGrid.prototype._getBaseViewModel = function() {
    var options = this.options,
        end = options.hourEnd,
        i = options.hourStart,
        hours = [];

    for (; i < end; i += 1) {
        hours.push({hour: i});
    }

    return {hours: hours};
};

/**
 * Reconcilation child views and render.
 * @param {object} viewModels Viewmodel
 * @param {number} width The width percent of each time view.
 * @param {HTMLElement} container Container element for each time view.
 */
TimeGrid.prototype._renderChilds = function(viewModels, width, container) {
    var options = this.options,
        childOption,
        child,
        isToday,
        today = datetime.format(new Date(), 'YYYYMMDD');

    // clear contents
    container.innerHTML = '';
    this.childs.clear();
    this.todaymarkerLeft = null;

    // reconcilation of child views
    util.forEach(viewModels, function(events, ymd) {
        isToday = ymd === today;

        if (isToday) {
            this.todaymarkerLeft = width * this.childs.length;
        }

        childOption = {
            ymd: ymd,
            isToday: isToday,
            hourStart: options.hourStart,
            hourEnd: options.hourEnd
        };

        child = new Time(
            width,
            childOption,
            domutil.appendHTMLElement('div', container, 'schedule-view-time-date')
        );
        child.render(ymd, events);

        this.addChild(child);
    }, this);
};

/**
 * @override
 * @param {object} viewModel ViewModel list from Week view.
 */
TimeGrid.prototype.render = function(viewModel) {
    var timeViewModel = viewModel.eventsInDateRange.time,
        container = this.container,
        baseViewModel = this._getBaseViewModel(),
        eventLen = util.keys(timeViewModel).length;

    if (!eventLen) {
        return;
    }

    container.innerHTML = mainTmpl(baseViewModel);

    /**********
     * Render childs
     **********/
    this._renderChilds(
        timeViewModel,
        100 / eventLen,
        domutil.find('.schedule-view-timegrid-events-container', container)
    );

    this._hourLabels = domutil.find('ul', container);

    /**********
     * Render hourmarker
     **********/
    this.hourmarker = domutil.find('.schedule-view-timegrid-hourmarker', container);
    this.refreshHourmarker();

    if (!this._scrolled) {
        this._scrolled = true;
        this.scrollToNow();
    }
};

/**
 * Refresh hourmarker element.
 */
TimeGrid.prototype.refreshHourmarker = function() {
    var hourLabels = this._hourLabels,
        hourmarker = this.hourmarker,

        viewModel = this._getHourmarkerViewModel(),
        todaymarkerLeft = this.todaymarkerLeft,
        todaymarker,
        text,
        labelToVisible,
        labelToInvisible;

    if (!hourmarker || !viewModel) {
        return;
    }

    todaymarker = domutil.find('.schedule-view-timegrid-todaymarker', hourmarker);
    text = domutil.find('.schedule-view-timegrid-hourmarker-time', hourmarker);
    labelToVisible = domutil.find('.schedule-invisible', hourLabels);
    labelToInvisible = domutil.find('.schedule-view-timegrid-hour-' + viewModel.hour, hourLabels);

    reqAnimFrame.requestAnimFrame(function() {
        if (labelToVisible !== labelToInvisible) {
            if (labelToVisible) {
                domutil.removeClass(labelToVisible, 'schedule-invisible');
            }

            if (labelToInvisible) {
                domutil.addClass(labelToInvisible, 'schedule-invisible');
            }
        }

        hourmarker.style.display = 'block';
        hourmarker.style.top = (viewModel.top - PIXEL_RENDER_ERROR) + 'px';

        if (!util.isNull(todaymarkerLeft)) {
            todaymarker.style.display = 'block';
            todaymarker.style.left = todaymarkerLeft + '%';
        } else {
            todaymarker.style.display = 'none';
        }

        text.innerHTML = viewModel.text;
    });
};

/**
 * Return grid size.
 * @returns {number[]} The size of grid element.
 */
TimeGrid.prototype._getGridSize = function() {
    var childNode = this.container.childNodes[0];

    if (!childNode) {
        return false;
    }

    return domutil.getSize(childNode);
};

/**
 * @param {Date} [time] - date object to convert pixel in grids.
 * use **Date.now()** when not supplied.
 * @returns {number} The pixel value represent current time in grids.
 */
TimeGrid.prototype._getTopByTime = function(time) {
    var now = util.isDate(time) ? new Date(time.getTime()) : new Date(),
        start = datetime.start(now),
        hourStart = this.options.hourStart,
        gridSize = this._getGridSize(),
        offset,
        top;

    if (!gridSize) {
        return 0;
    }

    offset = +now - +start;
    if (hourStart) {
        offset -= datetime.millisecondsFrom('hour', hourStart);
    }

    top = (offset * gridSize[1]) / (datetime.millisecondsFrom('hour', this._getBaseViewModel().hours.length));

    return top;
};

/**
 * Get Hourmarker viewmodel.
 * @returns {object} ViewModel of hourmarker.
 */
TimeGrid.prototype._getHourmarkerViewModel = function() {
    var now = new Date();

    return {
        top: this._getTopByTime(),
        hour: now.getHours(),
        text: datetime.format(now, 'HH:mm')
    };
};

/**
 * Attach events
 */
TimeGrid.prototype.attachEvent = function() {
    window.clearInterval(this.intervalID);
    this.intervalID = window.setInterval(util.bind(this.onTick, this), HOURMARKER_REFRESH_INTERVAL);
};

/**
 * Scroll time grid to current hourmarker.
 */
TimeGrid.prototype.scrollToNow = function() {
    var currentHourTop = this._getTopByTime(),
        viewBound = this.getViewBound(),
        container = this.container;

    window.setTimeout(function() {
        container.scrollTop = (0, currentHourTop - (viewBound.height / 2));
    }, INITIAL_AUTOSCROLL_DELAY);
};

/**********
 * Event handlers
 **********/

/**
 * Interval tick handler
 */
TimeGrid.prototype.onTick = function() {
    this.refreshHourmarker();
};

module.exports = TimeGrid;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/autoScroll":25,"../../common/datetime":28,"../../common/domutil":31,"../../common/reqAnimFrame":34,"../template/week/timeGrid.hbs":85,"../view":86,"./time":89}],91:[function(require,module,exports){
(function (global){
/**
 * @fileoverview View of days UI.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../../common/domutil');
var datetime = require('../../common/datetime');
var View = require('../view');

/**
 * @constructor
 * @param {Base.Week} controller The controller mixin part.
 * @param {object} options View options
 * @param {string} [options.renderStartDate] Start date of render. if not supplied then use -3d from today. YYYY-MM-DD format.
 * @param {string} [options.renderEndDate] End date of render. if not supplied then use +3d from today. YYYY-MM-DD format.
 * @param {HTMLElement} container The element to use container for this view.
 * @extends {View}
 */
function Week(controller, options, container) {
    var range;

    container = domutil.appendHTMLElement(
        'div',
        container,
        'schedule-view-week-container'
    );

    View.call(this, null, container);

    range = this._getRenderDateRange(new Date());

    /**
     * @type {object} Options for view.
     */
    this.options = util.extend({
        renderStartDate: datetime.format(range.start, 'YYYY-MM-DD'),
        renderEndDate: datetime.format(range.end, 'YYYY-MM-DD')
    }, options);

    /**
     * Week controller mixin.
     * @type {Base.Week}
     */
    this.controller = controller;
}

util.inherit(Week, View);

/**********
 * Override props
 **********/

/**
 * Render each child view with events in ranges.
 */
Week.prototype.render = function() {
    var options = this.options,
        renderStartDate = datetime.parse(options.renderStartDate),
        renderEndDate = datetime.parse(options.renderEndDate),
        eventsInDateRange = this.controller.findByDateRange(
            datetime.start(renderStartDate),
            datetime.end(renderEndDate)
        ),
        viewModel = {
            eventsInDateRange: eventsInDateRange,
            renderStartDate: renderStartDate,
            renderEndDate: renderEndDate
        };

    this.childs.each(function(childView) {
        childView.render(viewModel);
    });
};

/**
 * Listen child view's resize event and handle it.
 * @param {string} source - the string to use group requests.
 * @param {number} param - additional information for resizing session.
 */
// Week.prototype._onResize = function(source, param) {
//     var ownChilds = this.childs,
//         timegrid,
//         height;
//
//     if (source === 'monthweek:resize') {
//         timegrid = ownChilds.find(function(view) {
//             return view.viewName === 'timegrid';
//         }).single();
//
//         height = this.timeGridOriginHeight;
//
//         if (!this.timeGridOriginHeight) {
//             height = this.timeGridOriginHeight = domutil.getSize(timegrid.container)[1];
//         }
//
//         timegrid.container.style.height = (height - param) + 'px';
//         return;
//     }
// };

/**********
 * Prototype props
 **********/

Week.prototype.viewName = 'week';

/**
 * Calculate default render date range from supplied date.
 * @param {Date} baseDate base date.
 * @returns {object} date range.
 */
Week.prototype._getRenderDateRange = function(baseDate) {
    var base = datetime.start(baseDate),
        start = new Date(+base),
        end = new Date(+base);

    start.setDate(start.getDate() - 3);
    end.setDate(end.getDate() + 3);

    return {
        start: start,
        end: end
    };
};

module.exports = Week;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../view":86}]},{},[1])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb2RlLXNuaXBwZXQvY29kZS1zbmlwcGV0LmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvbGliL2hhbmRsZWJhcnMucnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvZGVjb3JhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvZGVjb3JhdG9ycy9saWIvaGFuZGxlYmFycy9kZWNvcmF0b3JzL2lubGluZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvZXhjZXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9oZWxwZXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvYmxvY2staGVscGVyLW1pc3NpbmcuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2hlbHBlcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy9lYWNoLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9oZWxwZXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvaGVscGVyLW1pc3NpbmcuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2hlbHBlcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy9pZi5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvaGVscGVycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2xvZy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvaGVscGVycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2xvb2t1cC5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvaGVscGVycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL3dpdGguanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2xvZ2dlci5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvbm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9uby1jb25mbGljdC5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvc2FmZS1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9oYnNmeS9ydW50aW1lLmpzIiwic3JjL2pzL2NvbW1vbi9hamF4LmpzIiwic3JjL2pzL2NvbW1vbi9hcnJheS5qcyIsInNyYy9qcy9jb21tb24vYXV0b1Njcm9sbC5qcyIsInNyYy9qcy9jb21tb24vY29sbGVjdGlvbi5qcyIsInNyYy9qcy9jb21tb24vY29tbW9uLmpzIiwic3JjL2pzL2NvbW1vbi9kYXRldGltZS5qcyIsInNyYy9qcy9jb21tb24vZGlydHkuanMiLCJzcmMvanMvY29tbW9uL2RvbWV2ZW50LmpzIiwic3JjL2pzL2NvbW1vbi9kb211dGlsLmpzIiwic3JjL2pzL2NvbW1vbi9tb2RlbC5qcyIsInNyYy9qcy9jb21tb24vcG9pbnQuanMiLCJzcmMvanMvY29tbW9uL3JlcUFuaW1GcmFtZS5qcyIsInNyYy9qcy9jb250cm9sbGVyL2Jhc2UuanMiLCJzcmMvanMvY29udHJvbGxlci92aWV3TWl4aW4vd2Vlay5qcyIsInNyYy9qcy9kb29yYXkvY2FsZW5kYXJBUEkuanMiLCJzcmMvanMvZG9vcmF5L2NvbnRyb2xsZXIvYXBpLmpzIiwic3JjL2pzL2Rvb3JheS9jb250cm9sbGVyL2Jhc2UuanMiLCJzcmMvanMvZG9vcmF5L2VudW1zLmpzIiwic3JjL2pzL2Rvb3JheS9mYWN0b3J5L2NhbGVuZGFyLmpzIiwic3JjL2pzL2Rvb3JheS9mYWN0b3J5L3dlZWtWaWV3LmpzIiwic3JjL2pzL2Rvb3JheS9tb2RlbC9jYWxlbmRhci5qcyIsInNyYy9qcy9kb29yYXkvbW9kZWwvZXZlbnQuanMiLCJzcmMvanMvZG9vcmF5L3ZpZXcvY2FsZW5kYXJzLmhicyIsInNyYy9qcy9kb29yYXkvdmlldy9jYWxlbmRhcnMuanMiLCJzcmMvanMvZG9vcmF5L3ZpZXcvZm9ybS9jYWxlbmRhci5oYnMiLCJzcmMvanMvZG9vcmF5L3ZpZXcvZm9ybS9jYWxlbmRhci5qcyIsInNyYy9qcy9kb29yYXkvdmlldy9taWxlc3RvbmUuaGJzIiwic3JjL2pzL2Rvb3JheS92aWV3L21pbGVzdG9uZS5qcyIsInNyYy9qcy9kb29yYXkvdmlldy9taW5pY2FsZW5kYXIuaGJzIiwic3JjL2pzL2Rvb3JheS92aWV3L21pbmljYWxlbmRhci5qcyIsInNyYy9qcy9kb29yYXkvdmlldy90YXNrdmlldy5oYnMiLCJzcmMvanMvZG9vcmF5L3ZpZXcvdGFza3ZpZXcuanMiLCJzcmMvanMvZG9vcmF5L3ZpZXcvdGVtcGxhdGUvZmFjdG9yeS93ZWVrVmlldy5oYnMiLCJzcmMvanMvZmFjdG9yeS9jYWxlbmRhci5qcyIsInNyYy9qcy9mYWN0b3J5L2NvbnRyb2xsZXIuanMiLCJzcmMvanMvZmFjdG9yeS93ZWVrVmlldy5qcyIsInNyYy9qcy9oYW5kbGVyL2FsbGRheS9jb3JlLmpzIiwic3JjL2pzL2hhbmRsZXIvYWxsZGF5L2NyZWF0aW9uLmpzIiwic3JjL2pzL2hhbmRsZXIvYWxsZGF5L2NyZWF0aW9uR3VpZGUuanMiLCJzcmMvanMvaGFuZGxlci9hbGxkYXkvbW92ZS5qcyIsInNyYy9qcy9oYW5kbGVyL2FsbGRheS9tb3ZlR3VpZGUuanMiLCJzcmMvanMvaGFuZGxlci9hbGxkYXkvcmVzaXplLmpzIiwic3JjL2pzL2hhbmRsZXIvYWxsZGF5L3Jlc2l6ZUd1aWRlLmpzIiwic3JjL2pzL2hhbmRsZXIvZHJhZy5qcyIsInNyYy9qcy9oYW5kbGVyL3RpbWUvY29yZS5qcyIsInNyYy9qcy9oYW5kbGVyL3RpbWUvY3JlYXRpb24uanMiLCJzcmMvanMvaGFuZGxlci90aW1lL2NyZWF0aW9uR3VpZGUuanMiLCJzcmMvanMvaGFuZGxlci90aW1lL21vdmUuanMiLCJzcmMvanMvaGFuZGxlci90aW1lL21vdmVHdWlkZS5qcyIsInNyYy9qcy9oYW5kbGVyL3RpbWUvcmVzaXplLmpzIiwic3JjL2pzL2hhbmRsZXIvdGltZS9yZXNpemVHdWlkZS5qcyIsInNyYy9qcy9tb2RlbC9ldmVudC5qcyIsInNyYy9qcy9tb2RlbC92aWV3TW9kZWwvZXZlbnQuanMiLCJzcmMvanMvdmlldy9sYXlvdXQuanMiLCJzcmMvanMvdmlldy9tb250aHdlZWsuanMiLCJzcmMvanMvdmlldy90ZW1wbGF0ZS9mYWN0b3J5L3dlZWtWaWV3LmhicyIsInNyYy9qcy92aWV3L3RlbXBsYXRlL2hlbHBlci5qcyIsInNyYy9qcy92aWV3L3RlbXBsYXRlL21vbnRod2Vlay5oYnMiLCJzcmMvanMvdmlldy90ZW1wbGF0ZS9yZWdpc3RlckhlbHBlcnMuanMiLCJzcmMvanMvdmlldy90ZW1wbGF0ZS93ZWVrL2FsbGRheS5oYnMiLCJzcmMvanMvdmlldy90ZW1wbGF0ZS93ZWVrL2RheW5hbWVzLmhicyIsInNyYy9qcy92aWV3L3RlbXBsYXRlL3dlZWsvdGltZS5oYnMiLCJzcmMvanMvdmlldy90ZW1wbGF0ZS93ZWVrL3RpbWVHcmlkLmhicyIsInNyYy9qcy92aWV3L3ZpZXcuanMiLCJzcmMvanMvdmlldy93ZWVrL2FsbGRheS5qcyIsInNyYy9qcy92aWV3L3dlZWsvZGF5bmFtZS5qcyIsInNyYy9qcy92aWV3L3dlZWsvdGltZS5qcyIsInNyYy9qcy92aWV3L3dlZWsvdGltZUdyaWQuanMiLCJzcmMvanMvdmlldy93ZWVrL3dlZWsuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs4QkN2aklzQixtQkFBbUI7Ozs7O0lBQTdCLElBQUk7O29DQUlPLDBCQUEwQjs7OzttQ0FDM0Isd0JBQXdCOzs7OytCQUN2QixvQkFBb0I7O0lBQS9CLEtBQUs7O2lDQUNRLHNCQUFzQjs7SUFBbkMsT0FBTzs7b0NBRUksMEJBQTBCOzs7Ozs7QUFHakQsU0FBUyxNQUFNLEdBQUc7QUFDaEIsTUFBSSxFQUFFLEdBQUcsSUFBSSxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQzs7QUFFMUMsT0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDdkIsSUFBRSxDQUFDLFVBQVUsb0NBQWEsQ0FBQztBQUMzQixJQUFFLENBQUMsU0FBUyxtQ0FBWSxDQUFDO0FBQ3pCLElBQUUsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ2pCLElBQUUsQ0FBQyxnQkFBZ0IsR0FBRyxLQUFLLENBQUMsZ0JBQWdCLENBQUM7O0FBRTdDLElBQUUsQ0FBQyxFQUFFLEdBQUcsT0FBTyxDQUFDO0FBQ2hCLElBQUUsQ0FBQyxRQUFRLEdBQUcsVUFBUyxJQUFJLEVBQUU7QUFDM0IsV0FBTyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztHQUNuQyxDQUFDOztBQUVGLFNBQU8sRUFBRSxDQUFDO0NBQ1g7O0FBRUQsSUFBSSxJQUFJLEdBQUcsTUFBTSxFQUFFLENBQUM7QUFDcEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7O0FBRXJCLGtDQUFXLElBQUksQ0FBQyxDQUFDOztBQUVqQixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDOztxQkFFUixJQUFJOzs7Ozs7Ozs7Ozs7O3FCQ3BDeUIsU0FBUzs7eUJBQy9CLGFBQWE7Ozs7dUJBQ0UsV0FBVzs7MEJBQ1IsY0FBYzs7c0JBQ25DLFVBQVU7Ozs7QUFFdEIsSUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDOztBQUN4QixJQUFNLGlCQUFpQixHQUFHLENBQUMsQ0FBQzs7O0FBRTVCLElBQU0sZ0JBQWdCLEdBQUc7QUFDOUIsR0FBQyxFQUFFLGFBQWE7QUFDaEIsR0FBQyxFQUFFLGVBQWU7QUFDbEIsR0FBQyxFQUFFLGVBQWU7QUFDbEIsR0FBQyxFQUFFLFVBQVU7QUFDYixHQUFDLEVBQUUsa0JBQWtCO0FBQ3JCLEdBQUMsRUFBRSxpQkFBaUI7QUFDcEIsR0FBQyxFQUFFLFVBQVU7Q0FDZCxDQUFDOzs7QUFFRixJQUFNLFVBQVUsR0FBRyxpQkFBaUIsQ0FBQzs7QUFFOUIsU0FBUyxxQkFBcUIsQ0FBQyxPQUFPLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRTtBQUNuRSxNQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sSUFBSSxFQUFFLENBQUM7QUFDN0IsTUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLElBQUksRUFBRSxDQUFDO0FBQy9CLE1BQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxJQUFJLEVBQUUsQ0FBQzs7QUFFbkMsV0F4Qk0sc0JBQXNCLENBd0JMLElBQUksQ0FBQyxDQUFDO0FBQzdCLGNBeEJNLHlCQUF5QixDQXdCTCxJQUFJLENBQUMsQ0FBQztDQUNqQzs7QUFFRCxxQkFBcUIsQ0FBQyxTQUFTLEdBQUc7QUFDaEMsYUFBVyxFQUFFLHFCQUFxQjs7QUFFbEMsUUFBTSxxQkFBUTtBQUNkLEtBQUcsRUFBRSxvQkFBTyxHQUFHOztBQUVmLGdCQUFjLEVBQUUsd0JBQVMsSUFBSSxFQUFFLEVBQUUsRUFBRTtBQUNqQyxRQUFJLE9BckNxQixRQUFRLENBcUNwQixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssVUFBVSxFQUFFO0FBQ3RDLFVBQUksRUFBRSxFQUFFO0FBQUUsY0FBTSwyQkFBYyx5Q0FBeUMsQ0FBQyxDQUFDO09BQUU7QUFDM0UsYUF2Q2UsTUFBTSxDQXVDZCxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQzVCLE1BQU07QUFDTCxVQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztLQUN6QjtHQUNGO0FBQ0Qsa0JBQWdCLEVBQUUsMEJBQVMsSUFBSSxFQUFFO0FBQy9CLFdBQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztHQUMzQjs7QUFFRCxpQkFBZSxFQUFFLHlCQUFTLElBQUksRUFBRSxPQUFPLEVBQUU7QUFDdkMsUUFBSSxPQWpEcUIsUUFBUSxDQWlEcEIsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLFVBQVUsRUFBRTtBQUN0QyxhQWxEZSxNQUFNLENBa0RkLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDN0IsTUFBTTtBQUNMLFVBQUksT0FBTyxPQUFPLEtBQUssV0FBVyxFQUFFO0FBQ2xDLGNBQU0sMkJBQWMsK0NBQStDLENBQUMsQ0FBQztPQUN0RTtBQUNELFVBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDO0tBQy9CO0dBQ0Y7QUFDRCxtQkFBaUIsRUFBRSwyQkFBUyxJQUFJLEVBQUU7QUFDaEMsV0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0dBQzVCOztBQUVELG1CQUFpQixFQUFFLDJCQUFTLElBQUksRUFBRSxFQUFFLEVBQUU7QUFDcEMsUUFBSSxPQS9EcUIsUUFBUSxDQStEcEIsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLFVBQVUsRUFBRTtBQUN0QyxVQUFJLEVBQUUsRUFBRTtBQUFFLGNBQU0sMkJBQWMsNENBQTRDLENBQUMsQ0FBQztPQUFFO0FBQzlFLGFBakVlLE1BQU0sQ0FpRWQsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQztLQUMvQixNQUFNO0FBQ0wsVUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7S0FDNUI7R0FDRjtBQUNELHFCQUFtQixFQUFFLDZCQUFTLElBQUksRUFBRTtBQUNsQyxXQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7R0FDOUI7Q0FDRixDQUFDOztBQUVLLElBQUksR0FBRyxHQUFHLG9CQUFPLEdBQUcsQ0FBQzs7O1FBRXBCLFdBQVcsVUE3RVgsV0FBVztRQTZFRSxNQUFNOzs7Ozs7Ozs7Ozs7Z0NDN0VBLHFCQUFxQjs7OztBQUV6QyxTQUFTLHlCQUF5QixDQUFDLFFBQVEsRUFBRTtBQUNsRCxnQ0FBZSxRQUFRLENBQUMsQ0FBQztDQUMxQjs7Ozs7Ozs7cUJDSm9CLFVBQVU7O3FCQUVoQixVQUFTLFFBQVEsRUFBRTtBQUNoQyxVQUFRLENBQUMsaUJBQWlCLENBQUMsUUFBUSxFQUFFLFVBQVMsRUFBRSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFO0FBQzNFLFFBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNiLFFBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFO0FBQ25CLFdBQUssQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO0FBQ3BCLFNBQUcsR0FBRyxVQUFTLE9BQU8sRUFBRSxPQUFPLEVBQUU7O0FBRS9CLFlBQUksUUFBUSxHQUFHLFNBQVMsQ0FBQyxRQUFRLENBQUM7QUFDbEMsaUJBQVMsQ0FBQyxRQUFRLEdBQUcsT0FWckIsTUFBTSxDQVVzQixFQUFFLEVBQUUsUUFBUSxFQUFFLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUMxRCxZQUFJLEdBQUcsR0FBRyxFQUFFLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQy9CLGlCQUFTLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztBQUM5QixlQUFPLEdBQUcsQ0FBQztPQUNaLENBQUM7S0FDSDs7QUFFRCxTQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDOztBQUU3QyxXQUFPLEdBQUcsQ0FBQztHQUNaLENBQUMsQ0FBQztDQUNKOzs7Ozs7Ozs7O0FDcEJELElBQU0sVUFBVSxHQUFHLENBQUMsYUFBYSxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7O0FBRW5HLFNBQVMsU0FBUyxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUU7QUFDaEMsTUFBSSxHQUFHLEdBQUcsSUFBSSxJQUFJLElBQUksQ0FBQyxHQUFHO01BQ3RCLElBQUksWUFBQTtNQUNKLE1BQU0sWUFBQSxDQUFDO0FBQ1gsTUFBSSxHQUFHLEVBQUU7QUFDUCxRQUFJLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUM7QUFDdEIsVUFBTSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDOztBQUUxQixXQUFPLElBQUksS0FBSyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDO0dBQ3hDOztBQUVELE1BQUksR0FBRyxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7OztBQUcxRCxPQUFLLElBQUksR0FBRyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsVUFBVSxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsRUFBRTtBQUNoRCxRQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0dBQzlDOzs7QUFHRCxNQUFJLEtBQUssQ0FBQyxpQkFBaUIsRUFBRTtBQUMzQixTQUFLLENBQUMsaUJBQWlCLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0dBQzFDOztBQUVELE1BQUksR0FBRyxFQUFFO0FBQ1AsUUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7QUFDdkIsUUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7R0FDdEI7Q0FDRjs7QUFFRCxTQUFTLENBQUMsU0FBUyxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7O3FCQUVuQixTQUFTOzs7Ozs7Ozs7Ozs7O3lDQ2xDZSxnQ0FBZ0M7Ozs7MkJBQzlDLGdCQUFnQjs7OztvQ0FDUCwwQkFBMEI7Ozs7eUJBQ3JDLGNBQWM7Ozs7MEJBQ2IsZUFBZTs7Ozs2QkFDWixrQkFBa0I7Ozs7MkJBQ3BCLGdCQUFnQjs7OztBQUVsQyxTQUFTLHNCQUFzQixDQUFDLFFBQVEsRUFBRTtBQUMvQyx5Q0FBMkIsUUFBUSxDQUFDLENBQUM7QUFDckMsMkJBQWEsUUFBUSxDQUFDLENBQUM7QUFDdkIsb0NBQXNCLFFBQVEsQ0FBQyxDQUFDO0FBQ2hDLHlCQUFXLFFBQVEsQ0FBQyxDQUFDO0FBQ3JCLDBCQUFZLFFBQVEsQ0FBQyxDQUFDO0FBQ3RCLDZCQUFlLFFBQVEsQ0FBQyxDQUFDO0FBQ3pCLDJCQUFhLFFBQVEsQ0FBQyxDQUFDO0NBQ3hCOzs7Ozs7OztxQkNoQnFELFVBQVU7O3FCQUVqRCxVQUFTLFFBQVEsRUFBRTtBQUNoQyxVQUFRLENBQUMsY0FBYyxDQUFDLG9CQUFvQixFQUFFLFVBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN2RSxRQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTztRQUN6QixFQUFFLEdBQUcsT0FBTyxDQUFDLEVBQUUsQ0FBQzs7QUFFcEIsUUFBSSxPQUFPLEtBQUssSUFBSSxFQUFFO0FBQ3BCLGFBQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ2pCLE1BQU0sSUFBSSxPQUFPLEtBQUssS0FBSyxJQUFJLE9BQU8sSUFBSSxJQUFJLEVBQUU7QUFDL0MsYUFBTyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDdEIsTUFBTSxJQUFJLE9BWHlCLE9BQU8sQ0FXeEIsT0FBTyxDQUFDLEVBQUU7QUFDM0IsVUFBSSxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtBQUN0QixZQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUU7QUFDZixpQkFBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUM5Qjs7QUFFRCxlQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztPQUNoRCxNQUFNO0FBQ0wsZUFBTyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7T0FDdEI7S0FDRixNQUFNO0FBQ0wsVUFBSSxPQUFPLENBQUMsSUFBSSxJQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUU7QUFDL0IsWUFBSSxJQUFJLEdBQUcsT0F2QlEsV0FBVyxDQXVCUCxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDckMsWUFBSSxDQUFDLFdBQVcsR0FBRyxPQXhCbkIsaUJBQWlCLENBd0JvQixPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDN0UsZUFBTyxHQUFHLEVBQUMsSUFBSSxFQUFFLElBQUksRUFBQyxDQUFDO09BQ3hCOztBQUVELGFBQU8sRUFBRSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztLQUM3QjtHQUNGLENBQUMsQ0FBQztDQUNKOzs7Ozs7Ozs7Ozs7O3FCQy9COEUsVUFBVTs7eUJBQ25FLGNBQWM7Ozs7cUJBRXJCLFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLFVBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN6RCxRQUFJLENBQUMsT0FBTyxFQUFFO0FBQ1osWUFBTSwyQkFBYyw2QkFBNkIsQ0FBQyxDQUFDO0tBQ3BEOztBQUVELFFBQUksRUFBRSxHQUFHLE9BQU8sQ0FBQyxFQUFFO1FBQ2YsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPO1FBQ3pCLENBQUMsR0FBRyxDQUFDO1FBQ0wsR0FBRyxHQUFHLEVBQUU7UUFDUixJQUFJLFlBQUE7UUFDSixXQUFXLFlBQUEsQ0FBQzs7QUFFaEIsUUFBSSxPQUFPLENBQUMsSUFBSSxJQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUU7QUFDL0IsaUJBQVcsR0FBRyxPQWpCWixpQkFBaUIsQ0FpQmEsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztLQUNqRjs7QUFFRCxRQUFJLE9BcEJzRCxVQUFVLENBb0JyRCxPQUFPLENBQUMsRUFBRTtBQUFFLGFBQU8sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQUU7O0FBRTFELFFBQUksT0FBTyxDQUFDLElBQUksRUFBRTtBQUNoQixVQUFJLEdBQUcsT0F2QjJCLFdBQVcsQ0F1QjFCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNsQzs7QUFFRCxhQUFTLGFBQWEsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRTtBQUN6QyxVQUFJLElBQUksRUFBRTtBQUNSLFlBQUksQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDO0FBQ2pCLFlBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ25CLFlBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxLQUFLLENBQUMsQ0FBQztBQUN6QixZQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7O0FBRW5CLFlBQUksV0FBVyxFQUFFO0FBQ2YsY0FBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLEdBQUcsS0FBSyxDQUFDO1NBQ3hDO09BQ0Y7O0FBRUQsU0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQzdCLFlBQUksRUFBRSxJQUFJO0FBQ1YsbUJBQVcsRUFBRSxPQXhDTSxXQUFXLENBd0NMLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFLEtBQUssQ0FBQyxFQUFFLENBQUMsV0FBVyxHQUFHLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztPQUMvRSxDQUFDLENBQUM7S0FDSjs7QUFFRCxRQUFJLE9BQU8sSUFBSSxPQUFPLE9BQU8sS0FBSyxRQUFRLEVBQUU7QUFDMUMsVUFBSSxPQTdDMkMsT0FBTyxDQTZDMUMsT0FBTyxDQUFDLEVBQUU7QUFDcEIsYUFBSyxJQUFJLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDdkMsY0FBSSxDQUFDLElBQUksT0FBTyxFQUFFO0FBQ2hCLHlCQUFhLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEtBQUssT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztXQUMvQztTQUNGO09BQ0YsTUFBTTtBQUNMLFlBQUksUUFBUSxZQUFBLENBQUM7O0FBRWIsYUFBSyxJQUFJLEdBQUcsSUFBSSxPQUFPLEVBQUU7QUFDdkIsY0FBSSxPQUFPLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxFQUFFOzs7O0FBSS9CLGdCQUFJLFFBQVEsS0FBSyxTQUFTLEVBQUU7QUFDMUIsMkJBQWEsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO2FBQ2hDO0FBQ0Qsb0JBQVEsR0FBRyxHQUFHLENBQUM7QUFDZixhQUFDLEVBQUUsQ0FBQztXQUNMO1NBQ0Y7QUFDRCxZQUFJLFFBQVEsS0FBSyxTQUFTLEVBQUU7QUFDMUIsdUJBQWEsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUN0QztPQUNGO0tBQ0Y7O0FBRUQsUUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQ1gsU0FBRyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNyQjs7QUFFRCxXQUFPLEdBQUcsQ0FBQztHQUNaLENBQUMsQ0FBQztDQUNKOzs7Ozs7Ozs7Ozs7O3lCQzlFcUIsY0FBYzs7OztxQkFFckIsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxlQUFlLEVBQUUsaUNBQWdDO0FBQ3ZFLFFBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7O0FBRTFCLGFBQU8sU0FBUyxDQUFDO0tBQ2xCLE1BQU07O0FBRUwsWUFBTSwyQkFBYyxtQkFBbUIsR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7S0FDdkY7R0FDRixDQUFDLENBQUM7Q0FDSjs7Ozs7Ozs7OztxQkNaaUMsVUFBVTs7cUJBRTdCLFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLFVBQVMsV0FBVyxFQUFFLE9BQU8sRUFBRTtBQUMzRCxRQUFJLE9BSlMsVUFBVSxDQUlSLFdBQVcsQ0FBQyxFQUFFO0FBQUUsaUJBQVcsR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQUU7Ozs7O0FBS3RFLFFBQUksQUFBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxJQUFJLENBQUMsV0FBVyxJQUFLLE9BVC9DLE9BQU8sQ0FTZ0QsV0FBVyxDQUFDLEVBQUU7QUFDdkUsYUFBTyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQzlCLE1BQU07QUFDTCxhQUFPLE9BQU8sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDekI7R0FDRixDQUFDLENBQUM7O0FBRUgsVUFBUSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsVUFBUyxXQUFXLEVBQUUsT0FBTyxFQUFFO0FBQy9ELFdBQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxFQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQztHQUN2SCxDQUFDLENBQUM7Q0FDSjs7Ozs7Ozs7OztxQkNuQmMsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsa0NBQWlDO0FBQzlELFFBQUksSUFBSSxHQUFHLENBQUMsU0FBUyxDQUFDO1FBQ2xCLE9BQU8sR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztBQUM5QyxTQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDN0MsVUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUN6Qjs7QUFFRCxRQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDZCxRQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksRUFBRTtBQUM5QixXQUFLLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7S0FDNUIsTUFBTSxJQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxFQUFFO0FBQ3JELFdBQUssR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztLQUM1QjtBQUNELFFBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7O0FBRWhCLFlBQVEsQ0FBQyxHQUFHLE1BQUEsQ0FBWixRQUFRLEVBQVMsSUFBSSxDQUFDLENBQUM7R0FDeEIsQ0FBQyxDQUFDO0NBQ0o7Ozs7Ozs7Ozs7cUJDbEJjLFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUFFLFVBQVMsR0FBRyxFQUFFLEtBQUssRUFBRTtBQUNyRCxXQUFPLEdBQUcsSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7R0FDMUIsQ0FBQyxDQUFDO0NBQ0o7Ozs7Ozs7Ozs7cUJDSjhFLFVBQVU7O3FCQUUxRSxVQUFTLFFBQVEsRUFBRTtBQUNoQyxVQUFRLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxVQUFTLE9BQU8sRUFBRSxPQUFPLEVBQUU7QUFDekQsUUFBSSxPQUpzRCxVQUFVLENBSXJELE9BQU8sQ0FBQyxFQUFFO0FBQUUsYUFBTyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FBRTs7QUFFMUQsUUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDLEVBQUUsQ0FBQzs7QUFFcEIsUUFBSSxDQUFDLE9BUjRDLE9BQU8sQ0FRM0MsT0FBTyxDQUFDLEVBQUU7QUFDckIsVUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQztBQUN4QixVQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUMvQixZQUFJLEdBQUcsT0FYeUIsV0FBVyxDQVd4QixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDakMsWUFBSSxDQUFDLFdBQVcsR0FBRyxPQVpuQixpQkFBaUIsQ0FZb0IsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO09BQ2hGOztBQUVELGFBQU8sRUFBRSxDQUFDLE9BQU8sRUFBRTtBQUNqQixZQUFJLEVBQUUsSUFBSTtBQUNWLG1CQUFXLEVBQUUsT0FqQk0sV0FBVyxDQWlCTCxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztPQUNoRSxDQUFDLENBQUM7S0FDSixNQUFNO0FBQ0wsYUFBTyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQzlCO0dBQ0YsQ0FBQyxDQUFDO0NBQ0o7Ozs7Ozs7Ozs7cUJDdkJxQixTQUFTOztBQUUvQixJQUFJLE1BQU0sR0FBRztBQUNYLFdBQVMsRUFBRSxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQztBQUM3QyxPQUFLLEVBQUUsTUFBTTs7O0FBR2IsYUFBVyxFQUFFLHFCQUFTLEtBQUssRUFBRTtBQUMzQixRQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtBQUM3QixVQUFJLFFBQVEsR0FBRyxPQVRiLE9BQU8sQ0FTYyxNQUFNLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0FBQzlELFVBQUksUUFBUSxJQUFJLENBQUMsRUFBRTtBQUNqQixhQUFLLEdBQUcsUUFBUSxDQUFDO09BQ2xCLE1BQU07QUFDTCxhQUFLLEdBQUcsUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztPQUM3QjtLQUNGOztBQUVELFdBQU8sS0FBSyxDQUFDO0dBQ2Q7OztBQUdELEtBQUcsRUFBRSxhQUFTLEtBQUssRUFBYztBQUMvQixTQUFLLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7QUFFbEMsUUFBSSxPQUFPLE9BQU8sS0FBSyxXQUFXLElBQUksTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxFQUFFO0FBQy9FLFVBQUksTUFBTSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDckMsVUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRTs7QUFDcEIsY0FBTSxHQUFHLEtBQUssQ0FBQztPQUNoQjs7d0NBUG1CLE9BQU87QUFBUCxlQUFPOzs7QUFRM0IsYUFBTyxDQUFDLE1BQU0sT0FBQyxDQUFmLE9BQU8sRUFBWSxPQUFPLENBQUMsQ0FBQztLQUM3QjtHQUNGO0NBQ0YsQ0FBQzs7cUJBRWEsTUFBTTs7Ozs7Ozs7Ozs7cUJDakNOLFVBQVMsVUFBVSxFQUFFOztBQUVsQyxNQUFJLElBQUksR0FBRyxPQUFPLE1BQU0sS0FBSyxXQUFXLEdBQUcsTUFBTSxHQUFHLE1BQU07TUFDdEQsV0FBVyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7O0FBRWxDLFlBQVUsQ0FBQyxVQUFVLEdBQUcsWUFBVztBQUNqQyxRQUFJLElBQUksQ0FBQyxVQUFVLEtBQUssVUFBVSxFQUFFO0FBQ2xDLFVBQUksQ0FBQyxVQUFVLEdBQUcsV0FBVyxDQUFDO0tBQy9CO0dBQ0YsQ0FBQztDQUNIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FCQ1hzQixTQUFTOztJQUFwQixLQUFLOzt5QkFDSyxhQUFhOzs7O29CQUM4QixRQUFROztBQUVsRSxTQUFTLGFBQWEsQ0FBQyxZQUFZLEVBQUU7QUFDMUMsTUFBTSxnQkFBZ0IsR0FBRyxZQUFZLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7TUFDdkQsZUFBZSxTQUpkLGlCQUFpQixBQUlpQixDQUFDOztBQUUxQyxNQUFJLGdCQUFnQixLQUFLLGVBQWUsRUFBRTtBQUN4QyxRQUFJLGdCQUFnQixHQUFHLGVBQWUsRUFBRTtBQUN0QyxVQUFNLGVBQWUsR0FBRyxNQVJGLGdCQUFnQixDQVFHLGVBQWUsQ0FBQztVQUNuRCxnQkFBZ0IsR0FBRyxNQVRILGdCQUFnQixDQVNJLGdCQUFnQixDQUFDLENBQUM7QUFDNUQsWUFBTSwyQkFBYyx5RkFBeUYsR0FDdkcscURBQXFELEdBQUcsZUFBZSxHQUFHLG1EQUFtRCxHQUFHLGdCQUFnQixHQUFHLElBQUksQ0FBQyxDQUFDO0tBQ2hLLE1BQU07O0FBRUwsWUFBTSwyQkFBYyx3RkFBd0YsR0FDdEcsaURBQWlELEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0tBQ25GO0dBQ0Y7Q0FDRjs7QUFFTSxTQUFTLFFBQVEsQ0FBQyxZQUFZLEVBQUUsR0FBRyxFQUFFOztBQUUxQyxNQUFJLENBQUMsR0FBRyxFQUFFO0FBQ1IsVUFBTSwyQkFBYyxtQ0FBbUMsQ0FBQyxDQUFDO0dBQzFEO0FBQ0QsTUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUU7QUFDdkMsVUFBTSwyQkFBYywyQkFBMkIsR0FBRyxPQUFPLFlBQVksQ0FBQyxDQUFDO0dBQ3hFOztBQUVELGNBQVksQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLFlBQVksQ0FBQyxNQUFNLENBQUM7Ozs7QUFJbEQsS0FBRyxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDOztBQUU1QyxXQUFTLG9CQUFvQixDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3ZELFFBQUksT0FBTyxDQUFDLElBQUksRUFBRTtBQUNoQixhQUFPLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNsRCxVQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUU7QUFDZixlQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztPQUN2QjtLQUNGOztBQUVELFdBQU8sR0FBRyxHQUFHLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDdEUsUUFBSSxNQUFNLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDOztBQUV4RSxRQUFJLE1BQU0sSUFBSSxJQUFJLElBQUksR0FBRyxDQUFDLE9BQU8sRUFBRTtBQUNqQyxhQUFPLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsZUFBZSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ3pGLFlBQU0sR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDM0Q7QUFDRCxRQUFJLE1BQU0sSUFBSSxJQUFJLEVBQUU7QUFDbEIsVUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFO0FBQ2xCLFlBQUksS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDL0IsYUFBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUM1QyxjQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQzVCLGtCQUFNO1dBQ1A7O0FBRUQsZUFBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3RDO0FBQ0QsY0FBTSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7T0FDM0I7QUFDRCxhQUFPLE1BQU0sQ0FBQztLQUNmLE1BQU07QUFDTCxZQUFNLDJCQUFjLGNBQWMsR0FBRyxPQUFPLENBQUMsSUFBSSxHQUFHLDBEQUEwRCxDQUFDLENBQUM7S0FDakg7R0FDRjs7O0FBR0QsTUFBSSxTQUFTLEdBQUc7QUFDZCxVQUFNLEVBQUUsZ0JBQVMsR0FBRyxFQUFFLElBQUksRUFBRTtBQUMxQixVQUFJLEVBQUUsSUFBSSxJQUFJLEdBQUcsQ0FBQSxBQUFDLEVBQUU7QUFDbEIsY0FBTSwyQkFBYyxHQUFHLEdBQUcsSUFBSSxHQUFHLG1CQUFtQixHQUFHLEdBQUcsQ0FBQyxDQUFDO09BQzdEO0FBQ0QsYUFBTyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDbEI7QUFDRCxVQUFNLEVBQUUsZ0JBQVMsTUFBTSxFQUFFLElBQUksRUFBRTtBQUM3QixVQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0FBQzFCLFdBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDNUIsWUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksRUFBRTtBQUN4QyxpQkFBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDeEI7T0FDRjtLQUNGO0FBQ0QsVUFBTSxFQUFFLGdCQUFTLE9BQU8sRUFBRSxPQUFPLEVBQUU7QUFDakMsYUFBTyxPQUFPLE9BQU8sS0FBSyxVQUFVLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxPQUFPLENBQUM7S0FDeEU7O0FBRUQsb0JBQWdCLEVBQUUsS0FBSyxDQUFDLGdCQUFnQjtBQUN4QyxpQkFBYSxFQUFFLG9CQUFvQjs7QUFFbkMsTUFBRSxFQUFFLFlBQVMsQ0FBQyxFQUFFO0FBQ2QsVUFBSSxHQUFHLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzFCLFNBQUcsQ0FBQyxTQUFTLEdBQUcsWUFBWSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUN2QyxhQUFPLEdBQUcsQ0FBQztLQUNaOztBQUVELFlBQVEsRUFBRSxFQUFFO0FBQ1osV0FBTyxFQUFFLGlCQUFTLENBQUMsRUFBRSxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRTtBQUNuRSxVQUFJLGNBQWMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztVQUNqQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwQixVQUFJLElBQUksSUFBSSxNQUFNLElBQUksV0FBVyxJQUFJLG1CQUFtQixFQUFFO0FBQ3hELHNCQUFjLEdBQUcsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxtQkFBbUIsRUFBRSxXQUFXLEVBQUUsTUFBTSxDQUFDLENBQUM7T0FDM0YsTUFBTSxJQUFJLENBQUMsY0FBYyxFQUFFO0FBQzFCLHNCQUFjLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztPQUM5RDtBQUNELGFBQU8sY0FBYyxDQUFDO0tBQ3ZCOztBQUVELFFBQUksRUFBRSxjQUFTLEtBQUssRUFBRSxLQUFLLEVBQUU7QUFDM0IsYUFBTyxLQUFLLElBQUksS0FBSyxFQUFFLEVBQUU7QUFDdkIsYUFBSyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUM7T0FDdkI7QUFDRCxhQUFPLEtBQUssQ0FBQztLQUNkO0FBQ0QsU0FBSyxFQUFFLGVBQVMsS0FBSyxFQUFFLE1BQU0sRUFBRTtBQUM3QixVQUFJLEdBQUcsR0FBRyxLQUFLLElBQUksTUFBTSxDQUFDOztBQUUxQixVQUFJLEtBQUssSUFBSSxNQUFNLElBQUssS0FBSyxLQUFLLE1BQU0sQUFBQyxFQUFFO0FBQ3pDLFdBQUcsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7T0FDdkM7O0FBRUQsYUFBTyxHQUFHLENBQUM7S0FDWjs7QUFFRCxRQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJO0FBQ2pCLGdCQUFZLEVBQUUsWUFBWSxDQUFDLFFBQVE7R0FDcEMsQ0FBQzs7QUFFRixXQUFTLEdBQUcsQ0FBQyxPQUFPLEVBQWdCO1FBQWQsT0FBTyx5REFBRyxFQUFFOztBQUNoQyxRQUFJLElBQUksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDOztBQUV4QixPQUFHLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3BCLFFBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxJQUFJLFlBQVksQ0FBQyxPQUFPLEVBQUU7QUFDNUMsVUFBSSxHQUFHLFFBQVEsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDaEM7QUFDRCxRQUFJLE1BQU0sWUFBQTtRQUNOLFdBQVcsR0FBRyxZQUFZLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRyxTQUFTLENBQUM7QUFDL0QsUUFBSSxZQUFZLENBQUMsU0FBUyxFQUFFO0FBQzFCLFVBQUksT0FBTyxDQUFDLE1BQU0sRUFBRTtBQUNsQixjQUFNLEdBQUcsT0FBTyxLQUFLLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUM7T0FDNUYsTUFBTTtBQUNMLGNBQU0sR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO09BQ3BCO0tBQ0Y7O0FBRUQsYUFBUyxJQUFJLENBQUMsT0FBTyxnQkFBZTtBQUNsQyxhQUFPLEVBQUUsR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsU0FBUyxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxDQUFDLENBQUM7S0FDckg7QUFDRCxRQUFJLEdBQUcsaUJBQWlCLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxNQUFNLElBQUksRUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQztBQUN0RyxXQUFPLElBQUksQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7R0FDL0I7QUFDRCxLQUFHLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQzs7QUFFakIsS0FBRyxDQUFDLE1BQU0sR0FBRyxVQUFTLE9BQU8sRUFBRTtBQUM3QixRQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRTtBQUNwQixlQUFTLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7O0FBRWxFLFVBQUksWUFBWSxDQUFDLFVBQVUsRUFBRTtBQUMzQixpQkFBUyxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO09BQ3RFO0FBQ0QsVUFBSSxZQUFZLENBQUMsVUFBVSxJQUFJLFlBQVksQ0FBQyxhQUFhLEVBQUU7QUFDekQsaUJBQVMsQ0FBQyxVQUFVLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztPQUM1RTtLQUNGLE1BQU07QUFDTCxlQUFTLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUM7QUFDcEMsZUFBUyxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDO0FBQ3RDLGVBQVMsQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQztLQUMzQztHQUNGLENBQUM7O0FBRUYsS0FBRyxDQUFDLE1BQU0sR0FBRyxVQUFTLENBQUMsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRTtBQUNsRCxRQUFJLFlBQVksQ0FBQyxjQUFjLElBQUksQ0FBQyxXQUFXLEVBQUU7QUFDL0MsWUFBTSwyQkFBYyx3QkFBd0IsQ0FBQyxDQUFDO0tBQy9DO0FBQ0QsUUFBSSxZQUFZLENBQUMsU0FBUyxJQUFJLENBQUMsTUFBTSxFQUFFO0FBQ3JDLFlBQU0sMkJBQWMseUJBQXlCLENBQUMsQ0FBQztLQUNoRDs7QUFFRCxXQUFPLFdBQVcsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztHQUNqRixDQUFDO0FBQ0YsU0FBTyxHQUFHLENBQUM7Q0FDWjs7QUFFTSxTQUFTLFdBQVcsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRTtBQUM1RixXQUFTLElBQUksQ0FBQyxPQUFPLEVBQWdCO1FBQWQsT0FBTyx5REFBRyxFQUFFOztBQUNqQyxRQUFJLGFBQWEsR0FBRyxNQUFNLENBQUM7QUFDM0IsUUFBSSxNQUFNLElBQUksT0FBTyxLQUFLLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRTtBQUNuQyxtQkFBYSxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQzFDOztBQUVELFdBQU8sRUFBRSxDQUFDLFNBQVMsRUFDZixPQUFPLEVBQ1AsU0FBUyxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsUUFBUSxFQUNyQyxPQUFPLENBQUMsSUFBSSxJQUFJLElBQUksRUFDcEIsV0FBVyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFDeEQsYUFBYSxDQUFDLENBQUM7R0FDcEI7O0FBRUQsTUFBSSxHQUFHLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUM7O0FBRXpFLE1BQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO0FBQ2pCLE1BQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0FBQ3hDLE1BQUksQ0FBQyxXQUFXLEdBQUcsbUJBQW1CLElBQUksQ0FBQyxDQUFDO0FBQzVDLFNBQU8sSUFBSSxDQUFDO0NBQ2I7O0FBRU0sU0FBUyxjQUFjLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUU7QUFDeEQsTUFBSSxDQUFDLE9BQU8sRUFBRTtBQUNaLFFBQUksT0FBTyxDQUFDLElBQUksS0FBSyxnQkFBZ0IsRUFBRTtBQUNyQyxhQUFPLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztLQUN6QyxNQUFNO0FBQ0wsYUFBTyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQzFDO0dBQ0YsTUFBTSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUU7O0FBRXpDLFdBQU8sQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDO0FBQ3ZCLFdBQU8sR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0dBQ3JDO0FBQ0QsU0FBTyxPQUFPLENBQUM7Q0FDaEI7O0FBRU0sU0FBUyxhQUFhLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUU7QUFDdkQsU0FBTyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7QUFDdkIsTUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFO0FBQ2YsV0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztHQUN2RTs7QUFFRCxNQUFJLFlBQVksWUFBQSxDQUFDO0FBQ2pCLE1BQUksT0FBTyxDQUFDLEVBQUUsSUFBSSxPQUFPLENBQUMsRUFBRSxLQUFLLElBQUksRUFBRTtBQUNyQyxXQUFPLENBQUMsSUFBSSxHQUFHLE1BdE8yQixXQUFXLENBc08xQixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDekMsZ0JBQVksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxFQUFFLENBQUM7O0FBRTFELFFBQUksWUFBWSxDQUFDLFFBQVEsRUFBRTtBQUN6QixhQUFPLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxRQUFRLEVBQUUsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0tBQzlFO0dBQ0Y7O0FBRUQsTUFBSSxPQUFPLEtBQUssU0FBUyxJQUFJLFlBQVksRUFBRTtBQUN6QyxXQUFPLEdBQUcsWUFBWSxDQUFDO0dBQ3hCOztBQUVELE1BQUksT0FBTyxLQUFLLFNBQVMsRUFBRTtBQUN6QixVQUFNLDJCQUFjLGNBQWMsR0FBRyxPQUFPLENBQUMsSUFBSSxHQUFHLHFCQUFxQixDQUFDLENBQUM7R0FDNUUsTUFBTSxJQUFJLE9BQU8sWUFBWSxRQUFRLEVBQUU7QUFDdEMsV0FBTyxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0dBQ2xDO0NBQ0Y7O0FBRU0sU0FBUyxJQUFJLEdBQUc7QUFBRSxTQUFPLEVBQUUsQ0FBQztDQUFFOztBQUVyQyxTQUFTLFFBQVEsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFO0FBQy9CLE1BQUksQ0FBQyxJQUFJLElBQUksRUFBRSxNQUFNLElBQUksSUFBSSxDQUFBLEFBQUMsRUFBRTtBQUM5QixRQUFJLEdBQUcsSUFBSSxHQUFHLE1BN1A0QixXQUFXLENBNlAzQixJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDckMsUUFBSSxDQUFDLElBQUksR0FBRyxPQUFPLENBQUM7R0FDckI7QUFDRCxTQUFPLElBQUksQ0FBQztDQUNiOztBQUVELFNBQVMsaUJBQWlCLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUU7QUFDekUsTUFBSSxFQUFFLENBQUMsU0FBUyxFQUFFO0FBQ2hCLFFBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUNmLFFBQUksR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLE1BQU0sSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUM1RixTQUFLLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztHQUMzQjtBQUNELFNBQU8sSUFBSSxDQUFDO0NBQ2I7Ozs7Ozs7O0FDM1FELFNBQVMsVUFBVSxDQUFDLE1BQU0sRUFBRTtBQUMxQixNQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztDQUN0Qjs7QUFFRCxVQUFVLENBQUMsU0FBUyxDQUFDLFFBQVEsR0FBRyxVQUFVLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxZQUFXO0FBQ3ZFLFNBQU8sRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7Q0FDekIsQ0FBQzs7cUJBRWEsVUFBVTs7Ozs7Ozs7Ozs7Ozs7O0FDVHpCLElBQU0sTUFBTSxHQUFHO0FBQ2IsS0FBRyxFQUFFLE9BQU87QUFDWixLQUFHLEVBQUUsTUFBTTtBQUNYLEtBQUcsRUFBRSxNQUFNO0FBQ1gsS0FBRyxFQUFFLFFBQVE7QUFDYixLQUFHLEVBQUUsUUFBUTtBQUNiLEtBQUcsRUFBRSxRQUFRO0FBQ2IsS0FBRyxFQUFFLFFBQVE7Q0FDZCxDQUFDOztBQUVGLElBQU0sUUFBUSxHQUFHLFlBQVk7SUFDdkIsUUFBUSxHQUFHLFdBQVcsQ0FBQzs7QUFFN0IsU0FBUyxVQUFVLENBQUMsR0FBRyxFQUFFO0FBQ3ZCLFNBQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQ3BCOztBQUVNLFNBQVMsTUFBTSxDQUFDLEdBQUcsb0JBQW9CO0FBQzVDLE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3pDLFNBQUssSUFBSSxHQUFHLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFO0FBQzVCLFVBQUksTUFBTSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRTtBQUMzRCxXQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO09BQzlCO0tBQ0Y7R0FDRjs7QUFFRCxTQUFPLEdBQUcsQ0FBQztDQUNaOztBQUVNLElBQUksUUFBUSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDOzs7Ozs7QUFLaEQsSUFBSSxVQUFVLEdBQUcsb0JBQVMsS0FBSyxFQUFFO0FBQy9CLFNBQU8sT0FBTyxLQUFLLEtBQUssVUFBVSxDQUFDO0NBQ3BDLENBQUM7OztBQUdGLElBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQ25CLFVBSU0sVUFBVSxHQUpoQixVQUFVLEdBQUcsVUFBUyxLQUFLLEVBQUU7QUFDM0IsV0FBTyxPQUFPLEtBQUssS0FBSyxVQUFVLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxtQkFBbUIsQ0FBQztHQUNwRixDQUFDO0NBQ0g7UUFDTyxVQUFVLEdBQVYsVUFBVTs7Ozs7QUFJWCxJQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsT0FBTyxJQUFJLFVBQVMsS0FBSyxFQUFFO0FBQ3RELFNBQU8sQUFBQyxLQUFLLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxHQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO0NBQ2pHLENBQUM7Ozs7O0FBR0ssU0FBUyxPQUFPLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUNwQyxPQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ2hELFFBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLEtBQUssRUFBRTtBQUN0QixhQUFPLENBQUMsQ0FBQztLQUNWO0dBQ0Y7QUFDRCxTQUFPLENBQUMsQ0FBQyxDQUFDO0NBQ1g7O0FBR00sU0FBUyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUU7QUFDdkMsTUFBSSxPQUFPLE1BQU0sS0FBSyxRQUFRLEVBQUU7O0FBRTlCLFFBQUksTUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEVBQUU7QUFDM0IsYUFBTyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUM7S0FDeEIsTUFBTSxJQUFJLE1BQU0sSUFBSSxJQUFJLEVBQUU7QUFDekIsYUFBTyxFQUFFLENBQUM7S0FDWCxNQUFNLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFDbEIsYUFBTyxNQUFNLEdBQUcsRUFBRSxDQUFDO0tBQ3BCOzs7OztBQUtELFVBQU0sR0FBRyxFQUFFLEdBQUcsTUFBTSxDQUFDO0dBQ3RCOztBQUVELE1BQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFO0FBQUUsV0FBTyxNQUFNLENBQUM7R0FBRTtBQUM5QyxTQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0NBQzdDOztBQUVNLFNBQVMsT0FBTyxDQUFDLEtBQUssRUFBRTtBQUM3QixNQUFJLENBQUMsS0FBSyxJQUFJLEtBQUssS0FBSyxDQUFDLEVBQUU7QUFDekIsV0FBTyxJQUFJLENBQUM7R0FDYixNQUFNLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO0FBQy9DLFdBQU8sSUFBSSxDQUFDO0dBQ2IsTUFBTTtBQUNMLFdBQU8sS0FBSyxDQUFDO0dBQ2Q7Q0FDRjs7QUFFTSxTQUFTLFdBQVcsQ0FBQyxNQUFNLEVBQUU7QUFDbEMsTUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUMvQixPQUFLLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztBQUN2QixTQUFPLEtBQUssQ0FBQztDQUNkOztBQUVNLFNBQVMsV0FBVyxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUU7QUFDdkMsUUFBTSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7QUFDbEIsU0FBTyxNQUFNLENBQUM7Q0FDZjs7QUFFTSxTQUFTLGlCQUFpQixDQUFDLFdBQVcsRUFBRSxFQUFFLEVBQUU7QUFDakQsU0FBTyxDQUFDLFdBQVcsR0FBRyxXQUFXLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQSxHQUFJLEVBQUUsQ0FBQztDQUNwRDs7OztBQzNHRDtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBOzs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ25QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL2FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2phQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbmpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDblFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKipcbiAqIOKWiOKWiOKWiOKWiOKWiOKWiOKVlyAgIOKWiOKWiOKWiOKWiOKWiOKWiOKVlyAgIOKWiOKWiOKWiOKWiOKWiOKWiOKVlyAg4paI4paI4paI4paI4paI4paI4pWXICAg4paI4paI4paI4paI4paI4pWXICDilojilojilZcgICDilojilojilZcg4paI4paI4pWXXG4gKiDilojilojilZTilZDilZDilojilojilZcg4paI4paI4pWU4pWQ4pWQ4pWQ4paI4paI4pWXIOKWiOKWiOKVlOKVkOKVkOKVkOKWiOKWiOKVlyDilojilojilZTilZDilZDilojilojilZcg4paI4paI4pWU4pWQ4pWQ4paI4paI4pWXIOKVmuKWiOKWiOKVlyDilojilojilZTilZ0g4paI4paI4pWRXG4gKiDilojilojilZEgIOKWiOKWiOKVkSDilojilojilZEgICDilojilojilZEg4paI4paI4pWRICAg4paI4paI4pWRIOKWiOKWiOKWiOKWiOKWiOKWiOKVlOKVnSDilojilojilojilojilojilojilojilZEgIOKVmuKWiOKWiOKWiOKWiOKVlOKVnSAg4paI4paI4pWRXG4gKiDilojilojilZEgIOKWiOKWiOKVkSDilojilojilZEgICDilojilojilZEg4paI4paI4pWRICAg4paI4paI4pWRIOKWiOKWiOKVlOKVkOKVkOKWiOKWiOKVlyDilojilojilZTilZDilZDilojilojilZEgICDilZrilojilojilZTilZ0gICDilZrilZDilZ1cbiAqIOKWiOKWiOKWiOKWiOKWiOKWiOKVlOKVnSDilZrilojilojilojilojilojilojilZTilZ0g4pWa4paI4paI4paI4paI4paI4paI4pWU4pWdIOKWiOKWiOKVkSAg4paI4paI4pWRIOKWiOKWiOKVkSAg4paI4paI4pWRICAgIOKWiOKWiOKVkSAgICDilojilojilZdcbiAqIOKVmuKVkOKVkOKVkOKVkOKVkOKVnSAgIOKVmuKVkOKVkOKVkOKVkOKVkOKVnSAgIOKVmuKVkOKVkOKVkOKVkOKVkOKVnSAg4pWa4pWQ4pWdICDilZrilZDilZ0g4pWa4pWQ4pWdICDilZrilZDilZ0gICAg4pWa4pWQ4pWdICAgIOKVmuKVkOKVnVxuICpcbiAqICDilojilojilojilojilojilojilZcgIOKWiOKWiOKWiOKWiOKWiOKVlyAg4paI4paI4pWXICAgICAg4paI4paI4paI4paI4paI4paI4paI4pWXIOKWiOKWiOKWiOKVlyAgIOKWiOKWiOKVlyDilojilojilojilojilojilojilZcgICDilojilojilojilojilojilZcgIOKWiOKWiOKWiOKWiOKWiOKWiOKVl1xuICog4paI4paI4pWU4pWQ4pWQ4pWQ4pWQ4pWdIOKWiOKWiOKVlOKVkOKVkOKWiOKWiOKVlyDilojilojilZEgICAgICDilojilojilZTilZDilZDilZDilZDilZ0g4paI4paI4paI4paI4pWXICDilojilojilZEg4paI4paI4pWU4pWQ4pWQ4paI4paI4pWXIOKWiOKWiOKVlOKVkOKVkOKWiOKWiOKVlyDilojilojilZTilZDilZDilojilojilZdcbiAqIOKWiOKWiOKVkSAgICAgIOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKVkSDilojilojilZEgICAgICDilojilojilojilojilojilZcgICDilojilojilZTilojilojilZcg4paI4paI4pWRIOKWiOKWiOKVkSAg4paI4paI4pWRIOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKVkSDilojilojilojilojilojilojilZTilZ1cbiAqIOKWiOKWiOKVkSAgICAgIOKWiOKWiOKVlOKVkOKVkOKWiOKWiOKVkSDilojilojilZEgICAgICDilojilojilZTilZDilZDilZ0gICDilojilojilZHilZrilojilojilZfilojilojilZEg4paI4paI4pWRICDilojilojilZEg4paI4paI4pWU4pWQ4pWQ4paI4paI4pWRIOKWiOKWiOKVlOKVkOKVkOKWiOKWiOKVl1xuICog4pWa4paI4paI4paI4paI4paI4paI4pWXIOKWiOKWiOKVkSAg4paI4paI4pWRIOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKVlyDilojilojilojilojilojilojilojilZcg4paI4paI4pWRIOKVmuKWiOKWiOKWiOKWiOKVkSDilojilojilojilojilojilojilZTilZ0g4paI4paI4pWRICDilojilojilZEg4paI4paI4pWRICDilojilojilZFcbiAqICDilZrilZDilZDilZDilZDilZDilZ0g4pWa4pWQ4pWdICDilZrilZDilZ0g4pWa4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWdIOKVmuKVkOKVkOKVkOKVkOKVkOKVkOKVnSDilZrilZDilZ0gIOKVmuKVkOKVkOKVkOKVnSDilZrilZDilZDilZDilZDilZDilZ0gIOKVmuKVkOKVnSAg4pWa4pWQ4pWdIOKVmuKVkOKVnSAg4pWa4pWQ4pWdXG4gKiBAdmVyc2lvbiAwLjEuNVxuICovXG4vKiBlc2xpbnQgdmFycy1vbi10b3A6MCwgc3RyaWN0OjAgKi9cblxuLyoqKioqKioqKipcbiAqIENvbW1vblxuICoqKioqKioqKiovXG5yZXF1aXJlKCdjb2RlLXNuaXBwZXQnKTtcbnJlcXVpcmUoJy4vc3JjL2pzL3ZpZXcvdGVtcGxhdGUvcmVnaXN0ZXJIZWxwZXJzJyk7XG52YXIgZGlydHkgPSByZXF1aXJlKCcuL3NyYy9qcy9jb21tb24vZGlydHknKTtcbnZhciBkYXRldGltZSA9IHJlcXVpcmUoJy4vc3JjL2pzL2NvbW1vbi9kYXRldGltZScpO1xudmFyIGFycmF5ID0gcmVxdWlyZSgnLi9zcmMvanMvY29tbW9uL2FycmF5Jyk7XG52YXIgZG9tZXZlbnQgPSByZXF1aXJlKCcuL3NyYy9qcy9jb21tb24vZG9tZXZlbnQnKTtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi9zcmMvanMvY29tbW9uL2RvbXV0aWwnKTtcbnZhciBDb2xsZWNpdG9uID0gcmVxdWlyZSgnLi9zcmMvanMvY29tbW9uL2NvbGxlY3Rpb24nKTtcbnZhciBtb2RlbCA9IHJlcXVpcmUoJy4vc3JjL2pzL2NvbW1vbi9tb2RlbCcpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vc3JjL2pzL2NvbW1vbi9jb21tb24nKTtcbnZhciByZXFBbmltRnJhbWUgPSByZXF1aXJlKCcuL3NyYy9qcy9jb21tb24vcmVxQW5pbUZyYW1lJyk7XG52YXIgQUpBWCA9IHJlcXVpcmUoJy4vc3JjL2pzL2NvbW1vbi9hamF4Jyk7XG5cbi8qKioqKioqKioqXG4gKiBNb2RlbHNcbiAqKioqKioqKioqL1xudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9zcmMvanMvY29tbW9uL3BvaW50Jyk7XG52YXIgRXZlbnQgPSByZXF1aXJlKCcuL3NyYy9qcy9tb2RlbC9ldmVudCcpO1xuXG4vKioqKioqKioqKlxuICogVmlld3NcbiAqKioqKioqKioqL1xudmFyIFZpZXcgPSByZXF1aXJlKCcuL3NyYy9qcy92aWV3L3ZpZXcnKTtcbnZhciBNb250aFdlZWsgPSByZXF1aXJlKCcuL3NyYy9qcy92aWV3L21vbnRod2VlaycpO1xuXG52YXIgV2VlayA9IHJlcXVpcmUoJy4vc3JjL2pzL3ZpZXcvd2Vlay93ZWVrJyk7XG52YXIgRGF5TmFtZSA9IHJlcXVpcmUoJy4vc3JjL2pzL3ZpZXcvd2Vlay9kYXluYW1lJyk7XG52YXIgVGltZUdyaWQgPSByZXF1aXJlKCcuL3NyYy9qcy92aWV3L3dlZWsvdGltZUdyaWQnKTtcbnZhciBUaW1lID0gcmVxdWlyZSgnLi9zcmMvanMvdmlldy93ZWVrL3RpbWUnKTtcblxuXG4vKioqKioqKioqKlxuICogVmlldyBNb2RlbHNcbiAqKioqKioqKioqL1xudmFyIEV2ZW50Vmlld01vZGVsID0gcmVxdWlyZSgnLi9zcmMvanMvbW9kZWwvdmlld01vZGVsL2V2ZW50Jyk7XG5cbi8qKioqKioqKioqXG4gKiBIYW5kbGVyc1xuICoqKioqKioqKiovXG52YXIgRHJhZyA9IHJlcXVpcmUoJy4vc3JjL2pzL2hhbmRsZXIvZHJhZycpO1xudmFyIFRpbWVDb3JlID0gcmVxdWlyZSgnLi9zcmMvanMvaGFuZGxlci90aW1lL2NvcmUnKTtcbnZhciBUaW1lQ3JlYXRpb24gPSByZXF1aXJlKCcuL3NyYy9qcy9oYW5kbGVyL3RpbWUvY3JlYXRpb24nKTtcbnZhciBUaW1lQ3JlYXRpb25HdWlkZSA9IHJlcXVpcmUoJy4vc3JjL2pzL2hhbmRsZXIvdGltZS9jcmVhdGlvbkd1aWRlJyk7XG52YXIgVGltZU1vdmUgPSByZXF1aXJlKCcuL3NyYy9qcy9oYW5kbGVyL3RpbWUvbW92ZScpO1xudmFyIFRpbWVNb3ZlR3VpZGUgPSByZXF1aXJlKCcuL3NyYy9qcy9oYW5kbGVyL3RpbWUvbW92ZUd1aWRlJyk7XG52YXIgVGltZVJlc2l6ZSA9IHJlcXVpcmUoJy4vc3JjL2pzL2hhbmRsZXIvdGltZS9yZXNpemUnKTtcbnZhciBUaW1lUmVzaXplR3VpZGUgPSByZXF1aXJlKCcuL3NyYy9qcy9oYW5kbGVyL3RpbWUvcmVzaXplR3VpZGUnKTtcblxudmFyIEFsbGRheUNvcmUgPSByZXF1aXJlKCcuL3NyYy9qcy9oYW5kbGVyL2FsbGRheS9jb3JlJyk7XG52YXIgQWxsZGF5Q3JlYXRpb24gPSByZXF1aXJlKCcuL3NyYy9qcy9oYW5kbGVyL2FsbGRheS9jcmVhdGlvbicpO1xudmFyIEFsbGRheUNyZWF0aW9uR3VpZGUgPSByZXF1aXJlKCcuL3NyYy9qcy9oYW5kbGVyL2FsbGRheS9jcmVhdGlvbkd1aWRlJyk7XG52YXIgQWxsZGF5TW92ZSA9IHJlcXVpcmUoJy4vc3JjL2pzL2hhbmRsZXIvYWxsZGF5L21vdmUnKTtcbnZhciBBbGxkYXlNb3ZlR3VpZGUgPSByZXF1aXJlKCcuL3NyYy9qcy9oYW5kbGVyL2FsbGRheS9tb3ZlR3VpZGUnKTtcbnZhciBBbGxkYXlSZXNpemUgPSByZXF1aXJlKCcuL3NyYy9qcy9oYW5kbGVyL2FsbGRheS9yZXNpemUnKTtcbnZhciBBbGxkYXlSZXNpemVHdWlkZSA9IHJlcXVpcmUoJy4vc3JjL2pzL2hhbmRsZXIvYWxsZGF5L3Jlc2l6ZUd1aWRlJyk7XG5cbi8qKioqKioqKioqXG4gKiBGYWN0b3J5XG4gKioqKioqKioqKi9cbnZhciBjb250cm9sbGVyRmFjdG9yeSA9IHJlcXVpcmUoJy4vc3JjL2pzL2ZhY3RvcnkvY29udHJvbGxlcicpO1xuXG4vKiogQG5hbWVzcGFjZSBuZS5kb29yYXkuY2FsZW5kYXIgKi9cblxuZ2xvYmFsLm5lLnV0aWwuZGVmaW5lTmFtZXNwYWNlKCduZS5kb29yYXkuY2FsZW5kYXInLCB7XG4gICAgLy8gY29tbW9uXG4gICAgZGlydHk6IGRpcnR5LFxuICAgIGRhdGV0aW1lOiBkYXRldGltZSxcbiAgICBhcnJheTogYXJyYXksXG4gICAgZG9tZXZlbnQ6IGRvbWV2ZW50LFxuICAgIGRvbXV0aWw6IGRvbXV0aWwsXG4gICAgQ29sbGVjdGlvbjogQ29sbGVjaXRvbixcbiAgICBtb2RlbDogbW9kZWwsXG4gICAgY29tbW9uOiBjb21tb24sXG4gICAgcmVxQW5pbUZyYW1lOiByZXFBbmltRnJhbWUsXG4gICAgQUpBWDogQUpBWCxcbiAgICBQb2ludDogUG9pbnQsIFxuXG4gICAgLy8gbW9kZWxcbiAgICBFdmVudDogRXZlbnQsXG4gICAgRXZlbnRWaWV3TW9kZWw6IEV2ZW50Vmlld01vZGVsLFxuXG4gICAgLy8gdmlld1xuICAgIFZpZXc6IFZpZXcsXG4gICAgV2VlazogV2VlayxcbiAgICBEYXlOYW1lOiBEYXlOYW1lLFxuICAgIFRpbWVHcmlkOiBUaW1lR3JpZCxcbiAgICBUaW1lOiBUaW1lLFxuICAgIE1vbnRoV2VlazogTW9udGhXZWVrLFxuXG4gICAgLy8gaGFuZGxlciwgZ3VpZGVcbiAgICBEcmFnOiBEcmFnLFxuXG4gICAgVGltZUNvcmU6IFRpbWVDb3JlLFxuICAgIFRpbWVDcmVhdGlvbjogVGltZUNyZWF0aW9uLFxuICAgIFRpbWVDcmVhdGlvbkd1aWRlOiBUaW1lQ3JlYXRpb25HdWlkZSxcbiAgICBUaW1lTW92ZTogVGltZU1vdmUsXG4gICAgVGltZU1vdmVHdWlkZTogVGltZU1vdmVHdWlkZSxcbiAgICBUaW1lUmVzaXplOiBUaW1lUmVzaXplLFxuICAgIFRpbWVSZXNpemVHdWlkZTogVGltZVJlc2l6ZUd1aWRlLFxuXG4gICAgQWxsZGF5Q29yZTogQWxsZGF5Q29yZSxcbiAgICBBbGxkYXlDcmVhdGlvbjogQWxsZGF5Q3JlYXRpb24sXG4gICAgQWxsZGF5Q3JlYXRpb25HdWlkZTogQWxsZGF5Q3JlYXRpb25HdWlkZSxcbiAgICBBbGxkYXlNb3ZlOiBBbGxkYXlNb3ZlLFxuICAgIEFsbGRheU1vdmVHdWlkZTogQWxsZGF5TW92ZUd1aWRlLFxuICAgIEFsbGRheVJlc2l6ZTogQWxsZGF5UmVzaXplLFxuICAgIEFsbGRheVJlc2l6ZUd1aWRlOiBBbGxkYXlSZXNpemVHdWlkZSxcblxuICAgIC8vIG9ubHkgZm9yIHRlc3RcbiAgICBDb250cm9sbGVyRmFjdG9yeTogY29udHJvbGxlckZhY3Rvcnlcbn0pO1xuXG4vKioqKioqKioqKlxuICogU0VSVklDRSBNT0RVTEVcbiAqKioqKioqKioqL1xudmFyIGNhbGVuZGFyQVBJID0gcmVxdWlyZSgnLi9zcmMvanMvZG9vcmF5L2NhbGVuZGFyQVBJJyk7XG52YXIgQVBJID0gcmVxdWlyZSgnLi9zcmMvanMvZG9vcmF5L2NvbnRyb2xsZXIvYXBpJyk7XG52YXIgTWluaUNhbGVuZGFyID0gcmVxdWlyZSgnLi9zcmMvanMvZG9vcmF5L3ZpZXcvbWluaWNhbGVuZGFyJyk7XG52YXIgRG9vcmF5RXZlbnQgPSByZXF1aXJlKCcuL3NyYy9qcy9kb29yYXkvbW9kZWwvZXZlbnQnKTtcbnZhciBDYWxlbmRhcnMgPSByZXF1aXJlKCcuL3NyYy9qcy9kb29yYXkvdmlldy9jYWxlbmRhcnMnKTtcbnZhciBUYXNrVmlldyA9IHJlcXVpcmUoJy4vc3JjL2pzL2Rvb3JheS92aWV3L3Rhc2t2aWV3Jyk7XG52YXIgQ2FsZW5kYXJGb3JtID0gcmVxdWlyZSgnLi9zcmMvanMvZG9vcmF5L3ZpZXcvZm9ybS9jYWxlbmRhcicpO1xuXG4vKiogQG5hbWVzcGFjZSBuZS5kb29yYXkuY2FsZW5kYXIuc2VydmljZSAqL1xuXG5nbG9iYWwubmUudXRpbC5kZWZpbmVOYW1lc3BhY2UoJ25lLmRvb3JheS5jYWxlbmRhci5zZXJ2aWNlJywge1xuICAgIERvb3JheUV2ZW50OiBEb29yYXlFdmVudCxcbiAgICBjYWxlbmRhckFQSTogY2FsZW5kYXJBUEksXG4gICAgQVBJOiBBUEksXG5cbiAgICBNaW5pQ2FsZW5kYXI6IE1pbmlDYWxlbmRhcixcbiAgICBDYWxlbmRhcnM6IENhbGVuZGFycyxcbiAgICBUYXNrVmlldzogVGFza1ZpZXcsXG5cbiAgICBDYWxlbmRhckZvcm06IENhbGVuZGFyRm9ybVxufSk7XG5cbi8qKioqKioqKioqXG4gKiBDYWxlbmRhciBGYWN0b3J5XG4gKioqKioqKioqKi9cblxudmFyIENhbGVuZGFyID0gcmVxdWlyZSgnLi9zcmMvanMvZmFjdG9yeS9jYWxlbmRhcicpO1xudmFyIFNlcnZpY2VDYWxlbmRhciA9IHJlcXVpcmUoJy4vc3JjL2pzL2Rvb3JheS9mYWN0b3J5L2NhbGVuZGFyJyk7XG5cbmdsb2JhbC5uZS5kb29yYXkuY2FsZW5kYXIuT3JpZ2luQ2FsZW5kYXIgPSBmdW5jdGlvbiAob3B0aW9ucywgY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG5ldyBDYWxlbmRhcihvcHRpb25zLCBjb250YWluZXIpO1xufTtcblxuZ2xvYmFsLm5lLmRvb3JheS5jYWxlbmRhci5DYWxlbmRhciA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNvbnRhaW5lcikge1xuICAgIHJldHVybiBuZXcgU2VydmljZUNhbGVuZGFyKG9wdGlvbnMsIGNvbnRhaW5lcik7XG59O1xuXG4iLCIvKiFjb2RlLXNuaXBwZXQgdjEuMC40IHwgTkhOIEVudGVydGFpbm1lbnQqL1xuLyoqKioqKioqKipcbiAqIGFycmF5LmpzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgbW9kdWxlIGhhcyBzb21lIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgYXJyYXkuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGppdW5nLmthbmdAbmhuZW50LmNvbT5cbiAqIEBkZXBlbmRlbmN5IHR5cGUuanNcbiAqL1xuXG4oZnVuY3Rpb24obmUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKCFuZSkge1xuICAgICAgICBuZSA9IHdpbmRvdy5uZSA9IHt9O1xuICAgIH1cbiAgICBpZiAoIW5lLnV0aWwpIHtcbiAgICAgICAgbmUudXRpbCA9IHdpbmRvdy5uZS51dGlsID0ge307XG4gICAgfVxuXG4gICAgdmFyIGFwcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdG9wXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXBcbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICB2YXIgYXJyID0gbmUudXRpbC5yYW5nZSg1KTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGFycik7IC8vIFswLDEsMiwzLDRdXG4gICAgICpcbiAgICAgKiAgIGFyciA9IG5lLnV0aWwucmFuZ2UoMSwgNSk7XG4gICAgICogICBjb25zb2xlLmxvZyhhcnIpOyAvLyBbMSwyLDMsNF1cbiAgICAgKlxuICAgICAqICAgYXJyID0gbmUudXRpbC5yYW5nZSgyLCAxMCwgMik7XG4gICAgICogICBjb25zb2xlLmxvZyhhcnIpOyAvLyBbMiw0LDYsOF1cbiAgICAgKlxuICAgICAqICAgYXJyID0gbmUudXRpbC5yYW5nZSgxMCwgMiwgLTIpO1xuICAgICAqICAgY29uc29sZS5sb2coYXJyKTsgLy8gWzEwLDgsNiw0XVxuICAgICAqL1xuICAgIHZhciByYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgICAgIHZhciBhcnIgPSBbXSxcbiAgICAgICAgICAgIGZsYWc7XG5cbiAgICAgICAgaWYgKG5lLnV0aWwuaXNVbmRlZmluZWQoc3RvcCkpIHtcbiAgICAgICAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RlcCA9IHN0ZXAgfHwgMTtcbiAgICAgICAgZmxhZyA9IHN0ZXAgPCAwID8gLTEgOiAxO1xuICAgICAgICBzdG9wICo9IGZsYWc7XG5cbiAgICAgICAgZm9yKDsgc3RhcnQgKiBmbGFnIDwgc3RvcDsgc3RhcnQgKz0gc3RlcCkge1xuICAgICAgICAgICAgYXJyLnB1c2goc3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fVxuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIHZhciByZXN1bHQgPSBuZS51dGlsLnppcChbMSwgMiwgM10sIFsnYScsICdiJywnYyddLCBbdHJ1ZSwgZmFsc2UsIHRydWVdKTtcbiAgICAgKlxuICAgICAqICAgY29uc29sZS5sb2cocmVzdWx0WzBdKTsgLy8gWzEsICdhJywgdHJ1ZV1cbiAgICAgKiAgIGNvbnNvbGUubG9nKHJlc3VsdFsxXSk7IC8vIFsyLCAnYicsIGZhbHNlXVxuICAgICAqICAgY29uc29sZS5sb2cocmVzdWx0WzJdKTsgLy8gWzMsICdjJywgdHJ1ZV1cbiAgICAgKi9cbiAgICB2YXIgemlwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcnIyZCA9IGFwcy5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgICBuZS51dGlsLmZvckVhY2goYXJyMmQsIGZ1bmN0aW9uKGFycikge1xuICAgICAgICAgICAgbmUudXRpbC5mb3JFYWNoKGFyciwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBuZS51dGlsLnJhbmdlID0gcmFuZ2U7XG4gICAgbmUudXRpbC56aXAgPSB6aXA7XG59KSh3aW5kb3cubmUpO1xuLyoqKioqKioqKipcbiAqIGJyb3dzZXIuanNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBtb2R1bGUgZGV0ZWN0cyB0aGUga2luZCBvZiB3ZWxsLWtub3duIGJyb3dzZXIgYW5kIHZlcnNpb24uXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGUwMjQyQG5obmVudC5jb20+XG4gKiBAbmFtZXNwYWNlIG5lLnV0aWxcbiAqL1xuXG4oZnVuY3Rpb24obmUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFuZSkge1xuICAgICAgICBuZSA9IHdpbmRvdy5uZSA9IHt9O1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIW5lLnV0aWwpIHtcbiAgICAgICAgbmUudXRpbCA9IHdpbmRvdy5uZS51dGlsID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBvYmplY3QgaGFzIGFuIGluZm9ybWF0aW9uIHRoYXQgaW5kaWNhdGUgdGhlIGtpbmQgb2YgYnJvd3Nlci48YnI+XG4gICAgICogVGhlIGxpc3QgYmVsb3cgaXMgYSBkZXRlY3RhYmxlIGJyb3dzZXIgbGlzdC5cbiAgICAgKiAgLSBpZTcgfiBpZTExXG4gICAgICogIC0gY2hyb21lXG4gICAgICogIC0gZmlyZWZveFxuICAgICAqICAtIHNhZmFyaVxuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgbmUudXRpbC5icm93c2VyLmNocm9tZSA9PT0gdHJ1ZTsgICAgLy8gY2hyb21lXG4gICAgICogIG5lLnV0aWwuYnJvd3Nlci5maXJlZm94ID09PSB0cnVlOyAgICAvLyBmaXJlZm94XG4gICAgICogIG5lLnV0aWwuYnJvd3Nlci5zYWZhcmkgPT09IHRydWU7ICAgIC8vIHNhZmFyaVxuICAgICAqICBuZS51dGlsLmJyb3dzZXIubXNpZSA9PT0gdHJ1ZTsgICAgLy8gSUVcbiAgICAgKiAgbmUudXRpbC5icm93c2VyLm90aGVyID09PSB0cnVlOyAgICAvLyBvdGhlciBicm93c2VyXG4gICAgICogIG5lLnV0aWwuYnJvd3Nlci52ZXJzaW9uOyAgICAvLyBicm93c2VyIHZlcnNpb25cbiAgICAgKi9cbiAgICB2YXIgYnJvd3NlciA9IHtcbiAgICAgICAgY2hyb21lOiBmYWxzZSxcbiAgICAgICAgZmlyZWZveDogZmFsc2UsXG4gICAgICAgIHNhZmFyaTogZmFsc2UsXG4gICAgICAgIG1zaWU6IGZhbHNlLFxuICAgICAgICBvdGhlcnM6IGZhbHNlLFxuICAgICAgICB2ZXJzaW9uOiAwXG4gICAgfTtcblxuICAgIHZhciBuYXYgPSB3aW5kb3cubmF2aWdhdG9yLFxuICAgICAgICBhcHBOYW1lID0gbmF2LmFwcE5hbWUucmVwbGFjZSgvXFxzL2csICdfJyksXG4gICAgICAgIHVzZXJBZ2VudCA9IG5hdi51c2VyQWdlbnQ7XG5cbiAgICB2YXIgcklFID0gL01TSUVcXHMoWzAtOV0rWy4wLTldKikvLFxuICAgICAgICBySUUxMSA9IC9UcmlkZW50LipydjoxMVxcLi8sXG4gICAgICAgIHZlcnNpb25SZWdleCA9IHtcbiAgICAgICAgICAgICdmaXJlZm94JzogL0ZpcmVmb3hcXC8oXFxkKylcXC4vLFxuICAgICAgICAgICAgJ2Nocm9tZSc6IC9DaHJvbWVcXC8oXFxkKylcXC4vLFxuICAgICAgICAgICAgJ3NhZmFyaSc6IC9WZXJzaW9uXFwvKFtcXGRcXC5dKylcXHNTYWZhcmlcXC8oXFxkKykvXG4gICAgICAgIH07XG5cbiAgICB2YXIga2V5LCB0bXA7XG5cbiAgICB2YXIgZGV0ZWN0b3IgPSB7XG4gICAgICAgICdNaWNyb3NvZnRfSW50ZXJuZXRfRXhwbG9yZXInOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGllOCB+IGllMTBcbiAgICAgICAgICAgIGJyb3dzZXIubXNpZSA9IHRydWU7XG4gICAgICAgICAgICBicm93c2VyLnZlcnNpb24gPSBwYXJzZUZsb2F0KHVzZXJBZ2VudC5tYXRjaChySUUpWzFdKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ05ldHNjYXBlJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGV0ZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHJJRTExLmV4ZWModXNlckFnZW50KSkge1xuICAgICAgICAgICAgICAgIGJyb3dzZXIubXNpZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJvd3Nlci52ZXJzaW9uID0gMTE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHZlcnNpb25SZWdleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmVyc2lvblJlZ2V4Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IHVzZXJBZ2VudC5tYXRjaCh2ZXJzaW9uUmVnZXhba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1wICYmIHRtcC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJvd3NlcltrZXldID0gZGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyb3dzZXIudmVyc2lvbiA9IHBhcnNlRmxvYXQodG1wWzFdIHx8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZXRlY3RlZCkge1xuICAgICAgICAgICAgICAgIGJyb3dzZXIub3RoZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBkZXRlY3RvclthcHBOYW1lXSgpO1xuICAgIG5lLnV0aWwuYnJvd3NlciA9IGJyb3dzZXI7XG59KSh3aW5kb3cubmUpO1xuXG4vKioqKioqKioqKlxuICogY29sbGVjdGlvbi5qc1xuICoqKioqKioqKiovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIG1vZHVsZSBoYXMgc29tZSBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIG9iamVjdCBhcyBjb2xsZWN0aW9uLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxlMDI0MkBuaG5lbnQuY29tPlxuICogQGRlcGVuZGVuY3kgdHlwZS5qcywgb2JqZWN0LmpzXG4gKi9cblxuKGZ1bmN0aW9uKG5lKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGlmICghbmUpIHtcbiAgICAgICAgbmUgPSB3aW5kb3cubmUgPSB7fTtcbiAgICB9XG4gICAgaWYgKCFuZS51dGlsKSB7XG4gICAgICAgIG5lLnV0aWwgPSB3aW5kb3cubmUudXRpbCA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgdmFyaWFibGUgc2F2ZXMgd2hldGhlciB0aGUgJ2luZGV4T2YnIG1ldGhvZCBpcyBpbiBBcnJheS5wcm90b3R5cGUgb3Igbm90Ljxicj5cbiAgICAgKiBBbmQgaXQgd2lsbCBiZSBjaGVja2VkIG9ubHkgb25jZSB3aGVuIHRoZSBwYWdlIGlzIGxvYWRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB2YXIgaGFzSW5kZXhPZiA9ICEhQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBvbmNlIGZvciBlYWNoIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkob3IgQXJyYXktbGlrZSBvYmplY3QpIGluIGFzY2VuZGluZyBvcmRlci48YnI+XG4gICAgICogSWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UsIHRoZSBsb29wIHdpbGwgYmUgc3RvcHBlZC48YnI+XG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb24oaXRlcmF0ZWUpIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogIC0gVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50XG4gICAgICogIC0gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50XG4gICAgICogIC0gVGhlIGFycmF5KG9yIEFycmF5LWxpa2Ugb2JqZWN0KSBiZWluZyB0cmF2ZXJzZWRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgVGhlIGFycmF5KG9yIEFycmF5LWxpa2Ugb2JqZWN0KSB0aGF0IHdpbGwgYmUgdHJhdmVyc2VkXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQodGhpcykgb2YgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciBzdW0gPSAwO1xuICAgICAqXG4gICAgICogIGZvckVhY2hBcnJheShbMSwyLDNdLCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICogICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICogICB9KTtcbiAgICAgKiAgYWxlcnQoc3VtKTsgLy8gNlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hBcnJheShhcnIsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IG51bGw7XG5cbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoaXRlcmF0ZWUuY2FsbChjb250ZXh0LCBhcnJbaW5kZXhdLCBpbmRleCwgYXJyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBvYmplY3Qgd2hpY2ggYWN0dWFsbHkgZXhpc3QuPGJyPlxuICAgICAqIElmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIGZhbHNlLCB0aGUgbG9vcCB3aWxsIGJlIHN0b3BwZWQuPGJyPlxuICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uKGl0ZXJhdGVlKSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICAtIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiAgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiAgLSBUaGUgb2JqZWN0IGJlaW5nIHRyYXZlcnNlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgdHJhdmVyc2VkXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0KHRoaXMpIG9mIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG5lLnV0aWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICB2YXIgc3VtID0gMDtcbiAgICAgKlxuICAgICAqICBmb3JFYWNoT3duUHJvcGVydGllcyh7YToxLGI6MixjOjN9LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICogICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICogIH0pO1xuICAgICAqICBhbGVydChzdW0pOyAvLyA2XG4gICAgICoqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hPd25Qcm9wZXJ0aWVzKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGtleTtcblxuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBudWxsO1xuXG4gICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdGVlLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBvYmplY3Qob3IgZWxlbWVudCBvZiBhcnJheSkgd2hpY2ggYWN0dWFsbHkgZXhpc3QuPGJyPlxuICAgICAqIElmIHRoZSBvYmplY3QgaXMgQXJyYXktbGlrZSBvYmplY3QoZXgtYXJndW1lbnRzIG9iamVjdCksIEl0IG5lZWRzIHRvIHRyYW5zZm9ybSB0byBBcnJheS4oc2VlICdleDInIG9mIGV4YW1wbGUpLjxicj5cbiAgICAgKiBJZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSwgdGhlIGxvb3Agd2lsbCBiZSBzdG9wcGVkLjxicj5cbiAgICAgKiBDYWxsYmFjayBmdW5jdGlvbihpdGVyYXRlZSkgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAgLSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5KG9yIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudClcbiAgICAgKiAgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkob3IgVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50KVxuICAgICAqICAtIFRoZSBvYmplY3QgYmVpbmcgdHJhdmVyc2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRoYXQgd2lsbCBiZSB0cmF2ZXJzZWRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ29udGV4dCh0aGlzKSBvZiBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgLy9leDFcbiAgICAgKiAgdmFyIHN1bSA9IDA7XG4gICAgICpcbiAgICAgKiAgZm9yRWFjaChbMSwyLDNdLCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICogICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICogIH0pO1xuICAgICAqICBhbGVydChzdW0pOyAvLyA2XG4gICAgICpcbiAgICAgKiAgLy9leDIgLSBJbiBjYXNlIG9mIEFycmF5LWxpa2Ugb2JqZWN0XG4gICAgICogIGZ1bmN0aW9uIHN1bSgpe1xuICAgICAqICAgICAgdmFyIGZhY3RvcnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAqICAgICAgZm9yRWFjaChmYWN0b3JzLCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICogICAgICAgICAgIC8vLi4uLi4uXG4gICAgICogICAgICB9KTtcbiAgICAgKiAgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2gob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICBpZiAobmUudXRpbC5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIG5lLnV0aWwuZm9yRWFjaEFycmF5KG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmUudXRpbC5mb3JFYWNoT3duUHJvcGVydGllcyhvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIG9uY2UgZm9yIGVhY2ggZWxlbWVudCBpbiBhbiBhcnJheSwgaW4gb3JkZXIsIGFuZCBjb25zdHJ1Y3RzIGEgbmV3IGFycmF5IGZyb20gdGhlIHJlc3VsdHMuPGJyPlxuICAgICAqIElmIHRoZSBvYmplY3QgaXMgQXJyYXktbGlrZSBvYmplY3QoZXgtYXJndW1lbnRzIG9iamVjdCksIEl0IG5lZWRzIHRvIHRyYW5zZm9ybSB0byBBcnJheS4oc2VlICdleDInIG9mIGZvckVhY2ggZXhhbXBsZSk8YnI+XG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb24oaXRlcmF0ZWUpIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogIC0gVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eShvciBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQpXG4gICAgICogIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5KG9yIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudClcbiAgICAgKiAgLSBUaGUgb2JqZWN0IGJlaW5nIHRyYXZlcnNlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgdHJhdmVyc2VkXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQodGhpcykgb2YgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IGNvbXBvc2VkIG9mIHJldHVybmVkIHZhbHVlcyBmcm9tIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG5lLnV0aWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICB2YXIgcmVzdWx0ID0gbWFwKFswLDEsMiwzXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICAgIHJldHVybiB2YWx1ZSArIDE7XG4gICAgICogIH0pO1xuICAgICAqXG4gICAgICogIGFsZXJ0KHJlc3VsdCk7ICAvLyAxLDIsMyw0XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHJlc3VsdEFycmF5ID0gW107XG5cbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgbnVsbDtcblxuICAgICAgICBuZS51dGlsLmZvckVhY2gob2JqLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlc3VsdEFycmF5LnB1c2goaXRlcmF0ZWUuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRBcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBvbmNlIGZvciBlYWNoIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkob3IgQXJyYXktbGlrZSBvYmplY3Qgb3IgcGxhaW4gb2JqZWN0KS48YnI+XG4gICAgICogSWYgdGhlIG9iamVjdCBpcyBBcnJheS1saWtlIG9iamVjdChleC1hcmd1bWVudHMgb2JqZWN0KSwgSXQgbmVlZHMgdG8gdHJhbnNmb3JtIHRvIEFycmF5LihzZWUgJ2V4Micgb2YgZm9yRWFjaCBleGFtcGxlKTxicj5cbiAgICAgKiBDYWxsYmFjayBmdW5jdGlvbihpdGVyYXRlZSkgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICAgICAqICAtIFRoZSBwcmV2aW91c1ZhbHVlXG4gICAgICogIC0gVGhlIGN1cnJlbnRWYWx1ZVxuICAgICAqICAtIFRoZSBpbmRleFxuICAgICAqICAtIFRoZSBvYmplY3QgYmVpbmcgdHJhdmVyc2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRoYXQgd2lsbCBiZSB0cmF2ZXJzZWRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ29udGV4dCh0aGlzKSBvZiBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0IHZhbHVlXG4gICAgICogQG1lbWJlcm9mIG5lLnV0aWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICB2YXIgcmVzdWx0ID0gcmVkdWNlKFswLDEsMiwzXSwgZnVuY3Rpb24oc3RvcmVkLCB2YWx1ZSkge1xuICAgICAqICAgICAgcmV0dXJuIHN0b3JlZCArIHZhbHVlO1xuICAgICAqICB9KTtcbiAgICAgKlxuICAgICAqICBhbGVydChyZXN1bHQpOyAvLyA2XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGtleXMsXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICBzdG9yZTtcblxuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBudWxsO1xuXG4gICAgICAgIGlmICghbmUudXRpbC5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGtleXMgPSBuZS51dGlsLmtleXMob2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aCA9IGtleXMgPyBrZXlzLmxlbmd0aCA6IG9iai5sZW5ndGg7XG5cbiAgICAgICAgc3RvcmUgPSBvYmpba2V5cyA/IGtleXNbaW5kZXgrK10gOiBpbmRleCsrXTtcblxuICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHN0b3JlID0gaXRlcmF0ZWUuY2FsbChjb250ZXh0LCBzdG9yZSwgb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RvcmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSB0aGUgQXJyYXktbGlrZSBvYmplY3QgdG8gQXJyYXkuPGJyPlxuICAgICAqIEluIGxvdyBJRSAoYmVsb3cgOCksIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsIGlzIG5vdCBwZXJmZWN0LiBTbywgdHJ5LWNhdGNoIHN0YXRlbWVudCBpcyB1c2VkLlxuICAgICAqIEBwYXJhbSB7Kn0gYXJyYXlMaWtlIEFycmF5LWxpa2Ugb2JqZWN0XG4gICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5XG4gICAgICogQG1lbWJlcm9mIG5lLnV0aWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICB2YXIgYXJyYXlMaWtlID0ge1xuICAgICAqICAgICAgMDogJ29uZScsXG4gICAgICogICAgICAxOiAndHdvJyxcbiAgICAgKiAgICAgIDI6ICd0aHJlZScsXG4gICAgICogICAgICAzOiAnZm91cicsXG4gICAgICogICAgICBsZW5ndGg6IDRcbiAgICAgKiAgfTtcbiAgICAgKiAgdmFyIHJlc3VsdCA9IHRvQXJyYXkoYXJyYXlMaWtlKTtcbiAgICAgKlxuICAgICAqICBhbGVydChyZXN1bHQgaW5zdGFuY2VvZiBBcnJheSk7IC8vIHRydWVcbiAgICAgKiAgYWxlcnQocmVzdWx0KTsgLy8gb25lLHR3byx0aHJlZSxmb3VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheShhcnJheUxpa2UpIHtcbiAgICAgICAgdmFyIGFycjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFyciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5TGlrZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGFyciA9IFtdO1xuICAgICAgICAgICAgZm9yRWFjaEFycmF5KGFycmF5TGlrZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBhcnJheSBvciBwbGFpbiBvYmplY3Qgd2l0aCBhbGwgZWxlbWVudHMob3IgcHJvcGVydGllcykgdGhhdCBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi48YnI+XG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb24oaXRlcmF0ZWUpIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogIC0gVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eShvciBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQpXG4gICAgICogIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5KG9yIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudClcbiAgICAgKiAgLSBUaGUgb2JqZWN0IGJlaW5nIHRyYXZlcnNlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0KHBsYWluIG9iamVjdCBvciBBcnJheSkgdGhhdCB3aWxsIGJlIHRyYXZlcnNlZFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0KHRoaXMpIG9mIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge09iamVjdH0gcGxhaW4gb2JqZWN0IG9yIEFycmF5XG4gICAgICogQG1lbWJlcm9mIG5lLnV0aWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICB2YXIgcmVzdWx0MSA9IGZpbHRlcihbMCwxLDIsM10sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICAgICByZXR1cm4gKHZhbHVlICUgMiA9PT0gMCk7XG4gICAgICogIH0pO1xuICAgICAqICBhbGVydChyZXN1bHQxKTsgLy8gMCwyXG4gICAgICpcbiAgICAgKiAgdmFyIHJlc3VsdDIgPSBmaWx0ZXIoe2EgOiAxLCBiOiAyLCBjOiAzfSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICAgIHJldHVybiAodmFsdWUgJSAyICE9PSAwKTtcbiAgICAgKiAgfSk7XG4gICAgICogIGFsZXJ0KHJlc3VsdDIuYSk7IC8vIDFcbiAgICAgKiAgYWxlcnQocmVzdWx0Mi5iKTsgLy8gdW5kZWZpbmVkXG4gICAgICogIGFsZXJ0KHJlc3VsdDIuYyk7IC8vIDNcbiAgICAgKi9cbiAgICB2YXIgZmlsdGVyID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgYWRkO1xuXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IG51bGw7XG5cbiAgICAgICAgaWYgKCFuZS51dGlsLmlzT2JqZWN0KG9iaikgfHwgIW5lLnV0aWwuaXNGdW5jdGlvbihpdGVyYXRlZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignd3JvbmcgcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmUudXRpbC5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgYWRkID0gZnVuY3Rpb24ocmVzdWx0LCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJnc1swXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBhZGQgPSBmdW5jdGlvbihyZXN1bHQsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbYXJnc1sxXV0gPSBhcmdzWzBdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5lLnV0aWwuZm9yRWFjaChvYmosIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGl0ZXJhdGVlLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cykpIHtcbiAgICAgICAgICAgICAgICBhZGQocmVzdWx0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBjb250ZXh0KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBhcnJheSBmcm9tIHN0YXJ0IGluZGV4KGRlZmF1bHQgMCksIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50Ljxicj5cbiAgICAgKiBJdCBjb21wYXJlcyBzZWFyY2hFbGVtZW50IHRvIGVsZW1lbnRzIG9mIHRoZSBBcnJheSB1c2luZyBzdHJpY3QgZXF1YWxpdHkgKHRoZSBzYW1lIG1ldGhvZCB1c2VkIGJ5IHRoZSA9PT0sIG9yIHRyaXBsZS1lcXVhbHMsIG9wZXJhdG9yKS5cbiAgICAgKiBAcGFyYW0geyp9IHNlYXJjaEVsZW1lbnQgRWxlbWVudCB0byBsb2NhdGUgaW4gdGhlIGFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdGhhdCB3aWxsIGJlIHRyYXZlcnNlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCBTdGFydCBpbmRleCBpbiBhcnJheSBmb3Igc2VhcmNoaW5nIChkZWZhdWx0IDApXG4gICAgICogQG1lbWJlcm9mIG5lLnV0aWxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBGaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgdmFyIGFyciA9IFsnb25lJywgJ3R3bycsICd0aHJlZScsICdmb3VyJ10sXG4gICAgICogICAgICAgaWR4MSxcbiAgICAgKiAgICAgICBpZHgyO1xuICAgICAqXG4gICAgICogICBpZHgxID0gbmUudXRpbC5pbkFycmF5KCdvbmUnLCBhcnIsIDMpO1xuICAgICAqICAgYWxlcnQoaWR4MSk7IC8vIC0xXG4gICAgICpcbiAgICAgKiAgIGlkeDIgPSBuZS51dGlsLmluQXJyYXkoJ29uZScsIGFycik7XG4gICAgICogICBhbGVydChpZHgyKTsgLy8gMFxuICAgICAqL1xuICAgIHZhciBpbkFycmF5ID0gZnVuY3Rpb24oc2VhcmNoRWxlbWVudCwgYXJyYXksIHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgaWYgKCFuZS51dGlsLmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzSW5kZXhPZikge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYXJyYXksIHNlYXJjaEVsZW1lbnQsIHN0YXJ0SW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgICAgLy8gc2V0IHN0YXJ0SW5kZXhcbiAgICAgICAgaWYgKG5lLnV0aWwuaXNVbmRlZmluZWQoc3RhcnRJbmRleCkpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0SW5kZXggPj0gbGVuZ3RoIHx8IHN0YXJ0SW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWFyY2hcbiAgICAgICAgZm9yIChpID0gc3RhcnRJbmRleDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZmV0Y2hpbmcgYSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyciB0YXJnZXQgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gcHJvcGVydHkgcHJvcGVydHkgbmFtZVxuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogICB2YXIgb2JqQXJyID0gW1xuICAgICAqICAgICAgICAgeydhYmMnOiAxLCAnZGVmJzogMiwgJ2doaSc6IDN9LFxuICAgICAqICAgICAgICAgeydhYmMnOiA0LCAnZGVmJzogNSwgJ2doaSc6IDZ9LFxuICAgICAqICAgICAgICAgeydhYmMnOiA3LCAnZGVmJzogOCwgJ2doaSc6IDl9XG4gICAgICogICAgICAgXSxcbiAgICAgKiAgICAgICBhcnIyZCA9IFtcbiAgICAgKiAgICAgICAgIFsxLCAyLCAzXSxcbiAgICAgKiAgICAgICAgIFs0LCA1LCA2XSxcbiAgICAgKiAgICAgICAgIFs3LCA4LCA5XVxuICAgICAqICAgICAgIF0sXG4gICAgICogICAgICAgcmVzdWx0O1xuICAgICAqXG4gICAgICogICByZXN1bHQgPSBuZS51dGlsLnBsdWNrKG9iakFyciwgJ2FiYycpO1xuICAgICAqICAgY29uc29sZS5sb2cocmVzdWx0KSAvLyBbMSwgNCwgN11cbiAgICAgKlxuICAgICAqICAgcmVzdWx0ID0gbmUudXRpbC5wbHVjayhhcnIyZCwgMik7XG4gICAgICogICBjb25zb2xlLmxvZyhyZXN1bHQpIC8vIFszLCA2LCA5XVxuICAgICAqL1xuICAgIHZhciBwbHVjayA9IGZ1bmN0aW9uKGFyciwgcHJvcGVydHkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5lLnV0aWwubWFwKGFyciwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1bcHJvcGVydHldO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgbmUudXRpbC5mb3JFYWNoT3duUHJvcGVydGllcyA9IGZvckVhY2hPd25Qcm9wZXJ0aWVzO1xuICAgIG5lLnV0aWwuZm9yRWFjaEFycmF5ID0gZm9yRWFjaEFycmF5O1xuICAgIG5lLnV0aWwuZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbmUudXRpbC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBuZS51dGlsLm1hcCA9IG1hcDtcbiAgICBuZS51dGlsLnJlZHVjZSA9IHJlZHVjZTtcbiAgICBuZS51dGlsLmZpbHRlciA9IGZpbHRlcjtcbiAgICBuZS51dGlsLmluQXJyYXkgPSBpbkFycmF5O1xuICAgIG5lLnV0aWwucGx1Y2sgPSBwbHVjaztcblxufSkod2luZG93Lm5lKTtcblxuLyoqKioqKioqKipcbiAqIGN1c3RvbUV2ZW50LmpzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiAgVGhpcyBtb2R1bGUgcHJvdmlkZXMgc29tZSBmdW5jdGlvbnMgZm9yIGN1c3RvbSBldmVudHMuPGJyPlxuICogIEFuZCBpdCBpcyBpbXBsZW1lbnRlZCBpbiB0aGUgb2JzZXJ2ZXIgZGVzaWduIHBhdHRlcm4uXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGUwMjQyQG5obmVudC5jb20+XG4gKiBAZGVwZW5kZW5jeSB0eXBlLmpzLCBjb2xsZWN0aW9uLmpzIG9iamVjdC5qc1xuICovXG5cbihmdW5jdGlvbihuZSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIW5lKSB7XG4gICAgICAgIG5lID0gd2luZG93Lm5lID0ge307XG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFuZS51dGlsKSB7XG4gICAgICAgIG5lLnV0aWwgPSB3aW5kb3cubmUudXRpbCA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgdW5pdCBvZiBldmVudCBoYW5kbGVyIGl0ZW0uXG4gICAgICogQGlnbm9yZVxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IGhhbmRsZXJJdGVtXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gZm4gLSBldmVudCBoYW5kbGVyXG4gICAgICogQHByb3BlcnR5IHsqfSBjdHggLSBjb250ZXh0IG9mIGV2ZW50IGhhbmRsZXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZGF0YSBzdHJ1Y3R1cmUgZm9yIHN0b3JpbmcgaGFuZGxlckl0ZW1zIGJvdW5kIHdpdGggYSBzcGVjaWZpYyBjb250ZXh0XG4gICAgICogIGFuZCBpcyBhIHVuaXQgaXRlbSBvZiBjdHhFdmVudHMuPGJyPlxuICAgICAqIEhhbmRsZXJzIGluIHRoaXMgaXRlbSwgd2lsbCBiZSBleGVjdXRlZCB3aXRoIHNhbWUgZXZlbnQuXG4gICAgICogQGlnbm9yZVxuICAgICAqIEB0eXBlZGVmIHtPYmplY3QuPHN0cmluZywgaGFuZGxlckl0ZW0+fSBjdHhFdmVudHNJdGVtXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgY3R4RXZlbnRzSXRlbSA9IHtcbiAgICAgKiAgICAgIDFfMToge1xuICAgICAqICAgICAgICAgIGZuOiBmdW5jdGlvbigpey4uLn0sXG4gICAgICogICAgICAgICAgY3R4OiBjb250ZXh0MVxuICAgICAqICAgICAgfSxcbiAgICAgKiAgICAgIDJfMToge1xuICAgICAqICAgICAgICAgIGZuOiBmdW5jdGlvbigpey4uLn0sXG4gICAgICogICAgICAgICAgY3R4OiBjb250ZXh0MVxuICAgICAqICAgICAgfVxuICAgICAqICB9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGRhdGEgc3RydWN0dXJlIGZvciBzdG9yaW5nIGN0eEV2ZW50c0l0ZW0gYW5kIGxlbmd0aCBmb3IgZWFjaCBldmVudChvciBldmVudCBuYW1lKS5cbiAgICAgKiBAaWdub3JlXG4gICAgICogQHR5cGVkZWYge09iamVjdC48c3RyaW5nLCAoY3R4RXZlbnRzSXRlbXxudW1iZXIpPn0gY3R4RXZlbnRzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgY3R4RXZlbnRzID0ge1xuICAgICAqICAgICAgZXZlbnROYW1lMV9pZHg6IHtcbiAgICAgKiAgICAgICAgICAxXzE6IHtcbiAgICAgKiAgICAgICAgICAgICAgZm46IGZ1bmN0aW9uKCl7Li4ufSxcbiAgICAgKiAgICAgICAgICAgICAgY3R4OiBjb250ZXh0MVxuICAgICAqICAgICAgICAgIH0sXG4gICAgICogICAgICAgICAgMl8xOiB7XG4gICAgICogICAgICAgICAgICAgIGZuOiBmdW5jdGlvbigpey4uLn0sXG4gICAgICogICAgICAgICAgICAgIGN0eDogY29udGV4dDFcbiAgICAgKiAgICAgICAgICB9XG4gICAgICogICAgICB9LFxuICAgICAqICAgICAgZXZlbnROYW1lMV9sZW46IDIsXG4gICAgICogICAgICBldmVudE5hbWUyX2lkeDoge1xuICAgICAqICAgICAgICAgIDNfMjoge1xuICAgICAqICAgICAgICAgICAgICBmbjogZnVuY3Rpb24oKXsuLi59LFxuICAgICAqICAgICAgICAgICAgICBjdHg6IGNvbnRleHQyXG4gICAgICogICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgICA0XzI6IHtcbiAgICAgKiAgICAgICAgICAgICAgZm46IGZ1bmN0aW9uKCl7Li4ufSxcbiAgICAgKiAgICAgICAgICAgICAgY3R4OiBjb250ZXh0MlxuICAgICAqICAgICAgICAgIH1cbiAgICAgKiAgICAgIH0sXG4gICAgICogICAgICBldmVudE5hbWUyX2xlbjogMlxuICAgICAqICB9O1xuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50cygpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhY2hpbmcgYSBkYXRhIHN0cnVjdHVyZSB0aGF0IGhhcyBub3JtYWwgZXZlbnQgaGFuZGxlcnMgd2hpY2ggYXJlIG5vdCBib3VuZCB3aXRoIGEgc3BlY2lmaWMgY29udGV4dC5cbiAgICAgICAgICogQHR5cGUge29iamVjdC48c3RyaW5nLCBoYW5kbGVySXRlbVtdPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhY2hpbmcgYSB7Y3R4RXZlbnRzfVxuICAgICAgICAgKiBAdHlwZSB7Y3R4RXZlbnRzfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY3R4RXZlbnRzID0gbnVsbDtcbiAgICB9XG5cblxuICAgIC8qKioqKioqKioqXG4gICAgICogc3RhdGljXG4gICAgICoqKioqKioqKiovXG5cbiAgICAvKipcbiAgICAgKiBVc2UgZm9yIG1ha2luZyBhIGNvbnN0cnVjdG9yIHRvIGJlIGFibGUgdG8gZG8gQ3VzdG9tRXZlbnQncyBmdW5jdGlvbnMuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyAtIENvbnN0cnVjdG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgZnVuY3Rpb24gTW9kZWwoKSB7XG4gICAgICogICAgICB0aGlzLm5hbWUgPSAnJztcbiAgICAgKiAgfVxuICAgICAqICBuZS51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihNb2RlbCk7XG4gICAgICpcbiAgICAgKiAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKCk7XG4gICAgICogIG1vZGVsLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHsgdGhpcy5uYW1lID0gJ21vZGVsJzsgfSwgdGhpcyk7XG4gICAgICogIG1vZGVsLmZpcmUoJ2NoYW5nZScpO1xuICAgICAqICBhbGVydChtb2RlbC5uYW1lKTsgLy8gJ21vZGVsJztcbiAgICAgKi9cbiAgICBDdXN0b21FdmVudHMubWl4aW4gPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgIG5lLnV0aWwuZXh0ZW5kKGZ1bmMucHJvdG90eXBlLCBDdXN0b21FdmVudHMucHJvdG90eXBlKTtcbiAgICB9O1xuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiBwcml2YXRlXG4gICAgICoqKioqKioqKiovXG5cbiAgICAvKipcbiAgICAgKiBXb3JrIHNpbWlsYXJseSB0byBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCgpLFxuICAgICAqICBob3dldmVyIGRvZXMgQXJyYXkucHJvdG90eXBlLnNwbGljZSgpIGFkZGl0aW9uYWxseS48YnI+XG4gICAgICogQ2FsbGJhY2soaXRlcmF0ZWUpIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAgICAgKiAgLSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnRcbiAgICAgKiAgLSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnRcbiAgICAgKiAgLSBUaGUgYXJyYXkgYmVpbmcgdHJhdmVyc2VkXG4gICAgICogIC0gQSBzcGVjaWFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZGVjcmVhc2VzIHRoZSBsZW5ndGggb2YgYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgLSBBcnJheSB0aGF0IHdpbGwgYmUgdHJhdmVyc2VkXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgLSBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqL1xuICAgIEN1c3RvbUV2ZW50cy5wcm90b3R5cGUuX2ZvckVhY2hBcnJheVNwbGljZSA9IGZ1bmN0aW9uKGFyciwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsZW4sXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgZGVjcmVhc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhcnIuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAxO1xuICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFuZS51dGlsLmlzRXhpc3R5KGFycikgfHwgIW5lLnV0aWwuaXNBcnJheShhcnIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBhcnJbaV07XG5cbiAgICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVtLCBpLCBhcnIsIGRlY3JlYXNlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiBjb250ZXh0IGV2ZW50IGhhbmRsZXJcbiAgICAgKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIGNhbGxiYWNrIG9uY2UgZm9yIGVhY2ggY3R4RXZlbnRzSXRlbS48YnI+XG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb24oaXRlcmF0ZWUpIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogIC0ge2N0eEV2ZW50c0l0ZW19IEEgdW5pdCBpdGVtIG9mIGN0eEV2ZW50c1xuICAgICAqICAtIHtzdHJpbmd9IEEga2V5IChleCAtICdldmVudE5hbWVfaWR4JyBvciAnZXZlbnROYW1lX2xlbicpXG4gICAgICogIC0ge2N0eEV2ZW50c30gQSBjdHhFdmVudHMgYmVpbmcgdHJhdmVyc2VkXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgLSBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ3VzdG9tRXZlbnRzLnByb3RvdHlwZS5fZWFjaEN0eEV2ZW50cyA9IGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9jdHhFdmVudHM7XG4gICAgICAgIG5lLnV0aWwuZm9yRWFjaE93blByb3BlcnRpZXMoZXZlbnRzLCBpdGVyYXRlZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIGNhbGxiYWNrIG9uY2VcbiAgICAgKiAgZm9yIGVhY2ggaGFuZGxlciBpdGVtIHRoYXQgaXMgdmFsdWUgb2YgdGhlIGtleSBpbmNsdWRpbmcgYSBzcGVjaWZpYyBzdHJpbmcoPWlkLCBhcmd1bWVudHNbMV0pLjxicj5cbiAgICAgKiBDYWxsYmFjayBmdW5jdGlvbihpdGVyYXRlZSkgaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6XG4gICAgICogIC0gaGFuZGxlckl0ZW1cbiAgICAgKiAgLSBoYW5kbGVySXRlbUlkXG4gICAgICogQHBhcmFtIHtjdHhFdmVudHNJdGVtfSBjdHhFdmVudHNJdGVtIC0gQSBkYXRhIHN0cnVjdHVyZSBzdG9yaW5nIGhhbmRsZXJJdGVtcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBBbiBpZCBvZiBoYW5kbGVyIGZvciBzZWFyY2hpbmdcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDdXN0b21FdmVudHMucHJvdG90eXBlLl9lYWNoQ3R4SGFuZGxlckl0ZW1CeUNvbnRhaW5JZCA9IGZ1bmN0aW9uKGN0eEV2ZW50c0l0ZW0sIGlkLCBpdGVyYXRlZSkge1xuICAgICAgICBuZS51dGlsLmZvckVhY2hPd25Qcm9wZXJ0aWVzKGN0eEV2ZW50c0l0ZW0sIGZ1bmN0aW9uKGhhbmRsZXJJdGVtLCBoYW5kbGVySXRlbUlkKSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlckl0ZW1JZC5pbmRleE9mKGlkKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZWUoaGFuZGxlckl0ZW0sIGhhbmRsZXJJdGVtSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgY2FsbGJhY2sgb25jZVxuICAgICAqICBmb3IgZWFjaCBjYXNlIG9mIHdoZW4gdGhlIHByb3ZpZGVkIGhhbmRsZXIoYXJndW1lbnRzWzBdKSBpcyBlcXVhbCB0byBhIGhhbmRsZXIgaW4gY3R4RXZlbnRzSXRlbS48YnI+XG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb24oaXRlcmF0ZWUpIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAgICAgKiAgLSBoYW5kbGVySXRlbVxuICAgICAqICAtIGhhbmRsZXJJdGVtSWRcbiAgICAgKiAgLSBjdHhFdmVudHNJdGVtXG4gICAgICogIC0gZXZlbnRLZXksIEEgTmFtZSBvZiBjdXN0b20gZXZlbnQgKGV4IC0gJ2V2ZW50TmFtZV9pZHgnKVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSBFdmVudCBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgLSBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ3VzdG9tRXZlbnRzLnByb3RvdHlwZS5fZWFjaEN0eEV2ZW50QnlIYW5kbGVyID0gZnVuY3Rpb24oaGFuZGxlciwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGhhbmRsZXJJZCA9IG5lLnV0aWwuc3RhbXAoaGFuZGxlciksXG4gICAgICAgICAgICBlYWNoQnlJZCA9IHRoaXMuX2VhY2hDdHhIYW5kbGVySXRlbUJ5Q29udGFpbklkO1xuXG4gICAgICAgIHRoaXMuX2VhY2hDdHhFdmVudHMoZnVuY3Rpb24oY3R4RXZlbnRzSXRlbSwgZXZlbnRLZXkpIHtcbiAgICAgICAgICAgIGVhY2hCeUlkKGN0eEV2ZW50c0l0ZW0sIGhhbmRsZXJJZCwgZnVuY3Rpb24oaGFuZGxlckl0ZW0sIGhhbmRsZXJJdGVtSWQpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRlZShoYW5kbGVySXRlbSwgaGFuZGxlckl0ZW1JZCwgY3R4RXZlbnRzSXRlbSwgZXZlbnRLZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBjYWxsYmFjayBvbmNlXG4gICAgICogIGZvciBlYWNoIGNhc2Ugb2Ygd2hlbiB0aGUgcHJvdmlkZWQgY29udGV4dChhcmd1bWVudHNbMF0pIGlzIGVxdWFsIHRvIGEgY29udGV4dCBpbiBjdHhFdmVudHNJdGVtLjxicj5cbiAgICAgKiBDYWxsYmFjayBmdW5jdGlvbihpdGVyYXRlZSkgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICAgICAqICAtIGhhbmRsZXJJdGVtXG4gICAgICogIC0gaGFuZGxlckl0ZW1JZFxuICAgICAqICAtIGN0eEV2ZW50c0l0ZW1cbiAgICAgKiAgLSBldmVudEtleSwgQSBOYW1lIG9mIGN1c3RvbSBldmVudCB3aXRoIHBvc3RmaXggKGV4IC0gJ2V2ZW50TmFtZV9pZHgnKVxuICAgICAqIEBwYXJhbSB7Kn0gY29udGV4dCAtIENvbnRleHQgZm9yIHNlYXJjaGluZ1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEN1c3RvbUV2ZW50cy5wcm90b3R5cGUuX2VhY2hDdHhFdmVudEJ5Q29udGV4dCA9IGZ1bmN0aW9uKGNvbnRleHQsIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBjb250ZXh0SWQgPSBuZS51dGlsLnN0YW1wKGNvbnRleHQpLFxuICAgICAgICAgICAgZWFjaEJ5SWQgPSB0aGlzLl9lYWNoQ3R4SGFuZGxlckl0ZW1CeUNvbnRhaW5JZDtcblxuICAgICAgICB0aGlzLl9lYWNoQ3R4RXZlbnRzKGZ1bmN0aW9uKGN0eEV2ZW50c0l0ZW0sIGV2ZW50S2V5KSB7XG4gICAgICAgICAgICBlYWNoQnlJZChjdHhFdmVudHNJdGVtLCBjb250ZXh0SWQsIGZ1bmN0aW9uKGhhbmRsZXJJdGVtLCBoYW5kbGVySXRlbUlkKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZWUoaGFuZGxlckl0ZW0sIGhhbmRsZXJJdGVtSWQsIGN0eEV2ZW50c0l0ZW0sIGV2ZW50S2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBoYW5kbGVyIG9mIGN0eEV2ZW50c0l0ZW0gb2YgdGhlIHByb3ZpZGVkIGV2ZW50TmFtZShhcmd1bWVudHNbMF0pLjxicj5cbiAgICAgKiBDYWxsYmFjayBmdW5jdGlvbihpdGVyYXRlZSkgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICAgICAqICAtIGhhbmRsZXJJdGVtXG4gICAgICogIC0gaGFuZGxlckl0ZW1JZFxuICAgICAqICAtIGN0eEV2ZW50c0l0ZW1cbiAgICAgKiAgLSBldmVudEtleSwgQSBOYW1lIG9mIGN1c3RvbSBldmVudCB3aXRoIHBvc3RmaXggKGV4IC0gJ2V2ZW50TmFtZV9pZHgnKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBDdXN0b20gZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEN1c3RvbUV2ZW50cy5wcm90b3R5cGUuX2VhY2hDdHhFdmVudEJ5RXZlbnROYW1lID0gZnVuY3Rpb24oZXZlbnROYW1lLCBpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2N0eEV2ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleSA9IHRoaXMuX2dldEN0eEtleShldmVudE5hbWUpLFxuICAgICAgICAgICAgY3R4RXZlbnRzSXRlbSA9IHRoaXMuX2N0eEV2ZW50c1trZXldLFxuICAgICAgICAgICAgYXJncztcblxuICAgICAgICBuZS51dGlsLmZvckVhY2hPd25Qcm9wZXJ0aWVzKGN0eEV2ZW50c0l0ZW0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBhcmdzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIGl0ZXJhdGVlLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiBub3JtYWwgZXZlbnQgaGFuZGxlclxuICAgICAqKioqKioqKioqL1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgY2FsbGJhY2sgb25jZVxuICAgICAqICBmb3IgZWFjaCBoYW5kbGVyIGluIGluc3RhbmNlIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBoYW5kbGVyKGFyZ3VtZW50c1swXSkuPGJyPlxuICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uKGl0ZXJhdGVlKSBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6XG4gICAgICogIC0gaGFuZGxlckl0ZW1cbiAgICAgKiAgLSBpbmRleCBvZiBoYW5kbGVySXRlbSBhcnJheVxuICAgICAqICAtIGV2ZW50TGlzdCBieSBoYW5kbGVyXG4gICAgICogIC0gZXZlbnRLZXksIEEgTmFtZSBvZiBjdXN0b20gZXZlbnQgd2l0aCBwb3N0Zml4IChleCAtICdldmVudE5hbWVfaWR4JylcbiAgICAgKiAgLSBkZWNyZWFzZSwgQSBzcGVjaWFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZGVjcmVhc2VzIHRoZSBsZW5ndGggb2YgYXJyYXkuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIEEgaGFuZGxlciBmb3Igc2VhcmNoaW5nXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgLSBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ3VzdG9tRXZlbnRzLnByb3RvdHlwZS5fZWFjaEV2ZW50QnlIYW5kbGVyID0gZnVuY3Rpb24oaGFuZGxlciwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cyxcbiAgICAgICAgICAgIGZvckVhY2hBcnJheURlY3JlYXNlID0gdGhpcy5fZm9yRWFjaEFycmF5U3BsaWNlLFxuICAgICAgICAgICAgaWR4ID0gMDtcblxuICAgICAgICBuZS51dGlsLmZvckVhY2hPd25Qcm9wZXJ0aWVzKGV2ZW50cywgZnVuY3Rpb24oZXZlbnRMaXN0LCBldmVudEtleSkge1xuICAgICAgICAgICAgZm9yRWFjaEFycmF5RGVjcmVhc2UoZXZlbnRMaXN0LCBmdW5jdGlvbihoYW5kbGVySXRlbSwgaW5kZXgsIGV2ZW50TGlzdCwgZGVjcmVhc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlckl0ZW0uZm4gPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZWUoaGFuZGxlckl0ZW0sIGlkeCwgZXZlbnRMaXN0LCBldmVudEtleSwgZGVjcmVhc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIGNhbGxiYWNrIG9uY2UgZm9yIGVhY2ggaGFuZGxlciBvZiBub3JtYWwgZXZlbnRzIG9mIHRoZSBwcm92aWRlZCBldmVudE5hbWUuPGJyPlxuICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uKGl0ZXJhdGVlKSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gICAgICogIC0gaGFuZGxlclxuICAgICAqICAtIGluZGV4IG9mIGhhbmRsZXItbGlzdFxuICAgICAqICAtIGhhbmRsZXItbGlzdFxuICAgICAqICAtIGRlY3JlYXNlLCBBIHNwZWNpYWwgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBkZWNyZWFzZXMgdGhlIGxlbmd0aCBvZiBhcnJheVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBDdXN0b20gZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEN1c3RvbUV2ZW50cy5wcm90b3R5cGUuX2VhY2hFdmVudEJ5RXZlbnROYW1lID0gZnVuY3Rpb24oZXZlbnROYW1lLCBpdGVyYXRlZSkge1xuICAgICAgICB2YXIgZXZlbnRzO1xuXG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBldmVudHMgPSB0aGlzLl9ldmVudHNbZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKCFuZS51dGlsLmlzRXhpc3R5KGV2ZW50cykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZvckVhY2hBcnJheVNwbGljZShldmVudHMsIGl0ZXJhdGVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IGtleSBmb3Igc2F2aW5nIGEgaGFuZGxlciB3aXRoIGEgY29udGV4dCBpbiBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgQSBldmVudCBuYW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ30gS2V5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDdXN0b21FdmVudHMucHJvdG90eXBlLl9nZXRDdHhLZXkgPSBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50TmFtZSArICdfaWR4JztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IGtleSBmb3Igc2F2aW5nIGxlbmd0aCBvZiBoYW5kbGVycyBpbiBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgQSBldmVudCBuYW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ30gS2V5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDdXN0b21FdmVudHMucHJvdG90eXBlLl9nZXRDdHhMZW5LZXkgPSBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50TmFtZSArICdfbGVuJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IGtleSBmb3Igc3RvcmluZyB0byBjdHhFdmVudHNJdGVtLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgQSBldmVudCBoYW5kbGVyXG4gICAgICogQHBhcmFtIHsqfSBjdHggQSBjb250ZXh0IGluIGhhbmRsZXJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBLZXlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEN1c3RvbUV2ZW50cy5wcm90b3R5cGUuX2dldEhhbmRsZXJLZXkgPSBmdW5jdGlvbihmdW5jLCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIG5lLnV0aWwuc3RhbXAoZnVuYykgKyAnXycgKyBuZS51dGlsLnN0YW1wKGN0eCk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBsZW5ndGggb2YgaGFuZGxlcnMgaW4gY3R4RXZlbnRzSXRlbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGVuS2V5IC0gQSBrZXkgZm9yIHNhdmluZyB0aGUgbGVuZ3RoIG9mIGhhbmRsZXJzIGluIGB0aGlzLl9jdHhFdmVudHNgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoYW5nZSAtIEEgdmFyaWF0aW9uIHZhbHVlIG9mIGxlbmd0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ3VzdG9tRXZlbnRzLnByb3RvdHlwZS5fc2V0Q3R4TGVuID0gZnVuY3Rpb24obGVuS2V5LCBjaGFuZ2UpIHtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2N0eEV2ZW50cztcblxuICAgICAgICBpZiAoIW5lLnV0aWwuaXNFeGlzdHkoZXZlbnRzW2xlbktleV0pKSB7XG4gICAgICAgICAgICBldmVudHNbbGVuS2V5XSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBldmVudHNbbGVuS2V5XSArPSBjaGFuZ2U7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogU3RvcmUgYSB7aGFuZGxlckl0ZW19IHRvIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBDdXN0b20gZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gY29udGV4dCAtIENvbnRleHQgZm9yIGJpbmRpbmdcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gSGFuZGxlciBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ3VzdG9tRXZlbnRzLnByb3RvdHlwZS5fYWRkQ3R4RXZlbnQgPSBmdW5jdGlvbihldmVudE5hbWUsIGNvbnRleHQsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2N0eEV2ZW50cyxcbiAgICAgICAgICAgIGtleSA9IHRoaXMuX2dldEN0eEtleShldmVudE5hbWUpLFxuICAgICAgICAgICAgZXZlbnQ7XG5cbiAgICAgICAgaWYgKCFuZS51dGlsLmlzRXhpc3R5KGV2ZW50cykpIHtcbiAgICAgICAgICAgIGV2ZW50cyA9IHRoaXMuX2N0eEV2ZW50cyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQgPSBldmVudHNba2V5XTtcbiAgICAgICAgaWYgKCFuZS51dGlsLmlzRXhpc3R5KGV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQgPSBldmVudHNba2V5XSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbktleSA9IHRoaXMuX2dldEN0eExlbktleShldmVudE5hbWUpLFxuICAgICAgICAgICAgaGFuZGxlckl0ZW1JZCA9IHRoaXMuX2dldEhhbmRsZXJLZXkoaGFuZGxlciwgY29udGV4dCk7XG5cbiAgICAgICAgZXZlbnRbaGFuZGxlckl0ZW1JZF0gPSB7XG4gICAgICAgICAgICBmbjogaGFuZGxlcixcbiAgICAgICAgICAgIGN0eDogY29udGV4dFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX3NldEN0eExlbihsZW5LZXksICsxKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RvcmUgYSBldmVudCBoYW5kbGVyIHdpdGhvdXQgY29udGV4dCB0byBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gQ3VzdG9tIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gSGFuZGxlciBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ3VzdG9tRXZlbnRzLnByb3RvdHlwZS5fYWRkTm9ybWFsRXZlbnQgPSBmdW5jdGlvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cyxcbiAgICAgICAgICAgIGV2ZW50O1xuXG4gICAgICAgIGlmICghbmUudXRpbC5pc0V4aXN0eShldmVudHMpKSB7XG4gICAgICAgICAgICBldmVudHMgPSB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50ID0gZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgICAgIGlmICghbmUudXRpbC5pc0V4aXN0eShldmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gZXZlbnRzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LnB1c2goeyBmbjogaGFuZGxlciB9KTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBUYWtlIHRoZSBldmVudCBoYW5kbGVyIG9mZiBieSBoYW5kbGVyKGFyZ3VtZW50c1swXSlcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gSGFuZGxlciBmb3Igb2ZmaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDdXN0b21FdmVudHMucHJvdG90eXBlLl9vZmZCeUhhbmRsZXIgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgIHZhciBjdHhFdmVudHMgPSB0aGlzLl9jdHhFdmVudHMsXG4gICAgICAgICAgICBsZW5LZXk7XG5cbiAgICAgICAgdGhpcy5fZWFjaEN0eEV2ZW50QnlIYW5kbGVyKGhhbmRsZXIsIGZ1bmN0aW9uKGhhbmRsZXJJdGVtLCBoYW5JZCwgY3R4SXRlbXMsIGV2ZW50S2V5KSB7XG4gICAgICAgICAgICBsZW5LZXkgPSBldmVudEtleS5yZXBsYWNlKCdfaWR4JywgJ19sZW4nKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjdHhJdGVtc1toYW5JZF07XG4gICAgICAgICAgICBjdHhFdmVudHNbbGVuS2V5XSAtPSAxO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9lYWNoRXZlbnRCeUhhbmRsZXIoaGFuZGxlciwgZnVuY3Rpb24oaGFuZGxlckl0ZW0sIGluZGV4LCBpdGVtcywgZXZlbnRLZXksIGRlY3JlYXNlKSB7XG4gICAgICAgICAgICBpdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgZGVjcmVhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRha2UgdGhlIGV2ZW50IGhhbmRsZXIgb2ZmIGJ5IGNvbnRleHQgd2l0aCBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIHsqfSBjb250ZXh0IC0gQ29udGV4dFxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xmdW5jdGlvbil9IFtldmVudE5hbWVdIC0gQ3VzdG9tIGV2ZW50IG5hbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEN1c3RvbUV2ZW50cy5wcm90b3R5cGUuX29mZkJ5Q29udGV4dCA9IGZ1bmN0aW9uKGNvbnRleHQsIGV2ZW50TmFtZSkge1xuICAgICAgICB2YXIgY3R4RXZlbnRzID0gdGhpcy5fY3R4RXZlbnRzLFxuICAgICAgICAgICAgaGFzQXJncyA9IG5lLnV0aWwuaXNFeGlzdHkoZXZlbnROYW1lKSxcbiAgICAgICAgICAgIG1hdGNoRXZlbnROYW1lLFxuICAgICAgICAgICAgbWF0Y2hIYW5kbGVyLFxuICAgICAgICAgICAgbGVuS2V5O1xuXG4gICAgICAgIHRoaXMuX2VhY2hDdHhFdmVudEJ5Q29udGV4dChjb250ZXh0LCBmdW5jdGlvbihoYW5kbGVySXRlbSwgaGFuSWQsIGN0eEl0ZW1zLCBldmVudEtleSkge1xuICAgICAgICAgICAgbGVuS2V5ID0gZXZlbnRLZXkucmVwbGFjZSgnX2lkeCcsICdfbGVuJyk7XG5cbiAgICAgICAgICAgIG1hdGNoRXZlbnROYW1lID0gaGFzQXJncyAmJiBuZS51dGlsLmlzU3RyaW5nKGV2ZW50TmFtZSkgJiYgZXZlbnRLZXkuaW5kZXhPZihldmVudE5hbWUpID4gLTE7XG4gICAgICAgICAgICBtYXRjaEhhbmRsZXIgPSBoYXNBcmdzICYmIG5lLnV0aWwuaXNGdW5jdGlvbihldmVudE5hbWUpICYmIGhhbmRsZXJJdGVtLmZuID09PSBldmVudE5hbWU7XG5cbiAgICAgICAgICAgIGlmICghaGFzQXJncyB8fCAobWF0Y2hFdmVudE5hbWUgfHwgbWF0Y2hIYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjdHhJdGVtc1toYW5JZF07XG4gICAgICAgICAgICAgICAgY3R4RXZlbnRzW2xlbktleV0gLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRha2UgdGhlIGV2ZW50IGhhbmRsZXIgb2ZmIGJ5IGV2ZW50IG5hbWUgd2l0aCBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIEN1c3RvbSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2hhbmRsZXJdIC0gRXZlbnQgaGFuZGxlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ3VzdG9tRXZlbnRzLnByb3RvdHlwZS5fb2ZmQnlFdmVudE5hbWUgPSBmdW5jdGlvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGN0eEV2ZW50cyA9IHRoaXMuX2N0eEV2ZW50cyxcbiAgICAgICAgICAgIGhhc0hhbmRsZXIgPSBuZS51dGlsLmlzRXhpc3R5KGhhbmRsZXIpLFxuICAgICAgICAgICAgbGVuS2V5O1xuXG4gICAgICAgIHRoaXMuX2VhY2hDdHhFdmVudEJ5RXZlbnROYW1lKGV2ZW50TmFtZSwgZnVuY3Rpb24oaGFuZGxlckl0ZW0sIGhhbklkLCBjdHhJdGVtcywgZXZlbnRLZXkpIHtcbiAgICAgICAgICAgIGxlbktleSA9IGV2ZW50S2V5LnJlcGxhY2UoJ19pZHgnLCAnX2xlbicpO1xuICAgICAgICAgICAgaWYgKCFoYXNIYW5kbGVyIHx8IChoYXNIYW5kbGVyICYmIGhhbmRsZXJJdGVtLmZuID09PSBoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjdHhJdGVtc1toYW5JZF07XG4gICAgICAgICAgICAgICAgY3R4RXZlbnRzW2xlbktleV0gLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fZWFjaEV2ZW50QnlFdmVudE5hbWUoZXZlbnROYW1lLCBmdW5jdGlvbihoYW5kbGVySXRlbSwgaW5kZXgsIGl0ZW1zLCBkZWNyZWFzZSkge1xuICAgICAgICAgICAgaWYgKCFoYXNIYW5kbGVyIHx8IChoYXNIYW5kbGVyICYmIGhhbmRsZXJJdGVtLmZuID09PSBoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgZGVjcmVhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICB9O1xuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiBwdWJsaWNcbiAgICAgKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCB0aGUgZXZlbnQgaGFuZGxlciB3aXRoIGV2ZW50IG5hbWUgYW5kIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfHtuYW1lOnN0cmluZywgaGFuZGxlcjpmdW5jdGlvbn0pfSBldmVudE5hbWUgLSBDdXN0b20gZXZlbnQgbmFtZSBvciBhbiBvYmplY3Qge2V2ZW50TmFtZTogaGFuZGxlcn1cbiAgICAgKiBAcGFyYW0geyhmdW5jdGlvbnwqKX0gW2hhbmRsZXJdIC0gSGFuZGxlciBmdW5jdGlvbiBvciBjb250ZXh0XG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF0gLSBDb250ZXh0IGZvciBiaW5kaW5nXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgLy8gMS4gQmFzaWNcbiAgICAgKiAgY3VzdG9tRXZlbnQub24oJ29ubG9hZCcsIGhhbmRsZXIpO1xuICAgICAqXG4gICAgICogIC8vIDIuIFdpdGggY29udGV4dFxuICAgICAqICBjdXN0b21FdmVudC5vbignb25sb2FkJywgaGFuZGxlciwgbXlPYmopO1xuICAgICAqXG4gICAgICogIC8vIDMuIEF0dGFjaCB3aXRoIGFuIG9iamVjdFxuICAgICAqICBjdXN0b21FdmVudC5vbih7XG4gICAgICogICAgJ3BsYXknOiBoYW5kbGVyLFxuICAgICAqICAgICdwYXVzZSc6IGhhbmRsZXIyXG4gICAgICogIH0pO1xuICAgICAqXG4gICAgICogIC8vIDQuIEF0dGFjaCB3aXRoIGFuIG9iamVjdCB3aXRoIGNvbnRleHRcbiAgICAgKiAgY3VzdG9tRXZlbnQub24oe1xuICAgICAqICAgICdwbGF5JzogaGFuZGxlclxuICAgICAqICB9LCBteU9iaik7XG4gICAgICovXG4gICAgQ3VzdG9tRXZlbnRzLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgaGFuZGxlciwgY29udGV4dCkge1xuICAgICAgICB2YXIgZXZlbnROYW1lTGlzdDtcblxuICAgICAgICBpZiAobmUudXRpbC5pc09iamVjdChldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAvLyB7ZXZlbnROYW1lOiBoYW5kbGVyfVxuICAgICAgICAgICAgY29udGV4dCA9IGhhbmRsZXI7XG4gICAgICAgICAgICBuZS51dGlsLmZvckVhY2hPd25Qcm9wZXJ0aWVzKGV2ZW50TmFtZSwgZnVuY3Rpb24oaGFuZGxlciwgbmFtZSkge1xuICAgICAgICAgICAgICAgICB0aGlzLm9uKG5hbWUsIGhhbmRsZXIsIGNvbnRleHQpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAobmUudXRpbC5pc1N0cmluZyhldmVudE5hbWUpICYmIGV2ZW50TmFtZS5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgICAgICAgLy8gcHJvY2Vzc2luZyBvZiBtdWx0aXBsZSBldmVudHMgYnkgc3BsaXQgZXZlbnQgbmFtZVxuICAgICAgICAgICAgZXZlbnROYW1lTGlzdCA9IGV2ZW50TmFtZS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgbmUudXRpbC5mb3JFYWNoQXJyYXkoZXZlbnROYW1lTGlzdCwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub24obmFtZSwgaGFuZGxlciwgY29udGV4dCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdHhJZDtcblxuICAgICAgICBpZiAobmUudXRpbC5pc0V4aXN0eShjb250ZXh0KSkge1xuICAgICAgICAgICAgY3R4SWQgPSBuZS51dGlsLnN0YW1wKGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5lLnV0aWwuaXNFeGlzdHkoY3R4SWQpKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRDdHhFdmVudChldmVudE5hbWUsIGNvbnRleHQsIGhhbmRsZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWRkTm9ybWFsRXZlbnQoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggdGhlIGV2ZW50IGhhbmRsZXIuXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfHtuYW1lOnN0cmluZywgaGFuZGxlcjpmdW5jdGlvbn0pfSBldmVudE5hbWUgLSBDdXN0b20gZXZlbnQgbmFtZSBvciBhbiBvYmplY3Qge2V2ZW50TmFtZTogaGFuZGxlcn1cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaGFuZGxlcl0gSGFuZGxlciBmdW5jdGlvblxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gMS4gb2ZmIGJ5IGNvbnRleHRcbiAgICAgKiBjdXN0b21FdmVudC5vZmYobXlPYmopO1xuICAgICAqXG4gICAgICogLy8gMi4gb2ZmIGJ5IGV2ZW50IG5hbWVcbiAgICAgKiBjdXN0b21FdmVudC5vZmYoJ29ubG9hZCcpO1xuICAgICAqXG4gICAgICogLy8gMy4gb2ZmIGJ5IGhhbmRsZXJcbiAgICAgKiBjdXN0b21FdmVudC5vZmYoaGFuZGxlcik7XG4gICAgICpcbiAgICAgKiAvLyA0LiBvZmYgYnkgZXZlbnQgbmFtZSBhbmQgaGFuZGxlclxuICAgICAqIGN1c3RvbUV2ZW50Lm9mZigncGxheScsIGhhbmRsZXIpO1xuICAgICAqXG4gICAgICogLy8gNS4gb2ZmIGJ5IGNvbnRleHQgYW5kIGhhbmRsZXJcbiAgICAgKiBjdXN0b21FdmVudC5vZmYobXlPYmosIGhhbmRsZXIpO1xuICAgICAqXG4gICAgICogLy8gNi4gb2ZmIGJ5IGNvbnRleHQgYW5kIGV2ZW50IG5hbWVcbiAgICAgKiBjdXN0b21FdmVudC5vZmYobXlPYmosICdvbmxvYWQnKTtcbiAgICAgKlxuICAgICAqIC8vIDcuIG9mZiBieSBhbiBPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+IHRoYXQgaXMge2V2ZW50TmFtZTogaGFuZGxlcn1cbiAgICAgKiBjdXN0b21FdmVudC5vZmYoe1xuICAgICAqICAgJ3BsYXknOiBoYW5kbGVyLFxuICAgICAqICAgJ3BhdXNlJzogaGFuZGxlcjJcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIDguIG9mZiB0aGUgYWxsIGV2ZW50c1xuICAgICAqIGN1c3RvbUV2ZW50Lm9mZigpO1xuICAgICAqL1xuICAgIEN1c3RvbUV2ZW50cy5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gOC4gb2ZmIHRoZSBhbGwgZXZlbnRzXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fY3R4RXZlbnRzID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZS51dGlsLmlzRnVuY3Rpb24oZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgLy8gMy4gb2ZmIGJ5IGhhbmRsZXJcbiAgICAgICAgICAgIHRoaXMuX29mZkJ5SGFuZGxlcihldmVudE5hbWUpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobmUudXRpbC5pc09iamVjdChldmVudE5hbWUpKSB7XG4gICAgICAgICAgICBpZiAobmUudXRpbC5oYXNTdGFtcChldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gMSwgNSwgNiBvZmYgYnkgY29udGV4dFxuICAgICAgICAgICAgICAgIHRoaXMuX29mZkJ5Q29udGV4dChldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyA0LiBvZmYgYnkgYW4gT2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPlxuICAgICAgICAgICAgICAgIG5lLnV0aWwuZm9yRWFjaE93blByb3BlcnRpZXMoZXZlbnROYW1lLCBmdW5jdGlvbihoYW5kbGVyLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2ZmKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAyLCA0IG9mZiBieSBldmVudCBuYW1lXG4gICAgICAgICAgICB0aGlzLl9vZmZCeUV2ZW50TmFtZShldmVudE5hbWUsIGhhbmRsZXIpO1xuXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgY291bnQgb2YgZXZlbnRzIHJlZ2lzdGVyZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIEN1c3RvbSBldmVudCBuYW1lXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgQ3VzdG9tRXZlbnRzLnByb3RvdHlwZS5nZXRMaXN0ZW5lckxlbmd0aCA9IGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICB2YXIgY3R4RXZlbnRzID0gdGhpcy5fY3R4RXZlbnRzLFxuICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzLFxuICAgICAgICAgICAgZXhpc3R5ID0gbmUudXRpbC5pc0V4aXN0eSxcbiAgICAgICAgICAgIGxlbktleSA9IHRoaXMuX2dldEN0eExlbktleShldmVudE5hbWUpO1xuXG4gICAgICAgIHZhciBub3JtYWwgPSAoZXhpc3R5KGV2ZW50cykgJiYgbmUudXRpbC5pc0FycmF5KGV2ZW50c1tldmVudE5hbWVdKSkgPyBldmVudHNbZXZlbnROYW1lXS5sZW5ndGggOiAwLFxuICAgICAgICAgICAgY3R4ID0gKGV4aXN0eShjdHhFdmVudHMpICYmIGV4aXN0eShjdHhFdmVudHNbbGVuS2V5XSkpID8gY3R4RXZlbnRzW2xlbktleV0gOiAwO1xuXG4gICAgICAgIHJldHVybiBub3JtYWwgKyBjdHg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB3aGV0aGVyIGF0IGxlYXN0IG9uZSBvZiB0aGUgaGFuZGxlcnMgaXMgcmVnaXN0ZXJlZCBpbiB0aGUgZ2l2ZW4gZXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gQ3VzdG9tIGV2ZW50IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgdGhlcmUgYXQgbGVhc3Qgb25lIGhhbmRsZXIgaW4gZXZlbnQgbmFtZT9cbiAgICAgKi9cbiAgICBDdXN0b21FdmVudHMucHJvdG90eXBlLmhhc0xpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExpc3RlbmVyTGVuZ3RoKGV2ZW50TmFtZSkgPiAwO1xuICAgIH07XG5cblxuXG4gICAgLyoqXG4gICAgICogRmlyZSBhIGV2ZW50IGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2Ygb3BlcmF0aW9uICdib29sZWFuIEFORCcgd2l0aCBhbGwgbGlzdGVuZXIncyByZXN1bHRzLjxicj5cbiAgICAgKiBTbywgSXQgaXMgZGlmZmVyZW50IGZyb20ge0BsaW5rIEN1c3RvbUV2ZW50cyNmaXJlfS48YnI+XG4gICAgICogSW4gc2VydmljZSBjb2RlLFxuICAgICAqICB1c2UgdGhpcyBhcyBhIGJlZm9yZSBldmVudCBpbiBjb21wb25lbnQgbGV2ZWwgdXN1YWxseSBmb3Igbm90aWZ5aW5nIHRoYXQgdGhlIGV2ZW50IGlzIGNhbmNlbGFibGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIEN1c3RvbSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIHsuLi4qfSBkYXRhIC0gRGF0YSBmb3IgZXZlbnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIHJlc3VsdCBvZiBvcGVyYXRpb24gJ2Jvb2xlYW4gQU5EJ1xuICAgICAqIEBleGFtcGxlXG4gICAgICogIGlmICh0aGlzLmludm9rZSgnYmVmb3JlWm9vbScpKSB7ICAgIC8vIGNoZWNrIHRoZSByZXN1bHQgb2YgJ2JlZm9yZVpvb20nXG4gICAgICogICAgICAvLyBpZiB0cnVlLFxuICAgICAqICAgICAgLy8gZG9Tb21ldGhpbmdcbiAgICAgKiAgfVxuICAgICAqXG4gICAgICogIC8vIEluIHNlcnZpY2UgY29kZSxcbiAgICAgKiAgbWFwLm9uKHtcbiAgICAgKiAgICAgICdiZWZvcmVab29tJzogZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICAgaWYgKHRoYXQuZGlzYWJsZWQgJiYgdGhpcy5nZXRTdGF0ZSgpKSB7ICAgIC8vIEl0IHNob3VsZCBjYW5jZWwgdGhlICd6b29tJyBldmVudCBieSBzb21lIGNvbmRpdGlvbnMuXG4gICAgICogICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgKiAgICAgICAgICB9XG4gICAgICogICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICAgICB9XG4gICAgICogIH0pO1xuICAgICAqL1xuICAgIEN1c3RvbUV2ZW50cy5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24oZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNMaXN0ZW5lcihldmVudE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgICAgICAgIGV4aXN0eSA9IG5lLnV0aWwuaXNFeGlzdHk7XG5cbiAgICAgICAgdGhpcy5fZWFjaEV2ZW50QnlFdmVudE5hbWUoZXZlbnROYW1lLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoZXhpc3R5KGl0ZW0pICYmIGl0ZW0uZm4uYXBwbHkoc2VsZiwgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2VhY2hDdHhFdmVudEJ5RXZlbnROYW1lKGV2ZW50TmFtZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgaWYgKGV4aXN0eShpdGVtKSAmJiBpdGVtLmZuLmFwcGx5KGl0ZW0uY3R4LCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZSBhIGV2ZW50IGJ5IGV2ZW50IG5hbWUgd2l0aCBkYXRhLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBDdXN0b20gZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7Li4uKn0gZGF0YSAtIERhdGEgZm9yIGV2ZW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgaW5zdGFuY2Uub24oJ21vdmUnLCBmdW5jdGlvbihkaXJlY3Rpb24pIHtcbiAgICAgKiAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICogIH0pO1xuICAgICAqICBpbnN0YW5jZS5maXJlKCdtb3ZlJywgJ2xlZnQnKTtcbiAgICAgKi9cbiAgICBDdXN0b21FdmVudHMucHJvdG90eXBlLmZpcmUgPSBmdW5jdGlvbihldmVudE5hbWUsIGRhdGEpIHtcbiAgICAgICAgdGhpcy5pbnZva2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBhIG9uZS1zaG90IGV2ZW50LlxuICAgICAqIEBwYXJhbSB7KG9iamVjdHxzdHJpbmcpfSBldmVudE5hbWUgLSBDdXN0b20gZXZlbnQgbmFtZSBvciBhbiBvYmplY3Qge2V2ZW50TmFtZTogaGFuZGxlcn1cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIEhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XSAtIENvbnRleHQgZm9yIGJpbmRpbmdcbiAgICAgKi9cbiAgICBDdXN0b21FdmVudHMucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudE5hbWUsIGZuLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICBpZiAobmUudXRpbC5pc09iamVjdChldmVudE5hbWUpKSB7XG4gICAgICAgICAgICBuZS51dGlsLmZvckVhY2hPd25Qcm9wZXJ0aWVzKGV2ZW50TmFtZSwgZnVuY3Rpb24oaGFuZGxlciwgZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKGV2ZW50TmFtZSwgaGFuZGxlciwgZm4pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uY2VIYW5kbGVyKCkge1xuICAgICAgICAgICAgZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoYXQub2ZmKGV2ZW50TmFtZSwgb25jZUhhbmRsZXIsIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbihldmVudE5hbWUsIG9uY2VIYW5kbGVyLCBjb250ZXh0KTtcbiAgICB9O1xuXG4gICAgbmUudXRpbC5DdXN0b21FdmVudHMgPSBDdXN0b21FdmVudHM7XG5cbn0pKHdpbmRvdy5uZSk7XG5cbi8qKioqKioqKioqXG4gKiBkZWZpbmVDbGFzcy5qc1xuICoqKioqKioqKiovXG5cbi8qKlxuICogQGZpbGVvdmVydmlld1xuICogIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGEgZnVuY3Rpb24gdG8gbWFrZSBhIGNvbnN0cnVjdG9yIHRoYXQgY2FuIGluaGVyaXQgZnJvbSB0aGUgb3RoZXIgY29uc3RydWN0b3JzIGxpa2UgdGhlIENMQVNTIGVhc2lseS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZTAyNDJAbmhuZW50LmNvbT5cbiAqIEBkZXBlbmRlbmN5IGluaGVyaXRhbmNlLmpzLCBvYmplY3QuanNcbiAqL1xuXG4oZnVuY3Rpb24obmUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFuZSkge1xuICAgICAgICBuZSA9IHdpbmRvdy5uZSA9IHt9O1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIW5lLnV0aWwpIHtcbiAgICAgICAgbmUudXRpbCA9IHdpbmRvdy5uZS51dGlsID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscCBhIGNvbnN0cnVjdG9yIHRvIGJlIGRlZmluZWQgYW5kIHRvIGluaGVyaXQgZnJvbSB0aGUgb3RoZXIgY29uc3RydWN0b3JzXG4gICAgICogQHBhcmFtIHsqfSBbcGFyZW50XSBQYXJlbnQgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgTWVtYmVycyBvZiBjb25zdHJ1Y3RvclxuICAgICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9wcy5pbml0IEluaXRpYWxpemF0aW9uIG1ldGhvZFxuICAgICAqICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnN0YXRpY10gU3RhdGljIG1lbWJlcnMgb2YgY29uc3RydWN0b3JcbiAgICAgKiBAcmV0dXJucyB7Kn0gQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciBQYXJlbnQgPSBkZWZpbmVDbGFzcyh7XG4gICAgICogICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICB0aGlzLm5hbWUgPSAnbWFkZSBieSBkZWYnO1xuICAgICAqICAgICAgfSxcbiAgICAgKiAgICAgIG1ldGhvZDogZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICAgLy8uLmNhbiBkbyBzb21ldGhpbmcgd2l0aCB0aGlzXG4gICAgICogICAgICB9LFxuICAgICAqICAgICAgc3RhdGljOiB7XG4gICAgICogICAgICAgICAgc3RhdGljTWV0aG9kOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICAgICAgIC8vLi5kbyBzb21ldGhpbmdcbiAgICAgKiAgICAgICAgICB9XG4gICAgICogICAgICB9XG4gICAgICogIH0pO1xuICAgICAqXG4gICAgICogIHZhciBDaGlsZCA9IGRlZmluZUNsYXNzKFBhcmVudCwge1xuICAgICAqICAgICAgbWV0aG9kMjogZnVuY3Rpb24oKSB7fVxuICAgICAqICB9KTtcbiAgICAgKlxuICAgICAqICBQYXJlbnQuc3RhdGljTWV0aG9kKCk7XG4gICAgICpcbiAgICAgKiAgdmFyIHBhcmVudEluc3RhbmNlID0gbmV3IFBhcmVudCgpO1xuICAgICAqICBjb25zb2xlLmxvZyhwYXJlbnRJbnN0YW5jZS5uYW1lKTsgLy9tYWRlIGJ5IGRlZlxuICAgICAqICBwYXJlbnRJbnN0YW5jZS5zdGF0aWNNZXRob2QoKTsgLy8gRXJyb3JcbiAgICAgKlxuICAgICAqICB2YXIgY2hpbGRJbnN0YW5jZSA9IG5ldyBDaGlsZCgpO1xuICAgICAqICBjaGlsZEluc3RhbmNlLm1ldGhvZCgpO1xuICAgICAqICBjaGlsZEluc3RhbmNlLm1ldGhvZDIoKTtcbiAgICAgKi9cbiAgICBuZS51dGlsLmRlZmluZUNsYXNzID0gZnVuY3Rpb24ocGFyZW50LCBwcm9wcykge1xuICAgICAgICB2YXIgb2JqO1xuXG4gICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICAgIHByb3BzID0gcGFyZW50O1xuICAgICAgICAgICAgcGFyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IHByb3BzLmluaXQgfHwgZnVuY3Rpb24oKXt9O1xuXG4gICAgICAgIGlmKHBhcmVudCkge1xuICAgICAgICAgICAgbmUudXRpbC5pbmhlcml0KG9iaiwgcGFyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnc3RhdGljJykpIHtcbiAgICAgICAgICAgIG5lLnV0aWwuZXh0ZW5kKG9iaiwgcHJvcHMuc3RhdGljKTtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9wcy5zdGF0aWM7XG4gICAgICAgIH1cblxuICAgICAgICBuZS51dGlsLmV4dGVuZChvYmoucHJvdG90eXBlLCBwcm9wcyk7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG59KSh3aW5kb3cubmUpO1xuXG4vKioqKioqKioqKlxuICogZGVmaW5lTW9kdWxlLmpzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERlZmluZSBtb2R1bGVcbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZTAyNDJAbmhuZW50LmNvbT5cbiAqIEBkZXBlbmRlbmN5IHR5cGUuanMsIGRlZmluZU5hbWVzcGFjZS5qc1xuICovXG4oZnVuY3Rpb24obmUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFuZSkge1xuICAgICAgICBuZSA9IHdpbmRvdy5uZSA9IHt9O1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIW5lLnV0aWwpIHtcbiAgICAgICAgbmUudXRpbCA9IHdpbmRvdy5uZS51dGlsID0ge307XG4gICAgfVxuXG4gICAgdmFyIHV0aWwgPSBuZS51dGlsLFxuICAgICAgICBJTklUSUFMSVpBVElPTl9NRVRIT0RfTkFNRSA9ICdpbml0aWFsaXplJztcblxuICAgIC8qKlxuICAgICAqIERlZmluZSBtb2R1bGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlIC0gTmFtZXNwYWNlIG9mIG1vZHVsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGVEZWZpbml0aW9uIC0gT2JqZWN0IGxpdGVyYWwgZm9yIG1vZHVsZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IERlZmluZWQgbW9kdWxlXG4gICAgICogQG1lbWJlcm9mIG5lLnV0aWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICB2YXIgbXlNb2R1bGUgPSBuZS51dGlsLmRlZmluZU1vZHVsZSgnbW9kdWxlcy5teU1vZHVsZScsIHtcbiAgICAgKiAgICAgICAgICBuYW1lOiAnam9obicsXG4gICAgICogICAgICAgICAgbWVzc2FnZTogJycsXG4gICAgICogICAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9ICdoZWxsbyB3b3JsZCc7XG4gICAgICogICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgICBnZXRNZXNzYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArICc6ICcgKyB0aGlzLm1lc3NhZ2VcbiAgICAgKiAgICAgICAgICB9XG4gICAgICogICAgIH0pO1xuICAgICAqXG4gICAgICogICAgIGNvbnNvbGUubG9nKG15TW9kdWxlLmdldE1lc3NhZ2UoKSk7ICAvLyAnam9objogaGVsbG8gd29ybGQnO1xuICAgICAqICAgICBjb25zb2xlLmxvZyh3aW5kb3cubW9kdWxlcy5teU1vZHVsZS5nZXRNZXNzYWdlKCkpOyAgIC8vICdqb2huOiBoZWxsbyB3b3JsZCc7XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmaW5lTW9kdWxlKG5hbWVzcGFjZSwgbW9kdWxlRGVmaW5pdGlvbikge1xuICAgICAgICB2YXIgYmFzZSA9IG1vZHVsZURlZmluaXRpb24gfHwge307XG5cbiAgICAgICAgaWYgKHV0aWwuaXNGdW5jdGlvbihiYXNlW0lOSVRJQUxJWkFUSU9OX01FVEhPRF9OQU1FXSkpIHtcbiAgICAgICAgICAgIGJhc2VbSU5JVElBTElaQVRJT05fTUVUSE9EX05BTUVdKCk7XG4gICAgICAgICAgICBkZWxldGUgYmFzZVtJTklUSUFMSVpBVElPTl9NRVRIT0RfTkFNRV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXRpbC5kZWZpbmVOYW1lc3BhY2UobmFtZXNwYWNlLCBiYXNlLCB0cnVlKTtcbiAgICB9XG4gICAgbmUudXRpbC5kZWZpbmVNb2R1bGUgPSBkZWZpbmVNb2R1bGU7XG59KSh3aW5kb3cubmUpO1xuXG4vKioqKioqKioqKlxuICogZGVmaW5lTmFtZXNwYWNlLmpzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERlZmluZSBuYW1lc3BhY2VcbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZTAyNDJAbmhuZW50LmNvbT5cbiAqIEBkZXBlbmRlbmN5IGluaGVyaXRhbmNlLmpzLCBvYmplY3QuanMsIGNvbGxlY3Rpb24uanNcbiAqL1xuKGZ1bmN0aW9uKG5lKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFuZSkge1xuICAgICAgICBuZSA9IHdpbmRvdy5uZSA9IHt9O1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIW5lLnV0aWwpIHtcbiAgICAgICAgbmUudXRpbCA9IHdpbmRvdy5uZS51dGlsID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lIG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTW9kdWxlIG5hbWVcbiAgICAgKiBAcGFyYW0geyhvYmplY3R8ZnVuY3Rpb24pfSBwcm9wcyAtIEEgc2V0IG9mIG1vZHVsZXMgb3Igb25lIG1vZHVsZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNPdmVycmlkZSBmbGFnIC0gV2hhdCBpZiBtb2R1bGUgYWxyZWFkeSBkZWZpbmUsIG92ZXJyaWRlIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHsob2JqZWN0fGZ1bmN0aW9uKX0gRGVmaW5lZCBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIG5lQ29tcCA9IGRlZmluZU5hbWVzcGFjZSgnbmUuY29tcG9uZW50Jyk7XG4gICAgICogbmVDb21wLmxpc3RNZW51ID0gbmUudXRpbC5kZWZpbmVDbGFzcyh7XG4gICAgICogICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICAvLyBjb2RlXG4gICAgICogICAgICB9XG4gICAgICogfSk7XG4gICAgICovXG4gICAgdmFyIGRlZmluZU5hbWVzcGFjZSA9IGZ1bmN0aW9uKG5hbWUsIHByb3BzLCBpc092ZXJyaWRlKSB7XG4gICAgICAgIHZhciBuYW1lc3BhY2UsXG4gICAgICAgICAgICBsYXN0c3BhY2UsXG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICBtb2R1bGUgPSBnZXROYW1lc3BhY2UobmFtZSk7XG5cbiAgICAgICAgaWYgKCFpc092ZXJyaWRlICYmIGlzVmFsaWRUeXBlKG1vZHVsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lc3BhY2UgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgIGxhc3RzcGFjZSA9IG5hbWVzcGFjZS5wb3AoKTtcbiAgICAgICAgbmFtZXNwYWNlLnVuc2hpZnQod2luZG93KTtcblxuICAgICAgICByZXN1bHQgPSBuZS51dGlsLnJlZHVjZShuYW1lc3BhY2UsIGZ1bmN0aW9uKG9iaiwgbmFtZSkge1xuICAgICAgICAgICAgb2JqW25hbWVdID0gb2JqW25hbWVdIHx8IHt9O1xuICAgICAgICAgICAgcmV0dXJuIG9ialtuYW1lXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzdWx0W2xhc3RzcGFjZV0gPSBpc1ZhbGlkVHlwZShwcm9wcykgPyBwcm9wcyA6IHt9O1xuXG4gICAgICAgIHJldHVybiByZXN1bHRbbGFzdHNwYWNlXTtcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbmFtZXNwYWNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBuYW1lc3BhY2VcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICB2YXIgZ2V0TmFtZXNwYWNlID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgbmFtZXNwYWNlLFxuICAgICAgICAgICAgcmVzdWx0O1xuXG4gICAgICAgIG5hbWVzcGFjZSA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgbmFtZXNwYWNlLnVuc2hpZnQod2luZG93KTtcblxuICAgICAgICByZXN1bHQgPSBuZS51dGlsLnJlZHVjZShuYW1lc3BhY2UsIGZ1bmN0aW9uKG9iaiwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmpbbmFtZV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB2YWxpZCB0eXBlXG4gICAgICogQHBhcmFtIHsqfSBtb2R1bGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB2YXIgaXNWYWxpZFR5cGUgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIChuZS51dGlsLmlzT2JqZWN0KG1vZHVsZSkgfHwgbmUudXRpbC5pc0Z1bmN0aW9uKG1vZHVsZSkpO1xuICAgIH07XG5cbiAgICBuZS51dGlsLmRlZmluZU5hbWVzcGFjZSA9IGRlZmluZU5hbWVzcGFjZTtcblxufSkod2luZG93Lm5lKTtcbi8qKioqKioqKioqXG4gKiBlbnVtLmpzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgbW9kdWxlIHByb3ZpZGVzIGEgRW51bSBDb25zdHJ1Y3Rvci5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZTAyNDJAbmhuZW50LmNvbT5cbiAqIEBkZXBlbmRlbmN5IHR5cGUsIGNvbGxlY3Rpb24uanNcbiAqL1xuXG4oZnVuY3Rpb24obmUpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICghbmUpIHtcbiAgICBuZSA9IHdpbmRvdy5uZSA9IHt9O1xufVxuaWYgKCFuZS51dGlsKSB7XG4gICAgbmUudXRpbCA9IHdpbmRvdy5uZS51dGlsID0ge307XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZGVmaW5lUHJvcGVydHkoKSBtZXRob2QgaXMgc3VwcG9ydGVkLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbnZhciBpc1N1cHBvcnREZWZpbmVkUHJvcGVydHkgPSAoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7fSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0oKSk7XG5cbi8qKlxuICogQSB1bmlxdWUgdmFsdWUgb2YgYSBjb25zdGFudC5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnZhciBlbnVtVmFsdWUgPSAwO1xuXG4vKipcbiAqIE1ha2UgYSBjb25zdGFudC1saXN0IHRoYXQgaGFzIHVuaXF1ZSB2YWx1ZXMuPGJyPlxuICogSW4gbW9kZXJuIGJyb3dzZXJzIChleGNlcHQgSUU4IGFuZCBsb3dlciksPGJyPlxuICogIGEgdmFsdWUgZGVmaW5lZCBvbmNlIGNhbiBub3QgYmUgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0gey4uLnN0cmluZyB8IHN0cmluZ1tdfSBpdGVtTGlzdCBDb25zdGFudC1saXN0IChBbiBhcnJheSBvZiBzdHJpbmcgaXMgYXZhaWxhYmxlKVxuICogQGV4cG9ydHMgRW51bVxuICogQGNvbnN0cnVjdG9yXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBuZS51dGlsXG4gKiBAZXhhbXBsZXNcbiAqICAvL2NyZWF0ZVxuICogIHZhciBNWUVOVU0gPSBuZXcgRW51bSgnVFlQRTEnLCAnVFlQRTInKTtcbiAqICB2YXIgTVlFTlVNMiA9IG5ldyBFbnVtKFsnVFlQRTEnLCAnVFlQRTInXSk7XG4gKlxuICogIC8vdXNhZ2VcbiAqICBpZiAodmFsdWUgPT09IE1ZRU5VTS5UWVBFMSkge1xuICogICAgICAgLi4uLlxuICogIH1cbiAqXG4gKiAgLy9hZGQgKElmIGEgZHVwbGljYXRlIG5hbWUgaXMgaW5wdXR0ZWQsIHdpbGwgYmUgZGlzcmVnYXJkZWQuKVxuICogIE1ZRU5VTS5zZXQoJ1RZUEUzJywgJ1RZUEU0Jyk7XG4gKlxuICogIC8vZ2V0IG5hbWUgb2YgYSBjb25zdGFudCBieSBhIHZhbHVlXG4gKiAgTVlFTlVNLmdldE5hbWUoTVlFTlVNLlRZUEUxKTsgLy8gJ1RZUEUxJ+ydtCDrpqzthLTrkJzri6QuXG4gKlxuICogIC8vIEluIG1vZGVybiBicm93c2VycyAoZXhjZXB0IElFOCBhbmQgbG93ZXIpLCBhIHZhbHVlIGNhbiBub3QgYmUgY2hhbmdlZCBpbiBjb25zdGFudHMuXG4gKiAgdmFyIG9yaWdpbmFsVmFsdWUgPSBNWUVOVU0uVFlQRTE7XG4gKiAgTVlFTlVNLlRZUEUxID0gMTIzNDsgLy8gbWF5YmUgVHlwZUVycm9yXG4gKiAgTVlFTlVNLlRZUEUxID09PSBvcmlnaW5hbFZhbHVlOyAvLyB0cnVlXG4gKlxuICoqL1xuZnVuY3Rpb24gRW51bShpdGVtTGlzdCkge1xuICAgIGlmIChpdGVtTGlzdCkge1xuICAgICAgICB0aGlzLnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBjb25zdGFudHMtbGlzdFxuICogQHBhcmFtIHsuLi5zdHJpbmd8IHN0cmluZ1tdfSBpdGVtTGlzdCBDb25zdGFudC1saXN0IChBbiBhcnJheSBvZiBzdHJpbmcgaXMgYXZhaWxhYmxlKVxuICovXG5FbnVtLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihpdGVtTGlzdCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICghbmUudXRpbC5pc0FycmF5KGl0ZW1MaXN0KSkge1xuICAgICAgICBpdGVtTGlzdCA9IG5lLnV0aWwudG9BcnJheShhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIG5lLnV0aWwuZm9yRWFjaChpdGVtTGlzdCwgZnVuY3Rpb24gaXRlbUxpc3RJdGVyYXRlZShpdGVtKSB7XG4gICAgICAgIHNlbGYuX2FkZEl0ZW0oaXRlbSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhIGtleSBvZiB0aGUgY29uc3RhbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgQSB2YWx1ZSBvZiB0aGUgY29uc3RhbnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gS2V5IG9mIHRoZSBjb25zdGFudC5cbiAqL1xuRW51bS5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGZvdW5kZWRLZXksXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgbmUudXRpbC5mb3JFYWNoKHRoaXMsIGZ1bmN0aW9uKGl0ZW1WYWx1ZSwga2V5KSB7XG4gICAgICAgIGlmIChzZWxmLl9pc0VudW1JdGVtKGtleSkgJiYgdmFsdWUgPT09IGl0ZW1WYWx1ZSkge1xuICAgICAgICAgICAgZm91bmRlZEtleSA9IGtleTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZvdW5kZWRLZXk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGNvbnN0YW50LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENvbnN0YW50IG5hbWUuIChJdCB3aWxsIGJlIGEga2V5IG9mIGEgY29uc3RhbnQpXG4gKi9cbkVudW0ucHJvdG90eXBlLl9hZGRJdGVtID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB2YWx1ZTtcblxuICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuX21ha2VFbnVtVmFsdWUoKTtcblxuICAgICAgICBpZiAoaXNTdXBwb3J0RGVmaW5lZFByb3BlcnR5KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJuIGEgdW5pcXVlIHZhbHVlIGZvciBhc3NpZ25pbmcgdG8gYSBjb25zdGFudC5cbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBBIHVuaXF1ZSB2YWx1ZVxuICovXG5FbnVtLnByb3RvdHlwZS5fbWFrZUVudW1WYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZTtcblxuICAgIHZhbHVlID0gZW51bVZhbHVlO1xuICAgIGVudW1WYWx1ZSArPSAxO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhIGNvbnN0YW50IGZyb20gdGhlIGdpdmVuIGtleSBpcyBpbiBpbnN0YW5jZSBvciBub3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gQSBjb25zdGFudCBrZXlcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXN1bHRcbiAqIEBwcml2YXRlXG4gKi9cbkVudW0ucHJvdG90eXBlLl9pc0VudW1JdGVtID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG5lLnV0aWwuaXNOdW1iZXIodGhpc1trZXldKTtcbn07XG5cbm5lLnV0aWwuRW51bSA9IEVudW07XG5cbn0pKHdpbmRvdy5uZSk7XG5cbi8qKioqKioqKioqXG4gKiBleE1hcC5qc1xuICoqKioqKioqKiovXG5cbi8qKlxuICogQGZpbGVvdmVydmlld1xuICogIEltcGxlbWVudHMgdGhlIEV4TWFwIChFeHRlbmRlZCBNYXApIG9iamVjdC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZTAyNDJAbmhuZW50LmNvbT5cbiAqIEBkZXBlbmRlbmN5IE1hcC5qcywgY29sbGVjdGlvbi5qc1xuICovXG5cbihmdW5jdGlvbihuZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghbmUpIHtcbiAgICAgICAgbmUgPSB3aW5kb3cubmUgPSB7fTtcbiAgICB9XG4gICAgaWYgKCFuZS51dGlsKSB7XG4gICAgICAgIG5lLnV0aWwgPSB3aW5kb3cubmUudXRpbCA9IHt9O1xuICAgIH1cblxuICAgIC8vIENhY2hpbmcgbmUudXRpbCBmb3IgcGVyZm9ybWFuY2UgZW5oYW5jaW5nXG4gICAgdmFyIHV0aWwgPSBuZS51dGlsLFxuICAgICAgICBtYXBBUElzRm9yUmVhZCA9IFsnZ2V0JywgJ2hhcycsICdmb3JFYWNoJywgJ2tleXMnLCAndmFsdWVzJywgJ2VudHJpZXMnXSxcbiAgICAgICAgbWFwQVBJc0ZvckRlbGV0ZSA9IFsnZGVsZXRlJywgJ2NsZWFyJ107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgRXhNYXAgb2JqZWN0IGlzIEV4dGVuZGVkIFZlcnNpb24gb2YgdGhlIG5lLnV0aWwuTWFwIG9iamVjdC48YnI+XG4gICAgICogYW5kIGFkZGVkIHNvbWUgdXNlZnVsIGZlYXR1cmUgdG8gbWFrZSBpdCBlYXN5IHRvIG1hbmFnZSB0aGUgTWFwIG9iamVjdC5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbml0RGF0YSAtIEFycmF5IG9mIGtleS12YWx1ZSBwYWlycyAoMi1lbGVtZW50IEFycmF5cykuXG4gICAgICogICAgICBFYWNoIGtleS12YWx1ZSBwYWlyIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG5ldyBNYXBcbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEV4TWFwKGluaXREYXRhKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyB1dGlsLk1hcChpbml0RGF0YSk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuX21hcC5zaXplO1xuICAgIH1cblxuICAgIHV0aWwuZm9yRWFjaEFycmF5KG1hcEFQSXNGb3JSZWFkLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIEV4TWFwLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcFtuYW1lXS5hcHBseSh0aGlzLl9tYXAsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICB1dGlsLmZvckVhY2hBcnJheShtYXBBUElzRm9yRGVsZXRlLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIEV4TWFwLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX21hcFtuYW1lXS5hcHBseSh0aGlzLl9tYXAsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLnNpemUgPSB0aGlzLl9tYXAuc2l6ZTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBFeE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX21hcC5zZXQuYXBwbHkodGhpcy5fbWFwLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLl9tYXAuc2l6ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgYWxsIG9mIHRoZSBrZXktdmFsdWUgcGFpcnMgaW4gdGhlIHNwZWNpZmllZCBvYmplY3QgdG8gdGhlIE1hcCBvYmplY3QuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvYmplY3QgLSBQbGFpbiBvYmplY3QgdGhhdCBoYXMgYSBrZXktdmFsdWUgcGFpclxuICAgICAqL1xuICAgIEV4TWFwLnByb3RvdHlwZS5zZXRPYmplY3QgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdXRpbC5mb3JFYWNoT3duUHJvcGVydGllcyhvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZWxlbWVudHMgYXNzb2NpYXRlZCB3aXRoIGtleXMgaW4gdGhlIHNwZWNpZmllZCBhcnJheS5cbiAgICAgKiBAcGFyYW0gIHtBcnJheX0ga2V5cyAtIEFycmF5IHRoYXQgY29udGFpbnMga2V5cyBvZiB0aGUgZWxlbWVudCB0byByZW1vdmVcbiAgICAgKi9cbiAgICBFeE1hcC5wcm90b3R5cGUuZGVsZXRlQnlLZXlzID0gZnVuY3Rpb24oa2V5cykge1xuICAgICAgICB1dGlsLmZvckVhY2hBcnJheShrZXlzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHRoaXNbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGFsbCBvZiB0aGUga2V5LXZhbHVlIHBhaXJzIGluIHRoZSBzcGVjaWZpZWQgTWFwIG9iamVjdCB0byB0aGlzIE1hcCBvYmplY3QuXG4gICAgICogQHBhcmFtICB7TWFwfSBtYXAgLSBNYXAgb2JqZWN0IHRvIGJlIG1lcmdlZCBpbnRvIHRoaXMgTWFwIG9iamVjdFxuICAgICAqL1xuICAgIEV4TWFwLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvb2tzIHRocm91Z2ggZWFjaCBrZXktdmFsdWUgcGFpciBpbiB0aGUgbWFwIGFuZCByZXR1cm5zIHRoZSBuZXcgRXhNYXAgb2JqZWN0IG9mXG4gICAgICogYWxsIGtleS12YWx1ZSBwYWlycyB0aGF0IHBhc3MgYSB0cnV0aCB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gcHJlZGljYXRlIC0gRnVuY3Rpb24gdG8gdGVzdCBlYWNoIGtleS12YWx1ZSBwYWlyIG9mIHRoZSBNYXAgb2JqZWN0Ljxicj5cbiAgICAgKiAgICAgIEludm9rZWQgd2l0aCBhcmd1bWVudHMgKHZhbHVlLCBrZXkpLiBSZXR1cm4gdHJ1ZSB0byBrZWVwIHRoZSBlbGVtZW50LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHJldHVybiB7RXhNYXB9IEEgbmV3IEV4TWFwIG9iamVjdFxuICAgICAqL1xuICAgIEV4TWFwLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIGZpbHRlcmVkID0gbmV3IEV4TWFwKCk7XG5cbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmaWx0ZXJlZDtcbiAgICB9O1xuXG4gICAgdXRpbC5FeE1hcCA9IEV4TWFwO1xufSkod2luZG93Lm5lKTtcblxuLyoqKioqKioqKipcbiAqIGZvcm1hdERhdGUuanNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBtb2R1bGUgaGFzIGEgZnVuY3Rpb24gZm9yIGRhdGUgZm9ybWF0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxlMDI0MkBuaG5lbnQuY29tPlxuICogQGRlcGVuZGVuY3kgdHlwZS5qc1xuICovXG5cbihmdW5jdGlvbihuZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciB0b2tlbnMgPSAvW1xcXFxdKllZWVl8W1xcXFxdKllZfFtcXFxcXSpNTU1NfFtcXFxcXSpNTU18W1xcXFxdKk1NfFtcXFxcXSpNfFtcXFxcXSpERHxbXFxcXF0qRHxbXFxcXF0qSEh8W1xcXFxdKkh8W1xcXFxdKkEvZ2ksXG4gICAgICAgIE1PTlRIX1NUUiA9IFtcIkludmFsaWQgbW9udGhcIiwgXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcbiAgICAgICAgTU9OVEhfREFZUyA9IFswLCAzMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXSxcbiAgICAgICAgcmVwbGFjZU1hcCA9IHtcbiAgICAgICAgICAgIE06IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKGRhdGUubW9udGgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIE1NOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vbnRoID0gZGF0ZS5tb250aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKE51bWJlcihtb250aCkgPCAxMCkgPyAnMCcgKyBtb250aCA6IG1vbnRoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIE1NTTogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNT05USF9TVFJbTnVtYmVyKGRhdGUubW9udGgpXS5zdWJzdHIoMCwgMyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTU1NTTogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNT05USF9TVFJbTnVtYmVyKGRhdGUubW9udGgpXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBEOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcihkYXRlLmRhdGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGQ6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZU1hcC5EKGRhdGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEREOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRheUluTW9udGggPSBkYXRlLmRhdGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChOdW1iZXIoZGF5SW5Nb250aCkgPCAxMCkgPyAnMCcgKyBkYXlJbk1vbnRoIDogZGF5SW5Nb250aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZDogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlTWFwLkREKGRhdGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFlZOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcihkYXRlLnllYXIpICUgMTAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHl5OiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VNYXAuWVkoZGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgWVlZWTogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSAnMjAnLFxuICAgICAgICAgICAgICAgICAgICB5ZWFyID0gZGF0ZS55ZWFyO1xuICAgICAgICAgICAgICAgIGlmICh5ZWFyID4gNjkgJiYgeWVhciA8IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSAnMTknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKE51bWJlcih5ZWFyKSA8IDEwMCkgPyBwcmVmaXggKyBTdHJpbmcoeWVhcikgOiB5ZWFyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHl5eXk6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZU1hcC5ZWVlZKGRhdGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEE6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZS5tZXJpZGlhbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGUubWVyaWRpYW4udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoaDogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBob3VyID0gZGF0ZS5ob3VyO1xuICAgICAgICAgICAgICAgIHJldHVybiAoTnVtYmVyKGhvdXIpIDwgMTApID8gJzAnICsgaG91ciA6IGhvdXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSEg6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZU1hcC5oaChkYXRlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhOdW1iZXIoZGF0ZS5ob3VyKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSDogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlTWFwLmgoZGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbTogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcoTnVtYmVyKGRhdGUubWludXRlKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW06IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWludXRlID0gZGF0ZS5taW51dGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChOdW1iZXIobWludXRlKSA8IDEwKSA/ICcwJyArIG1pbnV0ZSA6IG1pbnV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghbmUpIHtcbiAgICAgICAgbmUgPSB3aW5kb3cubmUgPSB7fTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFuZS51dGlsKSB7XG4gICAgICAgIG5lLnV0aWwgPSB3aW5kb3cubmUudXRpbCA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlcyBhcmUgdmFsaWQgZGF0ZSBvciBub3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHllYXIgLSBZZWFyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1vbnRoIC0gTW9udGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGF0ZSAtIERheSBpbiBtb250aC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgdmFsaWQ/XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNWYWxpZERhdGUoeWVhciwgbW9udGgsIGRhdGUpIHtcbiAgICAgICAgdmFyIGlzVmFsaWRZZWFyLFxuICAgICAgICAgICAgaXNWYWxpZE1vbnRoLFxuICAgICAgICAgICAgaXNWYWxpZCxcbiAgICAgICAgICAgIGxhc3REYXlJbk1vbnRoO1xuXG4gICAgICAgIHllYXIgPSBOdW1iZXIoeWVhcik7XG4gICAgICAgIG1vbnRoID0gTnVtYmVyKG1vbnRoKTtcbiAgICAgICAgZGF0ZSA9IE51bWJlcihkYXRlKTtcblxuICAgICAgICBpc1ZhbGlkWWVhciA9ICh5ZWFyID4gLTEgJiYgeWVhciA8IDEwMCkgfHwgKHllYXIgPiAxOTY5KSAmJiAoeWVhciA8IDIwNzApO1xuICAgICAgICBpc1ZhbGlkTW9udGggPSAobW9udGggPiAwKSAmJiAobW9udGggPCAxMyk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkWWVhciB8fCAhaXNWYWxpZE1vbnRoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0RGF5SW5Nb250aCA9IE1PTlRIX0RBWVNbbW9udGhdO1xuICAgICAgICBpZiAobW9udGggPT09IDIgJiYgeWVhciAlIDQgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0RGF5SW5Nb250aCA9IDI5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaXNWYWxpZCA9IChkYXRlID4gMCkgJiYgKGRhdGUgPD0gbGFzdERheUluTW9udGgpO1xuICAgICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgdGhhdCB0cmFuc2Zvcm1lZCBmcm9tIHRoZSBnaXZlbiBmb3JtIGFuZCBkYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtIC0gRGF0ZSBmb3JtXG4gICAgICogQHBhcmFtIHtEYXRlfE9iamVjdH0gZGF0ZSAtIERhdGUgb2JqZWN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW58c3RyaW5nfSBBIHRyYW5zZm9ybWVkIHN0cmluZyBvciBmYWxzZS5cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICogIC8vIGtleSAgICAgICAgIHwgU2hvcnRoYW5kXG4gICAgICogIC8vIC0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqICAvLyB5ZWFycyAgICAgICB8IFlZIC8gWVlZWSAvIHl5IC8geXl5eVxuICAgICAqICAvLyBtb250aHMobikgICB8IE0gLyBNTVxuICAgICAqICAvLyBtb250aHMoc3RyKSB8IE1NTSAvIE1NTU1cbiAgICAgKiAgLy8gZGF5cyAgICAgICAgfCBEIC8gREQgLyBkIC8gZGRcbiAgICAgKiAgLy8gaG91cnMgICAgICAgfCBIIC8gSEggLyBoIC8gaGhcbiAgICAgKiAgLy8gbWludXRlcyAgICAgfCBtIC8gbW1cbiAgICAgKiAgLy8gQU0vUE0gICAgICAgfCBBIC8gYVxuICAgICAqXG4gICAgICogIHZhciBkYXRlU3RyMSA9IGZvcm1hdERhdGUoJ3l5eXktTU0tZGQnLCB7XG4gICAgICogICAgICB5ZWFyOiAyMDE0LFxuICAgICAqICAgICAgbW9udGg6IDEyLFxuICAgICAqICAgICAgZGF0ZTogMTJcbiAgICAgKiAgfSk7XG4gICAgICogIGFsZXJ0KGRhdGVTdHIxKTsgLy8gJzIwMTQtMTItMTInXG4gICAgICpcbiAgICAgKiAgdmFyIGRhdGVTdHIyID0gZm9ybWF0RGF0ZSgnTU1NIEREIFlZWVkgSEg6bW0nLCB7XG4gICAgICogICAgICB5ZWFyOiAxOTk5LFxuICAgICAqICAgICAgbW9udGg6IDksXG4gICAgICogICAgICBkYXRlOiA5LFxuICAgICAqICAgICAgaG91cjogMCxcbiAgICAgKiAgICAgIG1pbnV0ZTogMlxuICAgICAqICB9KVxuICAgICAqICBhbGVydChkYXRlU3RyMik7IC8vICdTZXAgMDkgMTk5OSAwMDowMidcbiAgICAgKlxuICAgICAqICB2YXIgZHQgPSBuZXcgRGF0ZSgyMDEwLCAyLCAxMyksXG4gICAgICogICAgICBkYXRlU3RyMyA9IGZvcm1hdERhdGUoJ3l5eXnrhYQgTeyblCBkZOydvCcsIGR0KTtcbiAgICAgKlxuICAgICAqICBhbGVydChkYXRlU3RyMyk7IC8vICcyMDEw64WEIDPsm5QgMTPsnbwnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ybWF0RGF0ZShmb3JtLCBkYXRlKSB7XG4gICAgICAgIHZhciBtZXJpZGlhbixcbiAgICAgICAgICAgIG5EYXRlLFxuICAgICAgICAgICAgcmVzdWx0U3RyO1xuXG4gICAgICAgIGlmIChuZS51dGlsLmlzRGF0ZShkYXRlKSkge1xuICAgICAgICAgICAgbkRhdGUgPSB7XG4gICAgICAgICAgICAgICAgeWVhcjogZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgICAgICAgIG1vbnRoOiBkYXRlLmdldE1vbnRoKCkgKyAxLFxuICAgICAgICAgICAgICAgIGRhdGU6IGRhdGUuZ2V0RGF0ZSgpLFxuICAgICAgICAgICAgICAgIGhvdXI6IGRhdGUuZ2V0SG91cnMoKSxcbiAgICAgICAgICAgICAgICBtaW51dGU6IGRhdGUuZ2V0TWludXRlcygpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbkRhdGUgPSB7XG4gICAgICAgICAgICAgICAgeWVhcjogZGF0ZS55ZWFyLFxuICAgICAgICAgICAgICAgIG1vbnRoOiBkYXRlLm1vbnRoLFxuICAgICAgICAgICAgICAgIGRhdGU6IGRhdGUuZGF0ZSxcbiAgICAgICAgICAgICAgICBob3VyOiBkYXRlLmhvdXIsXG4gICAgICAgICAgICAgICAgbWludXRlOiBkYXRlLm1pbnV0ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNWYWxpZERhdGUobkRhdGUueWVhciwgbkRhdGUubW9udGgsIG5EYXRlLmRhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBuRGF0ZS5tZXJpZGlhbiA9ICcnO1xuICAgICAgICBpZiAoL1teXFxcXF1bYUFdXFxiL2cudGVzdChmb3JtKSkge1xuICAgICAgICAgICAgbWVyaWRpYW4gPSAobkRhdGUuaG91ciA+IDEyKSA/ICdQTScgOiAnQU0nO1xuICAgICAgICAgICAgbkRhdGUuaG91ciAlPSAxMjtcbiAgICAgICAgICAgIG5EYXRlLm1lcmlkaWFuID0gbWVyaWRpYW47XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRTdHIgPSBmb3JtLnJlcGxhY2UodG9rZW5zLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZignXFxcXCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5LnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZU1hcFtrZXldKG5EYXRlKSB8fCAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHRTdHI7XG4gICAgfVxuXG4gICAgbmUudXRpbC5mb3JtYXREYXRlID0gZm9ybWF0RGF0ZTtcbn0pKHdpbmRvdy5uZSk7XG5cblxuLyoqKioqKioqKipcbiAqIGZ1bmMuanNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBtb2R1bGUgcHJvdmlkZXMgYSBiaW5kKCkgZnVuY3Rpb24gZm9yIGNvbnRleHQgYmluZGluZy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZTAyNDJAbmhuZW50LmNvbT5cbiAqL1xuXG4oZnVuY3Rpb24obmUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIW5lKSB7XG4gICAgICAgIG5lID0gd2luZG93Lm5lID0ge307XG4gICAgfVxuICAgIGlmICghbmUudXRpbCkge1xuICAgICAgICBuZS51dGlsID0gd2luZG93Lm5lLnV0aWwgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGhhcyBpdHMgdGhpcyBrZXl3b3JkIHNldCB0byB0aGUgcHJvdmlkZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gQSBvcmlnaW5hbCBmdW5jdGlvbiBiZWZvcmUgYmluZGluZ1xuICAgICAqIEBwYXJhbSB7Kn0gb2JqIGNvbnRleHQgb2YgZnVuY3Rpb24gaW4gYXJndW1lbnRzWzBdXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb24oKX0gQSBuZXcgYm91bmQgZnVuY3Rpb24gd2l0aCBjb250ZXh0IHRoYXQgaXMgaW4gYXJndW1lbnRzWzFdXG4gICAgICogQG1lbWJlcm9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kKGZuLCBvYmopIHtcbiAgICAgICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgICAgIGlmIChmbi5iaW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYmluZC5hcHBseShmbiwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmxlbmd0aCA/IGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIG5lLnV0aWwuYmluZCA9IGJpbmQ7XG5cbn0pKHdpbmRvdy5uZSk7XG5cbi8qKioqKioqKioqXG4gKiBoYXNoTWFwLmpzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgbW9kdWxlIHByb3ZpZGVzIHRoZSBIYXNoTWFwIGNvbnN0cnVjdG9yLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxlMDI0MkBuaG5lbnQuY29tPlxuICogQGRlcGVuZGVuY3kgdHlwZSwgY29sbGVjdGlvbi5qc1xuICovXG5cbihmdW5jdGlvbihuZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghbmUpIHtcbiAgICAgICAgbmUgPSB3aW5kb3cubmUgPSB7fTtcbiAgICB9XG4gICAgaWYgKCFuZS51dGlsKSB7XG4gICAgICAgIG5lLnV0aWwgPSB3aW5kb3cubmUudXRpbCA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsbCB0aGUgZGF0YSBpbiBoYXNoTWFwIGJlZ2luIHdpdGggX01BUERBVEFQUkVGSVg7XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHZhciBfTUFQREFUQVBSRUZJWCA9ICfDpSc7XG5cbiAgICAvKipcbiAgICAgKiBIYXNoTWFwIGNhbiBoYW5kbGUgdGhlIGtleS12YWx1ZSBwYWlycy48YnI+XG4gICAgICogQ2F1dGlvbjo8YnI+XG4gICAgICogIEhhc2hNYXAgaW5zdGFuY2UgaGFzIGEgbGVuZ3RoIHByb3BlcnR5IGJ1dCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgQXJyYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmpdIEEgaW5pdGlhbCBkYXRhIGZvciBjcmVhdGlvbi5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciBobSA9IG5ldyBuZS51dGlsLkhhc2hNYXAoe1xuICAgICAqICAgICAgJ215ZGF0YSc6IHtcbiAgICAgKiAgICAgICAgICAgJ2hlbGxvJzogJ2ltZmluZSdcbiAgICAgKiAgICAgICB9LFxuICAgICAqICAgICAgJ3doYXQnOiAndGltZSdcbiAgICAgKiAgfSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gSGFzaE1hcChvYmopIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNpemVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICB0aGlzLnNldE9iamVjdChvYmopO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgZGF0YSBmcm9tIHRoZSBnaXZlbiBrZXkgd2l0aCB2YWx1ZSBvciB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5IEEgc3RyaW5nIG9yIG9iamVjdCBmb3Iga2V5XG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdIEEgZGF0YVxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciBobSA9IG5ldyBIYXNoTWFwKCk7XG4gICAgICpcbiAgICAgKiAgaG0uc2V0KCdrZXknLCAndmFsdWUnKTtcbiAgICAgKiAgaG0uc2V0KHtcbiAgICAgKiAgICAgICdrZXkxJzogJ2RhdGExJyxcbiAgICAgKiAgICAgICdrZXkyJzogJ2RhdGEyJ1xuICAgICAqICB9KTtcbiAgICAgKi9cbiAgICBIYXNoTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0S2V5VmFsdWUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldE9iamVjdChrZXkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBhIGRhdGEgZnJvbSB0aGUgZ2l2ZW4ga2V5IHdpdGggdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBBIHN0cmluZyBmb3Iga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBIGRhdGFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICB2YXIgaG0gPSBuZXcgSGFzaE1hcCgpO1xuICAgICAqICBobS5zZXRLZXlWYWx1ZSgna2V5JywgJ3ZhbHVlJyk7XG4gICAgICovXG4gICAgSGFzaE1hcC5wcm90b3R5cGUuc2V0S2V5VmFsdWUgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW3RoaXMuZW5jb2RlS2V5KGtleSldID0gdmFsdWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBhIGRhdGEgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogQSBvYmplY3QgZm9yIGRhdGFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICB2YXIgaG0gPSBuZXcgSGFzaE1hcCgpO1xuICAgICAqXG4gICAgICogIGhtLnNldE9iamVjdCh7XG4gICAgICogICAgICAna2V5MSc6ICdkYXRhMScsXG4gICAgICogICAgICAna2V5Mic6ICdkYXRhMidcbiAgICAgKiAgfSk7XG4gICAgICovXG4gICAgSGFzaE1hcC5wcm90b3R5cGUuc2V0T2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBuZS51dGlsLmZvckVhY2hPd25Qcm9wZXJ0aWVzKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgc2VsZi5zZXRLZXlWYWx1ZShrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1lcmdlIHdpdGggdGhlIGdpdmVuIGFub3RoZXIgaGFzaE1hcC5cbiAgICAgKiBAcGFyYW0ge0hhc2hNYXB9IGhhc2hNYXAgQW5vdGhlciBoYXNoTWFwIGluc3RhbmNlXG4gICAgICovXG4gICAgSGFzaE1hcC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihoYXNoTWFwKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBoYXNoTWFwLmVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgc2VsZi5zZXRLZXlWYWx1ZShrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZSB0aGUgZ2l2ZW4ga2V5IGZvciBoYXNoTWFwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgQSBzdHJpbmcgZm9yIGtleVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEEgZW5jb2RlZCBrZXlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhhc2hNYXAucHJvdG90eXBlLmVuY29kZUtleSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gX01BUERBVEFQUkVGSVggKyBrZXk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZSB0aGUgZ2l2ZW4ga2V5IGluIGhhc2hNYXAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBBIHN0cmluZyBmb3Iga2V5XG4gICAgICogQHJldHVybnMge3N0cmluZ30gQSBkZWNvZGVkIGtleVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSGFzaE1hcC5wcm90b3R5cGUuZGVjb2RlS2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBkZWNvZGVkS2V5ID0ga2V5LnNwbGl0KF9NQVBEQVRBUFJFRklYKTtcbiAgICAgICAgcmV0dXJuIGRlY29kZWRLZXlbZGVjb2RlZEtleS5sZW5ndGgtMV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgQSBzdHJpbmcgZm9yIGtleVxuICAgICAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgZnJvbSBhIGtleVxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciBobSA9IG5ldyBIYXNoTWFwKCk7XG4gICAgICogIGhtLnNldCgna2V5JywgJ3ZhbHVlJyk7XG4gICAgICpcbiAgICAgKiAgaG0uZ2V0KCdrZXknKSAvLyB2YWx1ZVxuICAgICAqL1xuICAgIEhhc2hNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpc1t0aGlzLmVuY29kZUtleShrZXkpXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhlIGV4aXN0ZW5jZSBvZiBhIHZhbHVlIGZyb20gdGhlIGtleS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEEgc3RyaW5nIGZvciBrZXlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSW5kaWNhdGluZyB3aGV0aGVyIGEgdmFsdWUgZXhpc3RzIG9yIG5vdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICB2YXIgaG0gPSBuZXcgSGFzaE1hcCgpO1xuICAgICAqICBobS5zZXQoJ2tleScsICd2YWx1ZScpO1xuICAgICAqXG4gICAgICogIGhtLmhhcygna2V5JykgLy8gdHJ1ZVxuICAgICAqL1xuICAgIEhhc2hNYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNPd25Qcm9wZXJ0eSh0aGlzLmVuY29kZUtleShrZXkpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgZGF0YShrZXktdmFsdWUgcGFpcnMpIGZyb20gdGhlIGdpdmVuIGtleSBvciB0aGUgZ2l2ZW4ga2V5LWxpc3QuXG4gICAgICogQHBhcmFtIHsuLi5zdHJpbmd8c3RyaW5nW119IGtleSBBIHN0cmluZyBmb3Iga2V5XG4gICAgICogQHJldHVybnMge3N0cmluZ3xzdHJpbmdbXX0gQSByZW1vdmVkIGRhdGFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICB2YXIgaG0gPSBuZXcgSGFzaE1hcCgpO1xuICAgICAqICBobS5zZXQoJ2tleScsICd2YWx1ZScpO1xuICAgICAqICBobS5zZXQoJ2tleTInLCAndmFsdWUnKTtcbiAgICAgKlxuICAgICAqICAvL2V4MVxuICAgICAqICBobS5yZW1vdmUoJ2tleScpO1xuICAgICAqXG4gICAgICogIC8vZXgyXG4gICAgICogIGhtLnJlbW92ZSgna2V5JywgJ2tleTInKTtcbiAgICAgKlxuICAgICAqICAvL2V4M1xuICAgICAqICBobS5yZW1vdmUoWydrZXknLCAna2V5MiddKTtcbiAgICAgKi9cbiAgICBIYXNoTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBrZXkgPSBuZS51dGlsLnRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZS51dGlsLmlzQXJyYXkoa2V5KSA/IHRoaXMucmVtb3ZlQnlLZXlBcnJheShrZXkpIDogdGhpcy5yZW1vdmVCeUtleShrZXkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZGF0YShrZXktdmFsdWUgcGFpcikgZnJvbSB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgQSBzdHJpbmcgZm9yIGtleVxuICAgICAqIEByZXR1cm5zIHsqfG51bGx9IEEgcmVtb3ZlZCBkYXRhXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgdmFyIGhtID0gbmV3IEhhc2hNYXAoKTtcbiAgICAgKiAgaG0uc2V0KCdrZXknLCAndmFsdWUnKTtcbiAgICAgKlxuICAgICAqICBobS5yZW1vdmVCeUtleSgna2V5JylcbiAgICAgKi9cbiAgICBIYXNoTWFwLnByb3RvdHlwZS5yZW1vdmVCeUtleSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuaGFzKGtleSkgPyB0aGlzLmdldChrZXkpIDogbnVsbDtcblxuICAgICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXNbdGhpcy5lbmNvZGVLZXkoa2V5KV07XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGRhdGEoa2V5LXZhbHVlIHBhaXJzKSBmcm9tIHRoZSBnaXZlbiBrZXktbGlzdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBrZXlBcnJheSBBbiBhcnJheSBvZiBrZXlzXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBBIHJlbW92ZWQgZGF0YVxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciBobSA9IG5ldyBIYXNoTWFwKCk7XG4gICAgICogIGhtLnNldCgna2V5JywgJ3ZhbHVlJyk7XG4gICAgICogIGhtLnNldCgna2V5MicsICd2YWx1ZScpO1xuICAgICAqXG4gICAgICogIGhtLnJlbW92ZUJ5S2V5QXJyYXkoWydrZXknLCAna2V5MiddKTtcbiAgICAgKi9cbiAgICBIYXNoTWFwLnByb3RvdHlwZS5yZW1vdmVCeUtleUFycmF5ID0gZnVuY3Rpb24oa2V5QXJyYXkpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBbXSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIG5lLnV0aWwuZm9yRWFjaChrZXlBcnJheSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBkYXRhLnB1c2goc2VsZi5yZW1vdmVCeUtleShrZXkpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgdGhlIGRhdGFcbiAgICAgKi9cbiAgICBIYXNoTWFwLnByb3RvdHlwZS5yZW1vdmVBbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBzZWxmLnJlbW92ZShrZXkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBhbGwgdGhlIGRhdGEuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICB2YXIgaG0gPSBuZXcgSGFzaE1hcCgpO1xuICAgICAqICBobS5zZXQoJ2tleScsICd2YWx1ZScpO1xuICAgICAqICBobS5zZXQoJ2tleTInLCAndmFsdWUnKTtcbiAgICAgKlxuICAgICAqICBobS5lYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgICAgIC8vZG8gc29tZXRoaW5nLi4uXG4gICAgICogIH0pO1xuICAgICAqL1xuICAgIEhhc2hNYXAucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBmbGFnO1xuXG4gICAgICAgIG5lLnV0aWwuZm9yRWFjaE93blByb3BlcnRpZXModGhpcywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgaWYgKGtleS5jaGFyQXQoMCkgPT09IF9NQVBEQVRBUFJFRklYKSB7XG4gICAgICAgICAgICAgICAgZmxhZyA9IGl0ZXJhdGVlKHZhbHVlLCBzZWxmLmRlY29kZUtleShrZXkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZsYWcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGtleS1saXN0IHN0b3JlZC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEEga2V5LWxpc3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICB2YXIgaG0gPSBuZXcgSGFzaE1hcCgpO1xuICAgICAqICBobS5zZXQoJ2tleScsICd2YWx1ZScpO1xuICAgICAqICBobS5zZXQoJ2tleTInLCAndmFsdWUnKTtcbiAgICAgKlxuICAgICAqICBobS5rZXlzKCk7ICAvL1sna2V5JywgJ2tleTInKTtcbiAgICAgKi9cbiAgICBIYXNoTWFwLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBrZXlzID0gW10sXG4gICAgICAgICAgICBzZWxmID0gdGhpcztcblxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKHNlbGYuZGVjb2RlS2V5KGtleSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV29yayBzaW1pbGFybHkgdG8gQXJyYXkucHJvdG90eXBlLm1hcCgpLjxicj5cbiAgICAgKiBJdCBleGVjdXRlcyB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgdGhhdCBjaGVja3MgY29uZGl0aW9ucyBvbmNlIGZvciBlYWNoIGVsZW1lbnQgb2YgaGFzaE1hcCw8YnI+XG4gICAgICogIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IGhhdmluZyBlbGVtZW50cyBzYXRpc2Z5aW5nIHRoZSBjb25kaXRpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZGl0aW9uIEEgZnVuY3Rpb24gdGhhdCBjaGVja3MgY29uZGl0aW9uc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgaGF2aW5nIGVsZW1lbnRzIHNhdGlzZnlpbmcgdGhlIGNvbmRpdGlvbnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAvL2V4MVxuICAgICAqICB2YXIgaG0gPSBuZXcgSGFzaE1hcCgpO1xuICAgICAqICBobS5zZXQoJ2tleScsICd2YWx1ZScpO1xuICAgICAqICBobS5zZXQoJ2tleTInLCAndmFsdWUnKTtcbiAgICAgKlxuICAgICAqICBobS5maW5kKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgICAgIHJldHVybiBrZXkgPT09ICdrZXkyJztcbiAgICAgKiAgfSk7IC8vIFsndmFsdWUnXVxuICAgICAqXG4gICAgICogIC8vZXgyXG4gICAgICogIHZhciBobSA9IG5ldyBIYXNoTWFwKHtcbiAgICAgKiAgICAgICdteW9iajEnOiB7XG4gICAgICogICAgICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgKiAgICAgICB9LFxuICAgICAqICAgICAgJ215Ym9iajInOiB7XG4gICAgICogICAgICAgICAgIHZpc2libGU6IGZhbHNlXG4gICAgICogICAgICAgfVxuICAgICAqICB9KTtcbiAgICAgKlxuICAgICAqICBobS5maW5kKGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgICogICAgICByZXR1cm4gb2JqLnZpc2libGUgPT09IHRydWU7XG4gICAgICogIH0pOyAvLyBbe3Zpc2libGU6IHRydWV9XTtcbiAgICAgKi9cbiAgICBIYXNoTWFwLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oY29uZGl0aW9uKSB7XG4gICAgICAgIHZhciBmb3VuZHMgPSBbXTtcblxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgaWYgKGNvbmRpdGlvbih2YWx1ZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIGZvdW5kcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IEFycmF5IGhhdmluZyBhbGwgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgaGF2aW5nIGFsbCB2YWx1ZXNcbiAgICAgKi9cbiAgICBIYXNoTWFwLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIG5lLnV0aWwuSGFzaE1hcCA9IEhhc2hNYXA7XG5cbn0pKHdpbmRvdy5uZSk7XG5cbi8qKioqKioqKioqXG4gKiBpbmhlcml0YW5jZS5qc1xuICoqKioqKioqKiovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIG1vZHVsZSBwcm92aWRlcyBzb21lIHNpbXBsZSBmdW5jdGlvbiBmb3IgaW5oZXJpdGFuY2UuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGUwMjQyQG5obmVudC5jb20+XG4gKi9cblxuKGZ1bmN0aW9uKG5lKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghbmUpIHtcbiAgICAgICAgbmUgPSB3aW5kb3cubmUgPSB7fTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFuZS51dGlsKSB7XG4gICAgICAgIG5lLnV0aWwgPSB3aW5kb3cubmUudXRpbCA9IHt9O1xuICAgIH1cblxuXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBwcm90b3R5cGUgb2JqZWN0IGFuZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhpcyBvYmplY3Qgd2lsbCBiZSBhIHByb3RvdHlwZSBvZiB0aGUgbmV3bHktY3JlYXRlZCBvYmplY3QuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0KCkge1xuICAgICAgICBmdW5jdGlvbiBGKCkge31cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBGLnByb3RvdHlwZSA9IG9iajtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRigpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgYSBzaW1wbGUgaW5oZXJpdGFuY2UgaW4gcHJvdG90eXBlLW9yaWVudGVkLlxuICAgICAqIENhdXRpb24gOlxuICAgICAqICBEb24ndCBvdmVyd3JpdGUgdGhlIHByb3RvdHlwZSBvZiBjaGlsZCBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1YlR5cGUgQ2hpbGQgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlclR5cGUgUGFyZW50IGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG5lLnV0aWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAvLyBQYXJlbnQgY29uc3RydWN0b3JcbiAgICAgKiAgZnVuY3Rpb24gQW5pbWFsKGxlZykge1xuICAgICAqICAgICAgdGhpcy5sZWcgPSBsZWc7XG4gICAgICogIH1cbiAgICAgKlxuICAgICAqICBBbmltYWwucHJvdG90eXBlLmdyb3dsID0gZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAvLyAuLi5cbiAgICAgKiAgfTtcbiAgICAgKlxuICAgICAqICAvLyBDaGlsZCBjb25zdHJ1Y3RvclxuICAgICAqICBmdW5jdGlvbiBQZXJzb24obmFtZSkge1xuICAgICAqICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgKiAgfVxuICAgICAqXG4gICAgICogIC8vIEluaGVyaXRhbmNlXG4gICAgICogIGNvcmUuaW5oZXJpdChQZXJzb24sIEFuaW1hbCk7XG4gICAgICpcbiAgICAgKiAgLy8gQWZ0ZXIgdGhpcyBpbmhlcml0YW5jZSwgcGxlYXNlIHVzZSBvbmx5IHRoZSBleHRlbmRpbmcgb2YgcHJvcGVydHkuXG4gICAgICogIC8vIERvIG5vdCBvdmVyd3JpdGUgcHJvdG90eXBlLlxuICAgICAqICBQZXJzb24ucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbihkaXJlY3Rpb24pIHtcbiAgICAgKiAgICAgIC8vIC4uLlxuICAgICAqICB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaGVyaXQoc3ViVHlwZSwgc3VwZXJUeXBlKSB7XG4gICAgICAgIHZhciBwcm90b3R5cGUgPSBuZS51dGlsLmNyZWF0ZU9iamVjdChzdXBlclR5cGUucHJvdG90eXBlKTtcbiAgICAgICAgcHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViVHlwZTtcbiAgICAgICAgc3ViVHlwZS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgfVxuXG4gICAgbmUudXRpbC5jcmVhdGVPYmplY3QgPSBjcmVhdGVPYmplY3QoKTtcbiAgICBuZS51dGlsLmluaGVyaXQgPSBpbmhlcml0O1xuXG59KSh3aW5kb3cubmUpO1xuXG4vKioqKioqKioqKlxuICogbWFwLmpzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiAgSW1wbGVtZW50cyB0aGUgTWFwIG9iamVjdC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZTAyNDJAbmhuZW50LmNvbT5cbiAqIEBkZXBlbmRlbmN5IHR5cGUuanMsIGNvbGxlY3Rpb24uanNcbiAqL1xuXG4oZnVuY3Rpb24obmUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIW5lKSB7XG4gICAgICAgIG5lID0gd2luZG93Lm5lID0ge307XG4gICAgfVxuICAgIGlmICghbmUudXRpbCkge1xuICAgICAgICBuZS51dGlsID0gd2luZG93Lm5lLnV0aWwgPSB7fTtcbiAgICB9XG5cblxuICAgIC8vIENhY2hpbmcgbmUudXRpbCBmb3IgcGVyZm9ybWFuY2UgZW5oYW5jaW5nXG4gICAgdmFyIHV0aWwgPSBuZS51dGlsLFxuXG4gICAgLyoqXG4gICAgICogVXNpbmcgdW5kZWZpbmVkIGZvciBhIGtleSBjYW4gYmUgYW1iaWd1b3VzIGlmIHRoZXJlJ3MgZGVsZXRlZCBpdGVtIGluIHRoZSBhcnJheSw8YnI+XG4gICAgICogd2hpY2ggaXMgYWxzbyB1bmRlZmluZWQgd2hlbiBhY2Nlc3NlZCBieSBpbmRleC48YnI+XG4gICAgICogU28gdXNlIHRoaXMgdW5pcXVlIG9iamVjdCBhcyBhbiB1bmRlZmluZWQga2V5IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb20gZGVsZXRlZCBrZXlzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgX0tFWV9GT1JfVU5ERUZJTkVEID0ge30sXG5cbiAgICAvKipcbiAgICAgKiBGb3IgdXNpbmcgTmFOIGFzIGEga2V5LCB1c2UgdGhpcyB1bmlxdWUgb2JqZWN0IGFzIGEgTmFOIGtleS48YnI+XG4gICAgICogVGhpcyBtYWtlcyBpdCBlYXNpZXIgYW5kIGZhc3RlciB0byBjb21wYXJlIGFuIG9iamVjdCB3aXRoIGVhY2gga2V5cyBpbiB0aGUgYXJyYXk8YnI+XG4gICAgICogdGhyb3VnaCBubyBleGNlcHRpb25hbCBjb21hcHJpbmcgZm9yIE5hTi5cbiAgICAgKi9cbiAgICBfS0VZX0ZPUl9OQU4gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIG9mIE1hcEl0ZXJhdG9yPGJyPlxuICAgICAqIENyZWF0ZXMgaXRlcmF0b3Igb2JqZWN0IHdpdGggbmV3IGtleXdvcmQuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGtleXMgLSBUaGUgYXJyYXkgb2Yga2V5cyBpbiB0aGUgbWFwXG4gICAgICogQHBhcmFtICB7ZnVuY3Rpb259IHZhbHVlR2V0dGVyIC0gRnVuY3Rpb24gdGhhdCByZXR1cm5zIGNlcnRhaW4gdmFsdWUsXG4gICAgICogICAgICB0YWtpbmcga2V5IGFuZCBrZXlJbmRleCBhcyBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFwSXRlcmF0b3Ioa2V5cywgdmFsdWVHZXR0ZXIpIHtcbiAgICAgICAgdGhpcy5fa2V5cyA9IGtleXM7XG4gICAgICAgIHRoaXMuX3ZhbHVlR2V0dGVyID0gdmFsdWVHZXR0ZXI7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHRoaXMuX2tleXMubGVuZ3RoO1xuICAgICAgICB0aGlzLl9pbmRleCA9IC0xO1xuICAgICAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50YXRpb24gb2YgSXRlcmF0b3IgcHJvdG9jb2wuXG4gICAgICogQHJldHVybiB7e2RvbmU6IGJvb2xlYW4sIHZhbHVlOiAqfX0gT2JqZWN0IHRoYXQgY29udGFpbnMgZG9uZShib29sZWFuKSBhbmQgdmFsdWUuXG4gICAgICovXG4gICAgTWFwSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICB0aGlzLl9pbmRleCArPSAxO1xuICAgICAgIH0gd2hpbGUgKHV0aWwuaXNVbmRlZmluZWQodGhpcy5fa2V5c1t0aGlzLl9pbmRleF0pICYmIHRoaXMuX2luZGV4IDwgdGhpcy5fbGVuZ3RoKTtcblxuICAgICAgICBpZiAodGhpcy5faW5kZXggPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgICBkYXRhLmRvbmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YS5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICBkYXRhLnZhbHVlID0gdGhpcy5fdmFsdWVHZXR0ZXIodGhpcy5fa2V5c1t0aGlzLl9pbmRleF0sIHRoaXMuX2luZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIE1hcCBvYmplY3QgaW1wbGVtZW50cyB0aGUgRVM2IE1hcCBzcGVjaWZpY2F0aW9uIGFzIGNsb3NlbHkgYXMgcG9zc2libGUuPGJyPlxuICAgICAqIEZvciB1c2luZyBvYmplY3RzIGFuZCBwcmltaXRpdmUgdmFsdWVzIGFzIGtleXMsIHRoaXMgb2JqZWN0IHVzZXMgYXJyYXkgaW50ZXJuYWxseS48YnI+XG4gICAgICogU28gaWYgdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIGdldCgpLCBzZXQoKSwgaGFzKCksIGRlbGV0ZSgpIHdpbGwgb3BlcmF0ZXMgaW4gTyhuKSw8YnI+XG4gICAgICogYW5kIGl0IGNhbiBjYXVzZSBwZXJmb3JtYW5jZSBpc3N1ZXMgd2l0aCBhIGxhcmdlIGRhdGFzZXQuXG4gICAgICpcbiAgICAgKiBGZWF0dXJlcyBsaXN0ZWQgYmVsb3cgYXJlIG5vdCBzdXBwb3J0ZWQuIChjYW4ndCBiZSBpbXBsZW50ZWQgd2l0aG91dCBuYXRpdmUgc3VwcG9ydClcbiAgICAgKiAtIE1hcCBvYmplY3QgaXMgaXRlcmFibGU8YnI+XG4gICAgICogLSBJdGVyYWJsZSBvYmplY3QgY2FuIGJlIHVzZWQgYXMgYW4gYXJndW1lbnQgb2YgY29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIElmIHRoZSBicm93c2VyIHN1cHBvcnRzIGZ1bGwgaW1wbGVtZW50YXRpb24gb2YgRVM2IE1hcCBzcGVjaWZpY2F0aW9uLCBuYXRpdmUgTWFwIG9iZWpjdFxuICAgICAqIHdpbGwgYmUgdXNlZCBpbnRlcm5hbGx5LlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBpbml0RGF0YSAtIEFycmF5IG9mIGtleS12YWx1ZSBwYWlycyAoMi1lbGVtZW50IEFycmF5cykuXG4gICAgICogICAgICBFYWNoIGtleS12YWx1ZSBwYWlyIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG5ldyBNYXBcbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1hcChpbml0RGF0YSkge1xuICAgICAgICB0aGlzLl92YWx1ZXNGb3JTdHJpbmcgPSB7fTtcbiAgICAgICAgdGhpcy5fdmFsdWVzRm9ySW5kZXggPSB7fTtcbiAgICAgICAgdGhpcy5fa2V5cyA9IFtdO1xuXG4gICAgICAgIGlmIChpbml0RGF0YSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0SW5pdERhdGEoaW5pdERhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYWxsIGVsZW1lbnRzIGluIHRoZSBpbml0RGF0YSB0byB0aGUgTWFwIG9iamVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAge0FycmF5fSBpbml0RGF0YSAtIEFycmF5IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgdG8gdGhlIE1hcCBvYmplY3RcbiAgICAgKi9cbiAgICBNYXAucHJvdG90eXBlLl9zZXRJbml0RGF0YSA9IGZ1bmN0aW9uKGluaXREYXRhKSB7XG4gICAgICAgIGlmICghdXRpbC5pc0FycmF5KGluaXREYXRhKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IEFycmF5IGlzIHN1cHBvcnRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmZvckVhY2hBcnJheShpbml0RGF0YSwgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICAgICAgdGhpcy5zZXQocGFpclswXSwgcGFpclsxXSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBOYU4uPGJyPlxuICAgICAqIEZvciB1bnNpbmcgTmFOIGFzIGEga2V5LCB1c2UgdGhpcyBtZXRob2QgdG8gdGVzdCBlcXVhbGl0eSBvZiBOYU48YnI+XG4gICAgICogYmVjYXVzZSA9PT0gb3BlcmF0b3IgZG9lc24ndCB3b3JrIGZvciBOYU4uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gQW55IG9iamVjdCB0byBiZSB0ZXN0ZWRcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIE5hTiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIE1hcC5wcm90b3R5cGUuX2lzTmFOID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IHZhbHVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgc3BlY2lmaWVkIGtleS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAgeyp9IGtleSAtIFRoZSBrZXkgb2JqZWN0IHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIHNwZWNpZmllZCBrZXlcbiAgICAgKi9cbiAgICBNYXAucHJvdG90eXBlLl9nZXRLZXlJbmRleCA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gLTEsXG4gICAgICAgICAgICB2YWx1ZTtcblxuICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3ZhbHVlc0ZvclN0cmluZ1trZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUua2V5SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB1dGlsLmluQXJyYXkoa2V5LCB0aGlzLl9rZXlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBrZXkgb2YgdGhlIHNwZWNpZmllZCBrZXkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHsqfSBrZXkgLSBrZXlcbiAgICAgKiBAcmV0dXJuIHsqfSBPcmlnaW5hbCBrZXlcbiAgICAgKi9cbiAgICBNYXAucHJvdG90eXBlLl9nZXRPcmlnaW5LZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIG9yaWdpbktleSA9IGtleTtcbiAgICAgICAgaWYgKGtleSA9PT0gX0tFWV9GT1JfVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICBvcmlnaW5LZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBfS0VZX0ZPUl9OQU4pIHtcbiAgICAgICAgICAgIG9yaWdpbktleSA9IE5hTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luS2V5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmlxdWUga2V5IG9mIHRoZSBzcGVjaWZpZWQga2V5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7Kn0ga2V5IC0ga2V5XG4gICAgICogQHJldHVybiB7Kn0gVW5pcXVlIGtleVxuICAgICAqL1xuICAgIE1hcC5wcm90b3R5cGUuX2dldFVuaXF1ZUtleSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgdW5pcXVlS2V5ID0ga2V5O1xuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChrZXkpKSB7XG4gICAgICAgICAgICB1bmlxdWVLZXkgPSBfS0VZX0ZPUl9VTkRFRklORUQ7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNOYU4oa2V5KSkge1xuICAgICAgICAgICAgdW5pcXVlS2V5ID0gX0tFWV9GT1JfTkFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmlxdWVLZXk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9iamVjdCBvZiB0aGUgc3BlY2lmaWVkIGtleS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAgeyp9IGtleSAtIFRoZSBrZXkgb2YgdGhlIHZhbHVlIG9iamVjdCB0byBiZSByZXR1cm5lZFxuICAgICAqIEBwYXJhbSAge251bWJlcn0ga2V5SW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGtleVxuICAgICAqIEByZXR1cm4ge3trZXlJbmRleDogbnVtYmVyLCBvcmlnaW46ICp9fSBWYWx1ZSBvYmplY3RcbiAgICAgKi9cbiAgICBNYXAucHJvdG90eXBlLl9nZXRWYWx1ZU9iamVjdCA9IGZ1bmN0aW9uKGtleSwga2V5SW5kZXgpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlc0ZvclN0cmluZ1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQoa2V5SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAga2V5SW5kZXggPSB0aGlzLl9nZXRLZXlJbmRleChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleUluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzRm9ySW5kZXhba2V5SW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQga2V5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7Kn0ga2V5IC0gVGhlIGtleSBvZiB0aGUgdmFsdWUgb2JqZWN0IHRvIGJlIHJldHVybmVkXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBrZXlJbmRleCAtIFRoZSBpbmRleCBvZiB0aGUga2V5XG4gICAgICogQHJldHVybiB7Kn0gT3JpZ2luYWwgdmFsdWVcbiAgICAgKi9cbiAgICBNYXAucHJvdG90eXBlLl9nZXRPcmlnaW5WYWx1ZSA9IGZ1bmN0aW9uKGtleSwga2V5SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFZhbHVlT2JqZWN0KGtleSwga2V5SW5kZXgpLm9yaWdpbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBrZXktdmFsdWUgcGFpciBvZiB0aGUgc3BlY2lmaWVkIGtleS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAgeyp9IGtleSAtIFRoZSBrZXkgb2YgdGhlIHZhbHVlIG9iamVjdCB0byBiZSByZXR1cm5lZFxuICAgICAqIEBwYXJhbSAge251bWJlcn0ga2V5SW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGtleVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBLZXktdmFsdWUgUGFpclxuICAgICAqL1xuICAgIE1hcC5wcm90b3R5cGUuX2dldEtleVZhbHVlUGFpciA9IGZ1bmN0aW9uKGtleSwga2V5SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLl9nZXRPcmlnaW5LZXkoa2V5KSwgdGhpcy5fZ2V0T3JpZ2luVmFsdWUoa2V5LCBrZXlJbmRleCldO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSB3cmFwcGVyIG9iamVjdCBvZiBvcmlnaW5hbCB2YWx1ZSB0aGF0IGNvbnRhaW5zIGEga2V5IGluZGV4XG4gICAgICogYW5kIHJldHVybnMgaXQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHt0eXBlfSBvcmlnaW4gLSBPcmlnaW5hbCB2YWx1ZVxuICAgICAqIEBwYXJhbSAge3R5cGV9IGtleUluZGV4IC0gSW5kZXggb2YgdGhlIGtleVxuICAgICAqIEByZXR1cm4ge3trZXlJbmRleDogbnVtYmVyLCBvcmlnaW46ICp9fSBWYWx1ZSBvYmplY3RcbiAgICAgKi9cbiAgICBNYXAucHJvdG90eXBlLl9jcmVhdGVWYWx1ZU9iamVjdCA9IGZ1bmN0aW9uKG9yaWdpbiwga2V5SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleUluZGV4OiBrZXlJbmRleCxcbiAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIGZvciB0aGUga2V5IGluIHRoZSBNYXAgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAgeyp9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBNYXAgb2JqZWN0XG4gICAgICogQHBhcmFtICB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBNYXAgb2JqZWN0XG4gICAgICogQHJldHVybiB7TWFwfSBUaGUgTWFwIG9iamVjdFxuICAgICAqL1xuICAgIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdW5pcXVlS2V5ID0gdGhpcy5fZ2V0VW5pcXVlS2V5KGtleSksXG4gICAgICAgICAgICBrZXlJbmRleCA9IHRoaXMuX2dldEtleUluZGV4KHVuaXF1ZUtleSksXG4gICAgICAgICAgICB2YWx1ZU9iamVjdDtcblxuICAgICAgICBpZiAoa2V5SW5kZXggPCAwKSB7XG4gICAgICAgICAgICBrZXlJbmRleCA9IHRoaXMuX2tleXMucHVzaCh1bmlxdWVLZXkpIC0gMTtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlT2JqZWN0ID0gdGhpcy5fY3JlYXRlVmFsdWVPYmplY3QodmFsdWUsIGtleUluZGV4KTtcblxuICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNGb3JTdHJpbmdba2V5XSA9IHZhbHVlT2JqZWN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzRm9ySW5kZXhba2V5SW5kZXhdID0gdmFsdWVPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgdG8gdGhlIGtleSwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vbmUuXG4gICAgICogQHBhcmFtICB7Kn0ga2V5IC0gVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZXR1cm5cbiAgICAgKiBAcmV0dXJuIHsqfSBFbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleVxuICAgICAqL1xuICAgIE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciB1bmlxdWVLZXkgPSB0aGlzLl9nZXRVbmlxdWVLZXkoa2V5KSxcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fZ2V0VmFsdWVPYmplY3QodW5pcXVlS2V5KTtcblxuICAgICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUub3JpZ2luO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBrZXlzIGZvciBlYWNoIGVsZW1lbnRcbiAgICAgKiBpbiB0aGUgTWFwIG9iamVjdCBpbiBpbnNlcnRpb24gb3JkZXIuXG4gICAgICogQHJldHVybiB7SXRlcmF0b3J9IEEgbmV3IEl0ZXJhdG9yIG9iamVjdFxuICAgICAqL1xuICAgIE1hcC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMuX2tleXMsIHV0aWwuYmluZCh0aGlzLl9nZXRPcmlnaW5LZXksIHRoaXMpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgdmFsdWVzIGZvciBlYWNoIGVsZW1lbnRcbiAgICAgKiBpbiB0aGUgTWFwIG9iamVjdCBpbiBpbnNlcnRpb24gb3JkZXIuXG4gICAgICogQHJldHVybiB7SXRlcmF0b3J9IEEgbmV3IEl0ZXJhdG9yIG9iamVjdFxuICAgICAqL1xuICAgIE1hcC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcy5fa2V5cywgdXRpbC5iaW5kKHRoaXMuX2dldE9yaWdpblZhbHVlLCB0aGlzKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgSXRlcmF0b3Igb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIFtrZXksIHZhbHVlXSBwYWlyc1xuICAgICAqIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIE1hcCBvYmplY3QgaW4gaW5zZXJ0aW9uIG9yZGVyLlxuICAgICAqIEByZXR1cm4ge0l0ZXJhdG9yfSBBIG5ldyBJdGVyYXRvciBvYmplY3RcbiAgICAgKi9cbiAgICBNYXAucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLl9rZXlzLCB1dGlsLmJpbmQodGhpcy5fZ2V0S2V5VmFsdWVQYWlyLCB0aGlzKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGFzc2VydGluZyB3aGV0aGVyIGEgdmFsdWUgaGFzIGJlZW4gYXNzb2NpYXRlZCB0byB0aGUga2V5XG4gICAgICogaW4gdGhlIE1hcCBvYmplY3Qgb3Igbm90LlxuICAgICAqIEBwYXJhbSAgeyp9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gdGVzdCBmb3IgcHJlc2VuY2VcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBleGlzdHM7XG4gICAgICogICAgICAgICAgT3RoZXJ3aXNlIGZhbHNlXG4gICAgICovXG4gICAgTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZ2V0VmFsdWVPYmplY3Qoa2V5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSBhIE1hcCBvYmplY3QuXG4gICAgICogQHBhcmFtIHsqfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZVxuICAgICAqL1xuICAgICAvLyBjYW5ub3QgdXNlIHJlc2VydmVkIGtleXdvcmQgYXMgYSBwcm9wZXJ0eSBuYW1lIGluIElFOCBhbmQgdW5kZXIuXG4gICAgTWFwLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGtleUluZGV4O1xuXG4gICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl92YWx1ZXNGb3JTdHJpbmdba2V5XSkge1xuICAgICAgICAgICAgICAgIGtleUluZGV4ID0gdGhpcy5fdmFsdWVzRm9yU3RyaW5nW2tleV0ua2V5SW5kZXg7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3ZhbHVlc0ZvclN0cmluZ1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5SW5kZXggPSB0aGlzLl9nZXRLZXlJbmRleChrZXkpO1xuICAgICAgICAgICAgaWYgKGtleUluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fdmFsdWVzRm9ySW5kZXhba2V5SW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleUluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9rZXlzW2tleUluZGV4XTtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSAtPSAxO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBwZXIgZWFjaCBrZXkvdmFsdWUgcGFpciBpbiB0aGUgTWFwIG9iamVjdCxcbiAgICAgKiBpbiBpbnNlcnRpb24gb3JkZXIuXG4gICAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBmb3IgZWFjaCBlbGVtZW50XG4gICAgICogQHBhcmFtICB7dGhpc0FyZ30gdGhpc0FyZyAtIFZhbHVlIHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrXG4gICAgICovXG4gICAgTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgdGhpc0FyZyA9IHRoaXNBcmcgfHwgdGhpcztcbiAgICAgICAgdXRpbC5mb3JFYWNoQXJyYXkodGhpcy5fa2V5cywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWQoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5fZ2V0VmFsdWVPYmplY3Qoa2V5KS5vcmlnaW4sIGtleSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGEgTWFwIG9iamVjdC5cbiAgICAgKi9cbiAgICBNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIE1hcC5jYWxsKHRoaXMpO1xuICAgIH07XG5cbiAgICAvLyBVc2UgbmF0aXZlIE1hcCBvYmplY3QgaWYgZXhpc3RzLlxuICAgIC8vIEJ1dCBvbmx5IGxhdGVzdCB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIEZpcmVmb3ggc3VwcG9ydCBmdWxsIGltcGxlbWVudGF0aW9uLlxuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJyb3dzZXIgPSB1dGlsLmJyb3dzZXI7XG4gICAgICAgIGlmICh3aW5kb3cuTWFwICYmIChcbiAgICAgICAgICAgIChicm93c2VyLmZpcmVmb3ggJiYgYnJvd3Nlci52ZXJzaW9uID49IDM3KSB8fFxuICAgICAgICAgICAgKGJyb3dzZXIuY2hyb21lICYmIGJyb3dzZXIudmVyc2lvbiA+PSA0MikgKSkge1xuICAgICAgICAgICAgTWFwID0gd2luZG93Lk1hcDtcbiAgICAgICAgfVxuICAgIH0pKCk7XG5cbiAgICB1dGlsLk1hcCA9IE1hcDtcbn0pKHdpbmRvdy5uZSk7XG5cbi8qKioqKioqKioqXG4gKiBvYmplY3QuanNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBtb2R1bGUgaGFzIHNvbWUgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBhIHBsYWluIG9iamVjdCwganNvbi5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZTAyNDJAbmhuZW50LmNvbT5cbiAqIEBkZXBlbmRlbmN5IHR5cGUuanMsIGNvbGxlY3Rpb24uanNcbiAqL1xuXG4oZnVuY3Rpb24obmUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFuZSkge1xuICAgICAgICBuZSA9IHdpbmRvdy5uZSA9IHt9O1xuICAgIH1cbiAgICBpZiAoIW5lLnV0aWwpIHtcbiAgICAgICAgbmUudXRpbCA9IHdpbmRvdy5uZS51dGlsID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIHRoZSB0YXJnZXQgb2JqZWN0IGZyb20gb3RoZXIgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gT2JqZWN0IHRoYXQgd2lsbCBiZSBleHRlbmRlZFxuICAgICAqIEBwYXJhbSB7Li4ub2JqZWN0fSBvYmplY3RzIC0gT2JqZWN0cyBhcyBzb3VyY2VzXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBFeHRlbmRlZCBvYmplY3RcbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIG9iamVjdHMpIHtcbiAgICAgICAgdmFyIHNvdXJjZSxcbiAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICBoYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBsZW47XG5cbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3AuY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCBpZCBvZiBzdGFtcFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdmFyIGxhc3RJZCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ24gYSB1bmlxdWUgaWQgdG8gYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIE9iamVjdCB0aGF0IHdpbGwgYmUgYXNzaWduZWQgaWQuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBTdGFtcGVkIGlkXG4gICAgICogQG1lbWJlck9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFtcChvYmopIHtcbiAgICAgICAgb2JqLl9fZmVfaWQgPSBvYmouX19mZV9pZCB8fCArK2xhc3RJZDtcbiAgICAgICAgcmV0dXJuIG9iai5fX2ZlX2lkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZlcmlmeSB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBzdGFtcGVkIGlkIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNTdGFtcChvYmopIHtcbiAgICAgICAgcmV0dXJuIG5lLnV0aWwuaXNFeGlzdHkobmUudXRpbC5waWNrKG9iaiwgJ19fZmVfaWQnKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGxhc3QgaWQgb2Ygc3RhbXBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXNldExhc3RJZCgpIHtcbiAgICAgICAgbGFzdElkID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBrZXktbGlzdChhcnJheSkgb2YgYSBnaXZlbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gT2JqZWN0IGZyb20gd2hpY2ggYSBrZXktbGlzdCB3aWxsIGJlIGV4dHJhY3RlZFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQSBrZXktbGlzdChhcnJheSlcbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXMob2JqKSB7XG4gICAgICAgIHZhciBrZXlzID0gW10sXG4gICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZXF1YWxpdHkgZm9yIG11bHRpcGxlIG9iamVjdHMoanNvbk9iamVjdHMpLjxicj5cbiAgICAgKiAgU2VlIHtAbGluayBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNjg4MzQvb2JqZWN0LWNvbXBhcmlzb24taW4tamF2YXNjcmlwdH1cbiAgICAgKiBAcGFyYW0gey4uLm9iamVjdH0gb2JqZWN0IC0gTXVsdGlwbGUgb2JqZWN0cyBmb3IgY29tcGFyaW5nLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IEVxdWFsaXR5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICB2YXIganNvbk9iajEgPSB7bmFtZTonbWlsaycsIHByaWNlOiAxMDAwfSxcbiAgICAgKiAgICAgIGpzb25PYmoyID0ge25hbWU6J21pbGsnLCBwcmljZTogMTAwMH0sXG4gICAgICogICAgICBqc29uT2JqMyA9IHtuYW1lOidtaWxrJywgcHJpY2U6IDEwMDB9O1xuICAgICAqXG4gICAgICogIG5lLnV0aWwuY29tcGFyZUpTT04oanNvbk9iajEsIGpzb25PYmoyLCBqc29uT2JqMyk7ICAgLy8gdHJ1ZVxuICAgICAqXG4gICAgICpcbiAgICAgKiAgdmFyIGpzb25PYmo0ID0ge25hbWU6J21pbGsnLCBwcmljZTogMTAwMH0sXG4gICAgICogICAgICBqc29uT2JqNSA9IHtuYW1lOidiZWVyJywgcHJpY2U6IDMwMDB9O1xuICAgICAqXG4gICAgICogICAgICBuZS51dGlsLmNvbXBhcmVKU09OKGpzb25PYmo0LCBqc29uT2JqNSk7IC8vIGZhbHNlXG5cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVKU09OKG9iamVjdCkge1xuICAgICAgICB2YXIgbGVmdENoYWluLFxuICAgICAgICAgICAgcmlnaHRDaGFpbixcbiAgICAgICAgICAgIGFyZ3NMZW4gPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBmdW5jdGlvbiBpc1NhbWVPYmplY3QoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHA7XG5cbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoYXQgTmFOID09PSBOYU4gcmV0dXJucyBmYWxzZVxuICAgICAgICAgICAgLy8gYW5kIGlzTmFOKHVuZGVmaW5lZCkgcmV0dXJucyB0cnVlXG4gICAgICAgICAgICBpZiAoaXNOYU4oeCkgJiZcbiAgICAgICAgICAgICAgICBpc05hTih5KSAmJlxuICAgICAgICAgICAgICAgIG5lLnV0aWwuaXNOdW1iZXIoeCkgJiZcbiAgICAgICAgICAgICAgICBuZS51dGlsLmlzTnVtYmVyKHkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbXBhcmUgcHJpbWl0aXZlcyBhbmQgZnVuY3Rpb25zLlxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYm90aCBhcmd1bWVudHMgbGluayB0byB0aGUgc2FtZSBvYmplY3QuXG4gICAgICAgICAgICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiBzdGVwIHdoZW4gY29tcGFyaW5nIHByb3RvdHlwZXNcbiAgICAgICAgICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdvcmtzIGluIGNhc2Ugd2hlbiBmdW5jdGlvbnMgYXJlIGNyZWF0ZWQgaW4gY29uc3RydWN0b3IuXG4gICAgICAgICAgICAvLyBDb21wYXJpbmcgZGF0ZXMgaXMgYSBjb21tb24gc2NlbmFyaW8uIEFub3RoZXIgYnVpbHQtaW5zP1xuICAgICAgICAgICAgLy8gV2UgY2FuIGV2ZW4gaGFuZGxlIGZ1bmN0aW9ucyBwYXNzZWQgYWNyb3NzIGlmcmFtZXNcbiAgICAgICAgICAgIGlmICgobmUudXRpbC5pc0Z1bmN0aW9uKHgpICYmIG5lLnV0aWwuaXNGdW5jdGlvbih5KSkgfHxcbiAgICAgICAgICAgICAgICAoeCBpbnN0YW5jZW9mIERhdGUgJiYgeSBpbnN0YW5jZW9mIERhdGUpIHx8XG4gICAgICAgICAgICAgICAgKHggaW5zdGFuY2VvZiBSZWdFeHAgJiYgeSBpbnN0YW5jZW9mIFJlZ0V4cCkgfHxcbiAgICAgICAgICAgICAgICAoeCBpbnN0YW5jZW9mIFN0cmluZyAmJiB5IGluc3RhbmNlb2YgU3RyaW5nKSB8fFxuICAgICAgICAgICAgICAgICh4IGluc3RhbmNlb2YgTnVtYmVyICYmIHkgaW5zdGFuY2VvZiBOdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudG9TdHJpbmcoKSA9PT0geS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBdCBsYXN0IGNoZWNraW5nIHByb3RvdHlwZXMgYXMgZ29vZCBhIHdlIGNhblxuICAgICAgICAgICAgaWYgKCEoeCBpbnN0YW5jZW9mIE9iamVjdCAmJiB5IGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHguaXNQcm90b3R5cGVPZih5KSB8fFxuICAgICAgICAgICAgICAgIHkuaXNQcm90b3R5cGVPZih4KSB8fFxuICAgICAgICAgICAgICAgIHguY29uc3RydWN0b3IgIT09IHkuY29uc3RydWN0b3IgfHxcbiAgICAgICAgICAgICAgICB4LnByb3RvdHlwZSAhPT0geS5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBpbmZpbml0aXZlIGxpbmtpbmcgbG9vcHNcbiAgICAgICAgICAgIGlmIChuZS51dGlsLmluQXJyYXkoeCwgbGVmdENoYWluKSA+IC0xIHx8XG4gICAgICAgICAgICAgICAgbmUudXRpbC5pbkFycmF5KHksIHJpZ2h0Q2hhaW4pID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFF1aWNrIGNoZWNraW5nIG9mIG9uZSBvYmplY3QgYmVlaW5nIGEgc3Vic2V0IG9mIGFub3RoZXIuXG4gICAgICAgICAgICBmb3IgKHAgaW4geSkge1xuICAgICAgICAgICAgICAgIGlmICh5Lmhhc093blByb3BlcnR5KHApICE9PSB4Lmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHlbcF0gIT09IHR5cGVvZiB4W3BdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vVGhpcyBmb3IgbG9vcCBleGVjdXRlcyBjb21wYXJpbmcgd2l0aCBoYXNPd25Qcm9wZXJ0eSgpIGFuZCB0eXBlb2YgZm9yIGVhY2ggcHJvcGVydHkgaW4gJ3gnIG9iamVjdCxcbiAgICAgICAgICAgIC8vYW5kIHZlcmlmeWluZyBlcXVhbGl0eSBmb3IgeFtwcm9wZXJ0eV0gYW5kIHlbcHJvcGVydHldLlxuICAgICAgICAgICAgZm9yIChwIGluIHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoeS5oYXNPd25Qcm9wZXJ0eShwKSAhPT0geC5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB5W3BdICE9PSB0eXBlb2YgeFtwXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZih4W3BdKSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mKHhbcF0pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRDaGFpbi5wdXNoKHgpO1xuICAgICAgICAgICAgICAgICAgICByaWdodENoYWluLnB1c2goeSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1NhbWVPYmplY3QoeFtwXSwgeVtwXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxlZnRDaGFpbi5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRDaGFpbi5wb3AoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHhbcF0gIT09IHlbcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJnc0xlbiA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3NMZW47IGkrKykge1xuICAgICAgICAgICAgbGVmdENoYWluID0gW107XG4gICAgICAgICAgICByaWdodENoYWluID0gW107XG5cbiAgICAgICAgICAgIGlmICghaXNTYW1lT2JqZWN0KGFyZ3VtZW50c1swXSwgYXJndW1lbnRzW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgbmVzdGVkIGl0ZW0gZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0L2FycmF5XG4gICAgICogQHBhcmFtIHtvYmplY3R8QXJyYXl9IG9iaiAtIE9iamVjdCBmb3IgcmV0cmlldmluZ1xuICAgICAqIEBwYXJhbSB7Li4uc3RyaW5nfG51bWJlcn0gcGF0aHMgLSBQYXRocyBvZiBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHsqfSBWYWx1ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciBvYmogPSB7XG4gICAgICogICAgICAna2V5MSc6IDEsXG4gICAgICogICAgICAnbmVzdGVkJyA6IHtcbiAgICAgKiAgICAgICAgICAna2V5MSc6IDExLFxuICAgICAqICAgICAgICAgICduZXN0ZWQnOiB7XG4gICAgICogICAgICAgICAgICAgICdrZXkxJzogMjFcbiAgICAgKiAgICAgICAgICB9XG4gICAgICogICAgICB9XG4gICAgICogIH07XG4gICAgICogIG5lLnV0aWwucGljayhvYmosICduZXN0ZWQnLCAnbmVzdGVkJywgJ2tleTEnKTsgLy8gMjFcbiAgICAgKiAgbmUudXRpbC5waWNrKG9iaiwgJ25lc3RlZCcsICduZXN0ZWQnLCAna2V5MicpOyAvLyB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqICB2YXIgYXJyID0gWydhJywgJ2InLCAnYyddO1xuICAgICAqICBuZS51dGlsLnBpY2soYXJyLCAxKTsgLy8gJ2InXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGljayhvYmosIHBhdGhzKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgdGFyZ2V0ID0gYXJnc1swXSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldFthcmdzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmUudXRpbC5leHRlbmQgPSBleHRlbmQ7XG4gICAgbmUudXRpbC5zdGFtcCA9IHN0YW1wO1xuICAgIG5lLnV0aWwuaGFzU3RhbXAgPSBoYXNTdGFtcDtcbiAgICBuZS51dGlsLl9yZXNldExhc3RJZCA9IHJlc2V0TGFzdElkO1xuICAgIG5lLnV0aWwua2V5cyA9IE9iamVjdC5rZXlzIHx8IGtleXM7XG4gICAgbmUudXRpbC5jb21wYXJlSlNPTiA9IGNvbXBhcmVKU09OO1xuICAgIG5lLnV0aWwucGljayA9IHBpY2s7XG59KSh3aW5kb3cubmUpO1xuXG4vKioqKioqKioqKlxuICogc3RyaW5nLmpzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgbW9kdWxlIGhhcyBzb21lIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgdGhlIHN0cmluZy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZTAyNDJAbmhuZW50LmNvbT5cbiAqL1xuXG4oZnVuY3Rpb24obmUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoIW5lKSB7XG4gICAgICAgIG5lID0gd2luZG93Lm5lID0ge307XG4gICAgfVxuICAgIGlmICghbmUudXRpbCkge1xuICAgICAgICBuZS51dGlsID0gd2luZG93Lm5lLnV0aWwgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gdGhlIGdpdmVuIEhUTUwgRW50aXR5IHN0cmluZyBpbnRvIHBsYWluIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBodG1sRW50aXR5IC0gSFRNTCBFbnRpdHkgdHlwZSBzdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFBsYWluIHN0cmluZ1xuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgdmFyIGh0bWxFbnRpdHlTdHJpbmcgPSBcIkEgJiMzOTtxdW90ZSYjMzk7IGlzICZsdDtiJmd0O2JvbGQmbHQ7L2ImZ3Q7XCJcbiAgICAgKiAgdmFyIHJlc3VsdCA9IGRlY29kZUhUTUxFbnRpdHkoaHRtbEVudGl0eVN0cmluZyk7IC8vXCJBICdxdW90ZScgaXMgPGI+Ym9sZDwvYj5cIlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlY29kZUhUTUxFbnRpdHkoaHRtbEVudGl0eSkge1xuICAgICAgICB2YXIgZW50aXRpZXMgPSB7JyZxdW90OycgOiAnXCInLCAnJmFtcDsnIDogJyYnLCAnJmx0OycgOiAnPCcsICcmZ3Q7JyA6ICc+JywgJyYjMzk7JyA6ICdcXCcnLCAnJm5ic3A7JyA6ICcgJ307XG4gICAgICAgIHJldHVybiBodG1sRW50aXR5LnJlcGxhY2UoLyZhbXA7fCZsdDt8Jmd0O3wmcXVvdDt8JiMzOTt8Jm5ic3A7L2csIGZ1bmN0aW9uKG0wKSB7XG4gICAgICAgICAgICByZXR1cm4gZW50aXRpZXNbbTBdID8gZW50aXRpZXNbbTBdIDogbTA7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSB0aGUgZ2l2ZW4gc3RyaW5nIGludG8gSFRNTCBFbnRpdHkgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGh0bWwgLSBTdHJpbmcgZm9yIGVuY29kaW5nXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBIVE1MIEVudGl0eVxuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgdmFyIGh0bWxFbnRpdHlTdHJpbmcgPSBcIjxzY3JpcHQ+IGFsZXJ0KCd0ZXN0Jyk7PC9zY3JpcHQ+PGEgaHJlZj0ndGVzdCc+XCI7XG4gICAgICogIHZhciByZXN1bHQgPSBlbmNvZGVIVE1MRW50aXR5KGh0bWxFbnRpdHlTdHJpbmcpOyAvL1wiJmx0O3NjcmlwdCZndDsgYWxlcnQoJiMzOTt0ZXN0JiMzOTspOyZsdDsvc2NyaXB0Jmd0OyZsdDthIGhyZWY9JiMzOTt0ZXN0JiMzOTsmZ3Q7XCJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmNvZGVIVE1MRW50aXR5KGh0bWwpIHtcbiAgICAgICAgdmFyIGVudGl0aWVzID0geydcIic6ICdxdW90JywgJyYnOiAnYW1wJywgJzwnOiAnbHQnLCAnPic6ICdndCcsICdcXCcnOiAnIzM5J307XG4gICAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoL1s8PiZcIiddL2csIGZ1bmN0aW9uKG0wKSB7XG4gICAgICAgICAgICByZXR1cm4gZW50aXRpZXNbbTBdID8gJyYnICsgZW50aXRpZXNbbTBdICsgJzsnIDogbTA7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB3aGV0aGVyIHRoZSBzdHJpbmcgY2FwYWJsZSB0byB0cmFuc2Zvcm0gaW50byBwbGFpbiBzdHJpbmcgaXMgaW4gdGhlIGdpdmVuIHN0cmluZyBvciBub3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNFbmNvZGFibGVTdHJpbmcoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAvWzw+JlwiJ10vLnRlc3Qoc3RyaW5nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gZHVwbGljYXRlIGNoYXJ0ZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhbmRTdHIxIFRoZSBvcGVyYW5kIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYW5kU3RyMiBUaGUgb3BlcmFuZCBzdHJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5lLnV0aWwuZ2V0RHVwbGljYXRlZENoYXIoJ2ZlIGRldicsICduaG4gZW50ZXJ0YWlubWVudCcpO1xuICAgICAqID0+ICdlJ1xuICAgICAqIG5lLnV0aWwuZ2V0RHVwbGljYXRlZENoYXIoJ2Zkc2EnLCAnYXNkZicpO1xuICAgICAqID0+ICdhc2RmJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldER1cGxpY2F0ZWRDaGFyKG9wZXJhbmRTdHIxLCBvcGVyYW5kU3RyMikge1xuICAgICAgICB2YXIgZHVwbCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gb3BlcmFuZFN0cjEubGVuZ3RoLFxuICAgICAgICAgICAgcG9vbCA9IHt9O1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGtleSA9IG9wZXJhbmRTdHIxLmNoYXJBdChpKTtcbiAgICAgICAgICAgIHBvb2xba2V5XSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBvcGVyYW5kU3RyMi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAga2V5ID0gb3BlcmFuZFN0cjIuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYocG9vbFtrZXldKSB7XG4gICAgICAgICAgICAgICAgcG9vbFtrZXldICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwb29sID0gbmUudXRpbC5maWx0ZXIocG9vbCwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0gPiAxO1xuICAgICAgICB9KTtcblxuICAgICAgICBwb29sID0gbmUudXRpbC5rZXlzKHBvb2wpLnNvcnQoKTtcbiAgICAgICAgZHVwbCA9IHBvb2wuam9pbignJyk7XG5cbiAgICAgICAgcmV0dXJuIGR1cGw7XG4gICAgfVxuXG4gICAgbmUudXRpbC5kZWNvZGVIVE1MRW50aXR5ID0gZGVjb2RlSFRNTEVudGl0eTtcbiAgICBuZS51dGlsLmVuY29kZUhUTUxFbnRpdHkgPSBlbmNvZGVIVE1MRW50aXR5O1xuICAgIG5lLnV0aWwuaGFzRW5jb2RhYmxlU3RyaW5nID0gaGFzRW5jb2RhYmxlU3RyaW5nO1xuICAgIG5lLnV0aWwuZ2V0RHVwbGljYXRlZENoYXIgPSBnZXREdXBsaWNhdGVkQ2hhcjtcblxufSkod2luZG93Lm5lKTtcblxuLyoqKioqKioqKipcbiAqIHRyaWNrcy5qc1xuICoqKioqKioqKiovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBjb2xsZWN0aW9ucyBvZiBzb21lIHRlY2huaWMgbWV0aG9kcy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZTAyNDIubmhuZW50LmNvbT5cbiAqL1xuXG4vKiogQG5hbWVzcGFjZSBuZSAqL1xuLyoqIEBuYW1lc3BhY2UgbmUudXRpbCAqL1xuXG4oZnVuY3Rpb24obmUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGFwcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghbmUpIHtcbiAgICAgICAgbmUgPSB3aW5kb3cubmUgPSB7fTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFuZS51dGlsKSB7XG4gICAgICAgIG5lLnV0aWwgPSB3aW5kb3cubmUudXRpbCA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgZm4gdW50aWwgYWZ0ZXIgZGVsYXkgbWlsbGlzZWNvbmRzIGhhcyBlbGFwc2VkXG4gICAgICogc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VjZWQgZnVuY3Rpb24gd2FzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXlcbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn0gZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzb21lTWV0aG9kVG9JbnZva2VEZWJvdW5jZWQoKSB7fVxuICAgICAqXG4gICAgICogdmFyIGRlYm91bmNlZCA9IG5lLnV0aWwuZGVib3VuY2Uoc29tZU1ldGhvZFRvSW52b2tlRGVib3VuY2VkLCAzMDApO1xuICAgICAqXG4gICAgICogLy8gaW52b2tlIHJlcGVhdGVkbHlcbiAgICAgKiBkZWJvdW5jZWQoKTtcbiAgICAgKiBkZWJvdW5jZWQoKTtcbiAgICAgKiBkZWJvdW5jZWQoKTtcbiAgICAgKiBkZWJvdW5jZWQoKTtcbiAgICAgKiBkZWJvdW5jZWQoKTtcbiAgICAgKiBkZWJvdW5jZWQoKTsgICAgLy8gbGFzdCBpbnZva2Ugb2YgZGVib3VuY2VkKClcbiAgICAgKlxuICAgICAqIC8vIGludm9rZSBzb21lTWV0aG9kVG9JbnZva2VEZWJvdW5jZWQoKSBhZnRlciAzMDAgbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZuLCBkZWxheSkge1xuICAgICAgICB2YXIgdGltZXIsXG4gICAgICAgICAgICBhcmdzO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlbGF5ID0gZGVsYXkgfHwgMDtcblxuICAgICAgICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIHRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVib3VuY2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aW1lc3RhbXBcbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGZyb20gSmFuLiAxOTcwIDAwOjAwOjAwIChHTVQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICAgICAgICByZXR1cm4gKyhuZXcgRGF0ZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGZuIGF0IG1vc3Qgb25jZSBwZXIgZXZlcnkgaW50ZXJ2YWwgbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogWW91IGNhbiB1c2UgdGhpcyB0aHJvdHRsZSBzaG9ydCB0aW1lIHJlcGVhdGVkbHkgaW52b2tpbmcgZnVuY3Rpb25zLiAoZS5nIE1vdXNlTW92ZSwgUmVzaXplIC4uLilcbiAgICAgKlxuICAgICAqIGlmIHlvdSBuZWVkIHJldXNlIHRocm90dGxlZCBtZXRob2QuIHlvdSBtdXN0IHJlbW92ZSBzbHVncyAoZS5nLiBmbGFnIHZhcmlhYmxlKSByZWxhdGVkIHdpdGggdGhyb3R0bGluZy5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBmdW5jdGlvbiB0byB0aHJvdHRsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaW50ZXJ2YWw9MF0gdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gICAgICogQG1lbWJlcm9mIG5lLnV0aWxcbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259IHRocm90dGxlZCBmdW5jdGlvblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzb21lTWV0aG9kVG9JbnZva2VUaHJvdHRsZWQoKSB7fVxuICAgICAqXG4gICAgICogdmFyIHRocm90dGxlZCA9IG5lLnV0aWwudGhyb3R0bGUoc29tZU1ldGhvZFRvSW52b2tlVGhyb3R0bGVkLCAzMDApO1xuICAgICAqXG4gICAgICogLy8gaW52b2tlIHJlcGVhdGVkbHlcbiAgICAgKiB0aHJvdHRsZWQoKTsgICAgLy8gaW52b2tlIChsZWFkaW5nKVxuICAgICAqIHRocm90dGxlZCgpO1xuICAgICAqIHRocm90dGxlZCgpOyAgICAvLyBpbnZva2UgKG5lYXIgMzAwIG1pbGxpc2Vjb25kcylcbiAgICAgKiB0aHJvdHRsZWQoKTtcbiAgICAgKiB0aHJvdHRsZWQoKTtcbiAgICAgKiB0aHJvdHRsZWQoKTsgICAgLy8gaW52b2tlIChuZWFyIDYwMCBtaWxsaXNlY29uZHMpXG4gICAgICogLy8gLi4uXG4gICAgICogLy8gaW52b2tlICh0cmFpbGluZylcbiAgICAgKlxuICAgICAqIC8vIGlmIHlvdSBuZWVkIHJldXNlIHRocm90dGxlZCBtZXRob2QuIHRoZW4gaW52b2tlIHJlc2V0KClcbiAgICAgKiB0aHJvdHRsZWQucmVzZXQoKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmbiwgaW50ZXJ2YWwpIHtcbiAgICAgICAgdmFyIGJhc2UsXG4gICAgICAgICAgICBfdGltZXN0YW1wID0gbmUudXRpbC50aW1lc3RhbXAsXG4gICAgICAgICAgICBkZWJvdW5jZWQsXG4gICAgICAgICAgICBpc0xlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgICAgc3RhbXAsXG4gICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgdGljayA9IGZ1bmN0aW9uKF9hcmdzKSB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgX2FyZ3MpO1xuICAgICAgICAgICAgICAgIGJhc2UgPSBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpbnRlcnZhbCA9IGludGVydmFsIHx8IDA7XG5cbiAgICAgICAgZGVib3VuY2VkID0gbmUudXRpbC5kZWJvdW5jZSh0aWNrLCBpbnRlcnZhbCk7XG5cbiAgICAgICAgZnVuY3Rpb24gdGhyb3R0bGVkKCkge1xuICAgICAgICAgICAgYXJncyA9IGFwcy5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmIChpc0xlYWRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aWNrKGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlzTGVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhbXAgPSBfdGltZXN0YW1wKCk7XG5cbiAgICAgICAgICAgIGJhc2UgPSBiYXNlIHx8IHN0YW1wO1xuXG4gICAgICAgICAgICBkZWJvdW5jZWQoKTtcblxuICAgICAgICAgICAgaWYgKChzdGFtcCAtIGJhc2UpID49IGludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgdGljayhhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgaXNMZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGJhc2UgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3R0bGVkLnJlc2V0ID0gcmVzZXQ7XG4gICAgICAgIHJldHVybiB0aHJvdHRsZWQ7XG4gICAgfVxuXG4gICAgbmUudXRpbC50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgbmUudXRpbC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIG5lLnV0aWwudGhyb3R0bGUgPSB0aHJvdHRsZTtcbn0pKHdpbmRvdy5uZSk7XG5cblxuLyoqKioqKioqKipcbiAqIHR5cGUuanNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBtb2R1bGUgcHJvdmlkZXMgc29tZSBmdW5jdGlvbnMgdG8gY2hlY2sgdGhlIHR5cGUgb2YgdmFyaWFibGVcbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZTAyNDJAbmhuZW50LmNvbT5cbiAqIEBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uanNcbiAqL1xuXG4oZnVuY3Rpb24obmUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFuZSkge1xuICAgICAgICBuZSA9IHdpbmRvdy5uZSA9IHt9O1xuICAgIH1cbiAgICBpZiAoIW5lLnV0aWwpIHtcbiAgICAgICAgbmUudXRpbCA9IHdpbmRvdy5uZS51dGlsID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgZXhpc3Rpbmcgb3Igbm90Ljxicj5cbiAgICAgKiAgSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIG5vdCBudWxsIGFuZCBub3QgdW5kZWZpbmVkLCByZXR1cm5zIHRydWUuXG4gICAgICogQHBhcmFtIHsqfSBwYXJhbSAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgZXhpc3R5P1xuICAgICAqIEBtZW1iZXJPZiBuZS51dGlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgbmUudXRpbC5pc0V4aXN0eSgnJyk7IC8vdHJ1ZVxuICAgICAqICBuZS51dGlsLmlzRXhpc3R5KDApOyAvL3RydWVcbiAgICAgKiAgbmUudXRpbC5pc0V4aXN0eShbXSk7IC8vdHJ1ZVxuICAgICAqICBuZS51dGlsLmlzRXhpc3R5KHt9KTsgLy90cnVlXG4gICAgICogIG5lLnV0aWwuaXNFeGlzdHkobnVsbCk7IC8vZmFsc2VcbiAgICAgKiAgbmUudXRpbC5pc0V4aXN0eSh1bmRlZmluZWQpOyAvL2ZhbHNlXG4gICAgKi9cbiAgICBmdW5jdGlvbiBpc0V4aXN0eShwYXJhbSkge1xuICAgICAgICByZXR1cm4gcGFyYW0gIT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyB1bmRlZmluZWQgb3Igbm90Ljxicj5cbiAgICAgKiAgSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgcmV0dXJucyB0cnVlLlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBJcyB1bmRlZmluZWQ/XG4gICAgICogQG1lbWJlck9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIG51bGwgb3Igbm90Ljxicj5cbiAgICAgKiAgSWYgdGhlIGdpdmVuIHZhcmlhYmxlKGFyZ3VtZW50c1swXSkgaXMgbnVsbCwgcmV0dXJucyB0cnVlLlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBJcyBudWxsP1xuICAgICAqIEBtZW1iZXJPZiBuZS51dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIHRydXRoeSBvciBub3QuPGJyPlxuICAgICAqICBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgbm90IG51bGwgb3Igbm90IHVuZGVmaW5lZCBvciBub3QgZmFsc2UsIHJldHVybnMgdHJ1ZS48YnI+XG4gICAgICogIChJdCByZWdhcmRzIDAgYXMgdHJ1ZSlcbiAgICAgKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyB0cnV0aHk/XG4gICAgICogQG1lbWJlck9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1RydXRoeShvYmopIHtcbiAgICAgICAgcmV0dXJuIGlzRXhpc3R5KG9iaikgJiYgb2JqICE9PSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBmYWxzeSBvciBub3QuPGJyPlxuICAgICAqICBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgbnVsbCBvciB1bmRlZmluZWQgb3IgZmFsc2UsIHJldHVybnMgdHJ1ZS5cbiAgICAgKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBmYWxzeT9cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmFsc3kob2JqKSB7XG4gICAgICAgIHJldHVybiAhaXNUcnV0aHkob2JqKTtcbiAgICB9XG5cblxuICAgIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBhcmd1bWVudHMgb2JqZWN0IG9yIG5vdC48YnI+XG4gICAgICogIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBhcmd1bWVudHMgb2JqZWN0LCByZXR1cm4gdHJ1ZS5cbiAgICAgKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBhcmd1bWVudHM/XG4gICAgICogQG1lbWJlck9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmopIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGlzRXhpc3R5KG9iaikgJiZcbiAgICAgICAgICAgICgodG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcmd1bWVudHNdJykgfHwgISFvYmouY2FsbGVlKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFuIGluc3RhbmNlIG9mIEFycmF5IG9yIG5vdC48YnI+XG4gICAgICogIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBpbnN0YW5jZSBvZiBBcnJheSwgcmV0dXJuIHRydWUuXG4gICAgICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgYXJyYXkgaW5zdGFuY2U/XG4gICAgICogQG1lbWJlck9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgQXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYW4gb2JqZWN0IG9yIG5vdC48YnI+XG4gICAgICogIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBvYmplY3QsIHJldHVybiB0cnVlLlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIG9iamVjdD9cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgICAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uIG9yIG5vdC48YnI+XG4gICAgICogIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uLCByZXR1cm4gdHJ1ZS5cbiAgICAgKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBmdW5jdGlvbj9cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBGdW5jdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIG51bWJlciBvciBub3QuPGJyPlxuICAgICAqICBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBudW1iZXIsIHJldHVybiB0cnVlLlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIG51bWJlcj9cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgTnVtYmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgc3RyaW5nIG9yIG5vdC48YnI+XG4gICAgICogIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIHN0cmluZywgcmV0dXJuIHRydWUuXG4gICAgICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgc3RyaW5nP1xuICAgICAqIEBtZW1iZXJPZiBuZS51dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyB8fCBvYmogaW5zdGFuY2VvZiBTdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBib29sZWFuIG9yIG5vdC48YnI+XG4gICAgICogIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGJvb2xlYW4sIHJldHVybiB0cnVlLlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGJvb2xlYW4/XG4gICAgICogQG1lbWJlck9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4ob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnYm9vbGVhbicgfHwgb2JqIGluc3RhbmNlb2YgQm9vbGVhbjtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFuIGluc3RhbmNlIG9mIEFycmF5IG9yIG5vdC48YnI+XG4gICAgICogIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBpbnN0YW5jZSBvZiBBcnJheSwgcmV0dXJuIHRydWUuPGJyPlxuICAgICAqICAoSXQgaXMgdXNlZCBmb3IgbXVsdGlwbGUgZnJhbWUgZW52aXJvbm1lbnRzKVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGFuIGluc3RhbmNlIG9mIGFycmF5P1xuICAgICAqIEBtZW1iZXJPZiBuZS51dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheVNhZmUob2JqKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvbiBvciBub3QuPGJyPlxuICAgICAqICBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvbiwgcmV0dXJuIHRydWUuPGJyPlxuICAgICAqICAoSXQgaXMgdXNlZCBmb3IgbXVsdGlwbGUgZnJhbWUgZW52aXJvbm1lbnRzKVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGEgZnVuY3Rpb24/XG4gICAgICogQG1lbWJlck9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uU2FmZShvYmopIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIG51bWJlciBvciBub3QuPGJyPlxuICAgICAqICBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBudW1iZXIsIHJldHVybiB0cnVlLjxicj5cbiAgICAgKiAgKEl0IGlzIHVzZWQgZm9yIG11bHRpcGxlIGZyYW1lIGVudmlyb25tZW50cylcbiAgICAgKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBhIG51bWJlcj9cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyU2FmZShvYmopIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBzdHJpbmcgb3Igbm90Ljxicj5cbiAgICAgKiAgSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgc3RyaW5nLCByZXR1cm4gdHJ1ZS48YnI+XG4gICAgICogIChJdCBpcyB1c2VkIGZvciBtdWx0aXBsZSBmcmFtZSBlbnZpcm9ubWVudHMpXG4gICAgICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgYSBzdHJpbmc/XG4gICAgICogQG1lbWJlck9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZ1NhZmUob2JqKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgYm9vbGVhbiBvciBub3QuPGJyPlxuICAgICAqICBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBib29sZWFuLCByZXR1cm4gdHJ1ZS48YnI+XG4gICAgICogIChJdCBpcyB1c2VkIGZvciBtdWx0aXBsZSBmcmFtZSBlbnZpcm9ubWVudHMpXG4gICAgICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgYSBib29sZWFuP1xuICAgICAqIEBtZW1iZXJPZiBuZS51dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuU2FmZShvYmopIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgaW5zdGFuY2Ugb2YgSFRNTE5vZGUgb3Igbm90Ljxicj5cbiAgICAgKiAgSWYgdGhlIGdpdmVuIHZhcmlhYmxlcyBpcyBhIGluc3RhbmNlIG9mIEhUTUxOb2RlLCByZXR1cm4gdHJ1ZS5cbiAgICAgKiBAcGFyYW0geyp9IGh0bWwgLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgSFRNTE5vZGUgP1xuICAgICAqIEBtZW1iZXJPZiBuZS51dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNIVE1MTm9kZShodG1sKSB7XG4gICAgICAgIGlmICh0eXBlb2YoSFRNTEVsZW1lbnQpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIChodG1sICYmIChodG1sIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgISFodG1sLm5vZGVUeXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhKGh0bWwgJiYgaHRtbC5ub2RlVHlwZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBIVE1MIHRhZyBvciBub3QuPGJyPlxuICAgICAqICBJZiB0aGUgZ2l2ZW4gdmFyaWFibGVzIGlzIGEgSFRNTCB0YWcsIHJldHVybiB0cnVlLlxuICAgICAqIEBwYXJhbSB7Kn0gaHRtbCAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBJcyBIVE1MIHRhZz9cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSFRNTFRhZyhodG1sKSB7XG4gICAgICAgIGlmICh0eXBlb2YoSFRNTEVsZW1lbnQpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIChodG1sICYmIChodG1sIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISEoaHRtbCAmJiBodG1sLm5vZGVUeXBlICYmIGh0bWwubm9kZVR5cGUgPT09IDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGVtcHR5KG51bGwsIHVuZGVmaW5lZCwgb3IgZW1wdHkgYXJyYXksIGVtcHR5IG9iamVjdCkgb3Igbm90Ljxicj5cbiAgICAgKiAgSWYgdGhlIGdpdmVuIHZhcmlhYmxlcyBpcyBlbXB0eSwgcmV0dXJuIHRydWUuXG4gICAgICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZW1wdHk/XG4gICAgICogQG1lbWJlck9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgICAgICB2YXIgaGFzS2V5ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFpc0V4aXN0eShvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1N0cmluZyhvYmopICYmIG9iaiA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQXJyYXkob2JqKSB8fCBpc0FyZ3VtZW50cyhvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc09iamVjdChvYmopICYmICFpc0Z1bmN0aW9uKG9iaikpIHtcbiAgICAgICAgICAgIG5lLnV0aWwuZm9yRWFjaE93blByb3BlcnRpZXMob2JqLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBoYXNLZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gIWhhc0tleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgbm90IGVtcHR5KG5vdCBudWxsLCBub3QgdW5kZWZpbmVkLCBvciBub3QgZW1wdHkgYXJyYXksIG5vdCBlbXB0eSBvYmplY3QpIG9yIG5vdC48YnI+XG4gICAgICogIElmIHRoZSBnaXZlbiB2YXJpYWJsZXMgaXMgbm90IGVtcHR5LCByZXR1cm4gdHJ1ZS5cbiAgICAgKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBub3QgZW1wdHk/XG4gICAgICogQG1lbWJlck9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05vdEVtcHR5KG9iaikge1xuICAgICAgICByZXR1cm4gIWlzRW1wdHkob2JqKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBpbnN0YW5jZSBvZiBEYXRlIG9yIG5vdC48YnI+XG4gICAgICogIElmIHRoZSBnaXZlbiB2YXJpYWJsZXMgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZSwgcmV0dXJuIHRydWUuXG4gICAgICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IElzIGFuIGluc3RhbmNlIG9mIERhdGU/XG4gICAgICogQG1lbWJlck9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0RhdGUob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFuIGluc3RhbmNlIG9mIERhdGUgb3Igbm90Ljxicj5cbiAgICAgKiAgSWYgdGhlIGdpdmVuIHZhcmlhYmxlcyBpcyBhbiBpbnN0YW5jZSBvZiBEYXRlLCByZXR1cm4gdHJ1ZS48YnI+XG4gICAgICogIChJdCBpcyB1c2VkIGZvciBtdWx0aXBsZSBmcmFtZSBlbnZpcm9ubWVudHMpXG4gICAgICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IElzIGFuIGluc3RhbmNlIG9mIERhdGU/XG4gICAgICogQG1lbWJlck9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0RhdGVTYWZlKG9iaikge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBEYXRlXSc7XG4gICAgfVxuXG5cbiAgICBuZS51dGlsLmlzRXhpc3R5ID0gaXNFeGlzdHk7XG4gICAgbmUudXRpbC5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuICAgIG5lLnV0aWwuaXNOdWxsID0gaXNOdWxsO1xuICAgIG5lLnV0aWwuaXNUcnV0aHkgPSBpc1RydXRoeTtcbiAgICBuZS51dGlsLmlzRmFsc3kgPSBpc0ZhbHN5O1xuICAgIG5lLnV0aWwuaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgICBuZS51dGlsLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGlzQXJyYXk7XG4gICAgbmUudXRpbC5pc0FycmF5U2FmZSA9IEFycmF5LmlzQXJyYXkgfHwgaXNBcnJheVNhZmU7XG4gICAgbmUudXRpbC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIG5lLnV0aWwuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgbmUudXRpbC5pc0Z1bmN0aW9uU2FmZSA9IGlzRnVuY3Rpb25TYWZlO1xuICAgIG5lLnV0aWwuaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgICBuZS51dGlsLmlzTnVtYmVyU2FmZSA9IGlzTnVtYmVyU2FmZTtcbiAgICBuZS51dGlsLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICBuZS51dGlsLmlzRGF0ZVNhZmUgPSBpc0RhdGVTYWZlO1xuICAgIG5lLnV0aWwuaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBuZS51dGlsLmlzU3RyaW5nU2FmZSA9IGlzU3RyaW5nU2FmZTtcbiAgICBuZS51dGlsLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbiAgICBuZS51dGlsLmlzQm9vbGVhblNhZmUgPSBpc0Jvb2xlYW5TYWZlO1xuICAgIG5lLnV0aWwuaXNIVE1MTm9kZSA9IGlzSFRNTE5vZGU7XG4gICAgbmUudXRpbC5pc0hUTUxUYWcgPSBpc0hUTUxUYWc7XG4gICAgbmUudXRpbC5pc0VtcHR5ID0gaXNFbXB0eTtcbiAgICBuZS51dGlsLmlzTm90RW1wdHkgPSBpc05vdEVtcHR5O1xuXG59KSh3aW5kb3cubmUpO1xuXG4vKioqKioqKioqKlxuICogd2luZG93LmpzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgbW9kdWxlIGhhcyBzb21lIG1ldGhvZHMgZm9yIGhhbmRsaW5nIHBvcHVwLXdpbmRvd1xuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxlMDI0MkBuaG5lbnQuY29tPlxuICogQGRlcGVuZGVuY3kgYnJvd3Nlci5qcywgdHlwZS5qcywgb2JqZWN0LmpzLCBjb2xsZWN0aW9uLmpzLCBmdW5jLmpzLCB3aW5kb3cuanNcbiAqL1xuXG4oZnVuY3Rpb24obmUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKCFuZSkge1xuICAgICAgICBuZSA9IHdpbmRvdy5uZSA9IHt9O1xuICAgIH1cbiAgICBpZiAoIW5lLnV0aWwpIHtcbiAgICAgICAgbmUudXRpbCA9IHdpbmRvdy5uZS51dGlsID0ge307XG4gICAgfVxuXG4gICAgdmFyIHBvcHVwX2lkID0gMDtcblxuICAgIC8qKlxuICAgICAqIFBvcHVwIG1hbmFnZW1lbnQgY2xhc3NcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBvcHVwKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWNoaW5nIHRoZSB3aW5kb3ctY29udGV4dHMgb2Ygb3BlbmVkIHBvcHVwc1xuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcGVuZWRQb3B1cCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbiBJRTcsIGFuIGVycm9yIG9jY3VycyB3aGVuIHRoZSBjbG9zZVdpdGhQYXJlbnQgcHJvcGVydHkgYXR0YWNoZXMgdG8gd2luZG93IG9iamVjdC48YnI+XG4gICAgICAgICAqIFNvLCBJdCBpcyBmb3Igc2F2aW5nIHRoZSB2YWx1ZSBvZiBjbG9zZVdpdGhQYXJlbnQgaW5zdGVhZCBvZiBhdHRhY2hpbmcgdG8gd2luZG93IG9iamVjdC5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2VXaXRoUGFyZW50UG9wdXAgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUG9zdCBkYXRhIGJyaWRnZSBmb3IgSUUxMSBwb3B1cFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3N0RGF0YUJyaWRnZVVybCA9ICcnO1xuICAgIH1cblxuICAgIC8qKioqKioqKioqXG4gICAgICogcHVibGljIG1ldGhvZHNcbiAgICAgKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwb3B1cC1saXN0IGFkbWluaXN0ZXJlZCBieSBjdXJyZW50IHdpbmRvdy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBwb3B1cC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBwb3B1cCB3aW5kb3cgbGlzdCBvYmplY3RcbiAgICAgKi9cbiAgICBQb3B1cC5wcm90b3R5cGUuZ2V0UG9wdXBMaXN0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciB0YXJnZXQ7XG4gICAgICAgIGlmIChuZS51dGlsLmlzRXhpc3R5KGtleSkpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMub3BlbmVkUG9wdXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMub3BlbmVkUG9wdXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogT3BlbiBwb3B1cFxuICAgICAqIENhdXRpb246XG4gICAgICogIEluIElFMTEsIHdoZW4gdHJhbnNmZXIgZGF0YSB0byBwb3B1cCBieSBQT1NULCBtdXN0IHNldCB0aGUgcG9zdERhdGFCcmlkZ2VVcmwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gcG9wdXAgdXJsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBvcHVwTmFtZV0gLSBLZXkgb2YgcG9wdXAgd2luZG93Ljxicj5cbiAgICAgKiAgICAgIElmIHRoZSBrZXkgaXMgc2V0LCB3aGVuIHlvdSB0cnkgdG8gb3BlbiBieSB0aGlzIGtleSwgdGhlIHBvcHVwIG9mIHRoaXMga2V5IGlzIGZvY3VzZWQuPGJyPlxuICAgICAqICAgICAgT3IgZWxzZSBhIG5ldyBwb3B1cCB3aW5kb3cgaGF2aW5nIHRoaXMga2V5IGlzIG9wZW5lZC5cbiAgICAgKlxuICAgICAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucG9wdXBPcHRpb25TdHI9XCJcIl0gLSBPcHRpb24gc3RyaW5nIG9mIHBvcHVwIHdpbmRvdzxicj5cbiAgICAgKiAgICAgIEl0IGlzIHNhbWUgd2l0aCB0aGUgdGhpcmQgcGFyYW1ldGVyIG9mIHdpbmRvdy5vcGVuKCkgbWV0aG9kLjxicj5cbiAgICAgKiAgICAgIFNlZSB7QGxpbmsgaHR0cDovL3d3dy53M3NjaG9vbHMuY29tL2pzcmVmL21ldF93aW5fb3Blbi5hc3B9XG4gICAgICpcbiAgICAgKiAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jbG9zZVdpdGhQYXJlbnQ9dHJ1ZV0gLSBJcyBjbG9zZWQgd2hlbiBwYXJlbnQgd2luZG93IGNsb3NlZD9cbiAgICAgKlxuICAgICAqICAgICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnVzZVJlbG9hZD1mYWxzZV0gLSBUaGlzIHByb3BlcnR5IGluZGljYXRlcyB3aGV0aGVyIHJlbG9hZCB0aGUgcG9wdXAgb3Igbm90Ljxicj5cbiAgICAgKiAgICAgIElmIHRydWUsIHRoZSBwb3B1cCB3aWxsIGJlIHJlbG9hZGVkIHdoZW4geW91IHRyeSB0byByZS1vcGVuIHRoZSBwb3B1cCB0aGF0IGhhcyBiZWVuIG9wZW5lZC48YnI+XG4gICAgICogICAgICBXaGVuIHRyYW5zbWl0IHRoZSBQT1NULWRhdGEsIHNvbWUgYnJvd3NlcnMgYWxlcnQgYSBtZXNzYWdlIGZvciBjb25maXJtaW5nIHdoZXRoZXIgcmV0cmFuc21pdCBvciBub3QuXG4gICAgICpcbiAgICAgKiAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBvc3REYXRhQnJpZGdlVXJsPScnXSAtIFVzZSB0aGlzIHVybCB0byBhdm9pZCBhIGNlcnRhaW4gYnVnIG9jY3VyaW5nIHdoZW4gdHJhbnNtaXR0aW5nIFBPU1QgZGF0YSB0byB0aGUgcG9wdXAgaW4gSUUxMS48YnI+XG4gICAgICogICAgICBUaGlzIHNwZWNpZmljIGJ1Z2d5IHNpdHVhdGlvbiBpcyBrbm93biB0byBoYXBwZW4gYmVjYXVzZSBJRTExIHRyaWVzIHRvIG9wZW4gdGhlIHJlcXVlc3RlZCB1cmwgbm90IGluIGEgbmV3IHBvcHVwIHdpbmRvdyBhcyBpbnRlbmRlZCwgYnV0IGluIGEgbmV3IHRhYi48YnI+XG4gICAgICogICAgICBTZWUge0BsaW5rIGh0dHA6Ly93aWtpLm5obmVudC5jb20vcGFnZXMvdmlld3BhZ2UuYWN0aW9uP3BhZ2VJZD0yNDA1NjI4NDR9XG4gICAgICpcbiAgICAgKiAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1ldGhvZD1nZXRdIC0gVGhlIG1ldGhvZCBvZiB0cmFuc21pc3Npb24gd2hlbiB0aGUgZm9ybS1kYXRhIGlzIHRyYW5zbWl0dGVkIHRvIHBvcHVwLXdpbmRvdy5cbiAgICAgKlxuICAgICAqICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGFyYW09bnVsbF0gLSBVc2luZyBhcyBwYXJhbWV0ZXJzIGZvciB0cmFuc21pc3Npb24gd2hlbiB0aGUgZm9ybS1kYXRhIGlzIHRyYW5zbWl0dGVkIHRvIHBvcHVwLXdpbmRvdy5cbiAgICAgKi9cbiAgICBQb3B1cC5wcm90b3R5cGUub3BlblBvcHVwID0gZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBuZS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBwb3B1cE5hbWU6ICdwb3B1cF8nICsgcG9wdXBfaWQgKyAnXycgKyAoK25ldyBEYXRlKCkpLFxuICAgICAgICAgICAgcG9wdXBPcHRpb25TdHI6ICcnLFxuICAgICAgICAgICAgdXNlUmVsb2FkOiB0cnVlLFxuICAgICAgICAgICAgY2xvc2VXaXRoUGFyZW50OiB0cnVlLFxuICAgICAgICAgICAgbWV0aG9kOiAnZ2V0JyxcbiAgICAgICAgICAgIHBhcmFtOiB7fVxuICAgICAgICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICAgICAgICBvcHRpb25zLm1ldGhvZCA9IG9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgdGhpcy5wb3N0RGF0YUJyaWRnZVVybCA9IG9wdGlvbnMucG9zdERhdGFCcmlkZ2VVcmwgfHwgdGhpcy5wb3N0RGF0YUJyaWRnZVVybDtcblxuICAgICAgICB2YXIgcG9wdXAsXG4gICAgICAgICAgICBmb3JtRWxlbWVudCxcbiAgICAgICAgICAgIHVzZUlFUG9zdEJyaWRnZSA9IG9wdGlvbnMubWV0aG9kID09PSAnUE9TVCcgJiYgb3B0aW9ucy5wYXJhbSAmJlxuICAgICAgICAgICAgICAgIG5lLnV0aWwuYnJvd3Nlci5tc2llICYmIG5lLnV0aWwuYnJvd3Nlci52ZXJzaW9uID09PSAxMTtcblxuICAgICAgICBpZiAoIW5lLnV0aWwuaXNFeGlzdHkodXJsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3B1cCNvcGVuKCkg7Yyd7JeFIFVSTOydtCDsnoXroKXrkJjsp4Ag7JWK7JWY7Iq164uI64ukJyk7XG4gICAgICAgIH1cblxuICAgICAgICBwb3B1cF9pZCArPSAxO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIEluIGZvcm0tZGF0YSB0cmFuc21pc3Npb25cbiAgICAgICAgICogMS4gQ3JlYXRlIGEgZm9ybSBiZWZvcmUgb3BlbmluZyBhIHBvcHVwLlxuICAgICAgICAgKiAyLiBUcmFuc21pdCB0aGUgZm9ybS1kYXRhLlxuICAgICAgICAgKiAzLiBSZW1vdmUgdGhlIGZvcm0gYWZ0ZXIgdHJhbnNtaXNzaW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKG9wdGlvbnMucGFyYW0pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwgKyAoL1xcPy8udGVzdCh1cmwpID8gJyYnIDogJz8nKSArIHRoaXMuX3BhcmFtZXRlcml6ZShvcHRpb25zLnBhcmFtKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5tZXRob2QgPT09ICdQT1NUJykge1xuICAgICAgICAgICAgICAgIGlmICghdXNlSUVQb3N0QnJpZGdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1FbGVtZW50ID0gdGhpcy5jcmVhdGVGb3JtKHVybCwgb3B0aW9ucy5wYXJhbSwgb3B0aW9ucy5tZXRob2QsIG9wdGlvbnMucG9wdXBOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gJ2Fib3V0OmJsYW5rJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwb3B1cCA9IHRoaXMub3BlbmVkUG9wdXBbb3B0aW9ucy5wb3B1cE5hbWVdO1xuXG4gICAgICAgIGlmICghbmUudXRpbC5pc0V4aXN0eShwb3B1cCkpIHtcbiAgICAgICAgICAgIHRoaXMub3BlbmVkUG9wdXBbb3B0aW9ucy5wb3B1cE5hbWVdID0gcG9wdXAgPSB0aGlzLl9vcGVuKHVzZUlFUG9zdEJyaWRnZSwgb3B0aW9ucy5wYXJhbSxcbiAgICAgICAgICAgICAgICB1cmwsIG9wdGlvbnMucG9wdXBOYW1lLCBvcHRpb25zLnBvcHVwT3B0aW9uU3RyKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBvcHVwLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbmVkUG9wdXBbb3B0aW9ucy5wb3B1cE5hbWVdID0gcG9wdXAgPSB0aGlzLl9vcGVuKHVzZUlFUG9zdEJyaWRnZSwgb3B0aW9ucy5wYXJhbSxcbiAgICAgICAgICAgICAgICAgICAgdXJsLCBvcHRpb25zLnBvcHVwTmFtZSwgb3B0aW9ucy5wb3B1cE9wdGlvblN0cik7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudXNlUmVsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcHVwLmxvY2F0aW9uLnJlcGxhY2UodXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9wdXAuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xvc2VXaXRoUGFyZW50UG9wdXBbb3B0aW9ucy5wb3B1cE5hbWVdID0gb3B0aW9ucy5jbG9zZVdpdGhQYXJlbnQ7XG5cbiAgICAgICAgaWYgKCFwb3B1cCB8fCBwb3B1cC5jbG9zZWQgfHwgbmUudXRpbC5pc1VuZGVmaW5lZChwb3B1cC5jbG9zZWQpKSB7XG4gICAgICAgICAgICBhbGVydCgn67iM65287Jqw7KCA7JeQIO2MneyXheydhCDrp4nripQg6riw64ql7J20IO2ZnOyEse2ZlCDsg4Htg5zsnbTquLAg65WM66y47JeQIOyEnOu5hOyKpCDsnbTsmqnsl5Ag66y47KCc6rCAIOyeiOydhCDsiJgg7J6I7Iq164uI64ukLiDtlbTri7kg6riw64ql7J2EIOu5hO2ZnOyEse2ZlCDtlbQg7KO87IS47JqUJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wYXJhbSAmJiBvcHRpb25zLm1ldGhvZCA9PT0gJ1BPU1QnICYmICF1c2VJRVBvc3RCcmlkZ2UpIHtcbiAgICAgICAgICAgIGlmIChwb3B1cCkge1xuICAgICAgICAgICAgICAgIGZvcm1FbGVtZW50LnN1Ym1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBmb3JtRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZvcm1FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvdy5vbnVubG9hZCA9IG5lLnV0aWwuYmluZCh0aGlzLmNsb3NlQWxsUG9wdXAsIHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgcG9wdXBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwQmVmb3JlVW5sb2FkXSAtIElmIHRydWUsIHRoZSAnd2luZG93Lm9udW5sb2FkJyB3aWxsIGJlIG51bGwgYW5kIHNraXAgdW5sb2FkIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7V2luZG93fSBbcG9wdXBdIC0gV2luZG93LWNvbnRleHQgb2YgcG9wdXAgZm9yIGNsb3NpbmcuIElmIG9taXQgdGhpcywgY3VycmVudCB3aW5kb3ctY29udGV4dCB3aWxsIGJlIGNsb3NlZC5cbiAgICAgKi9cbiAgICBQb3B1cC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihza2lwQmVmb3JlVW5sb2FkLCBwb3B1cCkge1xuICAgICAgICBza2lwQmVmb3JlVW5sb2FkID0gbmUudXRpbC5pc0V4aXN0eShza2lwQmVmb3JlVW5sb2FkKSA/IHNraXBCZWZvcmVVbmxvYWQgOiBmYWxzZTtcblxuICAgICAgICB2YXIgdGFyZ2V0ID0gcG9wdXAgfHwgd2luZG93O1xuXG4gICAgICAgIGlmIChza2lwQmVmb3JlVW5sb2FkKSB7XG4gICAgICAgICAgICB3aW5kb3cub251bmxvYWQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0YXJnZXQuY2xvc2VkKSB7XG4gICAgICAgICAgICB0YXJnZXQub3BlbmVyID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICAgICAgICB0YXJnZXQuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSBhbGwgdGhlIHBvcHVwcyBpbiBjdXJyZW50IHdpbmRvdy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsb3NlV2l0aFBhcmVudCAtIElmIHRydWUsIHBvcHVwcyBoYXZpbmcgdGhlIGNsb3NlV2l0aFBhcmVudFBvcHVwIHByb3BlcnR5IGFzIHRydWUgd2lsbCBiZSBjbG9zZWQuXG4gICAgICovXG4gICAgUG9wdXAucHJvdG90eXBlLmNsb3NlQWxsUG9wdXAgPSBmdW5jdGlvbihjbG9zZVdpdGhQYXJlbnQpIHtcbiAgICAgICAgdmFyIGhhc0FyZyA9IG5lLnV0aWwuaXNFeGlzdHkoY2xvc2VXaXRoUGFyZW50KTtcblxuICAgICAgICBuZS51dGlsLmZvckVhY2hPd25Qcm9wZXJ0aWVzKHRoaXMub3BlbmVkUG9wdXAsIGZ1bmN0aW9uKHBvcHVwLCBrZXkpIHtcbiAgICAgICAgICAgIGlmICgoaGFzQXJnICYmIHRoaXMuY2xvc2VXaXRoUGFyZW50UG9wdXBba2V5XSkgfHwgIWhhc0FyZykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoZmFsc2UsIHBvcHVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlKG9yIGZvY3VzKSB0aGUgcG9wdXAgb2YgdGhlIGdpdmVuIG5hbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBvcHVwTmFtZSAtIE5hbWUgb2YgcG9wdXAgZm9yIGFjdGl2YXRpb25cbiAgICAgKi9cbiAgICBQb3B1cC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbihwb3B1cE5hbWUpIHtcbiAgICAgICAgdGhpcy5nZXRQb3B1cExpc3QocG9wdXBOYW1lKS5mb2N1cygpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IG1hZGUgb2YgcGFyc2luZyB0aGUgcXVlcnkgc3RyaW5nLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IGhhdmluZyBzb21lIGluZm9ybWF0aW9uIG9mIHRoZSBxdWVyeSBzdHJpbmcuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQb3B1cC5wcm90b3R5cGUucGFyc2VRdWVyeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VhcmNoLFxuICAgICAgICAgICAgcGFpcixcbiAgICAgICAgICAgIHBhcmFtID0ge307XG5cbiAgICAgICAgc2VhcmNoID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIG5lLnV0aWwuZm9yRWFjaEFycmF5KHNlYXJjaC5zcGxpdCgnJicpLCBmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgICAgICBwYWlyID0gcGFydC5zcGxpdCgnPScpO1xuICAgICAgICAgICAgcGFyYW1bZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBoaWRkZW4gZm9ybSBmcm9tIHRoZSBnaXZlbiBhcmd1bWVudHMgYW5kIHJldHVybiB0aGlzIGZvcm0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvbiAtIFVSTCBmb3IgZm9ybSB0cmFuc21pc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIC0gRGF0YSBmb3IgZm9ybSB0cmFuc21pc3Npb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21ldGhvZF0gLSBNZXRob2Qgb2YgdHJhbnNtaXNzaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIC0gVGFyZ2V0IG9mIHRyYW5zbWlzc2lvblxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtjb250YWluZXJdIC0gQ29udGFpbmVyIGVsZW1lbnQgb2YgZm9ybS5cbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IEZvcm0gZWxlbWVudFxuICAgICAqL1xuICAgIFBvcHVwLnByb3RvdHlwZS5jcmVhdGVGb3JtID0gZnVuY3Rpb24oYWN0aW9uLCBkYXRhLCBtZXRob2QsIHRhcmdldCwgY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpLFxuICAgICAgICAgICAgaW5wdXQ7XG5cbiAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHk7XG5cbiAgICAgICAgZm9ybS5tZXRob2QgPSBtZXRob2QgfHwgJ1BPU1QnO1xuICAgICAgICBmb3JtLmFjdGlvbiA9IGFjdGlvbiB8fCAnJztcbiAgICAgICAgZm9ybS50YXJnZXQgPSB0YXJnZXQgfHwgJyc7XG4gICAgICAgIGZvcm0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICBuZS51dGlsLmZvckVhY2hPd25Qcm9wZXJ0aWVzKGRhdGEsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgIGlucHV0Lm5hbWUgPSBrZXk7XG4gICAgICAgICAgICBpbnB1dC50eXBlID0gJ2hpZGRlbic7XG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgICAgICByZXR1cm4gZm9ybTtcbiAgICB9O1xuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiBwcml2YXRlIG1ldGhvZHNcbiAgICAgKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBxdWVyeSBzdHJpbmcgbWFkZSBieSBwYXJzaW5nIHRoZSBnaXZlbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gQW4gb2JqZWN0IHRoYXQgaGFzIGluZm9ybWF0aW9uIGZvciBxdWVyeSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFF1ZXJ5IHN0cmluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUG9wdXAucHJvdG90eXBlLl9wYXJhbWV0ZXJpemUgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gW107XG5cbiAgICAgICAgbmUudXRpbC5mb3JFYWNoT3duUHJvcGVydGllcyhvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIHF1ZXJ5LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHF1ZXJ5LmpvaW4oJyYnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogT3BlbiBwb3B1cFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlSUVQb3N0QnJpZGdlIC0gQSBzd2l0Y2ggb3B0aW9uIHdoZXRoZXIgdG8gdXNlIGFsdGVybmF0aXZlIG9mIHRvc3NpbmcgUE9TVCBkYXRhIHRvIHRoZSBwb3B1cCB3aW5kb3cgaW4gSUUxMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbSAtIEEgZGF0YSBmb3IgdG9zc2luZyB0byBwb3B1cFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBQb3B1cCB1cmxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcG9wdXBOYW1lIC0gUG9wdXAgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25TdHIgLSBTZXR0aW5nIGZvciBwb3B1cCwgZXgpICd3aWR0aD02NDAsaGVpZ2h0PTMyMCxzY3JvbGxiYXJzPXllcydcbiAgICAgKiBAcmV0dXJucyB7V2luZG93fSBXaW5kb3cgY29udGV4dCBvZiBwb3B1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUG9wdXAucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24odXNlSUVQb3N0QnJpZGdlLCBwYXJhbSwgdXJsLCBwb3B1cE5hbWUsIG9wdGlvblN0cikge1xuICAgICAgICB2YXIgcG9wdXA7XG5cbiAgICAgICAgaWYgKHVzZUlFUG9zdEJyaWRnZSkge1xuICAgICAgICAgICAgdXJsID0gdGhpcy5wb3N0RGF0YUJyaWRnZVVybCArICc/c3RvcmFnZUtleT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBvcHVwTmFtZSkgK1xuICAgICAgICAgICAgJyZyZWRpcmVjdFVybD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHVybCk7XG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICBhbGVydCgnSUUxMeu4jOudvOyasOyggOydmCDrrLjsoJzroZwg7J247ZW0IOydtCDquLDriqXsnYAg67iM65287Jqw7KCA7J2YIExvY2FsU3RvcmFnZSDquLDriqXsnYQg7Zmc7ISx7ZmUIO2VmOyFlOyVvCDsnbTsmqntlZjsi6Qg7IiYIOyeiOyKteuLiOuLpCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShwb3B1cE5hbWUpO1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHBvcHVwTmFtZSwgSlNPTi5zdHJpbmdpZnkocGFyYW0pKTtcblxuICAgICAgICAgICAgICAgIHBvcHVwID0gd2luZG93Lm9wZW4odXJsLCBwb3B1cE5hbWUsIG9wdGlvblN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3B1cCA9IHdpbmRvdy5vcGVuKHVybCwgcG9wdXBOYW1lLCBvcHRpb25TdHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvcHVwO1xuICAgIH07XG5cbiAgICBuZS51dGlsLnBvcHVwID0gbmV3IFBvcHVwKCk7XG5cbn0pKHdpbmRvdy5uZSk7XG4iLCJpbXBvcnQgKiBhcyBiYXNlIGZyb20gJy4vaGFuZGxlYmFycy9iYXNlJztcblxuLy8gRWFjaCBvZiB0aGVzZSBhdWdtZW50IHRoZSBIYW5kbGViYXJzIG9iamVjdC4gTm8gbmVlZCB0byBzZXR1cCBoZXJlLlxuLy8gKFRoaXMgaXMgZG9uZSB0byBlYXNpbHkgc2hhcmUgY29kZSBiZXR3ZWVuIGNvbW1vbmpzIGFuZCBicm93c2UgZW52cylcbmltcG9ydCBTYWZlU3RyaW5nIGZyb20gJy4vaGFuZGxlYmFycy9zYWZlLXN0cmluZyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4vaGFuZGxlYmFycy9leGNlcHRpb24nO1xuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi9oYW5kbGViYXJzL3V0aWxzJztcbmltcG9ydCAqIGFzIHJ1bnRpbWUgZnJvbSAnLi9oYW5kbGViYXJzL3J1bnRpbWUnO1xuXG5pbXBvcnQgbm9Db25mbGljdCBmcm9tICcuL2hhbmRsZWJhcnMvbm8tY29uZmxpY3QnO1xuXG4vLyBGb3IgY29tcGF0aWJpbGl0eSBhbmQgdXNhZ2Ugb3V0c2lkZSBvZiBtb2R1bGUgc3lzdGVtcywgbWFrZSB0aGUgSGFuZGxlYmFycyBvYmplY3QgYSBuYW1lc3BhY2VcbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IGhiID0gbmV3IGJhc2UuSGFuZGxlYmFyc0Vudmlyb25tZW50KCk7XG5cbiAgVXRpbHMuZXh0ZW5kKGhiLCBiYXNlKTtcbiAgaGIuU2FmZVN0cmluZyA9IFNhZmVTdHJpbmc7XG4gIGhiLkV4Y2VwdGlvbiA9IEV4Y2VwdGlvbjtcbiAgaGIuVXRpbHMgPSBVdGlscztcbiAgaGIuZXNjYXBlRXhwcmVzc2lvbiA9IFV0aWxzLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgaGIuVk0gPSBydW50aW1lO1xuICBoYi50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICByZXR1cm4gcnVudGltZS50ZW1wbGF0ZShzcGVjLCBoYik7XG4gIH07XG5cbiAgcmV0dXJuIGhiO1xufVxuXG5sZXQgaW5zdCA9IGNyZWF0ZSgpO1xuaW5zdC5jcmVhdGUgPSBjcmVhdGU7XG5cbm5vQ29uZmxpY3QoaW5zdCk7XG5cbmluc3RbJ2RlZmF1bHQnXSA9IGluc3Q7XG5cbmV4cG9ydCBkZWZhdWx0IGluc3Q7XG4iLCJpbXBvcnQge2NyZWF0ZUZyYW1lLCBleHRlbmQsIHRvU3RyaW5nfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi9leGNlcHRpb24nO1xuaW1wb3J0IHtyZWdpc3RlckRlZmF1bHRIZWxwZXJzfSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHtyZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzfSBmcm9tICcuL2RlY29yYXRvcnMnO1xuaW1wb3J0IGxvZ2dlciBmcm9tICcuL2xvZ2dlcic7XG5cbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gJzQuMC4zJztcbmV4cG9ydCBjb25zdCBDT01QSUxFUl9SRVZJU0lPTiA9IDc7XG5cbmV4cG9ydCBjb25zdCBSRVZJU0lPTl9DSEFOR0VTID0ge1xuICAxOiAnPD0gMS4wLnJjLjInLCAvLyAxLjAucmMuMiBpcyBhY3R1YWxseSByZXYyIGJ1dCBkb2Vzbid0IHJlcG9ydCBpdFxuICAyOiAnPT0gMS4wLjAtcmMuMycsXG4gIDM6ICc9PSAxLjAuMC1yYy40JyxcbiAgNDogJz09IDEueC54JyxcbiAgNTogJz09IDIuMC4wLWFscGhhLngnLFxuICA2OiAnPj0gMi4wLjAtYmV0YS4xJyxcbiAgNzogJz49IDQuMC4wJ1xufTtcblxuY29uc3Qgb2JqZWN0VHlwZSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG5leHBvcnQgZnVuY3Rpb24gSGFuZGxlYmFyc0Vudmlyb25tZW50KGhlbHBlcnMsIHBhcnRpYWxzLCBkZWNvcmF0b3JzKSB7XG4gIHRoaXMuaGVscGVycyA9IGhlbHBlcnMgfHwge307XG4gIHRoaXMucGFydGlhbHMgPSBwYXJ0aWFscyB8fCB7fTtcbiAgdGhpcy5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycyB8fCB7fTtcblxuICByZWdpc3RlckRlZmF1bHRIZWxwZXJzKHRoaXMpO1xuICByZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzKHRoaXMpO1xufVxuXG5IYW5kbGViYXJzRW52aXJvbm1lbnQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogSGFuZGxlYmFyc0Vudmlyb25tZW50LFxuXG4gIGxvZ2dlcjogbG9nZ2VyLFxuICBsb2c6IGxvZ2dlci5sb2csXG5cbiAgcmVnaXN0ZXJIZWxwZXI6IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobmFtZSkgPT09IG9iamVjdFR5cGUpIHtcbiAgICAgIGlmIChmbikgeyB0aHJvdyBuZXcgRXhjZXB0aW9uKCdBcmcgbm90IHN1cHBvcnRlZCB3aXRoIG11bHRpcGxlIGhlbHBlcnMnKTsgfVxuICAgICAgZXh0ZW5kKHRoaXMuaGVscGVycywgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVscGVyc1tuYW1lXSA9IGZuO1xuICAgIH1cbiAgfSxcbiAgdW5yZWdpc3RlckhlbHBlcjogZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLmhlbHBlcnNbbmFtZV07XG4gIH0sXG5cbiAgcmVnaXN0ZXJQYXJ0aWFsOiBmdW5jdGlvbihuYW1lLCBwYXJ0aWFsKSB7XG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobmFtZSkgPT09IG9iamVjdFR5cGUpIHtcbiAgICAgIGV4dGVuZCh0aGlzLnBhcnRpYWxzLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBwYXJ0aWFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdBdHRlbXB0aW5nIHRvIHJlZ2lzdGVyIGEgcGFydGlhbCBhcyB1bmRlZmluZWQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFydGlhbHNbbmFtZV0gPSBwYXJ0aWFsO1xuICAgIH1cbiAgfSxcbiAgdW5yZWdpc3RlclBhcnRpYWw6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5wYXJ0aWFsc1tuYW1lXTtcbiAgfSxcblxuICByZWdpc3RlckRlY29yYXRvcjogZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgaWYgKGZuKSB7IHRocm93IG5ldyBFeGNlcHRpb24oJ0FyZyBub3Qgc3VwcG9ydGVkIHdpdGggbXVsdGlwbGUgZGVjb3JhdG9ycycpOyB9XG4gICAgICBleHRlbmQodGhpcy5kZWNvcmF0b3JzLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWNvcmF0b3JzW25hbWVdID0gZm47XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVyRGVjb3JhdG9yOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuZGVjb3JhdG9yc1tuYW1lXTtcbiAgfVxufTtcblxuZXhwb3J0IGxldCBsb2cgPSBsb2dnZXIubG9nO1xuXG5leHBvcnQge2NyZWF0ZUZyYW1lLCBsb2dnZXJ9O1xuIiwiaW1wb3J0IHJlZ2lzdGVySW5saW5lIGZyb20gJy4vZGVjb3JhdG9ycy9pbmxpbmUnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0RGVjb3JhdG9ycyhpbnN0YW5jZSkge1xuICByZWdpc3RlcklubGluZShpbnN0YW5jZSk7XG59XG5cbiIsImltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVyRGVjb3JhdG9yKCdpbmxpbmUnLCBmdW5jdGlvbihmbiwgcHJvcHMsIGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgIGxldCByZXQgPSBmbjtcbiAgICBpZiAoIXByb3BzLnBhcnRpYWxzKSB7XG4gICAgICBwcm9wcy5wYXJ0aWFscyA9IHt9O1xuICAgICAgcmV0ID0gZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgcGFydGlhbHMgc3RhY2sgZnJhbWUgcHJpb3IgdG8gZXhlYy5cbiAgICAgICAgbGV0IG9yaWdpbmFsID0gY29udGFpbmVyLnBhcnRpYWxzO1xuICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBleHRlbmQoe30sIG9yaWdpbmFsLCBwcm9wcy5wYXJ0aWFscyk7XG4gICAgICAgIGxldCByZXQgPSBmbihjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gb3JpZ2luYWw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHByb3BzLnBhcnRpYWxzW29wdGlvbnMuYXJnc1swXV0gPSBvcHRpb25zLmZuO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59XG4iLCJcbmNvbnN0IGVycm9yUHJvcHMgPSBbJ2Rlc2NyaXB0aW9uJywgJ2ZpbGVOYW1lJywgJ2xpbmVOdW1iZXInLCAnbWVzc2FnZScsICduYW1lJywgJ251bWJlcicsICdzdGFjayddO1xuXG5mdW5jdGlvbiBFeGNlcHRpb24obWVzc2FnZSwgbm9kZSkge1xuICBsZXQgbG9jID0gbm9kZSAmJiBub2RlLmxvYyxcbiAgICAgIGxpbmUsXG4gICAgICBjb2x1bW47XG4gIGlmIChsb2MpIHtcbiAgICBsaW5lID0gbG9jLnN0YXJ0LmxpbmU7XG4gICAgY29sdW1uID0gbG9jLnN0YXJ0LmNvbHVtbjtcblxuICAgIG1lc3NhZ2UgKz0gJyAtICcgKyBsaW5lICsgJzonICsgY29sdW1uO1xuICB9XG5cbiAgbGV0IHRtcCA9IEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuXG4gIC8vIFVuZm9ydHVuYXRlbHkgZXJyb3JzIGFyZSBub3QgZW51bWVyYWJsZSBpbiBDaHJvbWUgKGF0IGxlYXN0KSwgc28gYGZvciBwcm9wIGluIHRtcGAgZG9lc24ndCB3b3JrLlxuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBlcnJvclByb3BzLmxlbmd0aDsgaWR4KyspIHtcbiAgICB0aGlzW2Vycm9yUHJvcHNbaWR4XV0gPSB0bXBbZXJyb3JQcm9wc1tpZHhdXTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEV4Y2VwdGlvbik7XG4gIH1cblxuICBpZiAobG9jKSB7XG4gICAgdGhpcy5saW5lTnVtYmVyID0gbGluZTtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgfVxufVxuXG5FeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbmV4cG9ydCBkZWZhdWx0IEV4Y2VwdGlvbjtcbiIsImltcG9ydCByZWdpc3RlckJsb2NrSGVscGVyTWlzc2luZyBmcm9tICcuL2hlbHBlcnMvYmxvY2staGVscGVyLW1pc3NpbmcnO1xuaW1wb3J0IHJlZ2lzdGVyRWFjaCBmcm9tICcuL2hlbHBlcnMvZWFjaCc7XG5pbXBvcnQgcmVnaXN0ZXJIZWxwZXJNaXNzaW5nIGZyb20gJy4vaGVscGVycy9oZWxwZXItbWlzc2luZyc7XG5pbXBvcnQgcmVnaXN0ZXJJZiBmcm9tICcuL2hlbHBlcnMvaWYnO1xuaW1wb3J0IHJlZ2lzdGVyTG9nIGZyb20gJy4vaGVscGVycy9sb2cnO1xuaW1wb3J0IHJlZ2lzdGVyTG9va3VwIGZyb20gJy4vaGVscGVycy9sb29rdXAnO1xuaW1wb3J0IHJlZ2lzdGVyV2l0aCBmcm9tICcuL2hlbHBlcnMvd2l0aCc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHRIZWxwZXJzKGluc3RhbmNlKSB7XG4gIHJlZ2lzdGVyQmxvY2tIZWxwZXJNaXNzaW5nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJFYWNoKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJIZWxwZXJNaXNzaW5nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJJZihpbnN0YW5jZSk7XG4gIHJlZ2lzdGVyTG9nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJMb29rdXAoaW5zdGFuY2UpO1xuICByZWdpc3RlcldpdGgoaW5zdGFuY2UpO1xufVxuIiwiaW1wb3J0IHthcHBlbmRDb250ZXh0UGF0aCwgY3JlYXRlRnJhbWUsIGlzQXJyYXl9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2Jsb2NrSGVscGVyTWlzc2luZycsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBsZXQgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZSxcbiAgICAgICAgZm4gPSBvcHRpb25zLmZuO1xuXG4gICAgaWYgKGNvbnRleHQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBmbih0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRleHQgPT09IGZhbHNlIHx8IGNvbnRleHQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGludmVyc2UodGhpcyk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGNvbnRleHQpKSB7XG4gICAgICBpZiAoY29udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmlkcykge1xuICAgICAgICAgIG9wdGlvbnMuaWRzID0gW29wdGlvbnMubmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5zdGFuY2UuaGVscGVycy5lYWNoKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGludmVyc2UodGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLm5hbWUpO1xuICAgICAgICBvcHRpb25zID0ge2RhdGE6IGRhdGF9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbn1cbiIsImltcG9ydCB7YXBwZW5kQ29udGV4dFBhdGgsIGJsb2NrUGFyYW1zLCBjcmVhdGVGcmFtZSwgaXNBcnJheSwgaXNGdW5jdGlvbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuLi9leGNlcHRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignZWFjaCcsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ011c3QgcGFzcyBpdGVyYXRvciB0byAjZWFjaCcpO1xuICAgIH1cblxuICAgIGxldCBmbiA9IG9wdGlvbnMuZm4sXG4gICAgICAgIGludmVyc2UgPSBvcHRpb25zLmludmVyc2UsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICByZXQgPSAnJyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dFBhdGg7XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG4gICAgICBjb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pICsgJy4nO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRleHQpKSB7IGNvbnRleHQgPSBjb250ZXh0LmNhbGwodGhpcyk7IH1cblxuICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4ZWNJdGVyYXRpb24oZmllbGQsIGluZGV4LCBsYXN0KSB7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBkYXRhLmtleSA9IGZpZWxkO1xuICAgICAgICBkYXRhLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGRhdGEuZmlyc3QgPSBpbmRleCA9PT0gMDtcbiAgICAgICAgZGF0YS5sYXN0ID0gISFsYXN0O1xuXG4gICAgICAgIGlmIChjb250ZXh0UGF0aCkge1xuICAgICAgICAgIGRhdGEuY29udGV4dFBhdGggPSBjb250ZXh0UGF0aCArIGZpZWxkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldCA9IHJldCArIGZuKGNvbnRleHRbZmllbGRdLCB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyhbY29udGV4dFtmaWVsZF0sIGZpZWxkXSwgW2NvbnRleHRQYXRoICsgZmllbGQsIG51bGxdKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoaXNBcnJheShjb250ZXh0KSkge1xuICAgICAgICBmb3IgKGxldCBqID0gY29udGV4dC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICBpZiAoaSBpbiBjb250ZXh0KSB7XG4gICAgICAgICAgICBleGVjSXRlcmF0aW9uKGksIGksIGkgPT09IGNvbnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcHJpb3JLZXk7XG5cbiAgICAgICAgZm9yIChsZXQga2V5IGluIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBydW5uaW5nIHRoZSBpdGVyYXRpb25zIG9uZSBzdGVwIG91dCBvZiBzeW5jIHNvIHdlIGNhbiBkZXRlY3RcbiAgICAgICAgICAgIC8vIHRoZSBsYXN0IGl0ZXJhdGlvbiB3aXRob3V0IGhhdmUgdG8gc2NhbiB0aGUgb2JqZWN0IHR3aWNlIGFuZCBjcmVhdGVcbiAgICAgICAgICAgIC8vIGFuIGl0ZXJtZWRpYXRlIGtleXMgYXJyYXkuXG4gICAgICAgICAgICBpZiAocHJpb3JLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBleGVjSXRlcmF0aW9uKHByaW9yS2V5LCBpIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmlvcktleSA9IGtleTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaW9yS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBleGVjSXRlcmF0aW9uKHByaW9yS2V5LCBpIC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgcmV0ID0gaW52ZXJzZSh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cbiIsImltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi4vZXhjZXB0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbigvKiBbYXJncywgXW9wdGlvbnMgKi8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gQSBtaXNzaW5nIGZpZWxkIGluIGEge3tmb299fSBjb25zdHJ1Y3QuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTb21lb25lIGlzIGFjdHVhbGx5IHRyeWluZyB0byBjYWxsIHNvbWV0aGluZywgYmxvdyB1cC5cbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ01pc3NpbmcgaGVscGVyOiBcIicgKyBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdLm5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH0pO1xufVxuIiwiaW1wb3J0IHtpc0VtcHR5LCBpc0Z1bmN0aW9ufSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdpZicsIGZ1bmN0aW9uKGNvbmRpdGlvbmFsLCBvcHRpb25zKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oY29uZGl0aW9uYWwpKSB7IGNvbmRpdGlvbmFsID0gY29uZGl0aW9uYWwuY2FsbCh0aGlzKTsgfVxuXG4gICAgLy8gRGVmYXVsdCBiZWhhdmlvciBpcyB0byByZW5kZXIgdGhlIHBvc2l0aXZlIHBhdGggaWYgdGhlIHZhbHVlIGlzIHRydXRoeSBhbmQgbm90IGVtcHR5LlxuICAgIC8vIFRoZSBgaW5jbHVkZVplcm9gIG9wdGlvbiBtYXkgYmUgc2V0IHRvIHRyZWF0IHRoZSBjb25kdGlvbmFsIGFzIHB1cmVseSBub3QgZW1wdHkgYmFzZWQgb24gdGhlXG4gICAgLy8gYmVoYXZpb3Igb2YgaXNFbXB0eS4gRWZmZWN0aXZlbHkgdGhpcyBkZXRlcm1pbmVzIGlmIDAgaXMgaGFuZGxlZCBieSB0aGUgcG9zaXRpdmUgcGF0aCBvciBuZWdhdGl2ZS5cbiAgICBpZiAoKCFvcHRpb25zLmhhc2guaW5jbHVkZVplcm8gJiYgIWNvbmRpdGlvbmFsKSB8fCBpc0VtcHR5KGNvbmRpdGlvbmFsKSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuZm4odGhpcyk7XG4gICAgfVxuICB9KTtcblxuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcigndW5sZXNzJywgZnVuY3Rpb24oY29uZGl0aW9uYWwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuaGVscGVyc1snaWYnXS5jYWxsKHRoaXMsIGNvbmRpdGlvbmFsLCB7Zm46IG9wdGlvbnMuaW52ZXJzZSwgaW52ZXJzZTogb3B0aW9ucy5mbiwgaGFzaDogb3B0aW9ucy5oYXNofSk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvZycsIGZ1bmN0aW9uKC8qIG1lc3NhZ2UsIG9wdGlvbnMgKi8pIHtcbiAgICBsZXQgYXJncyA9IFt1bmRlZmluZWRdLFxuICAgICAgICBvcHRpb25zID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIGxldCBsZXZlbCA9IDE7XG4gICAgaWYgKG9wdGlvbnMuaGFzaC5sZXZlbCAhPSBudWxsKSB7XG4gICAgICBsZXZlbCA9IG9wdGlvbnMuaGFzaC5sZXZlbDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmRhdGEubGV2ZWwgIT0gbnVsbCkge1xuICAgICAgbGV2ZWwgPSBvcHRpb25zLmRhdGEubGV2ZWw7XG4gICAgfVxuICAgIGFyZ3NbMF0gPSBsZXZlbDtcblxuICAgIGluc3RhbmNlLmxvZyguLi4gYXJncyk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvb2t1cCcsIGZ1bmN0aW9uKG9iaiwgZmllbGQpIHtcbiAgICByZXR1cm4gb2JqICYmIG9ialtmaWVsZF07XG4gIH0pO1xufVxuIiwiaW1wb3J0IHthcHBlbmRDb250ZXh0UGF0aCwgYmxvY2tQYXJhbXMsIGNyZWF0ZUZyYW1lLCBpc0VtcHR5LCBpc0Z1bmN0aW9ufSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCd3aXRoJywgZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRleHQpKSB7IGNvbnRleHQgPSBjb250ZXh0LmNhbGwodGhpcyk7IH1cblxuICAgIGxldCBmbiA9IG9wdGlvbnMuZm47XG5cbiAgICBpZiAoIWlzRW1wdHkoY29udGV4dCkpIHtcbiAgICAgIGxldCBkYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlkcykge1xuICAgICAgICBkYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4oY29udGV4dCwge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBibG9ja1BhcmFtczogYmxvY2tQYXJhbXMoW2NvbnRleHRdLCBbZGF0YSAmJiBkYXRhLmNvbnRleHRQYXRoXSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgIH1cbiAgfSk7XG59XG4iLCJpbXBvcnQge2luZGV4T2Z9IGZyb20gJy4vdXRpbHMnO1xuXG5sZXQgbG9nZ2VyID0ge1xuICBtZXRob2RNYXA6IFsnZGVidWcnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJ10sXG4gIGxldmVsOiAnaW5mbycsXG5cbiAgLy8gTWFwcyBhIGdpdmVuIGxldmVsIHZhbHVlIHRvIHRoZSBgbWV0aG9kTWFwYCBpbmRleGVzIGFib3ZlLlxuICBsb29rdXBMZXZlbDogZnVuY3Rpb24obGV2ZWwpIHtcbiAgICBpZiAodHlwZW9mIGxldmVsID09PSAnc3RyaW5nJykge1xuICAgICAgbGV0IGxldmVsTWFwID0gaW5kZXhPZihsb2dnZXIubWV0aG9kTWFwLCBsZXZlbC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIGlmIChsZXZlbE1hcCA+PSAwKSB7XG4gICAgICAgIGxldmVsID0gbGV2ZWxNYXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbCA9IHBhcnNlSW50KGxldmVsLCAxMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxldmVsO1xuICB9LFxuXG4gIC8vIENhbiBiZSBvdmVycmlkZGVuIGluIHRoZSBob3N0IGVudmlyb25tZW50XG4gIGxvZzogZnVuY3Rpb24obGV2ZWwsIC4uLm1lc3NhZ2UpIHtcbiAgICBsZXZlbCA9IGxvZ2dlci5sb29rdXBMZXZlbChsZXZlbCk7XG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGxvZ2dlci5sb29rdXBMZXZlbChsb2dnZXIubGV2ZWwpIDw9IGxldmVsKSB7XG4gICAgICBsZXQgbWV0aG9kID0gbG9nZ2VyLm1ldGhvZE1hcFtsZXZlbF07XG4gICAgICBpZiAoIWNvbnNvbGVbbWV0aG9kXSkgeyAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICBtZXRob2QgPSAnbG9nJztcbiAgICAgIH1cbiAgICAgIGNvbnNvbGVbbWV0aG9kXSguLi5tZXNzYWdlKTsgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBsb2dnZXI7XG4iLCIvKiBnbG9iYWwgd2luZG93ICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihIYW5kbGViYXJzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGxldCByb290ID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3csXG4gICAgICAkSGFuZGxlYmFycyA9IHJvb3QuSGFuZGxlYmFycztcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgSGFuZGxlYmFycy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHJvb3QuSGFuZGxlYmFycyA9PT0gSGFuZGxlYmFycykge1xuICAgICAgcm9vdC5IYW5kbGViYXJzID0gJEhhbmRsZWJhcnM7XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4vZXhjZXB0aW9uJztcbmltcG9ydCB7IENPTVBJTEVSX1JFVklTSU9OLCBSRVZJU0lPTl9DSEFOR0VTLCBjcmVhdGVGcmFtZSB9IGZyb20gJy4vYmFzZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1JldmlzaW9uKGNvbXBpbGVySW5mbykge1xuICBjb25zdCBjb21waWxlclJldmlzaW9uID0gY29tcGlsZXJJbmZvICYmIGNvbXBpbGVySW5mb1swXSB8fCAxLFxuICAgICAgICBjdXJyZW50UmV2aXNpb24gPSBDT01QSUxFUl9SRVZJU0lPTjtcblxuICBpZiAoY29tcGlsZXJSZXZpc2lvbiAhPT0gY3VycmVudFJldmlzaW9uKSB7XG4gICAgaWYgKGNvbXBpbGVyUmV2aXNpb24gPCBjdXJyZW50UmV2aXNpb24pIHtcbiAgICAgIGNvbnN0IHJ1bnRpbWVWZXJzaW9ucyA9IFJFVklTSU9OX0NIQU5HRVNbY3VycmVudFJldmlzaW9uXSxcbiAgICAgICAgICAgIGNvbXBpbGVyVmVyc2lvbnMgPSBSRVZJU0lPTl9DSEFOR0VTW2NvbXBpbGVyUmV2aXNpb25dO1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVGVtcGxhdGUgd2FzIHByZWNvbXBpbGVkIHdpdGggYW4gb2xkZXIgdmVyc2lvbiBvZiBIYW5kbGViYXJzIHRoYW4gdGhlIGN1cnJlbnQgcnVudGltZS4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIHVwZGF0ZSB5b3VyIHByZWNvbXBpbGVyIHRvIGEgbmV3ZXIgdmVyc2lvbiAoJyArIHJ1bnRpbWVWZXJzaW9ucyArICcpIG9yIGRvd25ncmFkZSB5b3VyIHJ1bnRpbWUgdG8gYW4gb2xkZXIgdmVyc2lvbiAoJyArIGNvbXBpbGVyVmVyc2lvbnMgKyAnKS4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXNlIHRoZSBlbWJlZGRlZCB2ZXJzaW9uIGluZm8gc2luY2UgdGhlIHJ1bnRpbWUgZG9lc24ndCBrbm93IGFib3V0IHRoaXMgcmV2aXNpb24geWV0XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdUZW1wbGF0ZSB3YXMgcHJlY29tcGlsZWQgd2l0aCBhIG5ld2VyIHZlcnNpb24gb2YgSGFuZGxlYmFycyB0aGFuIHRoZSBjdXJyZW50IHJ1bnRpbWUuICcgK1xuICAgICAgICAgICAgJ1BsZWFzZSB1cGRhdGUgeW91ciBydW50aW1lIHRvIGEgbmV3ZXIgdmVyc2lvbiAoJyArIGNvbXBpbGVySW5mb1sxXSArICcpLicpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGUodGVtcGxhdGVTcGVjLCBlbnYpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKCFlbnYpIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdObyBlbnZpcm9ubWVudCBwYXNzZWQgdG8gdGVtcGxhdGUnKTtcbiAgfVxuICBpZiAoIXRlbXBsYXRlU3BlYyB8fCAhdGVtcGxhdGVTcGVjLm1haW4pIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdVbmtub3duIHRlbXBsYXRlIG9iamVjdDogJyArIHR5cGVvZiB0ZW1wbGF0ZVNwZWMpO1xuICB9XG5cbiAgdGVtcGxhdGVTcGVjLm1haW4uZGVjb3JhdG9yID0gdGVtcGxhdGVTcGVjLm1haW5fZDtcblxuICAvLyBOb3RlOiBVc2luZyBlbnYuVk0gcmVmZXJlbmNlcyByYXRoZXIgdGhhbiBsb2NhbCB2YXIgcmVmZXJlbmNlcyB0aHJvdWdob3V0IHRoaXMgc2VjdGlvbiB0byBhbGxvd1xuICAvLyBmb3IgZXh0ZXJuYWwgdXNlcnMgdG8gb3ZlcnJpZGUgdGhlc2UgYXMgcHN1ZWRvLXN1cHBvcnRlZCBBUElzLlxuICBlbnYuVk0uY2hlY2tSZXZpc2lvbih0ZW1wbGF0ZVNwZWMuY29tcGlsZXIpO1xuXG4gIGZ1bmN0aW9uIGludm9rZVBhcnRpYWxXcmFwcGVyKHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNoKSB7XG4gICAgICBjb250ZXh0ID0gVXRpbHMuZXh0ZW5kKHt9LCBjb250ZXh0LCBvcHRpb25zLmhhc2gpO1xuICAgICAgaWYgKG9wdGlvbnMuaWRzKSB7XG4gICAgICAgIG9wdGlvbnMuaWRzWzBdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJ0aWFsID0gZW52LlZNLnJlc29sdmVQYXJ0aWFsLmNhbGwodGhpcywgcGFydGlhbCwgY29udGV4dCwgb3B0aW9ucyk7XG4gICAgbGV0IHJlc3VsdCA9IGVudi5WTS5pbnZva2VQYXJ0aWFsLmNhbGwodGhpcywgcGFydGlhbCwgY29udGV4dCwgb3B0aW9ucyk7XG5cbiAgICBpZiAocmVzdWx0ID09IG51bGwgJiYgZW52LmNvbXBpbGUpIHtcbiAgICAgIG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXSA9IGVudi5jb21waWxlKHBhcnRpYWwsIHRlbXBsYXRlU3BlYy5jb21waWxlck9wdGlvbnMsIGVudik7XG4gICAgICByZXN1bHQgPSBvcHRpb25zLnBhcnRpYWxzW29wdGlvbnMubmFtZV0oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgaWYgKG9wdGlvbnMuaW5kZW50KSB7XG4gICAgICAgIGxldCBsaW5lcyA9IHJlc3VsdC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFsaW5lc1tpXSAmJiBpICsgMSA9PT0gbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGluZXNbaV0gPSBvcHRpb25zLmluZGVudCArIGxpbmVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVGhlIHBhcnRpYWwgJyArIG9wdGlvbnMubmFtZSArICcgY291bGQgbm90IGJlIGNvbXBpbGVkIHdoZW4gcnVubmluZyBpbiBydW50aW1lLW9ubHkgbW9kZScpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEp1c3QgYWRkIHdhdGVyXG4gIGxldCBjb250YWluZXIgPSB7XG4gICAgc3RyaWN0OiBmdW5jdGlvbihvYmosIG5hbWUpIHtcbiAgICAgIGlmICghKG5hbWUgaW4gb2JqKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdcIicgKyBuYW1lICsgJ1wiIG5vdCBkZWZpbmVkIGluICcgKyBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialtuYW1lXTtcbiAgICB9LFxuICAgIGxvb2t1cDogZnVuY3Rpb24oZGVwdGhzLCBuYW1lKSB7XG4gICAgICBjb25zdCBsZW4gPSBkZXB0aHMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoZGVwdGhzW2ldICYmIGRlcHRoc1tpXVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGRlcHRoc1tpXVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbGFtYmRhOiBmdW5jdGlvbihjdXJyZW50LCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGN1cnJlbnQgPT09ICdmdW5jdGlvbicgPyBjdXJyZW50LmNhbGwoY29udGV4dCkgOiBjdXJyZW50O1xuICAgIH0sXG5cbiAgICBlc2NhcGVFeHByZXNzaW9uOiBVdGlscy5lc2NhcGVFeHByZXNzaW9uLFxuICAgIGludm9rZVBhcnRpYWw6IGludm9rZVBhcnRpYWxXcmFwcGVyLFxuXG4gICAgZm46IGZ1bmN0aW9uKGkpIHtcbiAgICAgIGxldCByZXQgPSB0ZW1wbGF0ZVNwZWNbaV07XG4gICAgICByZXQuZGVjb3JhdG9yID0gdGVtcGxhdGVTcGVjW2kgKyAnX2QnXTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIHByb2dyYW1zOiBbXSxcbiAgICBwcm9ncmFtOiBmdW5jdGlvbihpLCBkYXRhLCBkZWNsYXJlZEJsb2NrUGFyYW1zLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XG4gICAgICBsZXQgcHJvZ3JhbVdyYXBwZXIgPSB0aGlzLnByb2dyYW1zW2ldLFxuICAgICAgICAgIGZuID0gdGhpcy5mbihpKTtcbiAgICAgIGlmIChkYXRhIHx8IGRlcHRocyB8fCBibG9ja1BhcmFtcyB8fCBkZWNsYXJlZEJsb2NrUGFyYW1zKSB7XG4gICAgICAgIHByb2dyYW1XcmFwcGVyID0gd3JhcFByb2dyYW0odGhpcywgaSwgZm4sIGRhdGEsIGRlY2xhcmVkQmxvY2tQYXJhbXMsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICAgICAgfSBlbHNlIGlmICghcHJvZ3JhbVdyYXBwZXIpIHtcbiAgICAgICAgcHJvZ3JhbVdyYXBwZXIgPSB0aGlzLnByb2dyYW1zW2ldID0gd3JhcFByb2dyYW0odGhpcywgaSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb2dyYW1XcmFwcGVyO1xuICAgIH0sXG5cbiAgICBkYXRhOiBmdW5jdGlvbih2YWx1ZSwgZGVwdGgpIHtcbiAgICAgIHdoaWxlICh2YWx1ZSAmJiBkZXB0aC0tKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuX3BhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIG1lcmdlOiBmdW5jdGlvbihwYXJhbSwgY29tbW9uKSB7XG4gICAgICBsZXQgb2JqID0gcGFyYW0gfHwgY29tbW9uO1xuXG4gICAgICBpZiAocGFyYW0gJiYgY29tbW9uICYmIChwYXJhbSAhPT0gY29tbW9uKSkge1xuICAgICAgICBvYmogPSBVdGlscy5leHRlbmQoe30sIGNvbW1vbiwgcGFyYW0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICBub29wOiBlbnYuVk0ubm9vcCxcbiAgICBjb21waWxlckluZm86IHRlbXBsYXRlU3BlYy5jb21waWxlclxuICB9O1xuXG4gIGZ1bmN0aW9uIHJldChjb250ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgZGF0YSA9IG9wdGlvbnMuZGF0YTtcblxuICAgIHJldC5fc2V0dXAob3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zLnBhcnRpYWwgJiYgdGVtcGxhdGVTcGVjLnVzZURhdGEpIHtcbiAgICAgIGRhdGEgPSBpbml0RGF0YShjb250ZXh0LCBkYXRhKTtcbiAgICB9XG4gICAgbGV0IGRlcHRocyxcbiAgICAgICAgYmxvY2tQYXJhbXMgPSB0ZW1wbGF0ZVNwZWMudXNlQmxvY2tQYXJhbXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICBpZiAodGVtcGxhdGVTcGVjLnVzZURlcHRocykge1xuICAgICAgaWYgKG9wdGlvbnMuZGVwdGhzKSB7XG4gICAgICAgIGRlcHRocyA9IGNvbnRleHQgIT09IG9wdGlvbnMuZGVwdGhzWzBdID8gW2NvbnRleHRdLmNvbmNhdChvcHRpb25zLmRlcHRocykgOiBvcHRpb25zLmRlcHRocztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlcHRocyA9IFtjb250ZXh0XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWluKGNvbnRleHQvKiwgb3B0aW9ucyovKSB7XG4gICAgICByZXR1cm4gJycgKyB0ZW1wbGF0ZVNwZWMubWFpbihjb250YWluZXIsIGNvbnRleHQsIGNvbnRhaW5lci5oZWxwZXJzLCBjb250YWluZXIucGFydGlhbHMsIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICAgIH1cbiAgICBtYWluID0gZXhlY3V0ZURlY29yYXRvcnModGVtcGxhdGVTcGVjLm1haW4sIG1haW4sIGNvbnRhaW5lciwgb3B0aW9ucy5kZXB0aHMgfHwgW10sIGRhdGEsIGJsb2NrUGFyYW1zKTtcbiAgICByZXR1cm4gbWFpbihjb250ZXh0LCBvcHRpb25zKTtcbiAgfVxuICByZXQuaXNUb3AgPSB0cnVlO1xuXG4gIHJldC5fc2V0dXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLnBhcnRpYWwpIHtcbiAgICAgIGNvbnRhaW5lci5oZWxwZXJzID0gY29udGFpbmVyLm1lcmdlKG9wdGlvbnMuaGVscGVycywgZW52LmhlbHBlcnMpO1xuXG4gICAgICBpZiAodGVtcGxhdGVTcGVjLnVzZVBhcnRpYWwpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gY29udGFpbmVyLm1lcmdlKG9wdGlvbnMucGFydGlhbHMsIGVudi5wYXJ0aWFscyk7XG4gICAgICB9XG4gICAgICBpZiAodGVtcGxhdGVTcGVjLnVzZVBhcnRpYWwgfHwgdGVtcGxhdGVTcGVjLnVzZURlY29yYXRvcnMpIHtcbiAgICAgICAgY29udGFpbmVyLmRlY29yYXRvcnMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5kZWNvcmF0b3JzLCBlbnYuZGVjb3JhdG9ycyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRhaW5lci5oZWxwZXJzID0gb3B0aW9ucy5oZWxwZXJzO1xuICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gb3B0aW9ucy5wYXJ0aWFscztcbiAgICAgIGNvbnRhaW5lci5kZWNvcmF0b3JzID0gb3B0aW9ucy5kZWNvcmF0b3JzO1xuICAgIH1cbiAgfTtcblxuICByZXQuX2NoaWxkID0gZnVuY3Rpb24oaSwgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocykge1xuICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlQmxvY2tQYXJhbXMgJiYgIWJsb2NrUGFyYW1zKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdtdXN0IHBhc3MgYmxvY2sgcGFyYW1zJyk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlRGVwdGhzICYmICFkZXB0aHMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ211c3QgcGFzcyBwYXJlbnQgZGVwdGhzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdyYXBQcm9ncmFtKGNvbnRhaW5lciwgaSwgdGVtcGxhdGVTcGVjW2ldLCBkYXRhLCAwLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcbiAgfTtcbiAgcmV0dXJuIHJldDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBQcm9ncmFtKGNvbnRhaW5lciwgaSwgZm4sIGRhdGEsIGRlY2xhcmVkQmxvY2tQYXJhbXMsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcbiAgZnVuY3Rpb24gcHJvZyhjb250ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgY3VycmVudERlcHRocyA9IGRlcHRocztcbiAgICBpZiAoZGVwdGhzICYmIGNvbnRleHQgIT09IGRlcHRoc1swXSkge1xuICAgICAgY3VycmVudERlcHRocyA9IFtjb250ZXh0XS5jb25jYXQoZGVwdGhzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm4oY29udGFpbmVyLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjb250YWluZXIuaGVscGVycywgY29udGFpbmVyLnBhcnRpYWxzLFxuICAgICAgICBvcHRpb25zLmRhdGEgfHwgZGF0YSxcbiAgICAgICAgYmxvY2tQYXJhbXMgJiYgW29wdGlvbnMuYmxvY2tQYXJhbXNdLmNvbmNhdChibG9ja1BhcmFtcyksXG4gICAgICAgIGN1cnJlbnREZXB0aHMpO1xuICB9XG5cbiAgcHJvZyA9IGV4ZWN1dGVEZWNvcmF0b3JzKGZuLCBwcm9nLCBjb250YWluZXIsIGRlcHRocywgZGF0YSwgYmxvY2tQYXJhbXMpO1xuXG4gIHByb2cucHJvZ3JhbSA9IGk7XG4gIHByb2cuZGVwdGggPSBkZXB0aHMgPyBkZXB0aHMubGVuZ3RoIDogMDtcbiAgcHJvZy5ibG9ja1BhcmFtcyA9IGRlY2xhcmVkQmxvY2tQYXJhbXMgfHwgMDtcbiAgcmV0dXJuIHByb2c7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUGFydGlhbChwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gIGlmICghcGFydGlhbCkge1xuICAgIGlmIChvcHRpb25zLm5hbWUgPT09ICdAcGFydGlhbC1ibG9jaycpIHtcbiAgICAgIHBhcnRpYWwgPSBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydGlhbCA9IG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIXBhcnRpYWwuY2FsbCAmJiAhb3B0aW9ucy5uYW1lKSB7XG4gICAgLy8gVGhpcyBpcyBhIGR5bmFtaWMgcGFydGlhbCB0aGF0IHJldHVybmVkIGEgc3RyaW5nXG4gICAgb3B0aW9ucy5uYW1lID0gcGFydGlhbDtcbiAgICBwYXJ0aWFsID0gb3B0aW9ucy5wYXJ0aWFsc1twYXJ0aWFsXTtcbiAgfVxuICByZXR1cm4gcGFydGlhbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludm9rZVBhcnRpYWwocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xuICBvcHRpb25zLnBhcnRpYWwgPSB0cnVlO1xuICBpZiAob3B0aW9ucy5pZHMpIHtcbiAgICBvcHRpb25zLmRhdGEuY29udGV4dFBhdGggPSBvcHRpb25zLmlkc1swXSB8fCBvcHRpb25zLmRhdGEuY29udGV4dFBhdGg7XG4gIH1cblxuICBsZXQgcGFydGlhbEJsb2NrO1xuICBpZiAob3B0aW9ucy5mbiAmJiBvcHRpb25zLmZuICE9PSBub29wKSB7XG4gICAgb3B0aW9ucy5kYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICBwYXJ0aWFsQmxvY2sgPSBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXSA9IG9wdGlvbnMuZm47XG5cbiAgICBpZiAocGFydGlhbEJsb2NrLnBhcnRpYWxzKSB7XG4gICAgICBvcHRpb25zLnBhcnRpYWxzID0gVXRpbHMuZXh0ZW5kKHt9LCBvcHRpb25zLnBhcnRpYWxzLCBwYXJ0aWFsQmxvY2sucGFydGlhbHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJ0aWFsID09PSB1bmRlZmluZWQgJiYgcGFydGlhbEJsb2NrKSB7XG4gICAgcGFydGlhbCA9IHBhcnRpYWxCbG9jaztcbiAgfVxuXG4gIGlmIChwYXJ0aWFsID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdUaGUgcGFydGlhbCAnICsgb3B0aW9ucy5uYW1lICsgJyBjb3VsZCBub3QgYmUgZm91bmQnKTtcbiAgfSBlbHNlIGlmIChwYXJ0aWFsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gcGFydGlhbChjb250ZXh0LCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHsgcmV0dXJuICcnOyB9XG5cbmZ1bmN0aW9uIGluaXREYXRhKGNvbnRleHQsIGRhdGEpIHtcbiAgaWYgKCFkYXRhIHx8ICEoJ3Jvb3QnIGluIGRhdGEpKSB7XG4gICAgZGF0YSA9IGRhdGEgPyBjcmVhdGVGcmFtZShkYXRhKSA6IHt9O1xuICAgIGRhdGEucm9vdCA9IGNvbnRleHQ7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGV4ZWN1dGVEZWNvcmF0b3JzKGZuLCBwcm9nLCBjb250YWluZXIsIGRlcHRocywgZGF0YSwgYmxvY2tQYXJhbXMpIHtcbiAgaWYgKGZuLmRlY29yYXRvcikge1xuICAgIGxldCBwcm9wcyA9IHt9O1xuICAgIHByb2cgPSBmbi5kZWNvcmF0b3IocHJvZywgcHJvcHMsIGNvbnRhaW5lciwgZGVwdGhzICYmIGRlcHRoc1swXSwgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocyk7XG4gICAgVXRpbHMuZXh0ZW5kKHByb2csIHByb3BzKTtcbiAgfVxuICByZXR1cm4gcHJvZztcbn1cbiIsIi8vIEJ1aWxkIG91dCBvdXIgYmFzaWMgU2FmZVN0cmluZyB0eXBlXG5mdW5jdGlvbiBTYWZlU3RyaW5nKHN0cmluZykge1xuICB0aGlzLnN0cmluZyA9IHN0cmluZztcbn1cblxuU2FmZVN0cmluZy5wcm90b3R5cGUudG9TdHJpbmcgPSBTYWZlU3RyaW5nLnByb3RvdHlwZS50b0hUTUwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICcnICsgdGhpcy5zdHJpbmc7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTYWZlU3RyaW5nO1xuIiwiY29uc3QgZXNjYXBlID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgJ2AnOiAnJiN4NjA7JyxcbiAgJz0nOiAnJiN4M0Q7J1xufTtcblxuY29uc3QgYmFkQ2hhcnMgPSAvWyY8PlwiJ2A9XS9nLFxuICAgICAgcG9zc2libGUgPSAvWyY8PlwiJ2A9XS87XG5cbmZ1bmN0aW9uIGVzY2FwZUNoYXIoY2hyKSB7XG4gIHJldHVybiBlc2NhcGVbY2hyXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChvYmogLyogLCAuLi5zb3VyY2UgKi8pIHtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gYXJndW1lbnRzW2ldKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3VtZW50c1tpXSwga2V5KSkge1xuICAgICAgICBvYmpba2V5XSA9IGFyZ3VtZW50c1tpXVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmV4cG9ydCBsZXQgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vLyBTb3VyY2VkIGZyb20gbG9kYXNoXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmVzdGllanMvbG9kYXNoL2Jsb2IvbWFzdGVyL0xJQ0VOU0UudHh0XG4vKiBlc2xpbnQtZGlzYWJsZSBmdW5jLXN0eWxlICovXG5sZXQgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59O1xuLy8gZmFsbGJhY2sgZm9yIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGlzRnVuY3Rpb24oL3gvKSkge1xuICBpc0Z1bmN0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICB9O1xufVxuZXhwb3J0IHtpc0Z1bmN0aW9ufTtcbi8qIGVzbGludC1lbmFibGUgZnVuYy1zdHlsZSAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykgPyB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJyA6IGZhbHNlO1xufTtcblxuLy8gT2xkZXIgSUUgdmVyc2lvbnMgZG8gbm90IGRpcmVjdGx5IHN1cHBvcnQgaW5kZXhPZiBzbyB3ZSBtdXN0IGltcGxlbWVudCBvdXIgb3duLCBzYWRseS5cbmV4cG9ydCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVFeHByZXNzaW9uKHN0cmluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBkb24ndCBlc2NhcGUgU2FmZVN0cmluZ3MsIHNpbmNlIHRoZXkncmUgYWxyZWFkeSBzYWZlXG4gICAgaWYgKHN0cmluZyAmJiBzdHJpbmcudG9IVE1MKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnRvSFRNTCgpO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2UgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcgKyAnJztcbiAgICB9XG5cbiAgICAvLyBGb3JjZSBhIHN0cmluZyBjb252ZXJzaW9uIGFzIHRoaXMgd2lsbCBiZSBkb25lIGJ5IHRoZSBhcHBlbmQgcmVnYXJkbGVzcyBhbmRcbiAgICAvLyB0aGUgcmVnZXggdGVzdCB3aWxsIGRvIHRoaXMgdHJhbnNwYXJlbnRseSBiZWhpbmQgdGhlIHNjZW5lcywgY2F1c2luZyBpc3N1ZXMgaWZcbiAgICAvLyBhbiBvYmplY3QncyB0byBzdHJpbmcgaGFzIGVzY2FwZWQgY2hhcmFjdGVycyBpbiBpdC5cbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZztcbiAgfVxuXG4gIGlmICghcG9zc2libGUudGVzdChzdHJpbmcpKSB7IHJldHVybiBzdHJpbmc7IH1cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGJhZENoYXJzLCBlc2NhcGVDaGFyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJhbWUob2JqZWN0KSB7XG4gIGxldCBmcmFtZSA9IGV4dGVuZCh7fSwgb2JqZWN0KTtcbiAgZnJhbWUuX3BhcmVudCA9IG9iamVjdDtcbiAgcmV0dXJuIGZyYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmxvY2tQYXJhbXMocGFyYW1zLCBpZHMpIHtcbiAgcGFyYW1zLnBhdGggPSBpZHM7XG4gIHJldHVybiBwYXJhbXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRDb250ZXh0UGF0aChjb250ZXh0UGF0aCwgaWQpIHtcbiAgcmV0dXJuIChjb250ZXh0UGF0aCA/IGNvbnRleHRQYXRoICsgJy4nIDogJycpICsgaWQ7XG59XG4iLCIvLyBDcmVhdGUgYSBzaW1wbGUgcGF0aCBhbGlhcyB0byBhbGxvdyBicm93c2VyaWZ5IHRvIHJlc29sdmVcbi8vIHRoZSBydW50aW1lIG9uIGEgc3VwcG9ydGVkIHBhdGguXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9janMvaGFuZGxlYmFycy5ydW50aW1lJylbJ2RlZmF1bHQnXTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImhhbmRsZWJhcnMvcnVudGltZVwiKVtcImRlZmF1bHRcIl07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTW9kdWxlIGZvciBmdWxsIG1hbmFnZW1lbnQgb2YgcmVxdWVzdGluZyBBSkFYIGZyb20gc2VydmVyLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQUpBWCgpIHt9XG5cbkFKQVguRVJST1IgPSB7XG4gICAgTk9UX1NVUFBPUlQ6ICfsgqzsmqntlZjsi5zripQg67iM65287Jqw7KCA6rCAIOyEnOu5hOyKpCDsnbTsmqnsl5Ag7ZWE7JqU7ZWcIO2VhOyImCDquLDriqXsnYQg7KeA7JuQ7ZWY7KeAIOyViuyKteuLiOuLpC4g7LWc7IugIOuyhOyghOydmCDruIzrnbzsmrDsoIDrpbwg7IKs7Jqp7ZW0IOyjvOyEuOyalC4nXG59O1xuXG4vKioqKioqKioqKlxuICogYWpheFxuICoqKioqKioqKiovXG5cbi8qKlxuICog67mE64+Z6riwIOyalOyyreydhCDsnITtlZwg6rCd7LK066W8IOunjOuTpOyWtCDrsJjtmZjtlZzri6RcbiAqIEByZXR1cm4geyhYTUxIdHRwUmVxdWVzdHxBY3RpdmVYT2JqZWN0KX0g67mE64+Z6riwIO2GteyLoCDsp4Dsm5Ag6rCd7LK0XG4gKi9cbkFKQVgucHJvdG90eXBlLl9jcmVhdGVYSFIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbC5pc0V4aXN0eSh1dGlsLnBpY2sod2luZG93LCAnWE1MSHR0cFJlcXVlc3QnKSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH0gZWxzZSBpZiAodXRpbC5pc0V4aXN0eSh1dGlsLnBpY2sod2luZG93LCAnQWN0aXZlWE9iamVjdCcpKSkge1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIH1cblxuICAgIHdpbmRvdy5hbGVydChBSkFYLkVSUk9SLk5PVF9TVVBQT1JUKTtcbn07XG5cbi8qKlxuICog7YOA7J6F7JeQIOuUsOudvCDrjbDsnbTthLDrpbwg7LaU6rCAIOqwgOqzte2VnOuLpFxuICpcbiAqIFRPRE86IO2YhOyerOuKlCBKU09O642w7J207YSw66eMIOyymOumrOykkeydtOqzoCDtlYTsmpTsl5Ag65Sw6528IOuKmOyWtOuCmOyVvCDtlZzri6RcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhVHlwZSDrjbDsnbTthLAg7YOA7J6FXG4gKiBAcGFyYW0geyp9IGRhdGEg6rCA6rO17ZWgIOuNsOydtO2EsFxuICogQHJldHVybiB7Kn0g6rCA6rO165CcIOuNsOydtO2EsFxuICovXG5BSkFYLnByb3RvdHlwZS5fcHJvY2Vzc1Jhd0RhdGEgPSBmdW5jdGlvbihkYXRhVHlwZSwgZGF0YSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhO1xuICAgIGlmIChkYXRhVHlwZSA9PT0gJ2pzb24nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBkYXRhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogWEhS7J2YIOydkeuLtSDrjbDsnbTthLDrpbwg7LKY66as7ZWc64ukXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGFqYXjsmLXshZgg6rCd7LK0XG4gKiBAcGFyYW0geyhYTUxIdHRwUmVxdWVzdHxBY3RpdmVYT2JqZWN0KX0geGhyIC0g67mE64+Z6riwIOyalOyyrSDqsJ3ssrRcbiAqL1xuQUpBWC5wcm90b3R5cGUuX29uUmVhZHlTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIHhocikge1xuICAgIHZhciBzdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICByZXNwb25zZUhlYWRlcjtcblxuICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhdHVzID0geGhyLnN0YXR1cztcblxuICAgIGlmICgoc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDApIHx8IHN0YXR1cyA9PT0gMzA0KSB7XG4gICAgICAgIHJlc3BvbnNlID0gdGhpcy5fcHJvY2Vzc1Jhd0RhdGEob3B0aW9ucy5kYXRhVHlwZSwgeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHJlc3BvbnNlSGVhZGVyID0gdXRpbC5waWNrKHJlc3BvbnNlLCAnaGVhZGVyJyk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZUhlYWRlcikge1xuICAgICAgICAgICAgb3B0aW9ucy5lcnJvcigpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlSGVhZGVyLmlzU3VjY2Vzc2Z1bCkge1xuICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzKHJlc3BvbnNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZmFpbChyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0YXR1cyAhPT0gMCkge1xuICAgICAgICBvcHRpb25zLmVycm9yKCk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5jb21wbGV0ZSgpO1xufTtcblxuXG4vKipcbiAqIGFqYXgg7JqU7LKt7J2EIOyImO2Wie2VnOuLpC5cbiAqIFxuICog7JqU7LKtIO2DgOyeheyXkCDrlLDrpbgg7LaU6rCAIOuNsOydtO2EsCDsspjrpqzripQg65Sw66GcIO2VmOyngCDslYrsnLzrr4DroZwg7IKs7KCE7JeQIOuvuOumrCDspIDruYTtlbTslbwg7ZWc64ukXG4gKiDsmIjrpbwg65Ok7Ja0LCBnZXTsmpTssq3snYAgUXVlcnlTdHJpbmfsnLzroZwgdXJs7J2EIOyEpOygle2VtOyVvCDtlZjqs6AsIHBvc3Trk7HsnZggZGF0YeulvCDsgqzsmqntlZhcbiAqIOuKlCDsmpTssq3snYAg66+466asIHN0cmluZ2Z565CcIOqwkuydhCBkYXRh7Ji17IWY7Jy866GcIOyghOuLrO2VtOyVvCDtlZzri6QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBhamF47JqU7LKtIO2VoCB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIOyYteyFmFxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1ldGhvZD0nUE9TVCddIOyalOyyrSDsi5wg7IKs7Jqp7ZWgIGh0dHAgbWV0aG9kc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hc3luYz10cnVlXSDruYTrj5nquLAg7JqU7LKtIOyCrOyaqSDsl6zrtoBcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50eXBlPSdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04J10gdHlwZSDtl6TrjZQg6rCSXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29udGVudFR5cGU9J2FwcGxpY2F0aW9uL2pzb24nXSBDb250ZW50LVR5cGUg7Zek642UIOqwklxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRhdGFUeXBlPSdqc29uJ10g7ISc67KE7JeQ7IScIOydkeuLteuwm+q4sCDrsJTrnbzripQg6rKw6rO87J2YIO2DgOyehVxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdG9pbnMuc3VjY2Vzc10gLSBpc1N1Y2Nlc3NmdWwgdHJ1ZeyXkCDrjIDtlZwg7L2c67CxXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5mYWlsXSAtIGlzU3VjY2Vzc2Z1bCBmYWxzZSDsl5Ag64yA7ZWcIOy9nOuwsVxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXJyb3JdIOyalOyyreyXkCDrjIDtlZwg7JeQ65+sIOuwnOyDnSDsi5wg7IiY7ZaJ7ZWgIOy9nOuwsVxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuY29tcGxldGVdIOyalOyyreydtCDrgZ3rgqzsnYQg65WMICjshLHqs7UsIOyLpO2MqCDsl6zrtoDsmYAg66y06rSAKSDsiJjtlontlZjripQg7L2c67CxXG4gKiBAcGFyYW0ge2JvbGxlYW59IFtvcHRpb25zLmNhY2hlPXRydWVdIC0gZmFsc2Ug7J28IOqyveyasCB0aW1lc3RhbXAg7YyM652866+47YSw66W8IHVybOyXkCDrtpnsl6wg7LqQ7Iuc66W8IOustOyLnFxuICovXG5BSkFYLnByb3RvdHlwZS5hamF4ID0gZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gICAgdmFyIHhocixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc2VwYXJhdG9yLFxuICAgICAgICBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04JyxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgIGZhaWw6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgICAgY2FjaGU6IHRydWVcbiAgICAgICAgfTtcblxuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZChkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgZGF0YSA9IHV0aWwucGljayhvcHRpb25zLCAnZGF0YScpO1xuICAgIGlmICghb3B0aW9ucy5jYWNoZSkge1xuICAgICAgICBzZXBhcmF0b3IgPSB+dXJsLmluZGV4T2YoJz8nKSA/ICcmJyA6ICc/JztcbiAgICAgICAgdXJsID0gdXJsICsgc2VwYXJhdG9yICsgJ189JyArICsobmV3IERhdGUoKSk7XG4gICAgfVxuXG4gICAgeGhyID0gdGhpcy5fY3JlYXRlWEhSKCk7XG4gICAgeGhyLm9wZW4ob3B0aW9ucy5tZXRob2QsIHVybCwgb3B0aW9ucy5hc3luYyk7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ3R5cGUnLCBvcHRpb25zLnR5cGUpO1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdjb250ZW50LXR5cGUnLCBvcHRpb25zLmNvbnRlbnRUeXBlKTtcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdXRpbC5iaW5kKHRoaXMuX29uUmVhZHlTdGF0ZUNoYW5nZSwgdGhpcywgb3B0aW9ucywgeGhyKTtcbiAgICB4aHIuc2VuZChkYXRhID8gZGF0YSA6IG51bGwpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBSkFYO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVXRpbGl0eSBtb2R1bGUgZm9yIGFycmF5IHNvcnQsIGJpbmFyeSBzZWFyY2guXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vY29tbW9uL2RhdGV0aW1lJyk7XG5cbi8qKlxuICogQSBtb2R1bGUgZm9yIHNvcnRpbmcgYXJyYXkuXG4gKiBAbW9kdWxlIGFycmF5XG4gKi9cblxuLyoqKioqKioqKipcbiAqIFNlYXJjaFxuICoqKioqKioqKiovXG5cbi8qKlxuICogc2VhcmNoIGl0ZW0gaW5kZXggdXNpbmcgYmluYXJ5IHNlYXJjaCBhbGdvcml0aG0uXG4gKlxuICogdGhlIGFycmF5IG11c3QgYmUgc29ydGVkLlxuICogQHBhcmFtIHthcnJheX0gYXJyIGFycmF5IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXJ8Ym9vbGVhbil9IHNlYXJjaCB2YWx1ZSB0byBzZWFyY2guXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZm5dIGl0ZXJhdGVlIGZvciByZXRyaWV2ZSBlYWNoIGVsZW1lbnQncyB2YWx1ZSB0byBzZWFyY2guXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY29tcGFyZV0gY29tcGFyZSBmdW5jdGlvbiBmb3Igc3BlY2lmaWMgc29ydCBzdGF0dXMuIGRlZmF1bHQgaXMgc3RyaW5nIGFzY2VuZGluZy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgaXRlbSBpbmRleCBzZWFyY2hlZC4gcmV0dXJuIG5lZ2F0aXZlIG51bWJlciB3aGVuIG5vIGV4aXN0IHRoYXQgaXRlbS5cbiAqIEl0IGNhbiB1c2UgaW5zZXJ0IGluZGV4IGFmdGVyIE1hdGguYWJzKClcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFyciA9IFsxLCAzLCA3LCAxMSwgMTUsIDIzXTtcbiAqXG4gKiBmdW5jdGlvbiBzb3J0TnVtYmVyKGEsIGIpIHtcbiAqICAgICByZXR1cm4gYSAtIGI7XG4gKiB9XG4gKlxuICogYnNlYXJjaChhcnIsIDE1LCBudWxsLCBzb3J0TnVtYmVyKTsgICAgLy8gNFxuICogYnNlYXJjaChhcnIsIDIxLCBudWxsLCBzb3J0TnVtYmVyKTsgICAgLy8gLTVcbiAqXG4gKiBhcnIuc3BsaWNlKE1hdGguYWJzKGJzZWFyY2goYXJyLCAyMSwgbnVsbCwgc29ydE51bWJlcikpLCAwLCAyMSk7XG4gKiAvLyBbMSwgMiwgNywgMTEsIDE1LCAyMSwgMjNdXG4gKi9cbmZ1bmN0aW9uIGJzZWFyY2goYXJyLCBzZWFyY2gsIGZuLCBjb21wYXJlKSB7XG4gICAgdmFyIG1pbkluZGV4ID0gMCxcbiAgICAgICAgbWF4SW5kZXggPSBhcnIubGVuZ3RoIC0gMSxcbiAgICAgICAgY3VycmVudEluZGV4LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgY29tcDtcblxuICAgIGNvbXBhcmUgPSBjb21wYXJlIHx8IHN0cmluZ0FTQztcblxuICAgIHdoaWxlIChtaW5JbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgICBjdXJyZW50SW5kZXggPSAobWluSW5kZXggKyBtYXhJbmRleCkgLyAyIHwgMDsgICAgLy8gTWF0aC5mbG9vclxuICAgICAgICB2YWx1ZSA9IGZuID8gZm4oYXJyW2N1cnJlbnRJbmRleF0pIDogYXJyW2N1cnJlbnRJbmRleF07XG4gICAgICAgIGNvbXAgPSBjb21wYXJlKHZhbHVlLCBzZWFyY2gpO1xuXG4gICAgICAgIGlmIChjb21wIDwgMCkge1xuICAgICAgICAgICAgbWluSW5kZXggPSBjdXJyZW50SW5kZXggKyAxO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXAgPiAwKSB7XG4gICAgICAgICAgICBtYXhJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEluZGV4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIH5tYXhJbmRleDtcbn1cblxuLyoqKioqKioqKipcbiAqIENvbXBhcmUgRnVuY3Rpb25zXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBjb21wYXJlIGZ1bmN0aW9uIGZvciBhcnJheSBzb3J0LlxuICpcbiAqIHNvcnQgYXJyYXkgYnkgYXNjZW5kaW5nLlxuICogQHBhcmFtIHtib29sZWFufSBhIFRoZSBib29sZWFuIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYiBUaGUgYm9vbGVhbiB0byBjb21wYXJlLlxuICogQHJldHVybnMge251bWJlcn0gUmVzdWx0IG9mIGNvbXBhcmlzb24uXG4gKi9cbmZ1bmN0aW9uIGJvb2xlYW5BU0MoYSwgYikge1xuICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIHJldHVybiBhID8gLTEgOiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBjb21wYXJlIGZ1bmN0aW9uIGZvciBhcnJheSBzb3J0LlxuICpcbiAqIHNvcnQgYXJyYXkgYnkgZGVzY2VuZGluZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYSBUaGUgYm9vbGVhbiB0byBjb21wYXJlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGIgVGhlIGJvb2xlYW4gdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJlc3VsdCBvZiBjb21wYXJpc29uLlxuICovXG5mdW5jdGlvbiBib29sZWFuREVTQyhhLCBiKSB7XG4gICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPyAxIDogLTE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuXG4vKipcbiAqIGNvbXBhcmUgZnVuY3Rpb24gZm9yIGFycmF5IHNvcnQuXG4gKlxuICogc29ydCBhcnJheSBieSBudW1iZXIgYXNjZW5kaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IF9hIFRoZSBudW1iZXIgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBfYiBUaGUgbnVtYmVyIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXN1bHQgb2YgY29tcGFyaXNvbi5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyQVNDKF9hLCBfYikge1xuICAgIHZhciBhID0gK19hLFxuICAgICAgICBiID0gK19iO1xuXG4gICAgcmV0dXJuIGEgLSBiO1xufVxuXG4vKipcbiAqIGNvbXBhcmUgZnVuY3Rpb24gZm9yIGFycmF5IHNvcnQuXG4gKlxuICogc29ydCBhcnJheSBieSBudW1iZXIgZGVzY2VuZGluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBfYSBUaGUgbnVtYmVyIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gX2IgVGhlIG51bWJlciB0byBjb21wYXJlLlxuICogQHJldHVybnMge251bWJlcn0gUmVzdWx0IG9mIGNvbXBhcmlzb24uXG4gKi9cbmZ1bmN0aW9uIG51bWJlckRFU0MoX2EsIF9iKSB7XG4gICAgdmFyIGEgPSArX2EsXG4gICAgICAgIGIgPSArX2I7XG5cbiAgICByZXR1cm4gYiAtIGE7XG59XG5cbi8qKlxuICogY29tcGFyZSBmdW5jdGlvbiBmb3IgYXJyYXkgc29ydC5cbiAqXG4gKiBzb3J0IGFycmF5IGJ5IHN0cmluZyBhc2NlbmRpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBfYSBUaGUgc3RyaW5nIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gX2IgVGhlIHN0cmluZyB0byBjb21wYXJlLlxuICogQHJldHVybnMge251bWJlcn0gUmVzdWx0IG9mIGNvbXBhcmlzb24uXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ0FTQyhfYSwgX2IpIHtcbiAgICB2YXIgYSA9IF9hICsgJycsXG4gICAgICAgIGIgPSBfYiArICcnO1xuXG4gICAgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xufVxuXG4vKipcbiAqIGNvbXBhcmUgZnVuY3Rpb24gZm9yIGFycmF5IHNvcnQuXG4gKlxuICogc29ydCBhcnJheSBieSBzdHJpbmcgZGVzY2VuZGluZ1xuICogQHBhcmFtIHtzdHJpbmd9IF9hIFRoZSBzdHJpbmcgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBfYiBUaGUgc3RyaW5nIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXN1bHQgb2YgY29tcGFyaXNvbi5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nREVTQyhfYSwgX2IpIHtcbiAgICB2YXIgYSA9IF9hICsgJycsXG4gICAgICAgIGIgPSBfYiArICcnO1xuXG4gICAgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xufVxuXG4vKipcbiAqIGNvbXBhcmUgZnVuY3Rpb24gZm9yIGFycmF5IHNvcnQuXG4gKlxuICogc29ydCBhcnJheSBieSBzdHJpbmcgYXNjZW5kaW5nIHdpdGggaWdub3JlIGNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gX2EgVGhlIHN0cmluZyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IF9iIFRoZSBzdHJpbmcgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJlc3VsdCBvZiBjb21wYXJpc29uLlxuICovXG5mdW5jdGlvbiBzdHJpbmdBU0NJZ25vcmVDYXNlKF9hLCBfYikge1xuICAgIHZhciBhID0gKF9hICsgJycpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGIgPSAoX2IgKyAnJykudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChhID4gYikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBjb21wYXJlIGZ1bmN0aW9uIGZvciBhcnJheSBzb3J0LlxuICpcbiAqIHNvcnQgYXJyYXkgYnkgc3RyaW5nIGRlc2NlbmRpbmcgd2l0aCBpZ25vcmUgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBfYSBUaGUgc3RyaW5nIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gX2IgVGhlIHN0cmluZyB0byBjb21wYXJlLlxuICogQHJldHVybnMge251bWJlcn0gUmVzdWx0IG9mIGNvbXBhcmlzb24uXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ0RFU0NJZ25vcmVDYXNlKF9hLCBfYikge1xuICAgIHZhciBhID0gKF9hICsgJycpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGIgPSAoX2IgKyAnJykudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChhID4gYikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmIChhIDwgYikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBDb21wYXJlIGV2ZW50IG1vZGVscyBmb3Igc29ydC5cbiAqXG4gKiAxLiBhbGwgZGF5IGV2ZW50IGZpcnN0LlxuICogMi4gZWFybHkgc3RhcnRzLlxuICogMy4gbG9uZ2VzdCBkdXJhdGlvbi5cbiAqIDQuIGVhcmx5IGNyZWF0ZWQuXG4gKiBAcGFyYW0geyhFdmVudHxFdmVudFZpZXdNb2RlbCl9IGEgVGhlIG9iamVjdCBldmVudCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KEV2ZW50fEV2ZW50Vmlld01vZGVsKX0gYiBUaGUgb2JqZWN0IGV2ZW50IGluc3RhbmNlLlxuICogQHJldHVybnMge251bWJlcn0gUmVzdWx0IG9mIGNvbXBhcmlzb24uXG4gKi9cbmZ1bmN0aW9uIGV2ZW50QVNDKGEsIGIpIHtcbiAgICB2YXIgZHVyYXRpb25BLFxuICAgICAgICBkdXJhdGlvbkIsXG4gICAgICAgIGFsbERheUNvbXBhcmUsXG4gICAgICAgIHN0YXJ0c0NvbXBhcmU7XG5cbiAgICBhID0gYS52YWx1ZU9mKCk7XG4gICAgYiA9IGIudmFsdWVPZigpO1xuXG4gICAgYWxsRGF5Q29tcGFyZSA9IGJvb2xlYW5BU0MoYS5pc0FsbERheSwgYi5pc0FsbERheSk7XG5cbiAgICBpZiAoYWxsRGF5Q29tcGFyZSkge1xuICAgICAgICByZXR1cm4gYWxsRGF5Q29tcGFyZTtcbiAgICB9XG5cbiAgICBzdGFydHNDb21wYXJlID0gZGF0ZXRpbWUuY29tcGFyZShhLmdldFN0YXJ0cygpLCBiLmdldFN0YXJ0cygpKTtcblxuICAgIGlmIChzdGFydHNDb21wYXJlKSB7XG4gICAgICAgIHJldHVybiBzdGFydHNDb21wYXJlO1xuICAgIH1cblxuICAgIGR1cmF0aW9uQSA9IGEuZHVyYXRpb24oKS5nZXRUaW1lKCk7XG4gICAgZHVyYXRpb25CID0gYi5kdXJhdGlvbigpLmdldFRpbWUoKTtcblxuICAgIGlmIChkdXJhdGlvbkEgPCBkdXJhdGlvbkIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChkdXJhdGlvbkEgPiBkdXJhdGlvbkIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlsLnN0YW1wKGEpIC0gdXRpbC5zdGFtcChiKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBic2VhcmNoOiBic2VhcmNoLFxuICAgIGNvbXBhcmU6IHtcbiAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgIGFzYzogZXZlbnRBU0NcbiAgICAgICAgfSxcbiAgICAgICAgYm9vbDoge1xuICAgICAgICAgICAgYXNjOiBib29sZWFuQVNDLFxuICAgICAgICAgICAgZGVzYzogYm9vbGVhbkRFU0NcbiAgICAgICAgfSxcbiAgICAgICAgbnVtOiB7XG4gICAgICAgICAgICBhc2M6IG51bWJlckFTQyxcbiAgICAgICAgICAgIGRlc2M6IG51bWJlckRFU0NcbiAgICAgICAgfSxcbiAgICAgICAgc3RyOiB7XG4gICAgICAgICAgICBhc2M6IHN0cmluZ0FTQyxcbiAgICAgICAgICAgIGRlc2M6IHN0cmluZ0RFU0MsXG4gICAgICAgICAgICBhc2NJZ25vcmVDYXNlOiBzdHJpbmdBU0NJZ25vcmVDYXNlLFxuICAgICAgICAgICAgZGVzY0lnbm9yZUNhc2U6IHN0cmluZ0RFU0NJZ25vcmVDYXNlXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQWRkIGF1dG9zY3JvbGwgZmVhdHVyZSB0byBlbGVtZW50cyB0aGF0IHByZXZlbnRlZCB0ZXh0IHNlbGVjdGlvbi5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgZG9tZXZlbnQgPSByZXF1aXJlKCcuLi9jb21tb24vZG9tZXZlbnQnKTtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4uL2NvbW1vbi9wb2ludCcpO1xuXG52YXIgU0NST0xMX0lOVEVSVkFMID0gMzA7XG52YXIgU0NST0xMX01BWCA9IDE1O1xudmFyIFNDUk9MTF9DTElDS19JTkNSRUFTRUQgPSAyOyAgICAvLyBJReyXkOyEnCDsiqTtgazroaQg67CUIO2BtOumrSDsi5wg7Iuk7KCcIFVJIHBpeGVsIOuztOuLpCDrhJPqsowg7J6h7Z6I64qUIO2YhOyDgSBvZmZzZXQuXG5cbi8qKlxuICogQWRkIGF1dG9zY3JvbGwgZmVhdHVyZSB0byBlbGVtZW50cyB0aGF0IHByZXZlbnRlZCB0ZXh0IHNlbGVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIC0gSFRNTEVsZW1lbnQgdG8gYWRkIGF1dG9zY3JvbGwgZmVhdHVyZXMuXG4gKi9cbmZ1bmN0aW9uIEF1dG9TY3JvbGwoY29udGFpbmVyKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0F1dG9TY3JvbGwuRElSRUNUSU9OfVxuICAgICAqL1xuICAgIHRoaXMuX2RpcmVjdGlvbiA9IEF1dG9TY3JvbGwuRElSRUNUSU9OLklOU0lERTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fb2Zmc2V0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIGludGVydmFsIHRvIHNjcm9sbGluZ1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5faW50ZXJ2YWxJRCA9IDA7XG5cbiAgICBkb21ldmVudC5vbihjb250YWluZXIsIHtcbiAgICAgICAgJ21vdXNlZG93bic6IHRoaXMuX29uTW91c2VEb3duXG4gICAgfSwgdGhpcyk7XG59XG5cbi8qKlxuICogQGVudW1cbiAqL1xuQXV0b1Njcm9sbC5ESVJFQ1RJT04gPSB7XG4gICAgSU5TSURFOiAwLFxuICAgIFRPUDogMSxcbiAgICBSSUdIVDogMixcbiAgICBCT1RUT006IDMsXG4gICAgTEVGVDogNFxufTtcblxuLyoqXG4gKiBJbnN0YW5jZSBkZXN0cm95IG1ldGhvZC5cbiAqL1xuQXV0b1Njcm9sbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvbWV2ZW50Lm9mZih0aGlzLmNvbnRhaW5lciwge1xuICAgICAgICAnbW91c2Vkb3duJzogdGhpcy5fb25Nb3VzZURvd24sXG4gICAgICAgICdtb3VzZW1vdmUnOiB0aGlzLl9vbk1vdXNlTW92ZSxcbiAgICAgICAgJ21vdXNldXAnOiB0aGlzLl9vbk1vdXNlVXBcbiAgICB9LCB0aGlzKTtcblxuICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsSUQpO1xuICAgIHRoaXMuX2ludGVydmFsSUQgPSB0aGlzLl9kaXJlY3Rpb24gPSB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBDbGllbnRSZWN0IGFuZCBjYWxjdWxhdGUgZWFjaCBwb3NpdGlvbiBvZiBlZGdlcy5cbiAqIEBwYXJhbSB7Q2xpZW50UmVjdH0gY2xpZW50UmVjdCAtIENsaWVudFJlY3Qgb2JqZWN0IG9mIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBlZGdlcy5cbiAqL1xuQXV0b1Njcm9sbC5wcm90b3R5cGUuX2dldEVkZ2VQb3NpdGlvbnMgPSBmdW5jdGlvbihjbGllbnRSZWN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBjbGllbnRSZWN0LnRvcCxcbiAgICAgICAgcmlnaHQ6IGNsaWVudFJlY3QubGVmdCArIGNsaWVudFJlY3Qud2lkdGgsXG4gICAgICAgIGJvdHRvbTogY2xpZW50UmVjdC5ib3R0b20sXG4gICAgICAgIGxlZnQ6IGNsaWVudFJlY3QubGVmdFxuICAgIH07XG59O1xuXG4vKipcbiAqIEdldCBlbGVtZW50IHJlYWwgc2l6ZSAoXCJyZWFsIHNpemVcIiAtPiBzaXplIHdpdGhvdXQgc2Nyb2xsYmFyKVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBlbGVtZW50IHdhbnQgdG8ga25vdyByZWFsIHNpemUgKFwicmVhbCBzaXplXCIgLT4gc2l6ZSB3aXRob3V0IHNjcm9sbGJhcilcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gcmVhbCBzaXplIFt3aWR0aCwgaGVpZ2h0XVxuICovXG5BdXRvU2Nyb2xsLnByb3RvdHlwZS5nZXRSZWFsU2l6ZSA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gZG9tdXRpbC5nZXRDb21wdXRlZFN0eWxlKGVsKSxcbiAgICAgICAgYm9yZGVyLFxuICAgICAgICBwYWRkaW5nO1xuXG4gICAgYm9yZGVyID0gcGFyc2VGbG9hdChjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCdib3JkZXItdG9wLXdpZHRoJykpICtcbiAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCdib3JkZXItYm90dG9tLXdpZHRoJykpO1xuICAgIHBhZGRpbmcgPSBwYXJzZUZsb2F0KGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctdG9wJykpICtcbiAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCdwYWRkaW5nLWJvdHRvbScpKTtcblxuICAgIHJldHVybiBbZWwuY2xpZW50V2lkdGggKyBib3JkZXIgKyBwYWRkaW5nLCBlbC5jbGllbnRIZWlnaHQgKyBib3JkZXIgKyBwYWRkaW5nXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgc3VwcGxpZWQgZWxlbWVudCBoYXMgc2Nyb2xsYmFyLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBlbGVtZW50IHdhbnQgdG8ga25vdyBoYXMgc2Nyb2xsYmFyLlxuICogQHJldHVybnMge2Jvb2xlYW5bXX0gaGFzIHNjcm9sbGJhcj8gW2hvcml6b250YWwsIHZlcnRpY2FsXVxuICovXG5BdXRvU2Nyb2xsLnByb3RvdHlwZS5oYXNTY3JvbGxiYXIgPSBmdW5jdGlvbihlbCkge1xuICAgIHZhciByZWFsU2l6ZSA9IHRoaXMuZ2V0UmVhbFNpemUoZWwpO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgZWwub2Zmc2V0V2lkdGggPiBNYXRoLmNlaWwocmVhbFNpemVbMF0pLFxuICAgICAgICBlbC5vZmZzZXRIZWlnaHQgPiBNYXRoLmNlaWwocmVhbFNpemVbMV0pXG4gICAgXTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBlbGVtZW50IHdhbnQgdG8ga25vdy5cbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gbW91c2VFdmVudCAtIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBtb3VzZSBwb2ludGVyIGlzIG9uIHRoZSBzY3JvbGxiYXI/XG4gKi9cbkF1dG9TY3JvbGwucHJvdG90eXBlLmlzT25TY3JvbGxiYXIgPSBmdW5jdGlvbihlbCwgbW91c2VFdmVudCkge1xuICAgIHZhciByZWFsU2l6ZSA9IHRoaXMuZ2V0UmVhbFNpemUoZWwpLFxuICAgICAgICBwb3MgPSBkb21ldmVudC5nZXRNb3VzZVBvc2l0aW9uKG1vdXNlRXZlbnQsIGVsKSxcbiAgICAgICAgbW91c2VJblNjcm9sbGJhciA9IGZhbHNlO1xuXG4gICAgbW91c2VJblNjcm9sbGJhciA9IChyZWFsU2l6ZVswXSAtIFNDUk9MTF9DTElDS19JTkNSRUFTRUQgPCBwb3NbMF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWxTaXplWzFdIC0gU0NST0xMX0NMSUNLX0lOQ1JFQVNFRCA8IHBvc1sxXSk7XG5cbiAgICByZXR1cm4gbW91c2VJblNjcm9sbGJhcjtcbn07XG5cbi8qKlxuICogTW91c2VEb3duIGV2ZW50IGhhbmRsZXJcbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gbW91c2VEb3duRXZlbnQgLSBtb3VzZSBkb3duIGV2ZW50XG4gKi9cbkF1dG9TY3JvbGwucHJvdG90eXBlLl9vbk1vdXNlRG93biA9IGZ1bmN0aW9uKG1vdXNlRG93bkV2ZW50KSB7XG4gICAgLy8gb25seSBwcmltYXJ5IGJ1dHRvbiBjYW4gc3RhcnQgZHJhZy5cbiAgICBpZiAoZG9tZXZlbnQuZ2V0TW91c2VCdXR0b24obW91c2VEb3duRXZlbnQpICE9PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBkZWFjdGl2YXRlIGF1dG9zY3JvbGwgZmVhdHVyZSB3aGVuIG1vdXNlIGlzIG9uIHRoZSBzY3JvbGxiYXIuIChJRSlcbiAgICBpZiAodXRpbC5icm93c2VyLm1zaWUgJiYgdGhpcy5pc09uU2Nyb2xsYmFyKHRoaXMuY29udGFpbmVyLCBtb3VzZURvd25FdmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsSUQpO1xuICAgIHRoaXMuX2ludGVydmFsSUQgPSB3aW5kb3cuc2V0SW50ZXJ2YWwodXRpbC5iaW5kKHRoaXMuX29uVGljaywgdGhpcyksIFNDUk9MTF9JTlRFUlZBTCk7XG5cbiAgICBkb21ldmVudC5vbihnbG9iYWwsIHtcbiAgICAgICAgJ21vdXNlbW92ZSc6IHRoaXMuX29uTW91c2VNb3ZlLFxuICAgICAgICAnbW91c2V1cCc6IHRoaXMuX29uTW91c2VVcFxuICAgIH0sIHRoaXMpO1xufTtcblxuLyoqXG4gKiBNb3VzZU1vdmUgZXZlbnQgaGFuZGxlclxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50IC0gbW91c2UgbW92ZSBldmVudCBvYmplY3QuXG4gKi9cbkF1dG9TY3JvbGwucHJvdG90eXBlLl9vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgICB2YXIgZWRnZSA9IHRoaXMuX2dldEVkZ2VQb3NpdGlvbnModGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLFxuICAgICAgICBwb3MgPSBQb2ludC5uKGRvbWV2ZW50LmdldE1vdXNlUG9zaXRpb24obW91c2VFdmVudCkpO1xuXG4gICAgaWYgKHBvcy55ID49IGVkZ2UudG9wICYmIHBvcy55IDw9IGVkZ2UuYm90dG9tICYmXG4gICAgICAgIHBvcy54ID49IGVkZ2UubGVmdCAmJiBwb3MueCA8PSBlZGdlLnJpZ2h0KSB7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IEF1dG9TY3JvbGwuRElSRUNUSU9OLklOU0lERTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwb3MueSA8IGVkZ2UudG9wKSB7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IEF1dG9TY3JvbGwuRElSRUNUSU9OLlRPUDtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gZWRnZS50b3AgLSBwb3MueTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwb3MueSA+IGVkZ2UuYm90dG9tKSB7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IEF1dG9TY3JvbGwuRElSRUNUSU9OLkJPVFRPTTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gcG9zLnkgLSBlZGdlLmJvdHRvbTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwb3MueCA8IGVkZ2UubGVmdCkge1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBBdXRvU2Nyb2xsLkRJUkVDVElPTi5MRUZUO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBlZGdlLmxlZnQgLSBwb3MueDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2RpcmVjdGlvbiA9IEF1dG9TY3JvbGwuRElSRUNUSU9OLlJJR0hUO1xuICAgIHRoaXMuX29mZnNldCA9IHBvcy54IC0gZWRnZS5yaWdodDtcbiAgICByZXR1cm47XG59O1xuXG4vKipcbiAqIE1vdXNlVXAgZXZlbnQgaGFuZGxlci5cbiAqL1xuQXV0b1Njcm9sbC5wcm90b3R5cGUuX29uTW91c2VVcCA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsSUQpO1xuICAgIHRoaXMuX2ludGVydmFsSUQgPSAwO1xuICAgIHRoaXMuX2RpcmVjdGlvbiA9IEF1dG9TY3JvbGwuRElSRUNUSU9OLklOU0lERTtcbiAgICB0aGlzLl9vZmZzZXQgPSAwO1xuXG4gICAgZG9tZXZlbnQub2ZmKGdsb2JhbCwge1xuICAgICAgICAnbW91c2Vtb3ZlJzogdGhpcy5fb25Nb3VzZU1vdmUsXG4gICAgICAgICdtb3VzZXVwJzogdGhpcy5fb25Nb3VzZVVwXG4gICAgfSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIEludGVydmFsIHRpY2sgZXZlbnQgaGFuZGxlclxuICovXG5BdXRvU2Nyb2xsLnByb3RvdHlwZS5fb25UaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBmYWN0b3I7XG5cbiAgICBpZiAoIWRpcmVjdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgZmFjdG9yID0gTWF0aC5taW4odGhpcy5fb2Zmc2V0LCBTQ1JPTExfTUFYKTtcblxuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGNhc2UgQXV0b1Njcm9sbC5ESVJFQ1RJT04uVE9QOlxuICAgICAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCAtPSBmYWN0b3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBdXRvU2Nyb2xsLkRJUkVDVElPTi5SSUdIVDpcbiAgICAgICAgICAgIGNvbnRhaW5lci5zY3JvbGxMZWZ0ICs9IGZhY3RvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEF1dG9TY3JvbGwuRElSRUNUSU9OLkJPVFRPTTpcbiAgICAgICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgKz0gZmFjdG9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb250YWluZXIuc2Nyb2xsTGVmdCAtPSBmYWN0b3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dG9TY3JvbGw7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBDb21tb24gY29sbGVjdGlvbnMuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsLFxuICAgIGZvckVhY2hQcm9wID0gdXRpbC5mb3JFYWNoT3duUHJvcGVydGllcyxcbiAgICBmb3JFYWNoQXJyID0gdXRpbC5mb3JFYWNoQXJyYXksXG4gICAgaXNGdW5jID0gdXRpbC5pc0Z1bmN0aW9uLFxuICAgIGlzT2JqID0gdXRpbC5pc09iamVjdDtcblxudmFyIGFwcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBDb21tb24gY29sbGVjdGlvbi5cbiAqXG4gKiBJdCBuZWVkIGZ1bmN0aW9uIGZvciBnZXQgbW9kZWwncyB1bmlxdWUgaWQuXG4gKlxuICogaWYgdGhlIGZ1bmN0aW9uIGlzIG5vdCBzdXBwbGllZCB0aGVuIGl0IHVzZSBkZWZhdWx0IGZ1bmN0aW9uIHtAbGluayBDb2xsZWN0aW9uI2dldEl0ZW1JRH1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2dldEl0ZW1JREZuXSBmdW5jdGlvbiBmb3IgZ2V0IG1vZGVsJ3MgaWQuXG4gKi9cbmZ1bmN0aW9uIENvbGxlY3Rpb24oZ2V0SXRlbUlERm4pIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7b2JqZWN0LjxzdHJpbmcsICo+fVxuICAgICAqL1xuICAgIHRoaXMuaXRlbXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgaWYgKGlzRnVuYyhnZXRJdGVtSURGbikpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0SXRlbUlEID0gZ2V0SXRlbUlERm47XG4gICAgfVxufVxuXG4vKioqKioqKioqKlxuICogc3RhdGljIHByb3BzXG4gKioqKioqKioqKi9cblxuQ29sbGVjdGlvbi5maWx0ZXIgPSB7XG4gICAgLyoqXG4gICAgICogcmV0dXJuIEFORCBvcGVyYXRlIGFsbCBvZiBmdW5jdGlvbidzIHJldHVybiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGFyciBmaWx0ZXJzXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFyYW1zXSBzdXBwb3J0IGZpbHRlciBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQU5EIG9wZXJhdGVkIHZhbHVlXG4gICAgICovXG4gICAgYW5kOiBmdW5jdGlvbihhcnIsIHBhcmFtcykgeyAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIHZhciBhcmdzID0gYXBzLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgY250ID0gYXJyLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGNudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIWFycltpXS5hcHBseShudWxsLCBhcmdzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gT1Igb3BlcmF0ZSBhbGwgb2YgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWVcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBhcnIgZmlsdGVyc1xuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcmFtc10gc3VwcG9ydCBmaWx0ZXIgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IE9SIG9wZXJhdGVkIHZhbHVlXG4gICAgICovXG4gICAgb3I6IGZ1bmN0aW9uKGFyciwgcGFyYW1zKSB7ICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgdmFyIGFyZ3MgPSBhcHMuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICAgdG1wLFxuICAgICAgICAgICAgcmVzdWx0O1xuXG4gICAgICAgIGZvckVhY2hBcnIoYXJyLCBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgICAgIHRtcCA9IGZpbHRlci5hcHBseShudWxsLCBhcmdzKTtcblxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCB8fCB0bXApO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbi8qKlxuICogTWVyZ2Ugc2V2ZXJhbCBjb2xsZWN0aW9ucy5cbiAqXG4gKiBZb3UgY2FuXFwndCBtZXJnZSBjb2xsZWN0aW9ucyBkaWZmZXJlbnQgX2dldEV2ZW50SUQgZnVuY3Rpb25zLiBUYWtlIGNhc2Ugb2YgdXNlLlxuICogQHBhcmFtIHsuLi5Db2xsZWN0aW9ufSBjb2xsZWN0aW9ucyBjb2xsZWN0aW9uIGFyZ3VtZW50cyB0byBtZXJnZVxuICogQHJldHVybnMge0NvbGxlY3Rpb259IG1lcmdlZCBjb2xsZWN0aW9uLlxuICovXG5Db2xsZWN0aW9uLm1lcmdlID0gZnVuY3Rpb24oY29sbGVjdGlvbnMpIHsgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciBjb2xzID0gYXBzLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgbmV3SXRlbXMgPSB7fSxcbiAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgbWVyZ2VkID0gbmV3IENvbGxlY3Rpb24oY29sc1swXS5nZXRJdGVtSUQpLFxuICAgICAgICBleHRlbmQgPSB1dGlsLmV4dGVuZDtcblxuICAgIGZvckVhY2hBcnIoY29scywgZnVuY3Rpb24oY29sKSB7XG4gICAgICAgIGV4dGVuZChuZXdJdGVtcywgY29sLml0ZW1zKTtcbiAgICAgICAgbGVuZ3RoICs9IGNvbC5sZW5ndGg7XG4gICAgfSk7XG5cbiAgICBtZXJnZWQuaXRlbXMgPSBuZXdJdGVtcztcbiAgICBtZXJnZWQubGVuZ3RoID0gbGVuZ3RoO1xuXG4gICAgcmV0dXJuIG1lcmdlZDtcbn07XG5cbi8qKioqKioqKioqXG4gKiBwcm90b3R5cGUgcHJvcHNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIGdldCBtb2RlbCdzIHVuaXF1ZSBpZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIG1vZGVsIGluc3RhbmNlLlxuICogQHJldHVybnMge251bWJlcn0gbW9kZWwgdW5pcXVlIGlkLlxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5nZXRJdGVtSUQgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0uX2lkICsgJyc7XG59O1xuXG4vKipcbiAqIGFkZCBtb2RlbHMuXG4gKiBAcGFyYW0gey4uLip9IGl0ZW0gbW9kZWxzIHRvIGFkZCB0aGlzIGNvbGxlY3Rpb24uXG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICB2YXIgaWQsXG4gICAgICAgIG93bkl0ZW1zO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvckVhY2hBcnIoYXBzLmNhbGwoYXJndW1lbnRzKSwgZnVuY3Rpb24obykge1xuICAgICAgICAgICAgdGhpcy5hZGQobyk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZCA9IHRoaXMuZ2V0SXRlbUlEKGl0ZW0pO1xuICAgIG93bkl0ZW1zID0gdGhpcy5pdGVtcztcblxuICAgIGlmICghb3duSXRlbXNbaWRdKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IDE7XG4gICAgfVxuICAgIG93bkl0ZW1zW2lkXSA9IGl0ZW07XG59O1xuXG4vKipcbiAqIHJlbW92ZSBtb2RlbHMuXG4gKiBAcGFyYW0gey4uLihvYmplY3R8c3RyaW5nfG51bWJlcil9IGlkIG1vZGVsIGluc3RhbmNlIG9yIHVuaXF1ZSBpZCB0byBkZWxldGUuXG4gKiBAcmV0dXJucyB7YXJyYXl9IGRlbGV0ZWQgbW9kZWwgbGlzdC5cbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgcmVtb3ZlZCA9IFtdLFxuICAgICAgICBvd25JdGVtcyxcbiAgICAgICAgaXRlbVRvUmVtb3ZlO1xuXG4gICAgaWYgKCF0aGlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmVtb3ZlZCA9IHV0aWwubWFwKGFwcy5jYWxsKGFyZ3VtZW50cyksIGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmUoaWQpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICBvd25JdGVtcyA9IHRoaXMuaXRlbXM7XG5cbiAgICBpZiAoaXNPYmooaWQpKSB7XG4gICAgICAgIGlkID0gdGhpcy5nZXRJdGVtSUQoaWQpO1xuICAgIH1cblxuICAgIGlmICghb3duSXRlbXNbaWRdKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoIC09IDE7XG4gICAgaXRlbVRvUmVtb3ZlID0gb3duSXRlbXNbaWRdO1xuICAgIGRlbGV0ZSBvd25JdGVtc1tpZF07XG5cbiAgICByZXR1cm4gaXRlbVRvUmVtb3ZlO1xufTtcblxuLyoqXG4gKiByZW1vdmUgYWxsIG1vZGVscyBpbiBjb2xsZWN0aW9uLlxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaXRlbXMgPSB7fTtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIGNoZWNrIGNvbGxlY3Rpb24gaGFzIHNwZWNpZmljIG1vZGVsLlxuICogQHBhcmFtIHsob2JqZWN0fHN0cmluZ3xudW1iZXJ8ZnVuY3Rpb24pfSBpZCBtb2RlbCBpbnN0YW5jZSBvciBpZCBvciBmaWx0ZXIgZnVuY3Rpb24gdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSBpcyBoYXMgbW9kZWw/XG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIGlzRmlsdGVyLFxuICAgICAgICBoYXM7XG5cbiAgICBpZiAoIXRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpc0ZpbHRlciA9IGlzRnVuYyhpZCk7XG4gICAgaGFzID0gZmFsc2U7XG5cbiAgICBpZiAoaXNGaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChpZChpdGVtKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGhhcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZCA9IGlzT2JqKGlkKSA/IHRoaXMuZ2V0SXRlbUlEKGlkKSA6IGlkO1xuICAgICAgICBoYXMgPSB1dGlsLmlzRXhpc3R5KHRoaXMuaXRlbXNbaWRdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzO1xufTtcblxuLyoqXG4gKiBpbnZva2UgY2FsbGJhY2sgd2hlbiBtb2RlbCBleGlzdCBpbiBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcil9IGlkIG1vZGVsIHVuaXF1ZSBpZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIHRoZSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdIGNhbGxiYWNrIGNvbnRleHQuXG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmRvV2hlbkhhcyA9IGZ1bmN0aW9uKGlkLCBmbiwgY29udGV4dCkge1xuICAgIHZhciBpdGVtID0gdGhpcy5pdGVtc1tpZF07XG5cbiAgICBpZiAoIXV0aWwuaXNFeGlzdHkoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZuLmNhbGwoY29udGV4dCB8fCB0aGlzLCBpdGVtKTtcbn07XG5cbi8qKlxuICogU2VhcmNoIG1vZGVsLiBhbmQgcmV0dXJuIG5ldyBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZmlsdGVyIGZpbHRlciBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtDb2xsZWN0aW9ufSBuZXcgY29sbGVjdGlvbiB3aXRoIGZpbHRlcmVkIG1vZGVscy5cbiAqIEBleGFtcGxlXG4gKiBjb2xsZWN0aW9uLmZpbmQoZnVuY3Rpb24oaXRlbSkge1xuICogICAgIHJldHVybiBpdGVtLmVkaXRlZCA9PT0gdHJ1ZTtcbiAqIH0pO1xuICpcbiAqIGZ1bmN0aW9uIGZpbHRlcjEoaXRlbSkge1xuICogICAgIHJldHVybiBpdGVtLmVkaXRlZCA9PT0gZmFsc2U7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gZmlsdGVyMihpdGVtKSB7XG4gKiAgICAgcmV0dXJuIGl0ZW0uZGlzYWJsZWQgPT09IGZhbHNlO1xuICogfVxuICpcbiAqIGNvbGxlY3Rpb24uZmluZChmdW5jdGlvbihpdGVtKSB7XG4gKiAgICAgcmV0dXJuIENvbGxlY3Rpb24uZmlsdGVyLmFuZChbZmlsdGVyMSwgZmlsdGVyMl0sIGl0ZW0pO1xuICogfSk7XG4gKlxuICogY29sbGVjdGlvbi5maW5kKGZ1bmN0aW9uKGl0ZW0pIHtcbiAqICAgICByZXR1cm4gQ29sbGVjdGlvbi5maWx0ZXIub3IoW2ZpbHRlcjEsIGZpbHRlcjJdLCBpdGVtKTtcbiAqIH0pO1xuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBDb2xsZWN0aW9uKCk7XG5cbiAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eSgnZ2V0SXRlbUlEJykpIHtcbiAgICAgICAgcmVzdWx0LmdldEl0ZW1JRCA9IHRoaXMuZ2V0SXRlbUlEO1xuICAgIH1cblxuICAgIHRoaXMuZWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGlmIChmaWx0ZXIoaXRlbSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEdyb3VwIGVsZW1lbnQgYnkgc3BlY2lmaWMga2V5IHZhbHVlcy5cbiAqXG4gKiBpZiBrZXkgcGFyYW1ldGVyIGlzIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0IGFuZCB1c2UgcmV0dXJuZWQgdmFsdWUuXG4gKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyfGZ1bmN0aW9ufGFycmF5KX0ga2V5IGtleSBwcm9wZXJ0eSBvciBnZXR0ZXIgZnVuY3Rpb24uIGlmIHN0cmluZ1tdIHN1cHBsaWVkLCBjcmVhdGUgZWFjaCBjb2xsZWN0aW9uIGJlZm9yZSBncm91cGluZy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtncm91cEZ1bmNdIC0gZnVuY3Rpb24gdGhhdCByZXR1cm4gZWFjaCBncm91cCdzIGtleVxuICogQHJldHVybnMge29iamVjdC48c3RyaW5nLCBDb2xsZWN0aW9uPn0gZ3JvdXBlZCBvYmplY3RcbiAqIEBleGFtcGxlXG4gKiBcbiAqIC8vIHBhc3MgYHN0cmluZ2AsIGBudW1iZXJgLCBgYm9vbGVhbmAgdHlwZSB2YWx1ZSB0aGVuIGdyb3VwIGJ5IHByb3BlcnR5IHZhbHVlLlxuICogY29sbGVjdGlvbi5ncm91cEJ5KCdnZW5kZXInKTsgICAgLy8gZ3JvdXAgYnkgJ2dlbmRlcicgcHJvcGVydHkgdmFsdWUuXG4gKiBjb2xsZWN0aW9uLmdyb3VwQnkoNTApOyAgICAgICAgICAvLyBncm91cCBieSAnNTAnIHByb3BlcnR5IHZhbHVlLlxuICogXG4gKiAvLyBwYXNzIGBmdW5jdGlvbmAgdGhlbiBncm91cCBieSByZXR1cm4gdmFsdWUuIGVhY2ggaW52b2NhdGlvbiBgZnVuY3Rpb25gIGlzIGNhbGxlZCB3aXRoIGAoaXRlbSlgLlxuICogY29sbGVjdGlvbi5ncm91cEJ5KGZ1bmN0aW9uKGl0ZW0pIHtcbiAqICAgICBpZiAoaXRlbS5zY29yZSA+IDYwKSB7XG4gKiAgICAgICAgIHJldHVybiAncGFzcyc7XG4gKiAgICAgfVxuICogICAgIHJldHVybiAnZmFpbCc7XG4gKiB9KTtcbiAqXG4gKiAvLyBwYXNzIGBhcnJheWAgd2l0aCBmaXJzdCBhcmd1bWVudHMgdGhlbiBjcmVhdGUgZWFjaCBjb2xsZWN0aW9uIGJlZm9yZSBncm91cGluZy5cbiAqIGNvbGxlY3Rpb24uZ3JvdXBCeShbJ2dvJywgJ3J1YnknLCAnamF2YXNjcmlwdCddKTtcbiAqIC8vIHJlc3VsdDogeyAnZ28nOiBlbXB0eSBDb2xsZWN0aW9uLCAncnVieSc6IGVtcHR5IENvbGxlY3Rpb24sICdqYXZhc2NyaXB0JzogZW1wdHkgQ29sbGVjdGlvbiB9XG4gKlxuICogLy8gY2FuIHBhc3MgYGZ1bmN0aW9uYCB3aXRoIGBhcnJheWAgdGhlbiBncm91cCBlYWNoIGVsZW1lbnRzLlxuICogY29sbGVjdGlvbi5ncm91cEJ5KFsnZ28nLCAncnVieScsICdqYXZhc2NyaXB0J10sIGZ1bmN0aW9uKGl0ZW0pIHtcbiAqICAgICBpZiAoaXRlbS5pc0Zhc3QpIHtcbiAqICAgICAgICAgcmV0dXJuICdnbyc7XG4gKiAgICAgfVxuICpcbiAqICAgICByZXR1cm4gaXRlbS5uYW1lO1xuICogfSk7XG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmdyb3VwQnkgPSBmdW5jdGlvbihrZXksIGdyb3VwRnVuYykge1xuICAgIHZhciByZXN1bHQgPSB7fSxcbiAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgYmFzZVZhbHVlLFxuICAgICAgICBpc0Z1bmMgPSB1dGlsLmlzRnVuY3Rpb24sXG4gICAgICAgIGtleUlzRnVuYyA9IGlzRnVuYyhrZXkpLFxuICAgICAgICBnZXRJdGVtSURGbiA9IHRoaXMuZ2V0SXRlbUlEO1xuXG4gICAgaWYgKHV0aWwuaXNBcnJheShrZXkpKSB7XG4gICAgICAgIHV0aWwuZm9yRWFjaEFycmF5KGtleSwgZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgcmVzdWx0W2sgKyAnJ10gPSBuZXcgQ29sbGVjdGlvbihnZXRJdGVtSURGbik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghZ3JvdXBGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAga2V5ID0gZ3JvdXBGdW5jO1xuICAgICAgICBrZXlJc0Z1bmMgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuZWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGlmIChrZXlJc0Z1bmMpIHtcbiAgICAgICAgICAgIGJhc2VWYWx1ZSA9IGtleShpdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VWYWx1ZSA9IGl0ZW1ba2V5XTtcblxuICAgICAgICAgICAgaWYgKGlzRnVuYyhiYXNlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgYmFzZVZhbHVlID0gYmFzZVZhbHVlLmFwcGx5KGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29sbGVjdGlvbiA9IHJlc3VsdFtiYXNlVmFsdWVdO1xuXG4gICAgICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgICAgICAgY29sbGVjdGlvbiA9IHJlc3VsdFtiYXNlVmFsdWVdID0gbmV3IENvbGxlY3Rpb24oZ2V0SXRlbUlERm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29sbGVjdGlvbi5hZGQoaXRlbSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gc2luZ2xlIGl0ZW0gaW4gY29sbGVjdGlvbi5cbiAqXG4gKiBSZXR1cm5lZCBpdGVtIGlzIGluc2VydGVkIGluIHRoaXMgY29sbGVjdGlvbiBmaXJzdGx5LlxuICogQHJldHVybnMge29iamVjdH0gaXRlbS5cbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUuc2luZ2xlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIHRoaXMuZWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJlc3VsdCA9IGl0ZW07XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIHNvcnQgYSBiYXNpcyBvZiBzdXBwbGllZCBjb21wYXJlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyZUZ1bmN0aW9uIGNvbXBhcmVGdW5jdGlvblxuICogQHJldHVybnMge2FycmF5fSBzb3J0ZWQgYXJyYXkuXG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbihjb21wYXJlRnVuY3Rpb24pIHtcbiAgICB2YXIgYXJyID0gW107XG5cbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBhcnIucHVzaChpdGVtKTtcbiAgICB9KTtcblxuICAgIGlmIChpc0Z1bmMoY29tcGFyZUZ1bmN0aW9uKSkge1xuICAgICAgICBhcnIgPSBhcnIuc29ydChjb21wYXJlRnVuY3Rpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBhcnI7XG59O1xuXG4vKipcbiAqIGl0ZXJhdGUgZWFjaCBtb2RlbCBlbGVtZW50LlxuICpcbiAqIHdoZW4gaXRlcmF0ZWUgcmV0dXJuIGZhbHNlIHRoZW4gYnJlYWsgdGhlIGxvb3AuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSBpdGVyYXRlZShpdGVtLCBpbmRleCwgaXRlbXMpXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XSBjb250ZXh0XG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbihpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGZvckVhY2hQcm9wKHRoaXMuaXRlbXMsIGl0ZXJhdGVlLCBjb250ZXh0IHx8IHRoaXMpO1xufTtcblxuLyoqXG4gKiByZXR1cm4gbmV3IGFycmF5IHdpdGggY29sbGVjdGlvbiBpdGVtcy5cbiAqIEByZXR1cm5zIHthcnJheX0gbmV3IGFycmF5LlxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWwubWFwKHRoaXMuaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxlY3Rpb247XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBjb21tb24vZ2VuZXJhbCB1dGlsaXRpZXMuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9jb21tb24vY29sbGVjdGlvbicpO1xudmFyIGFwcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuZnVuY3Rpb24gZXZlbnRJREdldHRlcihldmVudCkge1xuICAgIHJldHVybiBldmVudC5pZCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gey4uLip9IGluaXRJdGVtcyAtIGl0ZW1zIHRvIGFkZCBuZXdseSBjcmVhdGVkIGNvbGxlY3Rpb24uXG4gICAgICogQHJldHVybnMge0NvbGxlY3Rpb259IG5ldyBjb2xsZWN0aW9uIGZvciBldmVudCBtb2RlbHMuXG4gICAgICovXG4gICAgY3JlYXRlRXZlbnRDb2xsZWN0aW9uOiBmdW5jdGlvbihpbml0SXRlbXMpIHsgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICB2YXIgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKGV2ZW50SURHZXR0ZXIpO1xuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLmFkZC5hcHBseShjb2xsZWN0aW9uLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByYXRpbyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIGEgOiBiID0geSA6IFg7XG4gICAgICpcbiAgICAgKiA9XG4gICAgICpcbiAgICAgKiBYID0gKGIgKiB5KSAvIGE7XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGEgLSBhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGIgLSBiXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB5XG4gICAgICogQHJldHVybnMge251bWJlcn0gcmF0aW8gdmFsdWVcbiAgICAgKi9cbiAgICByYXRpbzogZnVuY3Rpb24oYSwgYiwgeSkge1xuICAgICAgICAvLyBhIDogYiA9IHkgOiB4O1xuICAgICAgICByZXR1cm4gKGIgKiB5KSAvIGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbmVhcmVzdCB2YWx1ZSBmcm9tIHN1cHBsaWVkIHBhcmFtcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kLlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IG5lYXJlc3QgLSBuZWFyZXN0IGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG5lYXJlc3QgdmFsdWVcbiAgICAgKi9cbiAgICBuZWFyZXN0OiBmdW5jdGlvbih2YWx1ZSwgbmVhcmVzdCkge1xuICAgICAgICB2YXIgZGlmZiA9IHV0aWwubWFwKG5lYXJlc3QsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModmFsdWUgLSB2KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbmVhcmVzdEluZGV4ID0gdXRpbC5pbkFycmF5KE1hdGgubWluLmFwcGx5KG51bGwsIGRpZmYpLCBkaWZmKTtcblxuICAgICAgICByZXR1cm4gbmVhcmVzdFtuZWFyZXN0SW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBwaWNrIHZhbHVlIGZyb20gb2JqZWN0IHRoZW4gcmV0dXJuIHV0aWxpdHkgb2JqZWN0IHRvIHRyZWF0IGl0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSBvYmplY3QgdG8gc2VhcmNoIHN1cHBsaWVkIHBhdGggcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHsuLi5zdHJpbmd9IHBhdGhzIC0gcmVzdCBwYXJhbWV0ZXIgdGhhdCBzdHJpbmcgdmFsdWUgdG8gc2VhcmNoIHByb3BlcnR5IGluIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBwaWNrIG9iamVjdC5cbiAgICAgKi9cbiAgICBwaWNrMjogZnVuY3Rpb24ob2JqLCBwYXRocykgeyAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIHZhciByZXN1bHQgPSB1dGlsLnBpY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKSxcbiAgICAgICAgICAgIHBpY2s7XG5cbiAgICAgICAgcGljayA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybnMgeyp9IHBpY2tlZCB2YWx1ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBpbnZva2Ugc3VwcGxpZWQgZnVuY3Rpb24gaW4gcGlja2VkIG9iamVjdC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiB0aGUgY2FsbGJhY2sgY29udGV4dCBpcyBzZXQgcGlja2VkIG9iamVjdC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufSBmbiAtIGZ1bmN0aW9uIHRvIGludm9rZSBpbiBwaWNrZWQgb2JqZWN0LlxuICAgICAgICAgICAgICogQHJldHVybnMgeyp9IHJlc3VsdCBvZiBpbnZva2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3M7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAgICAvL2VzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcmdzID0gYXBzLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKGZuKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHV0aWwucGljayhyZXN1bHQsIGZuKSB8fCBmdW5jdGlvbigpIHt9KS5hcHBseShyZXN1bHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHJlc3VsdCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gcGljaztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWl4aW4gbWV0aG9kLlxuICAgICAqXG4gICAgICogKGV4dGVuZCBtZXRob2RzIGV4Y2VwdCBwcm9wZXJ0eSBuYW1lICdtaXhpbicpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGZyb20gLSBtaXhpbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRvIC0gb2JqZWN0IHRvIG1peGluLlxuICAgICAqL1xuICAgIG1peGluOiBmdW5jdGlvbihmcm9tLCB0bykge1xuICAgICAgICB1dGlsLmV4dGVuZCh0by5wcm90b3R5cGUsIGZyb20pO1xuICAgIH1cbn07XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBkYXRldGltZSB1dGlsaXR5IG1vZHVsZVxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbCxcbiAgICBvcHQgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgZGF0ZUZvcm1hdFJ4ID0gL14oXFxkezR9Wy18XFwvXSpcXGR7Mn1bLXxcXC9dKlxcZHsyfSlcXHM/KFxcZHsyfTpcXGR7Mn06XFxkezJ9KT8kLztcblxudmFyIGRhdGV0aW1lLFxuICAgIHRva2VuRnVuYztcblxudmFyIG1lbW8gPSB7XG4gICAgbWlsbGlzZWNvbmRzVG86IHt9LFxuICAgIG1pbGxpc2Vjb25kc0Zyb206IHt9XG59O1xuXG50b2tlbkZ1bmMgPSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlIGRhdGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFlZWVlNTUREXG4gICAgICovXG4gICAgJ1lZWVlNTUREJzogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgICAgZGF0ZXRpbWUubGVhZGluZ1plcm8oZGF0ZS5nZXRNb250aCgpICsgMSwgMiksXG4gICAgICAgICAgICBkYXRldGltZS5sZWFkaW5nWmVybyhkYXRlLmdldERhdGUoKSwgMilcbiAgICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBkYXRlIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGZvdXIgZGlnaXQgeWVhciBudW1iZXJcbiAgICAgKi9cbiAgICAnWVlZWSc6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKSArICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUgZGF0ZSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0d28gZGlnaXQgbW9udGggbnVtYmVyXG4gICAgICovXG4gICAgJ01NJzogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZXRpbWUubGVhZGluZ1plcm8oZGF0ZS5nZXRNb250aCgpICsgMSwgMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBkYXRlIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHR3byBkaWdpdCBkYXRlIG51bWJlclxuICAgICAqL1xuICAgICdERCc6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGV0aW1lLmxlYWRpbmdaZXJvKGRhdGUuZ2V0RGF0ZSgpLCAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlIGRhdGUgb2JqZWN0XG4gICAgICogQHJldHVybnMge3N0cmluZ30gSEg6bW1cbiAgICAgKi9cbiAgICAnSEg6bW0nOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHZhciBob3VyID0gZGF0ZS5nZXRIb3VycygpLFxuICAgICAgICAgICAgbWludXRlcyA9IGRhdGUuZ2V0TWludXRlcygpO1xuXG4gICAgICAgIHJldHVybiBkYXRldGltZS5sZWFkaW5nWmVybyhob3VyLCAyKSArICc6JyArXG4gICAgICAgICAgICBkYXRldGltZS5sZWFkaW5nWmVybyhtaW51dGVzLCAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZm9ybWF0IHRvIGxvY2FsIGRhdGVcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUgZGF0ZSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAxOTg4LTA5LTI1VDA5OjAwOjAwKzA5OjAwXG4gICAgICovXG4gICAgJ0xPQ0FMJzogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB2YXIgdGltZVpvbmVPZmZzZXQgPSAtZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpLFxuICAgICAgICAgICAgZGlmZiA9IHRpbWVab25lT2Zmc2V0ID49IDAgPyAnKycgOiAnLScsXG4gICAgICAgICAgICBwYWQgPSBmdW5jdGlvbihudW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZXRpbWUubGVhZGluZ1plcm8obnVtLCAyKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKSBcbiAgICAgICAgICAgICsgJy0nICsgcGFkKGRhdGUuZ2V0TW9udGgoKSArIDEpXG4gICAgICAgICAgICArICctJyArIHBhZChkYXRlLmdldERhdGUoKSlcbiAgICAgICAgICAgICsgJ1QnICsgcGFkKGRhdGUuZ2V0SG91cnMoKSlcbiAgICAgICAgICAgICsgJzonICsgcGFkKGRhdGUuZ2V0TWludXRlcygpKSBcbiAgICAgICAgICAgICsgJzonICsgcGFkKGRhdGUuZ2V0U2Vjb25kcygpKSBcbiAgICAgICAgICAgICsgZGlmZiArIHBhZCh0aW1lWm9uZU9mZnNldCAvIDYwKSBcbiAgICAgICAgICAgICsgJzonICsgcGFkKHRpbWVab25lT2Zmc2V0ICUgNjApO1xuICAgIH1cbn07XG5cbmRhdGV0aW1lID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9uZSBkYXkuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBNSUxMSVNFQ09ORFNfUEVSX0RBWTogODY0MDAwMDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvbmUgaG91ci5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIE1JTExJU0VDT05EU19QRVJfSE9VUjogMzYwMDAwMCxcblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnQgbWlsbGlzZWNvbmRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSB0eXBlIG9mIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgLSBpdGVyYXRlZSBmdW5jdGlvbiB0byB1c2UgcmVkdWNlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGNvbnZlcnRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBfY29udk1pbGxpc2Vjb25kczogZnVuY3Rpb24odHlwZSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBjb252ID0gWzYwLCA2MCwgMTAwMF0sXG4gICAgICAgICAgICBpbmRleCA9IHtcbiAgICAgICAgICAgICAgICBob3VyOiAwLFxuICAgICAgICAgICAgICAgIG1pbnV0ZXM6IDEsXG4gICAgICAgICAgICAgICAgc2Vjb25kczogMlxuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAoISh0eXBlIGluIGluZGV4KSB8fCBnbG9iYWwuaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXRpbC5yZWR1Y2UoW3ZhbHVlXS5jb25jYXQoY29udi5zbGljZShpbmRleFt0eXBlXSkpLCBpdGVyYXRlZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgbWlsbGlzZWNvbmRzIHZhbHVlIHRvIG90aGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge3R5cGV9IHR5cGUgY29udmVydCB0byB0eXBlIHdhbnQgdG8uIHN1cHBvcnQgXCJob3VyXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIiBvbmx5LlxuICAgICAqIEBwYXJhbSB7dmFsdWV9IHZhbHVlIC0gdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBjb252ZXJ0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgbWlsbGlzZWNvbmRzVG86IGZ1bmN0aW9uKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IG1lbW8ubWlsbGlzZWNvbmRzVG8sXG4gICAgICAgICAgICBrZXkgPSB0eXBlICsgdmFsdWU7XG5cbiAgICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FjaGVba2V5XSA9IGRhdGV0aW1lLl9jb252TWlsbGlzZWNvbmRzKHR5cGUsIHZhbHVlLCBmdW5jdGlvbihtZW1vLCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gbWVtbyAvIHY7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjYWNoZVtrZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHZhbHVlIHRvIG1pbGxpc2Vjb25kc1xuICAgICAqIEBwYXJhbSB7dHlwZX0gdHlwZSAtIHR5cGUgb2Ygc3VwcGxpZWQgdmFsdWUuIHN1cHBvcnQgXCJob3VyXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIiBvbmx5LlxuICAgICAqIEBwYXJhbSB7dmFsdWV9IHZhbHVlIC0gdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBjb252ZXJ0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgbWlsbGlzZWNvbmRzRnJvbTogZnVuY3Rpb24odHlwZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gbWVtby5taWxsaXNlY29uZHNGcm9tLFxuICAgICAgICAgICAga2V5ID0gdHlwZSArIHZhbHVlO1xuXG4gICAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhY2hlW2tleV0gPSBkYXRldGltZS5fY29udk1pbGxpc2Vjb25kcyh0eXBlLCB2YWx1ZSwgZnVuY3Rpb24obWVtbywgdikge1xuICAgICAgICAgICAgcmV0dXJuIG1lbW8gKiB2O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2FjaGVba2V5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBkYXRlIGFycmF5IGZyb20gc3VwcGxpZWQgcGFyYW10ZXJzLlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gc3RhcnQgU3RhcnQgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0RhdGV9IGVuZCBFbmQgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB1c2UgaW5jcmVtZW50LlxuICAgICAqIEByZXR1cm5zIHthcnJheX0gRGF0ZSBhcnJheS5cbiAgICAgKi9cbiAgICByYW5nZTogZnVuY3Rpb24oc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgICB2YXIgY3Vyc29yID0gbmV3IERhdGUoc3RhcnQuZ2V0VGltZSgpKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIHdoaWxlIChjdXJzb3IgPD0gZW5kKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXJzb3IpO1xuICAgICAgICAgICAgY3Vyc29yID0gbmV3IERhdGUoY3Vyc29yLmdldFRpbWUoKSArIHN0ZXApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xvbmUgc3VwcGxpZWQgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUgZGF0ZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0RhdGV9IENsb25lZCBkYXRlIG9iamVjdFxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmUgdHdvIGRhdGVzLlxuICAgICAqXG4gICAgICogd2hlbiBmaXJzdCBkYXRlIGlzIGxhdGVzdCB0aGVuIHNlY29uZHMgdGhlbiByZXR1cm4gLTEuXG4gICAgICpcbiAgICAgKiByZXR1cm4gKzEgcmV2ZXJzZSwgYW5kIHJldHVybiAwIGlzIHNhbWUuXG4gICAgICogQHBhcmFtIHtEYXRlfSBkMSBEYXRlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZDIgRGF0ZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSByZXN1bHQgb2YgY29tcGFyZVxuICAgICAqL1xuICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGQxLCBkMikge1xuICAgICAgICB2YXIgX2QxID0gZDEuZ2V0VGltZSgpLFxuICAgICAgICAgICAgX2QyID0gZDIuZ2V0VGltZSgpO1xuXG4gICAgICAgIGlmIChfZDEgPCBfZDIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChfZDEgPiBfZDIpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBzdXBwbGllZCBwYXJhbWV0ZXIgaXMgdmFsaWQgZGF0ZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsqfSBkIE9iamVjdCB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJuIHRydWUgd2hlbiBwYXJhbWV0ZXIgaXMgdmFsaWQgZGF0ZSBvYmplY3QuXG4gICAgICovXG4gICAgaXNWYWxpZDogZnVuY3Rpb24oZCkge1xuICAgICAgICBpZiAob3B0LmNhbGwoZCkgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgICAgICAgICAgcmV0dXJuICF3aW5kb3cuaXNOYU4oZC5nZXRUaW1lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBub24gbG9jYWwgZGF0ZSB0byBVVEMgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0RhdGV9IGQgRGF0ZSB0byBjb252ZXJ0IFVUQy5cbiAgICAgKiBAcmV0dXJucyB7RGF0ZX0gVGhlIFVUQyBEYXRlLlxuICAgICAqL1xuICAgIHRvVVRDOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHZhciBsID0gZC5nZXRUaW1lKCksXG4gICAgICAgICAgICBvZmZzZXQgPSBkYXRldGltZS5taWxsaXNlY29uZHNGcm9tKCdtaW51dGVzJywgbmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpKTtcblxuICAgICAgICByZXR1cm4gbmV3IERhdGUobCArIG9mZnNldCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHBhZCBsZWZ0IHplcm8gY2hhcmFjdGVycy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIG51bWJlciB2YWx1ZSB0byBwYWQgemVyby5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIHBhZCBsZW5ndGggdG8gd2FudC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwYWRkZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGxlYWRpbmdaZXJvOiBmdW5jdGlvbihudW1iZXIsIGxlbmd0aCkge1xuICAgICAgICB2YXIgemVybyA9ICcnLFxuICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgaWYgKChudW1iZXIgKyAnJykubGVuZ3RoID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJyc7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaSA8IChsZW5ndGggLSAxKTsgaSArPSAxKSB7XG4gICAgICAgICAgICB6ZXJvICs9ICcwJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoemVybyArIG51bWJlcikuc2xpY2UobGVuZ3RoICogLTEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGRhdGUgc3RyaW5nIHRvIGRhdGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogT25seSBsaXN0ZWQgYmVsb3cgZm9ybWF0cyBhdmFsaWFibGUuXG4gICAgICpcbiAgICAgKiAtIFlZWVlNTUREXG4gICAgICogLSBZWVlZL01NL0REXG4gICAgICogLSBZWVlZLU1NLUREXG4gICAgICogLSBZWVlZL01NL0REIEhIOm1tOlNTXG4gICAgICogLSBZWVlZLU1NLUREIEhIOm1tOlNTXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIEZvcm1hdHRlZCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmaXhNb250aD0tMV0gLSBudW1iZXIgZm9yIGZpeCBtb250aCBjYWxjdWxhdGluZy5cbiAgICAgKiBAcmV0dXJucyB7KERhdGV8Ym9vbGVhbil9IENvbnZlcnRlZCBEYXRlIG9iamVjdC4gd2hlbiBzdXBwbGllZCBzdHIgaXMgbm90IGF2YWlsYWJsZSB0aGVuIHJldHVybiBmYWxzZS5cbiAgICAgKi9cbiAgICBwYXJzZTogZnVuY3Rpb24oc3RyLCBmaXhNb250aCkge1xuICAgICAgICB2YXIgc2VwYXJhdG9yLFxuICAgICAgICAgICAgbWF0Y2hlcyA9IHN0ci5tYXRjaChkYXRlRm9ybWF0UngpLFxuICAgICAgICAgICAgeW1kLFxuICAgICAgICAgICAgaG1zO1xuXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGZpeE1vbnRoKSkge1xuICAgICAgICAgICAgZml4TW9udGggPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPiA4KSB7XG4gICAgICAgICAgICAvLyBZWVlZL01NL0REXG4gICAgICAgICAgICAvLyBZWVlZLU1NLUREXG4gICAgICAgICAgICAvLyBZWVlZL01NL0REIEhIOm1tOlNTXG4gICAgICAgICAgICAvLyBZWVlZLU1NLUREIEhIOm1tOlNTXG4gICAgICAgICAgICBzZXBhcmF0b3IgPSB+c3RyLmluZGV4T2YoJy8nKSA/ICcvJyA6ICctJztcbiAgICAgICAgICAgIG1hdGNoZXMgPSBtYXRjaGVzLnNwbGljZSgxKTtcblxuICAgICAgICAgICAgeW1kID0gbWF0Y2hlc1swXS5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICAgICAgaG1zID0gbWF0Y2hlc1sxXSA/IG1hdGNoZXNbMV0uc3BsaXQoJzonKSA6IFswLCAwLCAwXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFlZWVlNTUREXG4gICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlc1swXTtcbiAgICAgICAgICAgIHltZCA9IFttYXRjaGVzLnN1YnN0cigwLCA0KSwgbWF0Y2hlcy5zdWJzdHIoNCwgMiksIG1hdGNoZXMuc3Vic3RyKDYsIDIpXTtcbiAgICAgICAgICAgIGhtcyA9IFswLCAwLCAwXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgreW1kWzBdLCAreW1kWzFdICsgZml4TW9udGgsICt5bWRbMl0sICtobXNbMF0sICtobXNbMV0sICtobXNbMl0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gZGF0ZSBvYmplY3QgZnJvbSBEYXRlLlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBkYXRlXG4gICAgICogQHJldHVybnMge29iamVjdH0gRGF0ZSBvYmplY3QuXG4gICAgICovXG4gICAgcmF3OiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5OiBkYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICBNOiBkYXRlLmdldE1vbnRoKCksXG4gICAgICAgICAgICBkOiBkYXRlLmdldERhdGUoKSxcbiAgICAgICAgICAgIGg6IGRhdGUuZ2V0SG91cnMoKSxcbiAgICAgICAgICAgIG06IGRhdGUuZ2V0TWludXRlcygpLFxuICAgICAgICAgICAgczogZGF0ZS5nZXRTZWNvbmRzKCksXG4gICAgICAgICAgICBtczogZGF0ZS5nZXRNaWxsaXNlY29uZHMoKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gMDA6MDA6MDAgc3VwcGxpZWQgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUgZGF0ZS5cbiAgICAgKiBAcmV0dXJucyB7RGF0ZX0gc3RhcnQgZGF0ZS5cbiAgICAgKi9cbiAgICBzdGFydDogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcbiAgICAgICAgZC5zZXRIb3VycygwLCAwLCAwLCAwKTtcblxuICAgICAgICByZXR1cm4gZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIDIzOjU5OjU5IHN1cHBsaWVkIGRhdGUuXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlIGRhdGUuXG4gICAgICogQHJldHVybnMge0RhdGV9IGVuZCBkYXRlLlxuICAgICAqL1xuICAgIGVuZDogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcbiAgICAgICAgZC5zZXRIb3VycygyMywgNTksIDU5LCAwKTtcblxuICAgICAgICByZXR1cm4gZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGZvcm1hdHRlZCBzdHJpbmcgYXMgYmFzaXMgb2Ygc3VwcGxpZWQgc3RyaW5nLlxuICAgICAqXG4gICAgICogU3VwcG9ydGVkIFRva2VuIExpc3RzLlxuICAgICAqXG4gICAgICogLSBZWVlZID0+IDE5ODhcbiAgICAgKiAtIE1NID0+IDAxIH4gMTJcbiAgICAgKiAtIEREID0+IDAxIH4gMzFcbiAgICAgKiAtIFlZWVlNTUREID0+IDE5ODgwOTI1XG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlIFN0cmluZyB3YW50IHRvIGZvcm1hdHRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IGZvcm1hdCBzdHIuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gIEZvcm1hdHRlZCBkYXRlIHN0cmluZy5cbiAgICAgKi9cbiAgICBmb3JtYXQ6IGZ1bmN0aW9uKGRhdGUsIGZvcm1hdCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZm9ybWF0O1xuICAgICAgICB1dGlsLmZvckVhY2hPd25Qcm9wZXJ0aWVzKHRva2VuRnVuYywgZnVuY3Rpb24oY29udmVydGVyLCB0b2tlbikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UodG9rZW4sIGNvbnZlcnRlcihkYXRlKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiAyLWRpbWVuc2lvbmFsIGFycmF5IG1vbnRoIGNhbGVuZGFyXG4gICAgICpcbiAgICAgKiBkYXRlcyB0aGF0IGRpZmZlcmVudCBtb250aCB3aXRoIGdpdmVuIGRhdGUgYXJlIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7RGF0ZX0gbW9udGggLSBkYXRlIHdhbnQgdG8gY2FsY3VsYXRlIG1vbnRoIGNhbGVuZGFyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydERheU9mV2Vlaz0wXSAtIHN0YXJ0IGRheSBvZiB3ZWVrXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2l0ZXJhdGVlXSAtIGl0ZXJhdGVlIGZvciBjdXN0b21pemluZyBjYWxlbmRhciBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZ1tdPn0gY2FsZW5kYXIgMmQgYXJyYXlcbiAgICAgKi9cbiAgICBhcnIyZENhbGVuZGFyOiBmdW5jdGlvbihtb250aCwgc3RhcnREYXlPZldlZWssIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciB3ZWVrQXJyLFxuICAgICAgICAgICAgc3RhcnRzLCBlbmRzLFxuICAgICAgICAgICAgc3RhcnRJbmRleCwgZW5kSW5kZXgsXG4gICAgICAgICAgICBhZnRlckRhdGVzLFxuICAgICAgICAgICAgY3Vyc29yLCB3ZWVrLFxuICAgICAgICAgICAgY2FsZW5kYXIgPSBbXTtcblxuICAgICAgICBzdGFydHMgPSBuZXcgRGF0ZShuZXcgRGF0ZSgrbW9udGgpLnNldERhdGUoMSkpO1xuICAgICAgICBlbmRzID0gbmV3IERhdGUobmV3IERhdGUoK3N0YXJ0cykuc2V0TW9udGgoc3RhcnRzLmdldE1vbnRoKCkgKyAxKSk7XG4gICAgICAgIGVuZHMgPSBuZXcgRGF0ZShuZXcgRGF0ZSgrZW5kcykuc2V0RGF0ZShlbmRzLmdldERhdGUoKSAtIDEpKTtcblxuICAgICAgICAvLyBjcmVhdGUgZGF5IG51bWJlciBhcnJheSBieSBzdGFydERheU9mV2VlayBudW1iZXJcbiAgICAgICAgLy8gNCAtPiBbNCwgNSwgNiwgMCwgMSwgMiwgM11cbiAgICAgICAgLy8gMiAtPiBbMiwgMywgNCwgNSwgNiwgMCwgMV1cbiAgICAgICAgd2Vla0FyciA9IHV0aWwucmFuZ2Uoc3RhcnREYXlPZldlZWssIDcpLmNvbmNhdCh1dGlsLnJhbmdlKDcpKS5zbGljZSgwLCA3KTtcbiAgICAgICAgc3RhcnRJbmRleCA9IHV0aWwuaW5BcnJheShzdGFydHMuZ2V0RGF5KCksIHdlZWtBcnIpO1xuICAgICAgICBlbmRJbmRleCA9IHV0aWwuaW5BcnJheShlbmRzLmdldERheSgpLCB3ZWVrQXJyKTtcbiAgICAgICAgLy8gZnJlZSBkYXRlcyBhZnRlciBsYXN0IGRhdGUgb2YgdGhpcyBtb250aFxuICAgICAgICBhZnRlckRhdGVzID0gNyAtIChlbmRJbmRleCArIDEpO1xuXG4gICAgICAgIGN1cnNvciA9IG5ldyBEYXRlKG5ldyBEYXRlKCtzdGFydHMpLnNldERhdGUoc3RhcnRzLmdldERhdGUoKSAtIHN0YXJ0SW5kZXgpKTtcbiAgICAgICAgLy8gaXRlcmF0ZWUgYWxsIGRhdGVzIHRvIHJlbmRlclxuICAgICAgICB1dGlsLmZvckVhY2hBcnJheSh1dGlsLnJhbmdlKHN0YXJ0SW5kZXggKyBlbmRzLmdldERhdGUoKSArIGFmdGVyRGF0ZXMpLCBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZTtcblxuICAgICAgICAgICAgaWYgKCEoaSAlIDcpKSB7XG4gICAgICAgICAgICAgICAgLy8gZ3JvdXAgZWFjaCBkYXRlIGJ5IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrID0gY2FsZW5kYXJbaSAvIDddID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgrY3Vyc29yKTtcbiAgICAgICAgICAgIGRhdGUgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKGRhdGUpIDogZGF0ZTtcbiAgICAgICAgICAgIHdlZWsucHVzaChkYXRlKTtcblxuICAgICAgICAgICAgLy8gYWRkIGRhdGVcbiAgICAgICAgICAgIGN1cnNvciA9IG5ldyBEYXRlKGN1cnNvci5zZXREYXRlKGN1cnNvci5nZXREYXRlKCkgKyAxKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjYWxlbmRhcjtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRhdGV0aW1lO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlydHkgZmxhZ2dpbmcgbW9kdWxlIGZvciBvYmplY3RzLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGNvbW1vbiA9IG5lLnV0aWwsXG4gICAgZXhpc3R5ID0gY29tbW9uLmlzRXhpc3R5LFxuICAgIHBpY2sgPSBjb21tb24ucGljayxcbiAgICBpc0Z1bmMgPSBjb21tb24uaXNGdW5jdGlvbjtcblxuLyoqXG4gKiBNaXhpbiBtb2R1bGUgZm9yIGRpcnR5IGZsYWdnaW5nIG9uIHNwZWNpZmljIG9iamVjdHMuXG4gKiBAbWl4aW5cbiAqIEBleGFtcGxlXG4gKiB2YXIgb2JqID0geyBoZWxsbzogJ2dvb2QnLCB0ZXN0OiAnMTIzJyB9O1xuICogZGlydHkubWl4aW4ob2JqKTtcbiAqXG4gKiBvYmouc2V0KCdoZWxsbycsICd3b3JsZCcpO1xuICogb2JqLmlzRGlydHkoKTsgICAgLy8gdHJ1ZVxuICogb2JqLmlzUHJvcENoYW5nZWQoJ2hlbGxvJyk7ICAgIC8vIHRydWVcbiAqIG9iai5pc1Byb3BDaGFuZ2VkKCd0ZXN0Jyk7ICAgIC8vIGZhbHNlXG4gKiBvYmouZGlydHkoZmFsc2UpO1xuICpcbiAqIG9iai5pc0RpcnR5KCk7ICAgIC8vIGZhbHNlXG4gKiBvYmouaXNQcm9wQ2hhbmdlZCgnaGVsbG8nKTsgICAgLy8gZmFsc2VcbiAqL1xudmFyIGRpcnR5ID0ge1xuICAgIC8qKlxuICAgICAqIFNldCBwcm9wZXJ0eSB2YWx1ZSB3aXRoIGRpcnR5IGZsYWdnaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wTmFtZSBQcm9wZXJ0eSBuYW1lLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgUHJvcHJ0eSB2YWx1ZS5cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKHByb3BOYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgb3JpZ2luVmFsdWUgPSB0aGlzW3Byb3BOYW1lXTtcblxuICAgICAgICBpZiAob3JpZ2luVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IHZhbHVlO1xuXG4gICAgICAgIGlmICghdGhpcy5fY2hhbmdlZCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTYXZlIGNoYW5nZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBkaXJ0eVxuICAgICAgICAgICAgICogQG5hbWUgX2NoYW5nZWRcbiAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NoYW5nZWRbcHJvcE5hbWVdID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlydHkgZmxhZ1xuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQG5hbWUgX2RpcnR5XG4gICAgICAgICAqIEBtZW1iZXJvZiBkaXJ0eVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBkaXJ0eSBmbGFnLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBQcm9wZXJ0eSBpcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIGlzRGlydHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kaXJ0eTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGRpcnR5IGZsYWcgbWFudWFsbHkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbdG9EaXJ0eT10cnVlXSBUaGlzIHdpbGwgc2V0IGRpcnR5IGZsYWcgZGlyZWN0bHkuXG4gICAgICovXG4gICAgZGlydHk6IGZ1bmN0aW9uKHRvRGlydHkpIHtcbiAgICAgICAgdG9EaXJ0eSA9IGV4aXN0eSh0b0RpcnR5KSA/IHRvRGlydHkgOiB0cnVlO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICghdG9EaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGlydHkgPSB0b0RpcnR5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgcHJvcGVydHkgc2FmZXR5LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZSBUaGUgbmFtZSBvZiBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBkZWxldGVQcm9wOiBmdW5jdGlvbihwcm9wTmFtZSkge1xuICAgICAgICBkZWxldGUgdGhpc1twcm9wTmFtZV07XG5cbiAgICAgICAgaWYgKHRoaXMuX2NoYW5nZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jaGFuZ2VkW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGUgY2hhbmdlcyB3aXRoIHNwZWNpZmljIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZSBUaGUgbmFtZSBvZiBwcm9wZXJ0eSB5b3Ugd2FudC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgcHJvcGVydHkgY2hhbmdlZD9cbiAgICAgKi9cbiAgICBpc1Byb3BDaGFuZ2VkOiBmdW5jdGlvbihwcm9wTmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2NoYW5nZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VkW3Byb3BOYW1lXSA9PT0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWl4aW4gdG8gc3BlY2lmaWMgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdG8gbWl4IHRoaXMgbW9kdWxlLlxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6dXRpbC9kaXJ0eVxuICAgICAqIEBleGFtcGxlXG4gICAgICogZnVuY3Rpb24gQW5pbWFsKCkge31cbiAgICAgKiBkaXJ0eS5taXhpbihBbmltYWwucHJvdG90eXBlKTtcbiAgICAgKi9cbiAgICBtaXhpbjogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIHZhciBtZXRob2RGaWx0ZXJSID0gLyheX3xtaXhpbnx3cmFwKS87XG5cbiAgICAgICAgY29tbW9uLmZvckVhY2hPd25Qcm9wZXJ0aWVzKGRpcnR5LCBmdW5jdGlvbihvLCBrKSB7XG4gICAgICAgICAgICBpZiAoIW1ldGhvZEZpbHRlclIudGVzdChrKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrXSA9IGRpcnR5W2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV3JhcHBlciBtZXRob2QgZm9yIGRpcnR5IGZsYWdnaW5nLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaW52b2tlIGFmdGVyIGludm9rZWQgc3BlY2lmaWMgbWV0aG9kIHRoYXQgYWRkZWQgYnkgeW91LlxuICAgICAqXG4gICAgICogVGhlIG1ldGhvZCB3YW50IHRvIGFkZCBhcmUgbXVzdCBleGlzdCBiZWZvcmUgYWRkLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgVGFyZ2V0IG9iamVjdCB0byBtZXRob2Qgd3JhcC5cbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0gbWV0aG9kTmFtZVxuICAgICAqICBNZXRob2QgbmFtZSB0byB3cmFwIG9yIG1ldGhvZE5hbWU6IGZsYWcgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbGFnPXRydWVdXG4gICAgICogIHRoaXMgd2lsbCB1c2VkIHRvIGZsYWdnaW5nIGJ5IGRpcnR5IGZsYWdnZXIgYWZ0ZXIgaW52b2tlIHRoZSBtZXRob2RzIGFkZGVkIGJ5IHlvdS5cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOnV0aWwvZGlydHlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGZ1bmN0aW9uIEFuaW1hbChuYW1lKSB7XG4gICAgICogICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICogfVxuICAgICAqIEFuaW1hbC5wcm90b3R5cGUuZ3Jvd2wgPSBqYXNtaW5lLmNyZWF0ZVNweSgnZ3Jvd2wnKTtcbiAgICAgKiBBbmltYWwucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogZGlydHkubWl4aW4oQW5pbWFsLnByb3RvdHlwZSk7XG4gICAgICogLy8gc2luZ2xlXG4gICAgICogZGlydHkud3JhcChBbmltYWwucHJvdG90eXBlLCAnZ3Jvd2wnLCB0cnVlKTtcbiAgICAgKiAvLyBtdWx0aXBsZVxuICAgICAqIGRpcnR5LndyYXAoQW5pbWFwLnByb3RvdHlwZSwge1xuICAgICAqICAgICBncm93bDogdHJ1ZSxcbiAgICAgKiAgICAgdGVzdDogZmFsc2VcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqL1xuICAgIHdyYXA6IGZ1bmN0aW9uKHRhcmdldCwgbWV0aG9kTmFtZSwgZmxhZykge1xuICAgICAgICB2YXIgd3JhcCA9IGRpcnR5LndyYXAsXG4gICAgICAgICAgICBmbjtcblxuICAgICAgICBpZiAoY29tbW9uLmlzT2JqZWN0KG1ldGhvZE5hbWUpKSB7XG4gICAgICAgICAgICBjb21tb24uZm9yRWFjaE93blByb3BlcnRpZXMobWV0aG9kTmFtZSwgZnVuY3Rpb24oZmxhZywgbWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgICAgIHdyYXAodGFyZ2V0LCBtZXRob2ROYW1lLCBmbGFnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZmxhZyA9IGV4aXN0eShmbGFnKSA/IGZsYWcgOiB0cnVlO1xuXG4gICAgICAgIGlmICghdGFyZ2V0Ll93cmFwcGVyKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIE9yaWdpbmFsIG1ldGhvZCB0byB3cmFwLlxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmbGFnVG9TZXQgVGhlIGJvb2xlYW4gdmFsdWUgdG8gdXNpbmcgZGlydHkgZmxhZ2dpbmcuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdCB2YWx1ZSBvZiBvcmlnaW5hbCBtZXRob2QuXG4gICAgICAgICAgICAgKiBAbmFtZSBfd3JhcHBlclxuICAgICAgICAgICAgICogQG1lbWJlcm9mIGRpcnR5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRhcmdldC5fd3JhcHBlciA9IGZ1bmN0aW9uKGZuLCBmbGFnVG9TZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IGZsYWdUb1NldDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleGlzdHkocGljayh0YXJnZXQsIG1ldGhvZE5hbWUpKSAmJlxuICAgICAgICAgICAgaXNGdW5jKHRhcmdldFttZXRob2ROYW1lXSkgJiZcbiAgICAgICAgICAgICFleGlzdHkocGljayh0YXJnZXQsIG1ldGhvZE5hbWUsICdfd3JhcHBlZCcpKSkge1xuICAgICAgICAgICAgZm4gPSB0YXJnZXRbbWV0aG9kTmFtZV07XG4gICAgICAgICAgICB0YXJnZXRbbWV0aG9kTmFtZV0gPSB0YXJnZXQuX3dyYXBwZXIoZm4sIGZsYWcpO1xuICAgICAgICAgICAgdGFyZ2V0W21ldGhvZE5hbWVdLl93cmFwcGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZGlydHk7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBVdGlsaXR5IG1vZHVsZSBmb3IgaGFuZGxpbmcgRE9NIGV2ZW50cy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWwsXG4gICAgYnJvd3NlciA9IHV0aWwuYnJvd3NlcixcbiAgICBldmVudEtleSA9ICdfZXZ0JyxcbiAgICBEUkFHID0ge1xuICAgICAgICBTVEFSVDogWyd0b3VjaHN0YXJ0JywgJ21vdXNlZG93biddLFxuICAgICAgICBFTkQ6IHtcbiAgICAgICAgICAgIG1vdXNlZG93bjogJ21vdXNldXAnLFxuICAgICAgICAgICAgdG91Y2hzdGFydDogJ3RvdWNoZW5kJyxcbiAgICAgICAgICAgIHBvaW50ZXJkb3duOiAndG91Y2hlbmQnLFxuICAgICAgICAgICAgTVNQb2ludGVyRG93bjogJ3RvdWNoZW5kJ1xuICAgICAgICB9LFxuICAgICAgICBNT1ZFOiB7XG4gICAgICAgICAgICBtb3VzZWRvd246ICdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgdG91Y2hzdGFydDogJ3RvdWNobW92ZScsXG4gICAgICAgICAgICBwb2ludGVyZG93bjogJ3RvdWNobW92ZScsXG4gICAgICAgICAgICBNU1BvaW50ZXJEb3duOiAndG91Y2htb3ZlJ1xuICAgICAgICB9XG4gICAgfTtcblxudmFyIGRvbWV2ZW50ID0ge1xuICAgIC8qKlxuICAgICAqIEJpbmQgZG9tIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvYmogSFRNTEVsZW1lbnQgdG8gYmluZCBldmVudHMuXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IHR5cGVzIFNwYWNlIHNwbGl0dGVkIGV2ZW50cyBuYW1lcyBvciBldmVudE5hbWU6aGFuZGxlciBvYmplY3QuXG4gICAgICogQHBhcmFtIHsqfSBmbiBoYW5kbGVyIGZ1bmN0aW9uIG9yIGNvbnRleHQgZm9yIGhhbmRsZXIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdIGNvbnRleHQgb2JqZWN0IGZvciBoYW5kbGVyIG1ldGhvZC5cbiAgICAgKi9cbiAgICBvbjogZnVuY3Rpb24ob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcodHlwZXMpKSB7XG4gICAgICAgICAgICB1dGlsLmZvckVhY2godHlwZXMuc3BsaXQoJyAnKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgICAgIGRvbWV2ZW50Ll9vbihvYmosIHR5cGUsIGZuLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1dGlsLmZvckVhY2hPd25Qcm9wZXJ0aWVzKHR5cGVzLCBmdW5jdGlvbihoYW5kbGVyLCB0eXBlKSB7XG4gICAgICAgICAgICBkb21ldmVudC5fb24ob2JqLCB0eXBlLCBoYW5kbGVyLCBmbik7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBET00gZXZlbnQgYmluZGluZy5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvYmogSFRNTEVsZW1lbnQgdG8gYmluZCBldmVudHMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgZXZlbnRzLlxuICAgICAqIEBwYXJhbSB7Kn0gZm4gaGFuZGxlciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdIGNvbnRleHQgb2JqZWN0IGZvciBoYW5kbGVyIG1ldGhvZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbjogZnVuY3Rpb24ob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xuICAgICAgICB2YXIgaWQsXG4gICAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgICAgb3JpZ2luSGFuZGxlcjtcblxuICAgICAgICBpZCA9IHR5cGUgKyB1dGlsLnN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgdXRpbC5zdGFtcChjb250ZXh0KSA6ICcnKTtcblxuICAgICAgICBpZiAob2JqW2V2ZW50S2V5XSAmJiBvYmpbZXZlbnRLZXldW2lkXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY29udGV4dCB8fCBvYmosIGUgfHwgd2luZG93LmV2ZW50KTtcbiAgICAgICAgfTtcblxuICAgICAgICBvcmlnaW5IYW5kbGVyID0gaGFuZGxlcjtcblxuICAgICAgICBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtb3VzZWVudGVyJyB8fCB0eXBlID09PSAnbW91c2VsZWF2ZScpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9tZXZlbnQuX2NoZWNrTW91c2Uob2JqLCBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbkhhbmRsZXIoZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBvYmouYWRkRXZlbnRMaXN0ZW5lcigodHlwZSA9PT0gJ21vdXNlZW50ZXInKSA/XG4gICAgICAgICAgICAgICAgICAgICdtb3VzZW92ZXInIDogJ21vdXNlb3V0JywgaGFuZGxlciwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoJ2F0dGFjaEV2ZW50JyBpbiBvYmopIHtcbiAgICAgICAgICAgIG9iai5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICBvYmpbZXZlbnRLZXldID0gb2JqW2V2ZW50S2V5XSB8fCB7fTtcbiAgICAgICAgb2JqW2V2ZW50S2V5XVtpZF0gPSBoYW5kbGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmJpbmQgRE9NIEV2ZW50IGhhbmRsZXIuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb2JqIEhUTUxFbGVtZW50IHRvIHVuYmluZC5cbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0gdHlwZXMgU3BhY2Ugc3BsaXR0ZWQgZXZlbnRzIG5hbWVzIG9yIGV2ZW50TmFtZTpoYW5kbGVyIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyp9IGZuIGhhbmRsZXIgZnVuY3Rpb24gb3IgY29udGV4dCBmb3IgaGFuZGxlciBtZXRob2QuXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF0gY29udGV4dCBvYmplY3QgZm9yIGhhbmRsZXIgbWV0aG9kLlxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24ob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcodHlwZXMpKSB7XG4gICAgICAgICAgICB1dGlsLmZvckVhY2godHlwZXMuc3BsaXQoJyAnKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgICAgIGRvbWV2ZW50Ll9vZmYob2JqLCB0eXBlLCBmbiwgY29udGV4dCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXRpbC5mb3JFYWNoT3duUHJvcGVydGllcyh0eXBlcywgZnVuY3Rpb24oaGFuZGxlciwgdHlwZSkge1xuICAgICAgICAgICAgZG9tZXZlbnQuX29mZihvYmosIHR5cGUsIGhhbmRsZXIsIGZuKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVuYmluZCBET00gZXZlbnQgaGFuZGxlci5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvYmogSFRNTEVsZW1lbnQgdG8gdW5iaW5kLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIGV2ZW50IHRvIHVuYmluZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGZuIEV2ZW50IGhhbmRsZXIgdGhhdCBzdXBwbGllZCB3aGVuIGJpbmRpbmcuXG4gICAgICogQHBhcmFtIHsqfSBjb250ZXh0IGNvbnRleHQgb2JqZWN0IHRoYXQgc3VwcGxpZWQgd2hlbiBiaW5kaW5nLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29mZjogZnVuY3Rpb24ob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xuICAgICAgICB2YXIgaWQgPSB0eXBlICsgdXRpbC5zdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIHV0aWwuc3RhbXAoY29udGV4dCkgOiAnJyksXG4gICAgICAgICAgICBoYW5kbGVyID0gb2JqW2V2ZW50S2V5XSAmJiBvYmpbZXZlbnRLZXldW2lkXTtcblxuICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ21vdXNlZW50ZXInIHx8IHR5cGUgPT09ICdtb3VzZWxlYXZlJykge1xuICAgICAgICAgICAgICAgIG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCh0eXBlID09PSAnbW91c2VlbnRlcicpID9cbiAgICAgICAgICAgICAgICAgICAgJ21vdXNlb3ZlcicgOiAnbW91c2VvdXQnLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgaGFuZGxlciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgnZGV0YWNoRXZlbnQnIGluIG9iaikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvYmouZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge30gICAgLy9lc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgb2JqW2V2ZW50S2V5XVtpZF07XG5cbiAgICAgICAgaWYgKHV0aWwua2V5cyhvYmpbZXZlbnRLZXldKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBvYmpbZXZlbnRLZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCaW5kIERPTSBldmVudC4gdGhpcyBldmVudCB3aWxsIHVuYmluZCBhZnRlciBpbnZva2VzLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9iaiBIVE1MRWxlbWVudCB0byBiaW5kIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0gdHlwZXMgU3BhY2Ugc3BsaXR0ZWQgZXZlbnRzIG5hbWVzIG9yIGV2ZW50TmFtZTpoYW5kbGVyIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyp9IGZuIGhhbmRsZXIgZnVuY3Rpb24gb3IgY29udGV4dCBmb3IgaGFuZGxlciBtZXRob2QuXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF0gY29udGV4dCBvYmplY3QgZm9yIGhhbmRsZXIgbWV0aG9kLlxuICAgICAqL1xuICAgIG9uY2U6IGZ1bmN0aW9uKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICBpZiAodXRpbC5pc09iamVjdCh0eXBlcykpIHtcbiAgICAgICAgICAgIHV0aWwuZm9yRWFjaE93blByb3BlcnRpZXModHlwZXMsIGZ1bmN0aW9uKGhhbmRsZXIsIHR5cGUpIHtcbiAgICAgICAgICAgICAgICBkb21ldmVudC5vbmNlKG9iaiwgdHlwZSwgaGFuZGxlciwgZm4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbmNlSGFuZGxlcigpIHtcbiAgICAgICAgICAgIGZuLmFwcGx5KGNvbnRleHQgfHwgb2JqLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhhdC5fb2ZmKG9iaiwgdHlwZXMsIG9uY2VIYW5kbGVyLCBjb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvbWV2ZW50Lm9uKG9iaiwgdHlwZXMsIG9uY2VIYW5kbGVyLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VsIGV2ZW50IGJ1YmJsaW5nLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VsIGJyb3dzZXIgZGVmYXVsdCBhY3Rpb25zLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0LlxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3ludGF0aWMgc3VnYXIgb2Ygc3RvcFByb3BhZ2F0aW9uIGFuZCBwcmV2ZW50RGVmYXVsdFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZG9tZXZlbnQucHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIGRvbWV2ZW50LnN0b3BQcm9wYWdhdGlvbihlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcCBzY3JvbGwgZXZlbnRzLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEhUTUwgZWxlbWVudCB0byBwcmV2ZW50IHNjcm9sbC5cbiAgICAgKi9cbiAgICBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb246IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGRvbWV2ZW50Lm9uKGVsLCAnbW91c2V3aGVlbCBNb3pNb3VzZVBpeGVsU2Nyb2xsJywgZG9tZXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcCBhbGwgZXZlbnRzIHJlbGF0ZWQgd2l0aCBjbGljay5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBIVE1MIGVsZW1lbnQgdG8gcHJldmVudCBhbGwgZXZlbnQgcmVsYXRlZCB3aXRoIGNsaWNrLlxuICAgICAqL1xuICAgIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uOiBmdW5jdGlvbihlbCkge1xuICAgICAgICBkb21ldmVudC5vbihlbCwgRFJBRy5TVEFSVC5qb2luKCcgJykgKyAnIGNsaWNrIGRibGNsaWNrJywgZG9tZXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IG1vdXNlIHBvc2l0aW9uIGZyb20gbW91c2UgZXZlbnQuXG4gICAgICpcbiAgICAgKiBJZiBzdXBwbGllZCByZWxhdHZlRWxlbWVudCBwYXJhbWV0ZXIgdGhlbiByZXR1cm4gcmVsYXRpdmUgcG9zaXRpb24gYmFzZWQgb24gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBtb3VzZUV2ZW50IE1vdXNlIGV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlbGF0aXZlRWxlbWVudCBIVE1MIGVsZW1lbnQgdGhhdCBjYWxjdWxhdGUgcmVsYXRpdmUgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBtb3VzZSBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBnZXRNb3VzZVBvc2l0aW9uOiBmdW5jdGlvbihtb3VzZUV2ZW50LCByZWxhdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHJlY3Q7XG5cbiAgICAgICAgaWYgKCFyZWxhdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbbW91c2VFdmVudC5jbGllbnRYLCBtb3VzZUV2ZW50LmNsaWVudFldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdCA9IHJlbGF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbW91c2VFdmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gcmVsYXRpdmVFbGVtZW50LmNsaWVudExlZnQsXG4gICAgICAgICAgICBtb3VzZUV2ZW50LmNsaWVudFkgLSByZWN0LnRvcCAtIHJlbGF0aXZlRWxlbWVudC5jbGllbnRUb3BcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIG1vdXNlIHdoZWVsIGV2ZW50IHRoYXQgZGlmZmVyZW50IGVhY2ggYnJvd3NlcnMuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIE1vdXNlIHdoZWVsIGV2ZW50LlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IGRlbHRhXG4gICAgICovXG4gICAgZ2V0V2hlZWxEZWx0YTogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZGVsdGEgPSAwO1xuXG4gICAgICAgIGlmIChlLndoZWVsRGVsdGEpIHtcbiAgICAgICAgICAgIGRlbHRhID0gZS53aGVlbERlbHRhIC8gMTIwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUuZGV0YWlsKSB7XG4gICAgICAgICAgICBkZWx0YSA9IC1lLmRldGFpbCAvIDM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVsdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHByZXZlbnQgZmlyaW5nIG1vdXNlbGVhdmUgZXZlbnQgd2hlbiBtb3VzZSBlbnRlcmVkIGNoaWxkIGVsZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEhUTUwgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSBNb3VzZSBldmVudFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBsZWF2ZT9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGVja01vdXNlOiBmdW5jdGlvbihlbCwgZSkge1xuICAgICAgICB2YXIgcmVsYXRlZCA9IGUucmVsYXRlZFRhcmdldDtcblxuICAgICAgICBpZiAoIXJlbGF0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlIChyZWxhdGVkICYmIChyZWxhdGVkICE9PSBlbCkpIHtcbiAgICAgICAgICAgICAgICByZWxhdGVkID0gcmVsYXRlZC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAocmVsYXRlZCAhPT0gZWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIHNwZWNpZmljIGV2ZW50cyB0byBodG1sIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb2JqIEhUTUxFbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZSBuYW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtldmVudERhdGFdIEV2ZW50IGRhdGFcbiAgICAgKi9cbiAgICB0cmlnZ2VyOiBmdW5jdGlvbihvYmosIHR5cGUsIGV2ZW50RGF0YSkge1xuICAgICAgICB2YXIgck1vdXNlRXZlbnQgPSAvKG1vdXNlfGNsaWNrKS87XG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGV2ZW50RGF0YSkgJiYgck1vdXNlRXZlbnQuZXhlYyh0eXBlKSkge1xuICAgICAgICAgICAgZXZlbnREYXRhID0gZG9tZXZlbnQubW91c2VFdmVudCh0eXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmouZGlzcGF0Y2hFdmVudCkge1xuICAgICAgICAgICAgb2JqLmRpc3BhdGNoRXZlbnQoZXZlbnREYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmouZmlyZUV2ZW50KSB7XG4gICAgICAgICAgICBvYmouZmlyZUV2ZW50KCdvbicgKyB0eXBlLCBldmVudERhdGEpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB2aXJ0dWFsIG1vdXNlIGV2ZW50LlxuICAgICAqXG4gICAgICogVGVzdGVkIGF0XG4gICAgICpcbiAgICAgKiAtIElFNyB+IElFMTFcbiAgICAgKiAtIENocm9tZVxuICAgICAqIC0gRmlyZWZveFxuICAgICAqIC0gU2FmYXJpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZXZlbnRPYmpdIEV2ZW50IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7TW91c2VFdmVudH0gVmlydHVhbCBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBtb3VzZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBldmVudE9iaikge1xuICAgICAgICB2YXIgZXZ0LFxuICAgICAgICAgICAgZTtcblxuICAgICAgICBlID0gdXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6ICh0eXBlICE9PSAnbW91c2Vtb3ZlJyksXG4gICAgICAgICAgICB2aWV3OiB3aW5kb3csXG4gICAgICAgICAgICB3aGVlbERlbHRhOiAwLFxuICAgICAgICAgICAgZGV0YWlsOiAwLFxuICAgICAgICAgICAgc2NyZWVuWDogMCxcbiAgICAgICAgICAgIHNjcmVlblk6IDAsXG4gICAgICAgICAgICBjbGllbnRYOiAwLFxuICAgICAgICAgICAgY2xpZW50WTogMCxcbiAgICAgICAgICAgIGN0cmxLZXk6IGZhbHNlLFxuICAgICAgICAgICAgYWx0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgIG1ldGFLZXk6IGZhbHNlLFxuICAgICAgICAgICAgYnV0dG9uOiAwLFxuICAgICAgICAgICAgcmVsYXRlZFRhcmdldDogdW5kZWZpbmVkICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIH0sIGV2ZW50T2JqKTtcblxuICAgICAgICAvLyBwcmV2ZW50IHRocm93IGVycm9yIHdoZW4gaW5zZXJ0aW5nIHdoZWVsRGVsdGEgcHJvcGVydHkgdG8gbW91c2UgZXZlbnQgb24gYmVsb3cgSUU4XG4gICAgICAgIGlmIChicm93c2VyLm1zaWUgJiYgYnJvd3Nlci52ZXJzaW9uIDwgOSkge1xuICAgICAgICAgICAgZGVsZXRlIGUud2hlZWxEZWx0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuICAgICAgICAgICAgZXZ0LmluaXRNb3VzZUV2ZW50KHR5cGUsXG4gICAgICAgICAgICAgICAgZS5idWJibGVzLCBlLmNhbmNlbGFibGUsIGUudmlldywgZS5kZXRhaWwsXG4gICAgICAgICAgICAgICAgZS5zY3JlZW5YLCBlLnNjcmVlblksIGUuY2xpZW50WCwgZS5jbGllbnRZLFxuICAgICAgICAgICAgICAgIGUuY3RybEtleSwgZS5hbHRLZXksIGUuc2hpZnRLZXksIGUubWV0YUtleSxcbiAgICAgICAgICAgICAgICBlLmJ1dHRvbiwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KSB7XG4gICAgICAgICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpO1xuXG4gICAgICAgICAgICB1dGlsLmZvckVhY2goZSwgZnVuY3Rpb24odmFsdWUsIHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgZXZ0W3Byb3BOYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICBldnQuYnV0dG9uID0gezA6IDEsIDE6IDQsIDI6IDJ9W2V2dC5idXR0b25dIHx8IGV2dC5idXR0b247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIG1vdXNlIGV2ZW50J3MgYnV0dG9uIGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBDYW4gZGV0ZWN0IHdoaWNoIGJ1dHRvbiBpcyBjbGlja2VkIGJ5IHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogTWVhbmluZyBvZiByZXR1cm4gbnVtYmVyc1xuICAgICAqXG4gICAgICogLSAwOiBwcmltYXJ5IG1vdXNlIGJ1dHRvblxuICAgICAqIC0gMTogd2hlZWwgYnV0dG9uIG9yIGNlbnRlciBidXR0b25cbiAgICAgKiAtIDI6IHNlY29uZGFyeSBtb3VzZSBidXR0b25cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IG1vdXNlRXZlbnQgLSBUaGUgbW91c2UgZXZlbnQgb2JqZWN0IHdhbnQgdG8ga25vdy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSB2YWx1ZSBvZiBtZWFuaW5nIHdoaWNoIGJ1dHRvbiBpcyBjbGlja2VkP1xuICAgICAqL1xuICAgIGdldE1vdXNlQnV0dG9uOiBmdW5jdGlvbihtb3VzZUV2ZW50KSB7XG4gICAgICAgIHZhciBidXR0b24sXG4gICAgICAgICAgICBwcmltYXJ5ID0gJzAsMSwzLDUsNycsXG4gICAgICAgICAgICBzZWNvbmRhcnkgPSAnMiw2JyxcbiAgICAgICAgICAgIHdoZWVsID0gJzQnO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdNb3VzZUV2ZW50cycsICcyLjAnKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vdXNlRXZlbnQuYnV0dG9uO1xuICAgICAgICB9XG5cbiAgICAgICAgYnV0dG9uID0gbW91c2VFdmVudC5idXR0b24gKyAnJztcbiAgICAgICAgaWYgKH5wcmltYXJ5LmluZGV4T2YoYnV0dG9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSBpZiAofnNlY29uZGFyeS5pbmRleE9mKGJ1dHRvbikpIHtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9IGVsc2UgaWYgKH53aGVlbC5pbmRleE9mKGJ1dHRvbikpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBkb21ldmVudDtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFV0aWxpdHkgbW9kdWxlcyBmb3IgbWFuaXB1bGF0ZSBET00gZWxlbWVudHMuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZG9tZXZlbnQgPSByZXF1aXJlKCcuL2RvbWV2ZW50Jyk7XG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbicpO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsLFxuICAgIHBvc0tleSA9ICdfcG9zJyxcbiAgICBkb211dGlsO1xuXG52YXIgQ1NTX0FVVE9fUkVHRVggPSAvXmF1dG8kfF4kfCUvO1xuXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxcc1xccyovLCAnJykucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7XG59XG5cbmRvbXV0aWwgPSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIERPTSBlbGVtZW50IGFuZCByZXR1cm4gaXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgVGFnIG5hbWUgdG8gYXBwZW5kLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtjb250YWluZXJdIEhUTUwgZWxlbWVudCB3aWxsIGJlIHBhcmVudCB0byBjcmVhdGVkIGVsZW1lbnQuXG4gICAgICogaWYgbm90IHN1cHBsaWVkLCB3aWxsIHVzZSAqKmRvY3VtZW50LmJvZHkqKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2xhc3NOYW1lXSBEZXNpZ24gY2xhc3MgbmFtZXMgdG8gYXBwbGluZyBjcmVhdGVkIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBIVE1MIGVsZW1lbnQgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBhcHBlbmRIVE1MRWxlbWVudDogZnVuY3Rpb24odGFnTmFtZSwgY29udGFpbmVyLCBjbGFzc05hbWUpIHtcbiAgICAgICAgdmFyIGVsO1xuXG4gICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCAnJztcblxuICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcblxuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBlbGVtZW50IGZyb20gcGFyZW50IG5vZGUuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGlmIChlbCAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZWxlbWVudCBieSBpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBlbGVtZW50IGlkIGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgc3VwcGxpZWQgZWxlbWVudCBpcyBtYXRjaGVkIHNlbGVjdG9yLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gZWxlbWVudCB0byBjaGVja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciAtIHNlbGVjdG9yIHN0cmluZyB0byBjaGVja1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IG1hdGNoP1xuICAgICAqL1xuICAgIF9tYXRjaGVyOiBmdW5jdGlvbihlbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzU2VsZWN0b3IgPSAvXlxcLi8sXG4gICAgICAgICAgICBpZFNlbGVjdG9yID0gL14jLztcblxuICAgICAgICBpZiAoY3NzQ2xhc3NTZWxlY3Rvci50ZXN0KHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvbXV0aWwuaGFzQ2xhc3MoZWwsIHNlbGVjdG9yLnJlcGxhY2UoJy4nLCAnJykpO1xuICAgICAgICB9IGVsc2UgaWYgKGlkU2VsZWN0b3IudGVzdChzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBlbC5pZCA9PT0gc2VsZWN0b3IucmVwbGFjZSgnIycsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBzZWxlY3Rvci50b0xvd2VyQ2FzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIERPTSBlbGVtZW50IGJ5IHNwZWNpZmljIHNlbGVjdG9ycy5cbiAgICAgKiBiZWxvdyB0aHJlZSBzZWxlY3RvciBvbmx5IHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqIDEuIGNzcyBzZWxlY3RvclxuICAgICAqIDIuIGlkIHNlbGVjdG9yXG4gICAgICogMy4gbm9kZU5hbWUgc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3Igc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0geyhIVE1MRWxlbWVudHxzdHJpbmcpfSBbcm9vdF0gWW91IGNhbiBhc3NpZ24gcm9vdCBlbGVtZW50IHRvIGZpbmQuIGlmIG5vdCBzdXBwbGllZCwgZG9jdW1lbnQuYm9keSB3aWxsIHVzZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58ZnVuY3Rpb259IFttdWx0aXBsZT1mYWxzZV0gLSBzZXQgdHJ1ZSB0aGVuIHJldHVybiBhbGwgZWxlbWVudHMgdGhhdCBtZWV0IGNvbmRpdGlvbiwgaWYgc2V0IGZ1bmN0aW9uIHRoZW4gdXNlIGl0IGZpbHRlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IEhUTUwgZWxlbWVudCBmaW5kZWQuXG4gICAgICovXG4gICAgZmluZDogZnVuY3Rpb24oc2VsZWN0b3IsIHJvb3QsIG11bHRpcGxlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIGZvdW5kID0gZmFsc2UsXG4gICAgICAgICAgICBpc0ZpcnN0ID0gdXRpbC5pc1VuZGVmaW5lZChtdWx0aXBsZSkgfHwgbXVsdGlwbGUgPT09IGZhbHNlLFxuICAgICAgICAgICAgaXNGaWx0ZXIgPSB1dGlsLmlzRnVuY3Rpb24obXVsdGlwbGUpO1xuXG4gICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKHJvb3QpKSB7XG4gICAgICAgICAgICByb290ID0gZG9tdXRpbC5nZXQocm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJvb3QgPSByb290IHx8IHdpbmRvdy5kb2N1bWVudC5ib2R5O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlY3Vyc2UoZWwsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IGVsLmNoaWxkTm9kZXMsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgbGVuID0gY2hpbGROb2Rlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgY3Vyc29yO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yID0gY2hpbGROb2Rlc1tpXTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJzb3Iubm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRvbXV0aWwuX21hdGNoZXIoY3Vyc29yLCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChpc0ZpbHRlciAmJiBtdWx0aXBsZShjdXJzb3IpKSB8fCAhaXNGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnNvci5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzZShjdXJzb3IsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2Uocm9vdCwgc2VsZWN0b3IpO1xuXG4gICAgICAgIHJldHVybiBpc0ZpcnN0ID8gKHJlc3VsdFswXSB8fCBudWxsKSA6IHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBwYXJlbnQgZWxlbWVudCByZWN1cnNpdmVseS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIGJhc2UgZWxlbWVudCB0byBzdGFydCBmaW5kLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciAtIHNlbGVjdG9yIHN0cmluZyBmb3IgZmluZFxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gLSBlbGVtZW50IGZpbmRlZCBvciB1bmRlZmluZWQuXG4gICAgICovXG4gICAgY2xvc2VzdDogZnVuY3Rpb24oZWwsIHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuXG4gICAgICAgIGlmIChkb211dGlsLl9tYXRjaGVyKGVsLCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50ICE9PSB3aW5kb3cuZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgaWYgKGRvbXV0aWwuX21hdGNoZXIocGFyZW50LCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGV4dHMgaW5zaWRlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRleHQgaW5zaWRlIG5vZGVcbiAgICAgKi9cbiAgICB0ZXh0OiBmdW5jdGlvbihlbCkge1xuICAgICAgICB2YXIgcmV0ID0gJycsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIG5vZGVUeXBlID0gZWwubm9kZVR5cGU7XG5cbiAgICAgICAgaWYgKG5vZGVUeXBlKSB7XG4gICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExKSB7XG4gICAgICAgICAgICAgICAgLy8gbm9kZXMgdGhhdCBhdmFpbGFibGUgY29udGFpbiBvdGhlciBub2Rlc1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWwudGV4dENvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGVsID0gZWwuZmlyc3RDaGlsZDsgZWw7IGVsID0gZWwubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ICs9IGRvbXV0aWwudGV4dChlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIC8vIFRFWFQsIENEQVRBIFNFQ1RJT05cbiAgICAgICAgICAgICAgICByZXR1cm4gZWwubm9kZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICg7IGVsW2ldOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICByZXQgKz0gZG9tdXRpbC50ZXh0KGVsW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICBzZXREYXRhOiBmdW5jdGlvbihlbCwga2V5LCBkYXRhKSB7XG4gICAgICAgIGlmICgnZGF0YXNldCcgaW4gZWwpIHtcbiAgICAgICAgICAgIGVsLmRhdGFzZXRba2V5XSA9IGRhdGE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIGtleSwgZGF0YSk7XG4gICAgfSxcblxuICAgIGdldERhdGE6IGZ1bmN0aW9uKGVsLCBrZXkpIHtcbiAgICAgICAgaWYgKCdkYXRhc2V0JyBpbiBlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsLmRhdGFzZXRba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIGtleSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGVsZW1lbnQgaGFzIHNwZWNpZmljIGRlc2lnbiBjbGFzcyBuYW1lLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgY3NzIGNsYXNzXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybiB0cnVlIHdoZW4gZWxlbWVudCBoYXMgdGhhdCBjc3MgY2xhc3MgbmFtZVxuICAgICAqL1xuICAgIGhhc0NsYXNzOiBmdW5jdGlvbihlbCwgbmFtZSkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lO1xuXG4gICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZChlbC5jbGFzc0xpc3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xhc3NOYW1lID0gZG9tdXRpbC5nZXRDbGFzcyhlbCk7XG5cbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZS5sZW5ndGggPiAwICYmIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBuYW1lICsgJyhcXFxcc3wkKScpLnRlc3QoY2xhc3NOYW1lKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGRlc2lnbiBjbGFzcyB0byBIVE1MIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBjc3MgY2xhc3MgbmFtZVxuICAgICAqL1xuICAgIGFkZENsYXNzOiBmdW5jdGlvbihlbCwgbmFtZSkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lO1xuXG4gICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZChlbC5jbGFzc0xpc3QpKSB7XG4gICAgICAgICAgICB1dGlsLmZvckVhY2hBcnJheShuYW1lLnNwbGl0KCcgJyksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICghZG9tdXRpbC5oYXNDbGFzcyhlbCwgbmFtZSkpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGRvbXV0aWwuZ2V0Q2xhc3MoZWwpO1xuICAgICAgICAgICAgZG9tdXRpbC5zZXRDbGFzcyhlbCwgKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSArICcgJyA6ICcnKSArIG5hbWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogT3ZlcndyaXRlIGRlc2lnbiBjbGFzcyB0byBIVE1MIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBjc3MgY2xhc3MgbmFtZVxuICAgICAqL1xuICAgIHNldENsYXNzOiBmdW5jdGlvbihlbCwgbmFtZSkge1xuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChlbC5jbGFzc05hbWUuYmFzZVZhbCkpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IG5hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbC5jbGFzc05hbWUuYmFzZVZhbCA9IG5hbWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRWxlbWVudOyXkCBjc3NDbGFzc+yGjeyEseydhCDsoJzqsbDtlZjripQg66mU7ISc65OcXG4gICAgICogUmVtb3ZlIHNwZWNpZmljIGRlc2lnbiBjbGFzcyBmcm9tIEhUTUwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNsYXNzIG5hbWUgdG8gcmVtb3ZlXG4gICAgICovXG4gICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKGVsLCBuYW1lKSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gJyc7XG5cbiAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKGVsLmNsYXNzTGlzdCkpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVkID0gKCcgJyArIGRvbXV0aWwuZ2V0Q2xhc3MoZWwpICsgJyAnKS5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJyk7XG4gICAgICAgICAgICBkb211dGlsLnNldENsYXNzKGVsLCB0cmltKHJlbW92ZWQpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgSFRNTCBlbGVtZW50J3MgZGVzaWduIGNsYXNzZXMuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBlbGVtZW50IGNzcyBjbGFzcyBuYW1lXG4gICAgICovXG4gICAgZ2V0Q2xhc3M6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGlmICghZWwgfHwgIWVsLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHV0aWwuaXNVbmRlZmluZWQoZWwuY2xhc3NOYW1lLmJhc2VWYWwpID8gZWwuY2xhc3NOYW1lIDogZWwuY2xhc3NOYW1lLmJhc2VWYWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzcGVjaWZpYyBDU1Mgc3R5bGUgdmFsdWUgZnJvbSBIVE1MIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3R5bGUgY3NzIGF0dHJpYnV0ZSBuYW1lXG4gICAgICogQHJldHVybnMgeyhzdHJpbmd8bnVsbCl9IGNzcyBzdHlsZSB2YWx1ZVxuICAgICAqL1xuICAgIGdldFN0eWxlOiBmdW5jdGlvbihlbCwgc3R5bGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZWwuc3R5bGVbc3R5bGVdIHx8IChlbC5jdXJyZW50U3R5bGUgJiYgZWwuY3VycmVudFN0eWxlW3N0eWxlXSksXG4gICAgICAgICAgICBjc3M7XG5cbiAgICAgICAgaWYgKCghdmFsdWUgfHwgdmFsdWUgPT09ICdhdXRvJykgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcbiAgICAgICAgICAgIGNzcyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xuICAgICAgICAgICAgdmFsdWUgPSBjc3MgPyBjc3Nbc3R5bGVdIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gJ2F1dG8nID8gbnVsbCA6IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgZWxlbWVudCdzIGNvbXB1dGVkIHN0eWxlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIGluIGxvd2VyIElFOC4gdXNlIHBvbHlmaWxsIGZ1bmN0aW9uIHRoYXQgcmV0dXJuIG9iamVjdC4gaXQgaGFzIG9ubHkgb25lIGZ1bmN0aW9uICdnZXRQcm9wZXJ0eVZhbHVlJ1xuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gZWxlbWVudCB3YW50IHRvIGdldCBzdHlsZS5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB2aXJ0dWFsIENTU1N0eWxlRGVjbGFyYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGdldENvbXB1dGVkU3R5bGU6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHZhciBkZWZhdWx0VmlldyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG4gICAgICAgIGlmICghZGVmYXVsdFZpZXcgfHwgIWRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ2V0UHJvcGVydHlWYWx1ZTogZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmUgPSAvKFxcLShbYS16XSl7MX0pL2c7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSAnZmxvYXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wID0gJ3N0eWxlRmxvYXQnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlLnRlc3QocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgPSBwcm9wLnJlcGxhY2UocmUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzJdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5jdXJyZW50U3R5bGVbcHJvcF0gPyBlbC5jdXJyZW50U3R5bGVbcHJvcF0gOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBwb3NpdGlvbiBDU1Mgc3R5bGUuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gbGVmdCBwaXhlbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gdG9wIHBpeGVsIHZhbHVlLlxuICAgICAqL1xuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbihlbCwgeCwgeSkge1xuICAgICAgICB4ID0gdXRpbC5pc1VuZGVmaW5lZCh4KSA/IDAgOiB4O1xuICAgICAgICB5ID0gdXRpbC5pc1VuZGVmaW5lZCh5KSA/IDAgOiB5O1xuXG4gICAgICAgIGVsW3Bvc0tleV0gPSBbeCwgeV07XG5cbiAgICAgICAgZWwuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgICAgICBlbC5zdHlsZS50b3AgPSB5ICsgJ3B4JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHBvc2l0aW9uIGZyb20gSFRNTCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2xlYXI9ZmFsc2VdIGNsZWFyIGNhY2hlIGJlZm9yZSBjYWxjdWxhdGluZyBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IHBvaW50XG4gICAgICovXG4gICAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uKGVsLCBjbGVhcikge1xuICAgICAgICB2YXIgbGVmdCxcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIGJvdW5kO1xuXG4gICAgICAgIGlmIChjbGVhcikge1xuICAgICAgICAgICAgZWxbcG9zS2V5XSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxbcG9zS2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsW3Bvc0tleV07XG4gICAgICAgIH1cblxuICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgdG9wID0gMDtcblxuICAgICAgICBpZiAoKENTU19BVVRPX1JFR0VYLnRlc3QoZWwuc3R5bGUubGVmdCkgfHwgQ1NTX0FVVE9fUkVHRVgudGVzdChlbC5zdHlsZS50b3ApKSAmJlxuICAgICAgICAgICAgJ2dldEJvdW5kaW5nQ2xpZW50UmVjdCcgaW4gZWwpIHtcbiAgICAgICAgICAgIC8vIOyXmOumrOuovO2KuOydmCBsZWZ065iQ64qUIHRvcOydtCAnYXV0byfsnbwg65WMIOyImOuLqFxuICAgICAgICAgICAgYm91bmQgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgbGVmdCA9IGJvdW5kLmxlZnQ7XG4gICAgICAgICAgICB0b3AgPSBib3VuZC50b3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWZ0ID0gcGFyc2VGbG9hdChlbC5zdHlsZS5sZWZ0IHx8IDApO1xuICAgICAgICAgICAgdG9wID0gcGFyc2VGbG9hdChlbC5zdHlsZS50b3AgfHwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2xlZnQsIHRvcF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBlbGVtZW50J3Mgc2l6ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHJldHVybiB7bnVtYmVyW119IHdpZHRoLCBoZWlnaHRcbiAgICAgKi9cbiAgICBnZXRTaXplOiBmdW5jdGlvbihlbCkge1xuICAgICAgICB2YXIgYm91bmQsXG4gICAgICAgICAgICB3aWR0aCA9IGRvbXV0aWwuZ2V0U3R5bGUoZWwsICd3aWR0aCcpLFxuICAgICAgICAgICAgaGVpZ2h0ID0gZG9tdXRpbC5nZXRTdHlsZShlbCwgJ2hlaWdodCcpO1xuXG4gICAgICAgIGlmICgoQ1NTX0FVVE9fUkVHRVgudGVzdCh3aWR0aCkgfHwgQ1NTX0FVVE9fUkVHRVgudGVzdChoZWlnaHQpKSAmJlxuICAgICAgICAgICAgJ2dldEJvdW5kaW5nQ2xpZW50UmVjdCcgaW4gZWwpIHtcbiAgICAgICAgICAgIGJvdW5kID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB3aWR0aCA9IGJvdW5kLndpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0gYm91bmQuaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2lkdGggPSBwYXJzZUZsb2F0KHdpZHRoIHx8IDApO1xuICAgICAgICAgICAgaGVpZ2h0ID0gcGFyc2VGbG9hdChoZWlnaHQgfHwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3dpZHRoLCBoZWlnaHRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBzcGVjaWZpYyBDU1Mgc3R5bGUgaXMgYXZhaWxhYmxlLlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IHByb3BzIHByb3BlcnR5IG5hbWUgdG8gdGVzdGluZ1xuICAgICAqIEByZXR1cm4geyhzdHJpbmd8Ym9vbGVhbil9IHJldHVybiB0cnVlIHdoZW4gcHJvcGVydHkgaXMgYXZhaWxhYmxlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcHJvcHMgPSBbJ3RyYW5zZm9ybScsICctd2Via2l0LXRyYW5zZm9ybSddO1xuICAgICAqIGRvbXV0aWwudGVzdFByb3AocHJvcHMpOyAgICAvLyAndHJhbnNmb3JtJ1xuICAgICAqL1xuICAgIHRlc3RQcm9wOiBmdW5jdGlvbihwcm9wcykge1xuICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGxlbiA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAocHJvcHNbaV0gaW4gc3R5bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZm9ybSBkYXRhXG4gICAgICogQHBhcmFtIHtIVE1MRm9ybUVsZW1lbnR9IGZvcm1FbGVtZW50IC0gZm9ybSBlbGVtZW50IHRvIGV4dHJhY3QgZGF0YVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGZvcm0gZGF0YVxuICAgICAqL1xuICAgIGdldEZvcm1EYXRhOiBmdW5jdGlvbihmb3JtRWxlbWVudCkge1xuICAgICAgICB2YXIgZ3JvdXBlZEJ5TmFtZSA9IG5ldyBDb2xsZWN0aW9uKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5sZW5ndGg7IH0pLFxuICAgICAgICAgICAgbm9EaXNhYmxlZEZpbHRlciA9IGZ1bmN0aW9uKGVsKSB7IHJldHVybiAhZWwuZGlzYWJsZWQ7IH0sXG4gICAgICAgICAgICBvdXRwdXQgPSB7fTtcbiAgICAgICAgICAgIFxuICAgICAgICBncm91cGVkQnlOYW1lLmFkZC5hcHBseShcbiAgICAgICAgICAgIGdyb3VwZWRCeU5hbWUsIFxuICAgICAgICAgICAgZG9tdXRpbC5maW5kKCdpbnB1dCcsIGZvcm1FbGVtZW50LCBub0Rpc2FibGVkRmlsdGVyKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoZG9tdXRpbC5maW5kKCdzZWxlY3QnLCBmb3JtRWxlbWVudCwgbm9EaXNhYmxlZEZpbHRlcikpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChkb211dGlsLmZpbmQoJ3RleHRhcmVhJywgZm9ybUVsZW1lbnQsIG5vRGlzYWJsZWRGaWx0ZXIpKVxuICAgICAgICApO1xuXG4gICAgICAgIGdyb3VwZWRCeU5hbWUgPSBncm91cGVkQnlOYW1lLmdyb3VwQnkoZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbCAmJiBlbC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSB8fCAnX290aGVyJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdXRpbC5mb3JFYWNoKGdyb3VwZWRCeU5hbWUsIGZ1bmN0aW9uKGVsZW1lbnRzLCBuYW1lKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ19vdGhlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZW1lbnRzLmVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gZWwudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3JhZGlvJyB8fCB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGVsZW1lbnRzLmZpbmQoZnVuY3Rpb24oZWwpIHsgcmV0dXJuIGVsLmNoZWNrZWQ7IH0pLnRvQXJyYXkoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSAnc2VsZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5maW5kKGZ1bmN0aW9uKGVsKSB7IHJldHVybiAhIWVsLmNoaWxkTm9kZXMubGVuZ3RoOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGRvbXV0aWwuZmluZCgnb3B0aW9uJywgZWwsIGZ1bmN0aW9uKG9wdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0LnNlbGVjdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGVsZW1lbnRzLmZpbmQoZnVuY3Rpb24oZWwpIHsgcmV0dXJuIGVsLnZhbHVlICE9PSAnJzsgfSkudG9BcnJheSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHV0aWwubWFwKHJlc3VsdCwgZnVuY3Rpb24oZWwpIHsgcmV0dXJuIGVsLnZhbHVlOyB9KTtcblxuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0WzBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG91dHB1dFtuYW1lXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbn07XG5cbi8qZXNsaW50LWRpc2FibGUqL1xudmFyIHVzZXJTZWxlY3RQcm9wZXJ0eSA9IGRvbXV0aWwudGVzdFByb3AoW1xuICAgICd1c2VyU2VsZWN0JywgXG4gICAgJ1dlYmtpdFVzZXJTZWxlY3QnLCBcbiAgICAnT1VzZXJTZWxlY3QnLCBcbiAgICAnTW96VXNlclNlbGVjdCcsIFxuICAgICdtc1VzZXJTZWxlY3QnXG5dKTtcbnZhciBzdXBwb3J0U2VsZWN0U3RhcnQgPSAnb25zZWxlY3RzdGFydCcgaW4gZG9jdW1lbnQ7XG52YXIgcHJldlNlbGVjdFN0eWxlID0gJyc7XG4vKmVzbGludC1lbmFibGUqL1xuXG4vKipcbiAqIERpc2FibGUgYnJvd3NlcidzIHRleHQgc2VsZWN0aW9uIGJlaGF2aW9ycy5cbiAqIEBtZXRob2RcbiAqL1xuZG9tdXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbiA9IChmdW5jdGlvbigpIHtcbiAgICBpZiAoc3VwcG9ydFNlbGVjdFN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRvbWV2ZW50Lm9uKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgZG9tZXZlbnQucHJldmVudERlZmF1bHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuICAgICAgICBwcmV2U2VsZWN0U3R5bGUgPSBzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldO1xuICAgICAgICBzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gJ25vbmUnO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIEVuYWJsZSBicm93c2VyJ3MgdGV4dCBzZWxlY3Rpb24gYmVoYXZpb3JzLlxuICogQG1ldGhvZFxuICovXG5kb211dGlsLmVuYWJsZVRleHRTZWxlY3Rpb24gPSAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHN1cHBvcnRTZWxlY3RTdGFydCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkb21ldmVudC5vZmYod2luZG93LCAnc2VsZWN0c3RhcnQnLCBkb21ldmVudC5wcmV2ZW50RGVmYXVsdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9IHByZXZTZWxlY3RTdHlsZTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBEaXNhYmxlIGJyb3dzZXIncyBpbWFnZSBkcmFnIGJlaGF2aW9ycy5cbiAqL1xuZG9tdXRpbC5kaXNhYmxlSW1hZ2VEcmFnID0gZnVuY3Rpb24oKSB7XG4gICAgZG9tZXZlbnQub24od2luZG93LCAnZHJhZ3N0YXJ0JywgZG9tZXZlbnQucHJldmVudERlZmF1bHQpO1xufTtcblxuLyoqXG4gKiBFbmFibGUgYnJvd3NlcidzIGltYWdlIGRyYWcgYmVoYXZpb3JzLlxuICovXG5kb211dGlsLmVuYWJsZUltYWdlRHJhZyA9IGZ1bmN0aW9uKCkge1xuICAgIGRvbWV2ZW50Lm9mZih3aW5kb3csICdkcmFnc3RhcnQnLCBkb21ldmVudC5wcmV2ZW50RGVmYXVsdCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRvbXV0aWw7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBNaXhpbiBtb2R1bGUgZm9yIG1vZGVscy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWwsXG4gICAgc3BhY2VSeCA9IC9eXFxzKnxcXHMqJC9nLFxuICAgIG1vZGVsO1xuXG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi9jb21tb24vZGF0ZXRpbWUnKTtcblxuLyoqXG4gKiBNaXhpbiBtb2R1bGUgZm9yIG1vZGVscy5cbiAqIEBtaXhpblxuICovXG5tb2RlbCA9IHtcbiAgICAvKipcbiAgICAgKiBzdHJpbmcgdHJpbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgc3RyaW5nIHRvIHRyaW1cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0cmltZWQgc3RyaW5nXG4gICAgICovXG4gICAgdHJpbTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShzcGFjZVJ4LCAnJyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgY29sbGVjdGlvbnMgb2YgdmFsaWRhdG9yIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICB2YWxpZGF0b3JzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGVjayBhbGwgb2Ygc3VwcGxpZWQgZmllbGRzKHByb3BlcnR5KSBpcyBub3QgdW5kZWZpbmVkIG9yIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGluc3RhbmNlIG1vZGVsIGluc3RhbmNlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZHMgcHJvcGVydHkgbmFtZXMgdG8gY2hlY2suXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXR1cm4gdHJ1ZSB3aGVuIHN1cHBsaWVkIGZpZWxkcyBhcmUgbm90IHVuZGVmaW5lZCBvciBlbXB0eSBzdHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICByZXF1aXJlZDogZnVuY3Rpb24oaW5zdGFuY2UsIGZpZWxkcykge1xuICAgICAgICAgICAgdmFyIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhdXRpbC5pc1VuZGVmaW5lZChvYmopICYmIG1vZGVsLnRyaW0ob2JqKSAhPT0gJyc7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdXRpbC5mb3JFYWNoKGZpZWxkcywgZnVuY3Rpb24oZmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFsaWQgPSBpc1ZhbGlkKGluc3RhbmNlW2ZpZWxkTmFtZV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoZWNrIHN1cHBsaWVkIGZpZWxkcyBhcmUgdmFsaWQgZGF0ZXMgYW5kIHZhbGlkIGRhdGUgcmFuZ2VzLlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdGFuY2UgbW9kZWwgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSB7RGF0ZVtdfSBmaWVsZHMgYXJyYXkgb2YgZGF0ZSByYW5nZSAoc3RhcnRzLCBlbmRzKVxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gaXMgdmFsaWQgZGF0ZSByYW5nZT9cbiAgICAgICAgICovXG4gICAgICAgIGRhdGVSYW5nZTogZnVuY3Rpb24oaW5zdGFuY2UsIGZpZWxkcykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0cyxcbiAgICAgICAgICAgICAgICBlbmRzO1xuXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNFeGlzdHkoaW5zdGFuY2UpIHx8IGZpZWxkcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhcnRzID0gbmV3IERhdGUoaW5zdGFuY2VbZmllbGRzWzBdXSk7XG4gICAgICAgICAgICBlbmRzID0gbmV3IERhdGUoaW5zdGFuY2VbZmllbGRzWzFdXSk7XG5cbiAgICAgICAgICAgIGlmICghZGF0ZXRpbWUuaXNWYWxpZChzdGFydHMpIHx8ICFkYXRldGltZS5pc1ZhbGlkKGVuZHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0ZXRpbWUuY29tcGFyZShzdGFydHMsIGVuZHMpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB2YWxpZGF0ZSBmb3IgbW9kZWwgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBUaGUgdmFsaWRhdGUgYXJlIHdvcmtzIG9uIGEgYmFzaXMgb2YgY29uc3RydWN0b3IncyBcInNjaGVtYVwiIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogWW91IGNhbiBjdXN0b21pemUgdmFsaWRhdG9ycyBhZGQgc29tZSBtZXRob2QgdG8gbW9kZWwjdmFsaWRhdG9ycy5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gbW9kZWwgaXMgdmFsaWQ/XG4gICAgICovXG4gICAgaXNWYWxpZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIHNjaGVtYSA9IHRoaXMuY29uc3RydWN0b3Iuc2NoZW1hLFxuICAgICAgICAgICAgdmFsaWRhdG9ycyA9IG1vZGVsLnZhbGlkYXRvcnMsXG4gICAgICAgICAgICB2YWxpZGF0b3IsXG4gICAgICAgICAgICB2YWxpZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFzY2hlbWEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdXRpbC5mb3JFYWNoKHNjaGVtYSwgZnVuY3Rpb24odmFsdWVzLCB2YWxpZGF0b3JOYW1lKSB7XG4gICAgICAgICAgICB2YWxpZGF0b3IgPSB2YWxpZGF0b3JzW3ZhbGlkYXRvck5hbWVdO1xuXG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFsaWQgPSB2YWxpZGF0b3IodGhhdCwgdmFsdWVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBkYXRhIG9iamVjdCBmb3JtIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogSXQgcmV0dXJuIG9iamVjdCBmaWxsIHdpdGggYWxsIG93bmVkIHByb3BlcnRpZXMgYnV0IGV4Y2x1ZGUgZnVuY3Rpb25zLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IERhdGEgb2JqZWN0XG4gICAgICovXG4gICAgcGFyYW1ldGVyaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0ge30sXG4gICAgICAgICAgICBpc0Z1bmMgPSB1dGlsLmlzRnVuY3Rpb247XG5cbiAgICAgICAgdXRpbC5mb3JFYWNoKHRoaXMsIGZ1bmN0aW9uKHZhbHVlLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgaWYgKCFpc0Z1bmModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1bcHJvcE5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWl4aW4gbW9kZWwgbW9kdWxlIHRvIHN1cHBsaWVkIHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3Qgb2Ygd2FudCB0byBtaXhlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGZ1bmN0aW9uIE1hbigpIHtcbiAgICAgKiAgICAgdGhpcy5uYW1lID0gJ2pvaG4nO1xuICAgICAqIH1cbiAgICAgKiBtb2RlbC5taXhpbihNYW4ucHJvdG90eXBlKTtcbiAgICAgKi9cbiAgICBtaXhpbjogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIHV0aWwuZm9yRWFjaChtb2RlbCwgZnVuY3Rpb24obWV0aG9kLCBuYW1lKSB7XG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gJ21peGluJykge1xuICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IG1ldGhvZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtb2RlbDtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiBDbGFzcyBmb3IgcmVwcmVzZW50IHR3byBkaW1lbnNpb25hbCB4LCB5IGNvb3JkaW5hdGVzLlxuICpcbiAqIEl0IHN1cHBsaXkgYSBncm91cCBvZiBmdW5jdGlvbnMgZm9yIG1hbmlwdWxhdGUgY29vcmRpbmF0ZXMuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqIEBleGFtcGxlXG4gKiB2YXIgcCA9IHBvaW50KDEwLCAxMCk7XG4gKiB2YXIgcjEgPSBwLmFkZChQb2ludCg1LCA1KSk7XG4gKiBjb25zb2xlLmxvZyhwLnRvU3RyaW5nKCkpICAgIC8vIFwiUG9pbnQoMTAsIDEwKVwiXG4gKiBjb25zb2xlLmxvZyhyMS50b1N0cmluZygpKSAgICAvLyBcIlBvaW50KDE1LCAxNSlcIlxuICpcbiAqIHZhciBwMiA9IG5ldyBQb2ludCgxMCwgMTApO1xuICogcDIuX2FkZChwb2ludCg1LCA1KSk7XG4gKiBjb25zb2xlLmxvZyhwMi50b1N0cmluZygpKSAgIC8vIFwiUG9pbnQoMTUsIDE1KVwiXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcblxuLyoqXG4gKiBDbGFzcyBmb3IgcmVwcmVzZW50IHR3byBkaW1lbnRpb25hbCB4LCB5IGNvb3JkaW5hdGVzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgbnVtYmVyIG9mIFggY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaGUgbnVtYmVyIG9mIFkgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VSb3VuZD1mYWxzZV0gc2V0IHRydWUgd2hlbiBlYWNoIGNvb3JkaW5hdGVzIGFyZSByb3VuZGVkIGJlZm9yZSBpbml0aWFsaXplLlxuICogQGV4YW1wbGVcbiAqIHZhciB0ID0gbmV3IFBvaW50KDEzLCA1KTtcbiAqL1xuZnVuY3Rpb24gUG9pbnQoeCwgeSwgdXNlUm91bmQpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMueCA9ICh1c2VSb3VuZCA/IE1hdGgucm91bmQoeCkgOiB4KTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy55ID0gKHVzZVJvdW5kID8gTWF0aC5yb3VuZCh5KSA6IHkpO1xufVxuXG4vKioqKioqKioqKlxuICogc3RhdGljIHByb3BzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBDYWxjdWxhdGUgcG9pbnQgcmF0aW8uXG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludCBUaGUgaW5zdGFuY2Ugb2YgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmFjdG9yIEZyb20gZmFjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gdG9GYWN0b3IgVG8gZmFjdG9yXG4gKiBAcmV0dXJucyB7UG9pbnR9IFBvaW50IGluc3RhbmNlIGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LmdldFJhdGlvID0gZnVuY3Rpb24ocG9pbnQsIGZhY3RvciwgdG9GYWN0b3IpIHtcbiAgICBpZiAoZmFjdG9yID09PSB0b0ZhY3Rvcikge1xuICAgICAgICByZXR1cm4gcG9pbnQuY2xvbmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnQubXVsdGlwbHlCeSh0b0ZhY3RvcikuX2RpdmlkZUJ5KGZhY3Rvcik7XG59O1xuXG4vKipcbiAqIFN5bnRhdGljIHN1Z2FyIG9mIG5ldyBQb2ludCgpXG4gKiBAcGFyYW0geyhQb2ludHxudW1iZXJ8bnVtYmVyW10pfSB4IFggY29vcmRpbmF0ZSB2YWx1ZS5cbiAqIEBwYXJhbSB7KG51bWJlcnxib29sZWFuKX0gW3ldIFkgY29vcmRpbmF0ZSB2YWx1ZSBvciBib29sZWFuIHZhbHVlIGZvciBjb29yZGluYXRlcyByb3VuZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZVJvdW5kXSBTZXQgdHJ1ZSB0aGVuIHJvdW5kIGluaXRpYWwgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7UG9pbnR9IFRoZSBpbnN0YW5jZSBvZiBwb2ludC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgcDEgPSBwb2ludCgxMCwgMTUpO1xuICogdmFyIHAyID0gcG9pbnQoWzEwLCAxNV0pO1xuICovXG5Qb2ludC5uID0gZnVuY3Rpb24oeCwgeSwgdXNlUm91bmQpIHtcbiAgICBpZiAoeCBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIGlmICh1dGlsLmlzQXJyYXkoeCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4WzBdLCB4WzFdLCB5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIHVzZVJvdW5kKTtcbn07XG5cbi8qKioqKioqKioqXG4gKiBwcm90b3R5cGUgcHJvcHNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIENsb25lIHBvaW50c1xuICogQHJldHVybnMge1BvaW50fSBUaGUgcG9pbnQgaW5zdGFuY2UgY2xvbmVkLlxuICovXG5Qb2ludC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbn07XG5cbi8qKlxuICogQWRkIHBvaW50cy5cbiAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IFRoZSBwb2ludCBpbnN0YW5jZSB0byBhZGQuXG4gKiBAcmV0dXJuIHtQb2ludH0gUG9pbnQgY2FsY3VsYXRlZC5cbiAqL1xuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKFBvaW50Lm4ocG9pbnQpKTtcbn07XG5cbi8qKlxuICogQWRkIHNlbGYgcG9pbnRzLlxuICogQHBhcmFtIHtQb2ludH0gcG9pbnQgVGhlIHBvaW50IGluc3RhbmNlIHRvIGFkZC5cbiAqIEByZXR1cm4ge1BvaW50fSBQb2ludCBjYWxjdWxhdGVkLlxuICovXG5Qb2ludC5wcm90b3R5cGUuX2FkZCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgdGhpcy54ICs9IHBvaW50Lng7XG4gICAgdGhpcy55ICs9IHBvaW50Lnk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0IHBvaW50cy5cbiAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IFRoZSBwb2ludCBpbnN0YW5jZSB0byBzdWJ0cmFjdC5cbiAqIEByZXR1cm4ge1BvaW50fSBQb2ludCBjYWxjdWxhdGVkLlxuICovXG5Qb2ludC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbihwb2ludCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuX3N1YnRyYWN0KFBvaW50Lm4ocG9pbnQpKTtcbn07XG5cbi8qKlxuICogU3VidHJhY3QgcG9pbnRzLiAobWFuaXB1bGF0ZSBzZWxmKVxuICogQHBhcmFtIHtQb2ludH0gcG9pbnQgVGhlIHBvaW50IGluc3RhbmNlIHRvIHN1YnRyYWN0LlxuICogQHJldHVybnMge1BvaW50fSBQb2ludCBjYWxjdWxhdGVkLlxuICovXG5Qb2ludC5wcm90b3R5cGUuX3N1YnRyYWN0ID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICB0aGlzLnggLT0gcG9pbnQueDtcbiAgICB0aGlzLnkgLT0gcG9pbnQueTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGl2aWRlIHBvaW50cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBkaXZpZGUuXG4gKiBAcmV0dXJucyB7UG9pbnR9IFBvaW50IGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5kaXZpZGVCeSA9IGZ1bmN0aW9uKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuX2RpdmlkZUJ5KG51bSk7XG59O1xuXG4vKipcbiAqIERpdmlkZSBwb2ludHMuIChtYW5pcHVsYXRlIHNlbGYpXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdG8gZGl2aWRlLlxuICogQHJldHVybnMge1BvaW50fSBQb2ludCBjYWxjdWxhdGVkLlxuICovXG5Qb2ludC5wcm90b3R5cGUuX2RpdmlkZUJ5ID0gZnVuY3Rpb24obnVtKSB7XG4gICAgdGhpcy54IC89IG51bTtcbiAgICB0aGlzLnkgLz0gbnVtO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGh5ZW4gbnVtYmVyIHRvIG11bHRpcGx5XG4gKiBAcmV0dXJuIHtQb2ludH0gUG9pbnQgY2FsY3VsYXRlZC5cbiAqL1xuUG9pbnQucHJvdG90eXBlLm11bHRpcGx5QnkgPSBmdW5jdGlvbihudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0aXBseUJ5KG51bSk7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IHNlbGYgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdG8gbXVsdGlwbHkuXG4gKiBAcmV0dXJucyB7UG9pbnR9IFBvaW50IGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5fbXVsdGlwbHlCeSA9IGZ1bmN0aW9uKG51bSkge1xuICAgIHRoaXMueCAqPSBudW07XG4gICAgdGhpcy55ICo9IG51bTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUm91bmQgY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJucyB7UG9pbnR9IFBvaW50IGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuX3JvdW5kKCk7XG59O1xuXG4vKipcbiAqIFJvdW5kIHNlbGYgY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJucyB7UG9pbnR9IFBvaW50IGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5fcm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XG4gICAgdGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXZlcnNlIHZhbHVlcyBiZXR3ZWVuIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZS5cbiAqIEByZXR1cm5zIHtQb2ludH0gUG9pbnQgY2FsY3VsYXRlZC5cbiAqL1xuUG9pbnQucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9yZXZlcnNlKCk7XG59O1xuXG4vKipcbiAqIFJldmVyc2Ugc2VsZiB2YWx1ZXMgYmV0d2VlbiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUuXG4gKiBAcmV0dXJucyB7UG9pbnR9IFBvaW50IGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5fcmV2ZXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMueCAqPSAtMTtcbiAgICB0aGlzLnkgKj0gLTE7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZsb29yIGNvb3JkaW5hdGVzLlxuICogQHJldHVybnMge1BvaW50fSBQb2ludCBjYWxjdWxhdGVkLlxuICovXG5Qb2ludC5wcm90b3R5cGUuZmxvb3IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9mbG9vcigpO1xufTtcblxuLyoqXG4gKiBGbG9vciBzZWxmIGNvb3JkaW5hdGVzLlxuICogQHJldHVybnMge1BvaW50fSBQb2ludCBjYWxjdWxhdGVkLlxuICovXG5Qb2ludC5wcm90b3R5cGUuX2Zsb29yID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy54ID0gTWF0aC5mbG9vcih0aGlzLngpO1xuICAgIHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2VpbCBjb29yZGluYXRlcy5cbiAqIEByZXR1cm5zIHtQb2ludH0gUG9pbnQgY2FsY3VsYXRlZC5cbiAqL1xuUG9pbnQucHJvdG90eXBlLmNlaWwgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9jZWlsKCk7XG59O1xuXG4vKipcbiAqIENlaWwgc2VsZiBjb29kaW5hdGVzLlxuICogQHJldHVybnMge1BvaW50fSBQb2ludCBjYWxjdWxhdGVkLlxuICovXG5Qb2ludC5wcm90b3R5cGUuX2NlaWwgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcbiAgICB0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUm90YXRlIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGRlZyBUaGUgbnVtYmVyIG9mIHJvdGF0ZSBkZWdyZWUuXG4gKiBAcGFyYW0ge1BvaW50fSBbY2VudGVyPXRoaXNdIENlbnRlciBwb2ludCBpbnN0YW5jZSB0byB1c2Ugcm90YXRlIGNlbnRlci4gdXNlIG93biB3aGVuIG5vdCBzdXBwbGllZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29zXSBDb3NpbmUgdmFsdWVzIGZvciByb3RhdGUuIGl0IHVzZWZ1bCB3aGVuIG11bHRpIHBvaW50IHJvdGF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2luXSBTaW5lIHZhbHVlcyBmb3Igcm90YXRlLiBpdCB1c2VmdWwgd2hlbiBtdWx0aSBwb2ludCByb3RhdGUuXG4gKiBAcmV0dXJucyB7UG9pbnR9IFRoZSBwb2ludCBpbnN0YW5jZSByb3RhdGVkLlxuICovXG5Qb2ludC5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24oZGVnLCBjZW50ZXIsIGNvcywgc2luKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm90YXRlKGRlZywgY2VudGVyLCBjb3MsIHNpbik7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBzZWxmLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlZyBUaGUgbnVtYmVyIG9mIHJvdGF0ZSBkZWdyZWUuXG4gKiBAcGFyYW0ge1BvaW50fSBbY2VudGVyPXRoaXNdIENlbnRlciBwb2ludCBpbnN0YW5jZSB0byB1c2Ugcm90YXRlIGNlbnRlci4gdXNlIG93biB3aGVuIG5vdCBzdXBwbGllZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29zXSBDb3NpbmUgdmFsdWVzIGZvciByb3RhdGUuIGl0IHVzZWZ1bCB3aGVuIG11bHRpIHBvaW50IHJvdGF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2luXSBTaW5lIHZhbHVlcyBmb3Igcm90YXRlLiBpdCB1c2VmdWwgd2hlbiBtdWx0aSBwb2ludCByb3RhdGUuXG4gKiBAcmV0dXJucyB7UG9pbnR9IFRoZSBwb2ludCBpbnN0YW5jZSByb3RhdGVkLlxuICovXG5Qb2ludC5wcm90b3R5cGUuX3JvdGF0ZSA9IGZ1bmN0aW9uKGRlZywgY2VudGVyLCBjb3MsIHNpbikge1xuICAgIHZhciByYWQgPSBkZWcgKiAoTWF0aC5QSSAvIDE4MCksXG4gICAgICAgIHgsXG4gICAgICAgIHk7XG5cbiAgICBjb3MgPSBjb3MgfHwgcGFyc2VGbG9hdChNYXRoLmNvcyhyYWQpLnRvRml4ZWQoOCkpO1xuICAgIHNpbiA9IHNpbiB8fCBwYXJzZUZsb2F0KE1hdGguc2luKHJhZCkudG9GaXhlZCg4KSk7XG5cbiAgICB0aGlzLl9zdWJ0cmFjdChjZW50ZXIpO1xuXG4gICAgeCA9IHRoaXMueDtcbiAgICB5ID0gdGhpcy55O1xuXG4gICAgdGhpcy54ID0geCAqIGNvcyAtIHkgKiBzaW47XG4gICAgdGhpcy55ID0geCAqIHNpbiArIHkgKiBjb3M7XG5cbiAgICB0aGlzLl9hZGQoY2VudGVyKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICogQHBhcmFtIHtQb2ludH0gcG9pbnQgUG9pbnQgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAqL1xuUG9pbnQucHJvdG90eXBlLmRpc3RhbmNlVG8gPSBmdW5jdGlvbihwb2ludCkge1xuICAgIHZhciB4LFxuICAgICAgICB5O1xuXG4gICAgcG9pbnQgPSBQb2ludC5uKHBvaW50KTtcblxuICAgIHggPSBwb2ludC54IC0gdGhpcy54O1xuICAgIHkgPSBwb2ludC55IC0gdGhpcy55O1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgcG9pbnQgZXF1YWxzLlxuICogQHBhcmFtIHtQb2ludH0gcG9pbnQgUG9pbnQgaW5zdGFuY2UgdG8gY29tcGFyZVxuICogQHJldHVybnMge2Jvb2xlYW59IGVxdWFsaXR5XG4gKi9cblBvaW50LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihwb2ludCkge1xuICAgIHBvaW50ID0gUG9pbnQubihwb2ludCk7XG4gICAgcmV0dXJuIHBvaW50LnggPT09IHRoaXMueCAmJiBwb2ludC55ID09PSB0aGlzLnk7XG59O1xuXG4vKipcbiAqIFJldHVybiBmb3JtYXR0ZWQgc3RyaW5nLiAnUG9pbnQoeCwgeSknXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBzdHJpbmdcbiAqL1xuUG9pbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICdQb2ludCgnICsgdGhpcy54ICsgJywgJyArIHRoaXMueSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJuIGNvb2RpbmF0ZXMgdG8gYXJyYXkuIFt4LCB5XVxuICogQHJldHVybnMge251bWJlcltdfSBjb29yZGluYXRlIGFycmF5LlxuICovXG5Qb2ludC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnldO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJlcXVlc3RBbmltRnJhbWVcbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgcmVxdWVzdEZuLFxuICAgIGNhbmNlbEZuO1xuXG5mdW5jdGlvbiBnZXRQcmVmaXhlZChuYW1lKSB7XG4gICAgcmV0dXJuIGdsb2JhbFsnd2Via2l0JyArIG5hbWVdIHx8IGdsb2JhbFsnbW96JyArIG5hbWVdIHx8IGdsb2JhbFsnbXMnICsgbmFtZV07XG59XG5cbnJlcXVlc3RGbiA9IGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICBnZXRQcmVmaXhlZCgnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHxcbiAgICBmdW5jdGlvbihmbiwgY29udGV4dCkge1xuICAgICAgICBmbi5jYWxsKGNvbnRleHQpO1xuICAgIH07XG5cbmNhbmNlbEZuID0gZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgZ2V0UHJlZml4ZWQoJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJykgfHxcbiAgICBnZXRQcmVmaXhlZCgnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHxcbiAgICBmdW5jdGlvbigpIHt9O1xuXG4vKipcbiAqIEBtb2R1bGUgbW9kdWxlOnJlcUFuaW1GcmFtZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIFNoaW0gb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHQgY29udGV4dCBmb3IgY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBVbmlxdWUgaWRcbiAgICAgKi9cbiAgICByZXF1ZXN0QW5pbUZyYW1lOiBmdW5jdGlvbihmbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcmVxdWVzdEZuLmNhbGwoZ2xvYmFsLCB1dGlsLmJpbmQoZm4sIGNvbnRleHQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hpbSBvZiBjYW5jZWxBbmltYXRpb25GcmFtZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgaWRcbiAgICAgKi9cbiAgICBjYW5jZWxBbmltRnJhbWU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbmNlbEZuLmNhbGwoZ2xvYmFsLCBpZCk7XG4gICAgfVxufTtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEJhc2UgY2FsZW5kYXIgY29udHJvbGxlclxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4uL21vZGVsL2V2ZW50Jyk7XG52YXIgRXZlbnRWaWV3TW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbC92aWV3TW9kZWwvZXZlbnQnKTtcbnZhciBkYXRldGltZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9kYXRldGltZScpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9jb21tb24nKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgYmFzZSBjb250cm9sbGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ncm91cEZ1bmNdIC0gZnVuY3Rpb24gZm9yIGdyb3VwIGVhY2ggbW9kZWxzIHtAc2VlIENvbGxlY3Rpb24jZ3JvdXBCeX1cbiAqIEBtaXhlcyB1dGlsLkN1c3RvbUV2ZW50c1xuICovXG5mdW5jdGlvbiBCYXNlKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIGZ1bmN0aW9uIGZvciBncm91cCBlYWNoIGV2ZW50IG1vZGVscy5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICogQHBhcmFtIHtFdmVudFZpZXdNb2RlbH0gdmlld01vZGVsIC0gdmlldyBtb2RlbCBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gZ3JvdXAga2V5XG4gICAgICovXG4gICAgdGhpcy5ncm91cEZ1bmMgPSBvcHRpb25zLmdyb3VwRnVuYyB8fCBmdW5jdGlvbih2aWV3TW9kZWwpIHtcbiAgICAgICAgaWYgKHZpZXdNb2RlbC5tb2RlbC5pc0FsbERheSkge1xuICAgICAgICAgICAgcmV0dXJuICdhbGxkYXknO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAndGltZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZXZlbnRzIGNvbGxlY3Rpb24uXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5ldmVudHMgPSBjb21tb24uY3JlYXRlRXZlbnRDb2xsZWN0aW9uKCk7XG5cbiAgICAvKipcbiAgICAgKiBNYXRyaXggZm9yIG11bHRpZGF0ZSBldmVudHMuXG4gICAgICogQHR5cGUge29iamVjdC48c3RyaW5nLCBhcnJheT59XG4gICAgICovXG4gICAgdGhpcy5kYXRlTWF0cml4ID0ge307XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGNvbnRhaW4gZGF0ZXMgaW4gZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGluc3RhbmNlIG9mIGV2ZW50LlxuICogQHJldHVybnMge2FycmF5fSBjb250YWluIGRhdGVzLlxuICovXG5CYXNlLnByb3RvdHlwZS5fZ2V0Q29udGFpbkRhdGVzSW5FdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIHJhbmdlID0gZGF0ZXRpbWUucmFuZ2UoXG4gICAgICAgIGRhdGV0aW1lLnN0YXJ0KGV2ZW50LmdldFN0YXJ0cygpKSxcbiAgICAgICAgZGF0ZXRpbWUuc3RhcnQoZXZlbnQuZ2V0RW5kcygpKSxcbiAgICAgICAgZGF0ZXRpbWUuTUlMTElTRUNPTkRTX1BFUl9EQVlcbiAgICApO1xuXG4gICAgcmV0dXJuIHJhbmdlO1xufTtcblxuLyoqKioqKioqKipcbiAqIENSVURcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIENyZWF0ZSBhbiBldmVudCBpbnN0YW5jZSBmcm9tIHJhdyBkYXRhLlxuICogQGVtaXRzIEJhc2UjY3JlYXRlZEV2ZW50XG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBEYXRhIG9iamVjdCB0byBjcmVhdGUgZXZlbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudCAtIHNldCB0cnVlIHRoZW4gZG9uJ3QgZmlyZSBldmVudHMuXG4gKiBAcmV0dXJucyB7RXZlbnR9IFRoZSBpbnN0YW5jZSBvZiBFdmVudCB0aGF0IGNyZWF0ZWQuXG4gKi9cbkJhc2UucHJvdG90eXBlLmNyZWF0ZUV2ZW50ID0gZnVuY3Rpb24ob3B0aW9ucywgc2lsZW50KSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5hZGRFdmVudChFdmVudC5jcmVhdGUob3B0aW9ucykpO1xuXG4gICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBCYXNlI2NyZWF0ZWRFdmVudFxuICAgICAgICAgKiBAdHlwZSB7RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpcmUoJ2NyZWF0ZWRFdmVudCcsIGV2ZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnQ7XG59O1xuXG4vKipcbiAqIFNldCBkYXRlIG1hdHJpeCB0byBzdXBwbGllZCBldmVudCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gaW5zdGFuY2Ugb2YgZXZlbnQuXG4gKi9cbkJhc2UucHJvdG90eXBlLl9hZGRUb01hdHJpeCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIG93bk1hdHJpeCA9IHRoaXMuZGF0ZU1hdHJpeCxcbiAgICAgICAgY29udGFpbkRhdGVzID0gdGhpcy5fZ2V0Q29udGFpbkRhdGVzSW5FdmVudChldmVudCk7XG5cbiAgICB1dGlsLmZvckVhY2goY29udGFpbkRhdGVzLCBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHZhciB5bWQgPSBkYXRldGltZS5mb3JtYXQoZGF0ZSwgJ1lZWVlNTUREJyksXG4gICAgICAgICAgICBtYXRyaXggPSBvd25NYXRyaXhbeW1kXSA9IG93bk1hdHJpeFt5bWRdIHx8IFtdO1xuXG4gICAgICAgIG1hdHJpeC5wdXNoKHV0aWwuc3RhbXAoZXZlbnQpKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50J3MgaWQgZnJvbSBtYXRyaXguXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIGluc3RhbmNlIG9mIGV2ZW50XG4gKi9cbkJhc2UucHJvdG90eXBlLl9yZW1vdmVGcm9tTWF0cml4ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgbW9kZWxJRCA9IHV0aWwuc3RhbXAoZXZlbnQpO1xuXG4gICAgdXRpbC5mb3JFYWNoKHRoaXMuZGF0ZU1hdHJpeCwgZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHV0aWwuaW5BcnJheShtb2RlbElELCBtYXRyaXgpO1xuXG4gICAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgICAgIG1hdHJpeC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBldmVudCBpbnN0YW5jZS5cbiAqIEBlbWl0cyBCYXNlI2FkZGVkRXZlbnRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBpbnN0YW5jZSBvZiBFdmVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IC0gc2V0IHRydWUgdGhlbiBkb24ndCBmaXJlIGV2ZW50cy5cbiAqIEByZXR1cm5zIHtFdmVudH0gVGhlIGluc3RhbmNlIG9mIEV2ZW50IHRoYXQgYWRkZWQuXG4gKi9cbkJhc2UucHJvdG90eXBlLmFkZEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsIHNpbGVudCkge1xuICAgIHRoaXMuZXZlbnRzLmFkZChldmVudCk7XG4gICAgdGhpcy5fYWRkVG9NYXRyaXgoZXZlbnQpO1xuXG4gICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBCYXNlI2FkZGVkRXZlbnRcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlyZSgnYWRkZWRFdmVudCcsIGV2ZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnQ7XG59O1xuXG4vKipcbiAqIHNwbGl0IGV2ZW50IG1vZGVsIGJ5IHltZC5cbiAqIEBwYXJhbSB7RGF0ZX0gc3RhcnRzIC0gc3RhcnQgZGF0ZVxuICogQHBhcmFtIHtEYXRlfSBlbmRzIC0gZW5kIGRhdGVcbiAqIEBwYXJhbSB7Q29sbGVjdGlvbn0gZXZlbnRDb2xsZWN0aW9uIC0gY29sbGVjdGlvbiBvZiBldmVudCBtb2RlbC5cbiAqIEByZXR1cm5zIHtvYmplY3QuPHN0cmluZywgQ29sbGVjdGlvbj59IHNwbGl0dGVkIGV2ZW50IG1vZGVsIGNvbGxlY3Rpb25zLlxuICovXG5CYXNlLnByb3RvdHlwZS5zcGxpdEV2ZW50QnlEYXRlUmFuZ2UgPSBmdW5jdGlvbihzdGFydHMsIGVuZHMsIGV2ZW50Q29sbGVjdGlvbikge1xuICAgIHZhciByYW5nZSA9IGRhdGV0aW1lLnJhbmdlKFxuICAgICAgICAgICAgZGF0ZXRpbWUuc3RhcnQoc3RhcnRzKSxcbiAgICAgICAgICAgIGRhdGV0aW1lLnN0YXJ0KGVuZHMpLFxuICAgICAgICAgICAgZGF0ZXRpbWUuTUlMTElTRUNPTkRTX1BFUl9EQVlcbiAgICAgICAgKSxcbiAgICAgICAgb3duTWF0cml4ID0gdGhpcy5kYXRlTWF0cml4LFxuICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgIHV0aWwuZm9yRWFjaEFycmF5KHJhbmdlLCBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHZhciB5bWQgPSBkYXRldGltZS5mb3JtYXQoZGF0ZSwgJ1lZWVlNTUREJyksXG4gICAgICAgICAgICBtYXRyaXggPSBvd25NYXRyaXhbeW1kXSxcbiAgICAgICAgICAgIGNvbGxlY3Rpb247XG5cbiAgICAgICAgY29sbGVjdGlvbiA9IHJlc3VsdFt5bWRdID0gY29tbW9uLmNyZWF0ZUV2ZW50Q29sbGVjdGlvbigpO1xuXG4gICAgICAgIGlmIChtYXRyaXggJiYgbWF0cml4Lmxlbmd0aCkge1xuICAgICAgICAgICAgdXRpbC5mb3JFYWNoQXJyYXkobWF0cml4LCBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGV2ZW50Q29sbGVjdGlvbi5kb1doZW5IYXMoaWQsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uYWRkKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gZXZlbnRzIGluIHN1cHBsaWVkIGRhdGUgcmFuZ2UuXG4gKlxuICogYXZhaWxhYmxlIG9ubHkgWU1ELlxuICogQHBhcmFtIHtEYXRlfSBzdGFydHMgc3RhcnQgZGF0ZS5cbiAqIEBwYXJhbSB7RGF0ZX0gZW5kcyBlbmQgZGF0ZS5cbiAqIEByZXR1cm5zIHtvYmplY3QuPHN0cmluZywgQ29sbGVjdGlvbj59IGV2ZW50IGNvbGxlY3Rpb24gZ3JvdXBlZCBieSBkYXRlcy5cbiAqL1xuQmFzZS5wcm90b3R5cGUuZmluZEJ5RGF0ZVJhbmdlID0gZnVuY3Rpb24oc3RhcnRzLCBlbmRzKSB7XG4gICAgdmFyIHJhbmdlID0gZGF0ZXRpbWUucmFuZ2UoXG4gICAgICAgICAgICBkYXRldGltZS5zdGFydChzdGFydHMpLFxuICAgICAgICAgICAgZGF0ZXRpbWUuc3RhcnQoZW5kcyksXG4gICAgICAgICAgICBkYXRldGltZS5NSUxMSVNFQ09ORFNfUEVSX0RBWVxuICAgICAgICApLFxuICAgICAgICBvd25FdmVudHMgPSB0aGlzLmV2ZW50cy5pdGVtcyxcbiAgICAgICAgb3duTWF0cml4ID0gdGhpcy5kYXRlTWF0cml4LFxuICAgICAgICBkZm9ybWF0ID0gZGF0ZXRpbWUuZm9ybWF0LFxuICAgICAgICByZXN1bHQgPSB7fSxcbiAgICAgICAgbWF0cml4LFxuICAgICAgICB5bWQsXG4gICAgICAgIHZpZXdNb2RlbHM7XG5cbiAgICB1dGlsLmZvckVhY2hBcnJheShyYW5nZSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB5bWQgPSBkZm9ybWF0KGRhdGUsICdZWVlZTU1ERCcpO1xuICAgICAgICBtYXRyaXggPSBvd25NYXRyaXhbeW1kXTtcbiAgICAgICAgdmlld01vZGVscyA9IHJlc3VsdFt5bWRdID0gY29tbW9uLmNyZWF0ZUV2ZW50Q29sbGVjdGlvbigpO1xuXG4gICAgICAgIGlmIChtYXRyaXggJiYgbWF0cml4Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmlld01vZGVscy5hZGQuYXBwbHkodmlld01vZGVscywgdXRpbC5tYXAobWF0cml4LCBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFdmVudFZpZXdNb2RlbC5jcmVhdGUob3duRXZlbnRzW2lkXSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBVcGRhdGVcbi8qKlxuICogVXBkYXRlIGFuIGV2ZW50LlxuICogQGVtaXRzIEJhc2UjdXBkYXRlRXZlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBUaGUgdW5pcXVlIGlkIG9mIEV2ZW50IGluc3RhbmNlLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgdXBkYXRlZCBvYmplY3QgZGF0YS5cbiAqIEByZXR1cm5zIHtFdmVudHxib29sZWFufSB1cGRhdGVkIGV2ZW50IGluc3RhbmNlLCB3aGVuIGl0IGZhaWwgdGhlbiByZXR1cm4gZmFsc2UuXG4gKi9cbkJhc2UucHJvdG90eXBlLnVwZGF0ZUV2ZW50ID0gZnVuY3Rpb24oaWQsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICB0aGlzLmV2ZW50cy5kb1doZW5IYXMoaWQsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGlmIChvcHRpb25zLnRpdGxlKSB7XG4gICAgICAgICAgICBldmVudC5zZXQoJ3RpdGxlJywgb3B0aW9ucy50aXRsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5pc0FsbERheSkge1xuICAgICAgICAgICAgZXZlbnQuc2V0KCdpc0FsbERheScsIG9wdGlvbnMuaXNBbGxEYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRzKSB7XG4gICAgICAgICAgICBldmVudC5zZXQoJ3N0YXJ0cycsIG5ldyBEYXRlKG9wdGlvbnMuc3RhcnRzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5lbmRzKSB7XG4gICAgICAgICAgICBldmVudC5zZXQoJ2VuZHMnLCBuZXcgRGF0ZShvcHRpb25zLmVuZHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbW92ZUZyb21NYXRyaXgoZXZlbnQpO1xuICAgICAgICB0aGlzLl9hZGRUb01hdHJpeChldmVudCk7XG5cbiAgICAgICAgcmVzdWx0ID0gZXZlbnQ7XG4gICAgfSwgdGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgQmFzZSN1cGRhdGVFdmVudFxuICAgICAqL1xuICAgIHRoaXMuZmlyZSgndXBkYXRlRXZlbnQnKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBEZWxldGVcbi8qKlxuICogRGVsZXRlIGV2ZW50IGluc3RhbmNlIGZyb20gY29udHJvbGxlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtIHVuaXF1ZSBpZCBvZiBtb2RlbCBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtFdmVudH0gZGVsZXRlZCBtb2RlbCBpbnN0YW5jZS5cbiAqL1xuQmFzZS5wcm90b3R5cGUuZGVsZXRlRXZlbnQgPSBmdW5jdGlvbihpZCkge1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcblxuICAgIHRoaXMuZXZlbnRzLmRvV2hlbkhhcyhpZCwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgcmVzdWx0ID0gZXZlbnQ7XG4gICAgICAgIHRoaXMuX3JlbW92ZUZyb21NYXRyaXgoZXZlbnQpO1xuICAgICAgICB0aGlzLmV2ZW50cy5yZW1vdmUoZXZlbnQpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKioqKioqKioqXG4gKiBBUElcbiAqKioqKioqKioqL1xuXG5CYXNlLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24oKSB7fTtcbkJhc2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24ocXVlcnkpIHt9O1xuXG4vLyBtaXhpblxudXRpbC5DdXN0b21FdmVudHMubWl4aW4oQmFzZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZTtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbnRyb2xsZXIgbWl4aW4gbW9kdWxlcyBmb3IgZGF5IHZpZXdzLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBkYXRldGltZSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kYXRldGltZScpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9jb21tb24nKTtcbnZhciBhcnJheSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9hcnJheScpO1xudmFyIEV2ZW50Vmlld01vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvdmlld01vZGVsL2V2ZW50Jyk7XG52YXIgYXBzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vKipcbiAqIEBtaXhpbiBCYXNlLldlZWtcbiAqL1xudmFyIFdlZWsgPSB7XG4gICAgLyoqKioqKioqKipcbiAgICAgKiBDT01NT05cbiAgICAgKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBjb2xsaXNpb24gZ3JvdXAuXG4gICAgICogQHRoaXMgQmFzZS5XZWVrXG4gICAgICogQHBhcmFtIHthcnJheX0gdmlld01vZGVscyBMaXN0IG9mIHZpZXdtb2RlbHMuXG4gICAgICogQHJldHVybnMge2FycmF5fSBDb2xsaXNpb24gR3JvdXAuXG4gICAgICovXG4gICAgZ2V0Q29sbGlzaW9uR3JvdXA6IGZ1bmN0aW9uKHZpZXdNb2RlbHMpIHtcbiAgICAgICAgdmFyIGNvbGxpc2lvbkdyb3VwcyA9IFtdLFxuICAgICAgICAgICAgZm91bmRQcmV2Q29sbGlzaW9uRXZlbnQgPSBmYWxzZSxcbiAgICAgICAgICAgIHByZXZpb3VzRXZlbnRMaXN0O1xuXG4gICAgICAgIGlmICghdmlld01vZGVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsaXNpb25Hcm91cHM7XG4gICAgICAgIH1cblxuICAgICAgICBjb2xsaXNpb25Hcm91cHNbMF0gPSBbdXRpbC5zdGFtcCh2aWV3TW9kZWxzWzBdLnZhbHVlT2YoKSldO1xuICAgICAgICB1dGlsLmZvckVhY2hBcnJheSh2aWV3TW9kZWxzLnNsaWNlKDEpLCBmdW5jdGlvbihldmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGZvdW5kUHJldkNvbGxpc2lvbkV2ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBwcmV2aW91c0V2ZW50TGlzdCA9IGFwcy5hcHBseSh2aWV3TW9kZWxzLCBbMCwgaW5kZXggKyAxXSkucmV2ZXJzZSgpO1xuXG4gICAgICAgICAgICB1dGlsLmZvckVhY2hBcnJheShwcmV2aW91c0V2ZW50TGlzdCwgZnVuY3Rpb24ocHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY29sbGlkZXNXaXRoKHByZXZpb3VzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyDsnbTsoIQg7J287KCV65Ok6rO8IOqyuey5mOuKlCDqsr3smrAg6rK57LmY64qUIOydvOygleydmCBDb2xsaXNpb24gR3JvdXDsnYRcbiAgICAgICAgICAgICAgICAgICAgLy8g7LC+7JWEIOydtCDsnbzsoJXsnYQg7LaU6rCA7ZWc64ukXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kUHJldkNvbGxpc2lvbkV2ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB1dGlsLmZvckVhY2hBcnJheShjb2xsaXNpb25Hcm91cHMuc2xpY2UoMCkucmV2ZXJzZSgpLCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKH51dGlsLmluQXJyYXkodXRpbC5zdGFtcChwcmV2aW91cy52YWx1ZU9mKCkpLCBncm91cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDqsrnsuZjripQg7J207KCEIOydvOygleydhCDssL7snYAg6rK97JqwIOq3uCDsnbzsoJXsnbQg7IaN7ZWcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGlzaW9uIEdyb3Vw7JeQIOydtCDsnbzsoJXsnYQg7Y+s7ZWo7Iuc7YKo64ukLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwLnB1c2godXRpbC5zdGFtcChldmVudC52YWx1ZU9mKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFmb3VuZFByZXZDb2xsaXNpb25FdmVudCkge1xuICAgICAgICAgICAgICAgIC8vIOydtCDsnbzsoJXsnYAg7J207KCE7J287KCV6rO8IOqyuey5mOyngCDslYrripQg7J287KCV7J2066+A66GcXG4gICAgICAgICAgICAgICAgLy8g7IOIIENvbGxpc2lvbiBHcm91cOydhCDqtazshLHtlZzri6QuXG4gICAgICAgICAgICAgICAgY29sbGlzaW9uR3JvdXBzLnB1c2goW3V0aWwuc3RhbXAoZXZlbnQudmFsdWVPZigpKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY29sbGlzaW9uR3JvdXBzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcm93IGxlbmd0aCBieSBjb2x1bW4gaW5kZXggaW4gMmQgbWF0cml4LlxuICAgICAqIEB0aGlzIEJhc2UuV2Vla1xuICAgICAqIEBwYXJhbSB7YXJyYXlbXX0gYXJyMmQgTWF0cml4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbCBDb2x1bW4gaW5kZXguXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBMYXN0IHJvdyBudW1iZXIgaW4gY29sdW1uLlxuICAgICAqL1xuICAgIGdldExhc3RSb3dJbkNvbHVtbjogZnVuY3Rpb24oYXJyMmQsIGNvbCkge1xuICAgICAgICB2YXIgcm93ID0gYXJyMmQubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChyb3cgPiAwKSB7XG4gICAgICAgICAgICByb3cgLT0gMTtcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZChhcnIyZFtyb3ddW2NvbF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIG1hdHJpeCBmb3IgYXBwb2ludG1lbnQgYmxvY2sgZWxlbWVudCBwbGFjaW5nLlxuICAgICAqIEB0aGlzIEJhc2UuV2Vla1xuICAgICAqIEBwYXJhbSB7Q29sbGVjdGlvbn0gY29sbGVjdGlvbiBtb2RlbCBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7YXJyYXlbXX0gY29sbGlzaW9uR3JvdXBzIENvbGxpc2lvbiBncm91cHMgZm9yIGV2ZW50IHNldC5cbiAgICAgKiBAcmV0dXJucyB7YXJyYXl9IG1hdHJpY2VzXG4gICAgICovXG4gICAgZ2V0TWF0cmljZXM6IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGNvbGxpc2lvbkdyb3Vwcykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICBnZXRMYXN0Um93SW5Db2x1bW4gPSBXZWVrLmdldExhc3RSb3dJbkNvbHVtbjtcblxuICAgICAgICB1dGlsLmZvckVhY2hBcnJheShjb2xsaXNpb25Hcm91cHMsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgbWF0cml4ID0gW1tdXTtcblxuICAgICAgICAgICAgdXRpbC5mb3JFYWNoQXJyYXkoZ3JvdXAsIGZ1bmN0aW9uKGV2ZW50SUQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBjb2xsZWN0aW9uLml0ZW1zW2V2ZW50SURdLFxuICAgICAgICAgICAgICAgICAgICBjb2wgPSAwLFxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBuZXh0Um93LFxuICAgICAgICAgICAgICAgICAgICBsYXN0Um93SW5Db2x1bW47XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RSb3dJbkNvbHVtbiA9IGdldExhc3RSb3dJbkNvbHVtbihtYXRyaXgsIGNvbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RSb3dJbkNvbHVtbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeFswXS5wdXNoKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghZXZlbnQuY29sbGlkZXNXaXRoKG1hdHJpeFtsYXN0Um93SW5Db2x1bW5dW2NvbF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Um93ID0gbGFzdFJvd0luQ29sdW1uICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKG1hdHJpeFtuZXh0Um93XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXhbbmV4dFJvd10gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeFtuZXh0Um93XVtjb2xdID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb2wgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobWF0cml4KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiBUSU1FIEdSSUQgVklFV1xuICAgICAqKioqKioqKioqL1xuXG4gICAgLyoqXG4gICAgICogTWFrZSBhcnJheSB3aXRoIHN0YXJ0IGFuZCBlbmQgdGltZXMgb24gZXZlbnRzLlxuICAgICAqIEB0aGlzIEJhc2UuV2Vla1xuICAgICAqIEBwYXJhbSB7YXJyYXlbXX0gbWF0cml4IC0gbWF0cml4IGZyb20gY29udHJvbGxlci5cbiAgICAgKiBAcmV0dXJucyB7YXJyYXlbXX0gc3RhcnR0aW1lLCBlbmR0aW1lIGFycmF5IChleGNsdWRlIGZpcnN0IHJvdydzIGV2ZW50cylcbiAgICAgKi9cbiAgICBnZW5lcmF0ZVRpbWVBcnJheUluUm93OiBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICAgICAgdmFyIHJvdyxcbiAgICAgICAgICAgIGNvbCxcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgbWFwID0gW10sXG4gICAgICAgICAgICBjdXJzb3IgPSBbXSxcbiAgICAgICAgICAgIG1heENvbExlbiA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHV0aWwubWFwKG1hdHJpeCwgZnVuY3Rpb24oY29sKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbC5sZW5ndGg7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgZm9yIChjb2wgPSAxOyBjb2wgPCBtYXhDb2xMZW47IGNvbCArPSAxKSB7XG4gICAgICAgICAgICByb3cgPSAwO1xuICAgICAgICAgICAgZXZlbnQgPSB1dGlsLnBpY2sobWF0cml4LCByb3csIGNvbCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChldmVudCkge1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoKFtldmVudC5nZXRTdGFydHMoKS5nZXRUaW1lKCksIGV2ZW50LmdldEVuZHMoKS5nZXRUaW1lKCldKTtcblxuICAgICAgICAgICAgICAgIHJvdyArPSAxO1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gdXRpbC5waWNrKG1hdHJpeCwgcm93LCBjb2wpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXAucHVzaChjdXJzb3IpO1xuICAgICAgICAgICAgY3Vyc29yID0gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29sbGlzaW9uIGluZm9ybWF0aW9uIGZyb20gbGlzdFxuICAgICAqIEB0aGlzIEJhc2UuV2Vla1xuICAgICAqIEBwYXJhbSB7YXJyYXkuPG51bWJlcltdPn0gYXJyIC0gbGlzdCB0byBkZXRlY3RpbmcgY29sbGlzaW9uLiBbW3N0YXJ0LCBlbmRdLCBbc3RhcnQsIGVuZF1dXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gZXZlbnQgc3RhcnQgdGltZSB0aGF0IHdhbnQgdG8gZGV0ZWN0IGNvbGxpc2lvbnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCAtIGV2ZW50IGVuZCB0aW1lIHRoYXQgd2FudCB0byBkZXRlY3QgY29sbGlzaW9ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdGFyZ2V0IGhhcyBjb2xsaWRlIGluIHN1cHBsaWVkIGFycmF5P1xuICAgICAqL1xuICAgIGhhc0NvbGxpZGU6IGZ1bmN0aW9uKGFyciwgc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgc3RhcnRTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0RW5kLFxuICAgICAgICAgICAgZW5kU3RhcnQsXG4gICAgICAgICAgICBlbmRFbmQsXG4gICAgICAgICAgICBnZXRGdW5jID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrW2luZGV4XTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFicyA9IE1hdGguYWJzLFxuICAgICAgICAgICAgY29tcGFyZSA9IGFycmF5LmNvbXBhcmUubnVtLmFzYyxcbiAgICAgICAgICAgIGhhc0NvbGxpZGU7XG5cbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydFN0YXJ0ID0gYWJzKGFycmF5LmJzZWFyY2goYXJyLCBzdGFydCwgZ2V0RnVuYygwKSwgY29tcGFyZSkpO1xuICAgICAgICBzdGFydEVuZCA9IGFicyhhcnJheS5ic2VhcmNoKGFyciwgc3RhcnQsIGdldEZ1bmMoMSksIGNvbXBhcmUpKTtcbiAgICAgICAgZW5kU3RhcnQgPSBhYnMoYXJyYXkuYnNlYXJjaChhcnIsIGVuZCwgZ2V0RnVuYygwKSwgY29tcGFyZSkpO1xuICAgICAgICBlbmRFbmQgPSBhYnMoYXJyYXkuYnNlYXJjaChhcnIsIGVuZCwgZ2V0RnVuYygxKSwgY29tcGFyZSkpO1xuICAgICAgICBoYXNDb2xsaWRlID0gIShzdGFydFN0YXJ0ID09PSBzdGFydEVuZCAmJiBzdGFydEVuZCA9PT0gZW5kU3RhcnQgJiYgZW5kU3RhcnQgPT09IGVuZEVuZCk7XG5cbiAgICAgICAgcmV0dXJuIGhhc0NvbGxpZGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdmFsdWVzIHRvIHZpZXdtb2RlbHMgZm9yIGRldGVjdCByZWFsIGNvbGxpc2lvbiBhdCByZW5kZXJpbmcgcGhhc2UuXG4gICAgICogQHRoaXMgQmFzZS5XZWVrXG4gICAgICogQHBhcmFtIHthcnJheVtdfSBtYXRyaWNlcyAtIE1hdHJpeCBkYXRhLlxuICAgICAqL1xuICAgIGdldENvbGxpZGVzOiBmdW5jdGlvbihtYXRyaWNlcykge1xuICAgICAgICB1dGlsLmZvckVhY2hBcnJheShtYXRyaWNlcywgZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICAgICAgICB2YXIgYmluYXJ5TWFwLFxuICAgICAgICAgICAgICAgIG1heFJvd0xlbmd0aDtcblxuICAgICAgICAgICAgYmluYXJ5TWFwID0gV2Vlay5nZW5lcmF0ZVRpbWVBcnJheUluUm93KG1hdHJpeCk7XG4gICAgICAgICAgICBtYXhSb3dMZW5ndGggPSBNYXRoLm1heC5hcHBseShudWxsLCB1dGlsLm1hcChtYXRyaXgsIGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiByb3cubGVuZ3RoO1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICB1dGlsLmZvckVhY2hBcnJheShtYXRyaXgsIGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgICAgIHV0aWwuZm9yRWFjaEFycmF5KHJvdywgZnVuY3Rpb24odmlld01vZGVsLCBjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDb2xsaWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZpZXdNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gdmlld01vZGVsLmdldFN0YXJ0cygpLmdldFRpbWUoKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGVuZFRpbWUgPSB2aWV3TW9kZWwuZ2V0RW5kcygpLmdldFRpbWUoKSAtIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gKGNvbCArIDEpOyBpIDwgbWF4Um93TGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NvbGxpZGUgPSBXZWVrLmhhc0NvbGxpZGUoYmluYXJ5TWFwW2kgLSAxXSwgc3RhcnRUaW1lLCBlbmRUaW1lKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0NvbGxpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZWwuaGFzQ29sbGlkZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdNb2RlbC5leHRyYVNwYWNlICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHRoaXMgQmFzZVxuICAgICAqIEBwYXJhbSB7RGF0ZX0gc3RhcnRzIC0gc3RhcnQgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0RhdGV9IGVuZHMgLSBlbmQgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0NvbGxlY3Rpb259IHRpbWUgLSB2aWV3IG1vZGVsIGNvbGxlY3Rpb24uXG4gICAgICogQHJldHVybnMge29iamVjdH0gdmlldyBtb2RlbCBmb3IgdGltZSBwYXJ0LlxuICAgICAqL1xuICAgIGdldFZpZXdNb2RlbEZvclRpbWVWaWV3OiBmdW5jdGlvbihzdGFydHMsIGVuZHMsIHRpbWUpIHtcbiAgICAgICAgdmFyIHltZFNwbGl0dGVkID0gdGhpcy5zcGxpdEV2ZW50QnlEYXRlUmFuZ2Uoc3RhcnRzLCBlbmRzLCB0aW1lKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIHV0aWwuZm9yRWFjaCh5bWRTcGxpdHRlZCwgZnVuY3Rpb24oY29sbGVjdGlvbiwgeW1kKSB7XG4gICAgICAgICAgICB2YXIgdmlld01vZGVscyA9IGNvbGxlY3Rpb24uc29ydChhcnJheS5jb21wYXJlLmV2ZW50LmFzYyksXG4gICAgICAgICAgICAgICAgY29sbGlzaW9uR3JvdXBzLFxuICAgICAgICAgICAgICAgIG1hdHJpY2VzO1xuXG4gICAgICAgICAgICBjb2xsaXNpb25Hcm91cHMgPSB0aGlzLmdldENvbGxpc2lvbkdyb3VwKHZpZXdNb2RlbHMpO1xuICAgICAgICAgICAgbWF0cmljZXMgPSB0aGlzLmdldE1hdHJpY2VzKGNvbGxlY3Rpb24sIGNvbGxpc2lvbkdyb3Vwcyk7XG4gICAgICAgICAgICB0aGlzLmdldENvbGxpZGVzKG1hdHJpY2VzKTtcblxuICAgICAgICAgICAgcmVzdWx0W3ltZF0gPSBtYXRyaWNlcztcbiAgICAgICAgfSwgV2Vlayk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiBBTExEQVkgVklFV1xuICAgICAqKioqKioqKioqL1xuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIHZpZXcgbW9kZWwgZm9yIGFsbGRheSB2aWV3IHBhcnQuXG4gICAgICogQHBhcmFtIHtEYXRlfSBzdGFydHMgc3RhcnQgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0RhdGV9IGVuZHMgZW5kIGRhdGUuXG4gICAgICogQHBhcmFtIHtDb2xsZWN0aW9ufSB2aWV3TW9kZWxzIC0gYWxsZGF5IGV2ZW50IHZpZXdNb2RlbCB2aWV3TW9kZWxzLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGFsbGRheSB2aWV3TW9kZWwuXG4gICAgICovXG4gICAgZ2V0Vmlld01vZGVsRm9yQWxsZGF5VmlldzogZnVuY3Rpb24oc3RhcnRzLCBlbmRzLCB2aWV3TW9kZWxzKSB7XG4gICAgICAgIHZhciBsaXN0LFxuICAgICAgICAgICAgeW1kc1RvUmVuZGVyLFxuICAgICAgICAgICAgY29sbGlzaW9uR3JvdXBzLFxuICAgICAgICAgICAgbWF0cmljZXM7XG5cbiAgICAgICAgaWYgKCF2aWV3TW9kZWxzIHx8ICF2aWV3TW9kZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgeW1kc1RvUmVuZGVyID0gdXRpbC5tYXAoXG4gICAgICAgICAgICBkYXRldGltZS5yYW5nZShzdGFydHMsIGVuZHMsIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZXRpbWUuZm9ybWF0KGRhdGUsICdZWVlZTU1ERCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGxpc3QgPSB2aWV3TW9kZWxzLnNvcnQoYXJyYXkuY29tcGFyZS5ldmVudC5hc2MpO1xuICAgICAgICBjb2xsaXNpb25Hcm91cHMgPSBXZWVrLmdldENvbGxpc2lvbkdyb3VwKGxpc3QpO1xuICAgICAgICBtYXRyaWNlcyA9IFdlZWsuZ2V0TWF0cmljZXModmlld01vZGVscywgY29sbGlzaW9uR3JvdXBzKTtcblxuICAgICAgICB1dGlsLmZvckVhY2hBcnJheShtYXRyaWNlcywgZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICAgICAgICB1dGlsLmZvckVhY2hBcnJheShtYXRyaXgsIGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHV0aWwuZm9yRWFjaEFycmF5KGNvbHVtbiwgZnVuY3Rpb24odmlld01vZGVsLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeW1kLCBkYXRlTGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmlld01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB5bWQgPSBkYXRldGltZS5mb3JtYXQodmlld01vZGVsLmdldFN0YXJ0cygpLCAnWVlZWU1NREQnKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUxlbmd0aCA9IGRhdGV0aW1lLnJhbmdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld01vZGVsLmdldFN0YXJ0cygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld01vZGVsLmdldEVuZHMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZXG4gICAgICAgICAgICAgICAgICAgICkubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIHZpZXdNb2RlbC50b3AgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdmlld01vZGVsLmxlZnQgPSB1dGlsLmluQXJyYXkoeW1kLCB5bWRzVG9SZW5kZXIpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZWwud2lkdGggPSBkYXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtYXRyaWNlcztcbiAgICB9LFxuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiBSRUFEXG4gICAgICoqKioqKioqKiovXG5cbiAgICAvKipcbiAgICAgKiBQb3B1bGF0ZSBldmVudHMgaW4gZGF0ZSByYW5nZS5cbiAgICAgKiBAdGhpcyBCYXNlXG4gICAgICogQHBhcmFtIHtEYXRlfSBzdGFydHMgc3RhcnQgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0RhdGV9IGVuZHMgZW5kIGRhdGUuXG4gICAgICogQHJldHVybnMge29iamVjdH0gZXZlbnRzIGdyb3VwZWQgYnkgZGF0ZXMuXG4gICAgICovXG4gICAgZmluZEJ5RGF0ZVJhbmdlOiBmdW5jdGlvbihzdGFydHMsIGVuZHMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgZXZlbnRzLFxuICAgICAgICAgICAgdmlld01vZGVscztcblxuICAgICAgICAvLyBRVUVSWSBFVkVOVFNcbiAgICAgICAgZXZlbnRzID0gdGhpcy5ldmVudHMuZmluZChmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAgICAgdmFyIG93blN0YXJ0cyA9IG1vZGVsLmdldFN0YXJ0cygpLFxuICAgICAgICAgICAgICAgIG93bkVuZHMgPSBtb2RlbC5nZXRFbmRzKCk7XG5cbiAgICAgICAgICAgIHJldHVybiAob3duU3RhcnRzID49IHN0YXJ0cyAmJiBvd25FbmRzIDw9IGVuZHMpIHx8XG4gICAgICAgICAgICAgICAgKG93blN0YXJ0cyA8IHN0YXJ0cyAmJiBvd25FbmRzID49IHN0YXJ0cykgfHxcbiAgICAgICAgICAgICAgICAob3duRW5kcyA+IGVuZHMgJiYgb3duU3RhcnRzIDw9IGVuZHMpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDT05WRVJUIFRPIFZJRVdNT0RFTFxuICAgICAgICB2aWV3TW9kZWxzID0gY29tbW9uLmNyZWF0ZUV2ZW50Q29sbGVjdGlvbi5hcHBseShcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICB1dGlsLm1hcChldmVudHMuaXRlbXMsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEV2ZW50Vmlld01vZGVsLmNyZWF0ZShldmVudCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApLmdyb3VwQnkoWydhbGxkYXknLCAndGltZSddLCB0aGlzLmdyb3VwRnVuYyk7XG5cbiAgICAgICAgLy8gQ1VTVE9NSVpFIFZJRVdNT0RFTCBGT1IgRUFDSCBWSUVXXG4gICAgICAgIHV0aWwuZm9yRWFjaCh2aWV3TW9kZWxzLCBmdW5jdGlvbihjb2xsLCBrZXksIG9iaikge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2FsbGRheScpIHtcbiAgICAgICAgICAgICAgICBjb2xsLmVhY2goZnVuY3Rpb24odmlld01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvd25TdGFydHMgPSB2aWV3TW9kZWwuZ2V0U3RhcnRzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBvd25FbmRzID0gdmlld01vZGVsLmdldEVuZHMoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3duU3RhcnRzIDwgc3RhcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZWwucmVuZGVyU3RhcnRzID0gbmV3IERhdGUoc3RhcnRzLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAob3duRW5kcyA+IGVuZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdNb2RlbC5yZW5kZXJFbmRzID0gbmV3IERhdGUoZW5kcy5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBvYmouYWxsZGF5ID0gdXRpbC5iaW5kKFdlZWsuZ2V0Vmlld01vZGVsRm9yQWxsZGF5VmlldywgdGhhdCkoc3RhcnRzLCBlbmRzLCBjb2xsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAndGltZScpIHtcbiAgICAgICAgICAgICAgICBvYmoudGltZSA9IHV0aWwuYmluZChXZWVrLmdldFZpZXdNb2RlbEZvclRpbWVWaWV3LCB0aGF0KShzdGFydHMsIGVuZHMsIGNvbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdmlld01vZGVscztcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlZWs7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBNb2R1bGUgZm9yIG1hbmFnZSBjYWxlbmRhciBSRVNUIEFQSSByZXF1ZXN0cy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBamF4ID0gcmVxdWlyZSgnLi4vY29tbW9uL2FqYXgnKTtcblxuLy8g7LqY66aw642UIEFQSSDquLDrs7ggUEFUSFxudmFyIFJPT1RfUEFUSCA9ICcvd2FwaS90YXNrLXRyYWNrZXInO1xuXG4vKioqKioqKioqKlxuICogQ0FMRU5EQVJcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIO2VtOuLuSDtlITroZzsoJ3tirjsnZgg7LqY66aw642UIOuqqeuhnSDtmZXsnbhcbiAqIEBtZW1iZXJvZiBDYWxlbmRhckFQSVxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9qZWN0Q29kZT0nKiddIC0g7ZSE66Gc7KCd7Yq4IOy9lOuTnCAnKicg7IKs7Jqp6rCA64qlXG4gKiBAcGFyYW0ge29iamVjdH0gYWpheE9wdGlvbnMgLSBhamF4IOuqqOuTiOyXkCDsgqzsmqntlaAg7Ji17IWYIOqwneyytFxuICovIFxuZnVuY3Rpb24gZ2V0Q2FsZW5kYXJzKHByb2plY3RDb2RlLCBhamF4T3B0aW9ucykge1xuICAgIHZhciB1cmwgPSAncHJvamVjdHMve3sgcHJvamVjdENvZGUgfX0vY2FsZW5kYXJzJztcbiAgICBwcm9qZWN0Q29kZSA9IHByb2plY3RDb2RlIHx8ICcqJztcbiAgICB1cmwgPSBST09UX1BBVEggKyAnLycgKyB1cmwucmVwbGFjZSgne3sgcHJvamVjdENvZGUgfX0nLCBwcm9qZWN0Q29kZSk7XG5cbiAgICBhamF4T3B0aW9ucyA9IGFqYXhPcHRpb25zIHx8IHt9O1xuXG4gICAgbmV3IEFqYXgoKS5hamF4KHVybCwgYWpheE9wdGlvbnMpO1xufVxuXG4vKipcbiAqIOy6mOumsOuNlCDrp4zrk6TquLBcbiAqIEBtZW1iZXJvZiBDYWxlbmRhckFQSVxuICogQHBhcmFtIHtzdHJpbmd9IHByb2plY3RDb2RlIC0g7ZSE66Gc7KCd7Yq4IOy9lOuTnFxuICogQHBhcmFtIHtzZXJ2aWNlL21vZGVsL2NhbGVuZGFyfSBkYXRhIC0g7LqY66aw642UIOyDneyEsSDqtIDroKgg642w7J207YSwXG4gKiBAcGFyYW0ge29iamVjdH0gYWpheE9wdGlvbnMgLSBhamF4IOuqqOuTiOyXkCDsgqzsmqntlaAg7Ji17IWYIOqwneyytFxuICovXG5mdW5jdGlvbiBwb3N0Q2FsZW5kYXJzKHByb2plY3RDb2RlLCBkYXRhLCBhamF4T3B0aW9ucykge1xuICAgIHZhciB1cmwgPSAncHJvamVjdHMve3sgcHJvamVjdENvZGUgfX0vY2FsZW5kYXJzJztcbiAgICBwcm9qZWN0Q29kZSA9IHByb2plY3RDb2RlIHx8ICcqJztcbiAgICB1cmwgPSBST09UX1BBVEggKyAnLycgKyB1cmwucmVwbGFjZSgne3sgcHJvamVjdENvZGUgfX0nLCBwcm9qZWN0Q29kZSk7XG5cbiAgICBhamF4T3B0aW9ucyA9IGFqYXhPcHRpb25zIHx8IHt9O1xuICAgIGFqYXhPcHRpb25zLmRhdGEgPSBKU09OLnN0cmluZ2lmeShbZGF0YV0pO1xuICAgIGFqYXhPcHRpb25zLm1ldGhvZCA9ICdQT1NUJztcblxuICAgIG5ldyBBamF4KCkuYWpheCh1cmwsIGFqYXhPcHRpb25zKTtcbn1cblxuLyoqKioqKioqKipcbiAqIFRBU0tcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIOydvOyglSDrqqnroZ0g7KGw7ZqMXG4gKiBAbWVtYmVyb2YgQ2FsZW5kYXJBUElcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvamVjdENvZGU9JyonXSAtIO2UhOuhnOygne2KuCDsvZTrk5xcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY2FsZW5kYXJJZD0nKiddIC0g7LqY66aw642UIElEXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RpbWVNaW5dIC0g7KGw7ZqM7Iuc7J6R7J287J6QXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RpbWVNYXhdIC0g7KGw7ZqMIOyiheujjOydvOyekFxuICogQHBhcmFtIHtvYmplY3R9IFthamF4T3B0aW9uc10gLSBhamF4IOuqqOuTiOyXkCDsgqzsmqntlaAg7Ji17IWYIOqwneyytFxuICovXG5mdW5jdGlvbiBnZXRDYWxlbmRhclRhc2tzKHByb2plY3RDb2RlLCBjYWxlbmRhcklkLCB0aW1lTWluLCB0aW1lTWF4LCBhamF4T3B0aW9ucykge1xuICAgIHZhciB1cmwgPSAncHJvamVjdHMve3sgcHJvamVjdENvZGUgfX0vY2FsZW5kYXJzL3t7IGNhbGVuZGFySWQgfX0vdGFza3MnICtcbiAgICAgICAgJz9jYWxlbmRhcnM9e3sgY2FsZW5kYXJzIH19JnRpbWVNaW49e3sgdGltZU1pbiB9fSZ0aW1lTWF4PXt7IHRpbWVNYXggfX0nO1xuXG4gICAgY2FsZW5kYXJJZCA9IGNhbGVuZGFySWQucmVwbGFjZSgvXFxzL2csICcnKTtcblxuICAgIHVybCA9IFJPT1RfUEFUSCArICcvJyArIHVybC5yZXBsYWNlKCd7eyBwcm9qZWN0Q29kZSB9fScsIHByb2plY3RDb2RlIHx8ICcqJylcbiAgICAgICAgLnJlcGxhY2UoJ3t7IGNhbGVuZGFySWQgfX0nLCB+Y2FsZW5kYXJJZC5pbmRleE9mKCcsJykgPyAnKicgOiBjYWxlbmRhcklkIHx8ICcqJylcbiAgICAgICAgLnJlcGxhY2UoJ3t7IGNhbGVuZGFycyB9fScsIH5jYWxlbmRhcklkLmluZGV4T2YoJywnKSA/IGNhbGVuZGFySWQgOiAnJylcbiAgICAgICAgLnJlcGxhY2UoJ3t7IHRpbWVNaW4gfX0nLCB0aW1lTWluIHx8ICcnKVxuICAgICAgICAucmVwbGFjZSgne3sgdGltZU1heCB9fScsIHRpbWVNYXggfHwgJycpO1xuXG4gICAgbmV3IEFqYXgoKS5hamF4KHVybCwgYWpheE9wdGlvbnMgfHwge30pO1xufVxuXG4vKipcbiAqIOy6mOumsOuNlOyXkCDqtIDroKjrkJwgQVBJ7Zi47LacIOq4sOuKpeydhCDrqqjslYTrkZQg66+57Iqk7J24IOuqqOuTiC4gc2VydmljZS9jYWxlbmRhciDrqqjrk4jsl5DshJwg7IKs7Jqp7ZWc64ukLlxuICogQG1peGluIENhbGVuZGFyQVBJXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gLyoqIEBsZW5kcyBDYWxlbmRhckFQSSAqLyB7XG4gICAgZ2V0Q2FsZW5kYXJzOiBnZXRDYWxlbmRhcnMsXG4gICAgcG9zdENhbGVuZGFyczogcG9zdENhbGVuZGFycyxcbiAgICBnZXRDYWxlbmRhclRhc2tzOiBnZXRDYWxlbmRhclRhc2tzXG59O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEludGVyZmFjZSBmb3IgRG9vcmF5QmFzZSBjb250cm9sbGVyIHRvIGFsbG93IHRhbGsgd2l0aCBkb29yYXkgQVBJIHNlcnZlclxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi8uLi9jb21tb24vY29tbW9uJyk7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBjYWxlbmRhckFQSSA9IHJlcXVpcmUoJy4uL2NhbGVuZGFyQVBJJyk7XG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9jb2xsZWN0aW9uJyk7XG52YXIgbm9vcCA9IChmdW5jdGlvbigpIHt9KTtcblxuLy8gbW9kZWxcbnZhciBEb29yYXlFdmVudCA9IHJlcXVpcmUoJy4uL21vZGVsL2V2ZW50Jyk7XG52YXIgQ2FsZW5kYXJSZWZlcmVuY2UgPSByZXF1aXJlKCcuLi9tb2RlbC9jYWxlbmRhcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGZvciBBUEkgbW9kdWxlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5iZWZvcmVSZXF1ZXN0XSAtIGZ1bmN0aW9uIGludm9rZSBiZWZvcmUgYWxsIHJlcXVlc3Qgc2VuZGluZ1xuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuYWZ0ZXJSZXNwb25zZV0gLSBmdW5jdGlvbiBpbnZva2UgYWZ0ZXIgYWxsIHJlcXVlc3QgcmVwb25kZWRcbiAqL1xuZnVuY3Rpb24gQVBJKG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgbWVtYmVyOiBudWxsLFxuICAgICAgICBiZWZvcmVSZXF1ZXN0OiBub29wLFxuICAgICAgICBhZnRlclJlc3BvbnNlOiBub29wXG4gICAgfSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICog66qo65OgIEFQSe2GteyLoOydtCDsi6TtjKjtlojsnYQg65WMIOuPmeyeke2VmOuKlCDsvZzrsLEg7ZW465Ok65+sIOuwmO2ZmFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSDsgqzsmqnsnpAg7L2c67CxIO2VqOyImFxuICogQHJldHVybnMge2Z1bmN0aW9ufSAtIEFQSeyLpO2MqCDtlbjrk6Trn6wg7ZWo7IiYXG4gKi9cbkFQSS5wcm90b3R5cGUuX29uRmFpbEZ1bmMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2sodHJ1ZSwgbnVsbCk7XG4gICAgfTtcbn07XG5cbi8qKlxuICog7LqY66aw642UIOuqqeuhnSDsobDtmowg7ZWo7IiYIOy6mOumsOuNlCDrqqnroZ3snYQg7L2c66CJ7IWYIO2Yle2DnOuhnCDrsJjtmZjtlZzri6RcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvamVjdENvZGU9JyonXSAtIOyhsO2ajO2VoCDtlITroZzsoJ3tirhcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gY29tbW9uIG5vZGVqcyBjb2xsYmFjayBmdW5jdGlvbi4g7LKrIOuyiOynuCDsnbjsnpDripQg7Jik66WYLCDrkZAg67KI7Ke4IOyduOyekOuKlCDsupjrprDrjZQg7L2c66CJ7IWY7J2EIOuwmO2ZmO2VnOuLpFxuICovXG5BUEkucHJvdG90eXBlLmdldENhbGVuZGFycyA9IGZ1bmN0aW9uKHByb2plY3RDb2RlLCBjYWxsYmFjaykge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBvbkZhaWwgPSB0aGlzLl9vbkZhaWxGdW5jKGNhbGxiYWNrKSxcbiAgICAgICAgY2FsZW5kYXJzID0gbmV3IENvbGxlY3Rpb24oZnVuY3Rpb24oY2FsZW5kYXJSZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxlbmRhclJlZi5pZCArICcnO1xuICAgICAgICB9KTtcblxuICAgIGNhbGVuZGFyQVBJLmdldENhbGVuZGFycyhwcm9qZWN0Q29kZSwge1xuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgIHZhciBkYXRhT2JqZWN0ID0gdXRpbC5waWNrKHJlcywgJ3Jlc3VsdCcsICdjYWxlbmRhcnMnKTtcblxuICAgICAgICAgICAgaWYgKGRhdGFPYmplY3QgJiYgZGF0YU9iamVjdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYWxlbmRhcnMuYWRkLmFwcGx5KGNhbGVuZGFycywgdXRpbC5tYXAoZGF0YU9iamVjdCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdCA9IG5ldyBDYWxlbmRhclJlZmVyZW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0LnVubWFyc2hhbChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3Q7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWxsYmFjayhmYWxzZSwgY2FsZW5kYXJzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IG9uRmFpbCxcbiAgICAgICAgZmFpbDogb25GYWlsLFxuICAgICAgICBjb21wbGV0ZTogb3B0aW9ucy5hZnRlclJlc3BvbnNlXG4gICAgfSk7XG5cbiAgICBvcHRpb25zLmJlZm9yZVJlcXVlc3QoKTtcbn07XG5cbkFQSS5wcm90b3R5cGUucG9zdENhbGVuZGFyID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgbWVtYmVyID0gb3B0aW9ucy5tZW1iZXIsXG4gICAgICAgIG9uRmFpbCA9IHRoaXMuX29uRmFpbEZ1bmMoY2FsbGJhY2spLFxuICAgICAgICBwcm9qZWN0Q29kZTtcblxuICAgIGlmIChkYXRhLnR5cGUgPT09ICdwcml2YXRlJykge1xuICAgICAgICAvLyDqsJzsnbgg7LqY66aw642U7J2YIOqyveyasCBwcm9qZWN0Q29kZeuKlCBAdXNlckNvZGVcbiAgICAgICAgcHJvamVjdENvZGUgPSAnQCcgKyBtZW1iZXIudXNlckNvZGU7XG4gICAgICAgIGRhdGEuZGVsZWdhdGlvbiA9IFtdO1xuICAgICAgICAvLyBkYXRhLmRlbGVnYXRpb24gPSBkYXRhLmRlbGVnYXRpb24gfHwgW107XG4gICAgICAgIGRhdGEuZGVsZWdhdGlvbi5wdXNoKHtcbiAgICAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICAgICAgICBpZDogbWVtYmVyLm9yZ01lbWJlcklkIFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBlcm1pc3Npb246ICdyZWFkX3dyaXRlJ1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjYWxlbmRhckFQSS5wb3N0Q2FsZW5kYXJzKHByb2plY3RDb2RlLCBkYXRhLCB7XG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UsIHJlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBvbkZhaWwsXG4gICAgICAgIGZhaWw6IG9uRmFpbCxcbiAgICAgICAgY29tcGxldGU6IG9wdGlvbnMuYWZ0ZXJSZXNwb25zZVxuICAgIH0pO1xuXG4gICAgb3B0aW9ucy5iZWZvcmVSZXF1ZXN0KCk7XG59O1xuXG4vKipcbiAqIOydvOyglSDrqqnroZ3snYQg7KGw7ZqM7ZWc64ukXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb2plY3RDb2RlPScqJ10gLSDtlITroZzsoJ3tirgg7L2U65OcXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NhbGVuZGFySWQ9JyonXSAtIOy6mOumsOuNlCBJRFxuICogQHBhcmFtIHtzdHJpbmd8RGF0ZX0gW3RpbWVNaW5dIC0g7KGw7ZqM7Iuc7J6R7J287J6QIFRpbWV6b25lIG9mZnNldCDsnYQg7Y+s7ZWo7ZWcIFVUQ+2VhOyalFxuICogQHBhcmFtIHtzdHJpbmd8RGF0ZX0gW3RpbWVNYXhdIC0g7KGw7ZqMIOyiheujjOydvOyekCBUaW1lem9uZSBvZmZzZXQg7J2EIO2PrO2VqO2VnCBVVEPtlYTsmpRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0g7L2c67CxIO2VqOyImC4g7LKrIOuyiOynuCDsnbjsnpDripQg7Jik66WYIOyXrOu2gCwg65GQIOuyiOynuCDsnbjsnpDripQg7J287KCVIOy9nOugieyFmFxuICovXG5BUEkucHJvdG90eXBlLmdldFRhc2tzID0gZnVuY3Rpb24ocHJvamVjdENvZGUsIGNhbGVuZGFySWQsIHRpbWVNaW4sIHRpbWVNYXgsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIG9uRmFpbCA9IHRoaXMuX29uRmFpbEZ1bmMoY2FsbGJhY2spLFxuICAgICAgICB0YXNrcyA9IGNvbW1vbi5jcmVhdGVFdmVudENvbGxlY3Rpb24oKTtcblxuICAgIHRpbWVNaW4gPSB1dGlsLmlzRGF0ZVNhZmUodGltZU1pbikgPyBkYXRldGltZS5mb3JtYXQodGltZU1pbiwgJ0xPQ0FMJykgOiB0aW1lTWluO1xuICAgIHRpbWVNYXggPSB1dGlsLmlzRGF0ZVNhZmUodGltZU1heCkgPyBkYXRldGltZS5mb3JtYXQodGltZU1heCwgJ0xPQ0FMJykgOiB0aW1lTWF4O1xuXG4gICAgY2FsZW5kYXJBUEkuZ2V0Q2FsZW5kYXJUYXNrcyhwcm9qZWN0Q29kZSwgY2FsZW5kYXJJZCwgdGltZU1pbiwgdGltZU1heCwge1xuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgIHZhciBkYXRhT2JqZWN0ID0gdXRpbC5waWNrKHJlcywgJ3Jlc3VsdCcsICd0YXNrcycpO1xuXG4gICAgICAgICAgICBpZiAoZGF0YU9iamVjdCAmJiBkYXRhT2JqZWN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRhc2tzLmFkZC5hcHBseSh0YXNrcywgdXRpbC5tYXAoZGF0YU9iamVjdCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdCA9IG5ldyBEb29yYXlFdmVudCgpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0LnVubWFyc2hhbChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3Q7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWxsYmFjayhmYWxzZSwgdGFza3MpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogb25GYWlsLFxuICAgICAgICBmYWlsOiBvbkZhaWwsXG4gICAgICAgIGNvbXBsZXRlOiBvcHRpb25zLmFmdGVyUmVzcG9uc2VcbiAgICB9KTtcblxuICAgIG9wdGlvbnMuYmVmb3JlUmVxdWVzdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBUEk7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBCYXNlIGNvbnRyb2xsZXIgZm9yIERvb3JheSBzZXJ2aWNlIHByb2plY3QuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIEJhc2UgPSByZXF1aXJlKCcuLi8uLi9jb250cm9sbGVyL2Jhc2UnKTtcbnZhciBEb29yYXlFdmVudCA9IHJlcXVpcmUoJy4uL21vZGVsL2V2ZW50Jyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIGJhc2UgY29udHJvbGxlclxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZ3JvdXBGdW5jXSAtIGZ1bmN0aW9uIGZvciBncm91cCBlYWNoIG1vZGVscyB7QHNlZSBDb2xsZWN0aW9uI2dyb3VwQnl9XG4gKiBAZXh0ZW5kcyB7QmFzZX1cbiAqL1xuZnVuY3Rpb24gRG9vcmF5QmFzZShvcHRpb25zKSB7XG4gICAgQmFzZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG51dGlsLmluaGVyaXQoRG9vcmF5QmFzZSwgQmFzZSk7XG5cbi8qKioqKioqKioqXG4gKiBDUlVEIG92ZXJyaWRlXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBDcmVhdGUgYW4gZXZlbnQgaW5zdGFuY2UgZnJvbSByYXcgZGF0YS5cbiAqIEBvdmVycmlkZVxuICogQGVtaXRzIEJhc2UjY3JlYXRlZEV2ZW50XG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBEYXRhIG9iamVjdCB0byBjcmVhdGUgZXZlbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudCAtIHNldCB0cnVlIHRoZW4gZG9uJ3QgZmlyZSBldmVudHMuXG4gKiBAcmV0dXJucyB7RXZlbnR9IFRoZSBpbnN0YW5jZSBvZiBFdmVudCB0aGF0IGNyZWF0ZWQuXG4gKi9cbkRvb3JheUJhc2UucHJvdG90eXBlLmNyZWF0ZUV2ZW50ID0gZnVuY3Rpb24ob3B0aW9ucywgc2lsZW50KSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5hZGRFdmVudChEb29yYXlFdmVudC5jcmVhdGUob3B0aW9ucykpO1xuXG4gICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBCYXNlI2NyZWF0ZWRFdmVudFxuICAgICAgICAgKiBAdHlwZSB7RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpcmUoJ2NyZWF0ZWRFdmVudCcsIGV2ZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERvb3JheUJhc2U7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBDb25maWd1cmF0aW9uIG1vZHVsZSBmb3IgZG9vcmF5IHByb2plY3QuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIOydvOyglSDsubTthYzqs6DrpqxcbiAqIEByZWFkb25seVxuICogQGVudW0ge3N0cmluZ31cbiAqL1xudmFyIEVWRU5UX0NBVEVHT1JZID0ge1xuICAgIEdFTkVSQUw6ICdnZW5lcmFsJyxcbiAgICBUQVNLOiAndGFzaycsXG4gICAgTUlMRVNUT05FOiAnbWlsZXN0b25lJ1xufTtcblxuLyoqXG4gKiDtg5zsiqTtgawg66eI6rCQ7Iuc6rCEIOu2hOulmFxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG52YXIgRFVFX0RBVEVfQ0xBU1MgPSB7XG4gICAgTU9STklORzogJ21vcm5pbmcnLFxuICAgIExVTkNIOiAnbHVuY2gnLFxuICAgIEVWRU5JTkc6ICdldmVuaW5nJ1xufTtcblxuLyoqXG4gKiDsupjrprDrjZQg7JWE7J207YWc7J2YIO2DgOyehVxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG52YXIgQ0FMRU5EQVJfSVRFTV9UWVBFID0ge1xuICAgIFBSSVZBVEU6ICdwcml2YXRlJywgICAgLy8g6rCc7J24IOy6mOumsOuNlFxuICAgIFNIQVJFRDogJ3NoYXJlZCcgICAgICAgLy8g6rO17JygIOy6mOumsOuNlFxufTtcblxuLyoqXG4gKiDsupjrprDrjZTsl5Ag64yA7ZWcIOyCrOyaqeyekOydmCDqtoztlZxcbiAqIEByZWFkb25seVxuICogQGVudW0ge3N0cmluZ31cbiAqL1xudmFyIENBTEVOREFSX0lURU1fUEVSTUlTU0lPTiA9IHtcbiAgICBPV05FUjogJ293bmVyJyxcbiAgICBPUEFRVUVfVklFVzogJ29wYXF1ZV92aWV3JyxcbiAgICBWSUVXOiAndmlldycsXG4gICAgUkVBRF9XUklURTogJ3JlYWRfd3JpdGUnLFxuICAgIEFMTDogJ2FsbCdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG1vZGVsOiB7XG4gICAgICAgIEVWRU5UX0NBVEVHT1JZOiBFVkVOVF9DQVRFR09SWSxcbiAgICAgICAgRFVFX0RBVEVfQ0xBU1M6IERVRV9EQVRFX0NMQVNTLFxuICAgICAgICBDQUxFTkRBUl9JVEVNX1RZUEU6IENBTEVOREFSX0lURU1fVFlQRSxcbiAgICAgICAgQ0FMRU5EQVJfSVRFTV9QRVJNSVNTSU9OOiBDQUxFTkRBUl9JVEVNX1BFUk1JU1NJT05cbiAgICB9XG59O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENhbGVuZGFyIGZvciBzZXJ2aWNlLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBkYXRldGltZSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kYXRldGltZScpO1xuXG4vLyBGQUNUT1JZXG52YXIgQ2FsZW5kYXIgPSByZXF1aXJlKCcuLi8uLi9mYWN0b3J5L2NhbGVuZGFyJyk7XG5cbi8vIENPTlRST0xMRVJcbnZhciBEb29yYXlCYXNlID0gcmVxdWlyZSgnLi4vY29udHJvbGxlci9iYXNlJyk7XG52YXIgV2VlayA9IHJlcXVpcmUoJy4uLy4uL2NvbnRyb2xsZXIvdmlld01peGluL3dlZWsnKTtcblxuLy8gVklFV1xudmFyIHNlcnZpY2VXZWVrVmlld0ZhY3RvcnkgPSByZXF1aXJlKCcuL3dlZWtWaWV3Jyk7XG5cbi8vIEFQSVxuLy8gdmFyIGNhbGVuZGFyQVBJID0gcmVxdWlyZSgnLi4vY2FsZW5kYXJBUEknKTtcbnZhciBBUEkgPSByZXF1aXJlKCcuLi9jb250cm9sbGVyL2FwaScpO1xuXG52YXIgZW51bXMgPSByZXF1aXJlKCcuLi9lbnVtcycpO1xuXG4vKipcbiAqIENhbGVuZGFyIGZhY3RvciBtb2R1bGUgZm9yIHNlcnZpY2UgKGRvb3JheSlcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0NhbGVuZGFyfVxuICogQG1peGVkIHtDYWxlbmRhckFQSX1cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgY2FsZW5kYXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmdyb3VwRnVuY10gLSBmdW5jdGlvbiBmb3IgZ3JvdXAgZXZlbnQgbW9kZWxzIHtAc2VlIENvbGxlY3Rpb24jZ3JvdXBCeX1cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmNvbnRyb2xsZXJdIC0gY29udHJvbGxlciBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRlZmF1bHRWaWV3PSd3ZWVrJ10gLSBkZWZhdWx0IHZpZXcgb2YgY2FsZW5kYXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLm1lbWJlciAtIG1lbWJlciBpbmZvcm1hdGlvbiBmcm9tIGRvb3JheSBzZXJ2ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5tZW1iZXIub3JnTWVtYmVySWQgLSB1c2VyIGlkXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5tZW1iZXIudXNlckNvZGUgLSB1c2VyIGNvZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy53ZWVrXSAtIG9wdGlvbnMgZm9yIHdlZWsgdmlld1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMud2Vlay5yZW5kZXJTdGFydERhdGUgLSBZWVlZLU1NLUREIHJlbmRlciBzdGFydCBkYXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy53ZWVrLnJlbmRlckVuZERhdGUgLSBZWVlZLU1NLUREIHJlbmRlciBlbmQgZGF0ZVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm1vbnRoXSAtIG9wdGlvbnMgZm9yIG1vbnRoIHZpZXdcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm1vbnRoLnJlbmRlck1vbnRoIC0gWVlZWS1NTSByZW5kZXIgbW9udGhcbiAqIEBwYXJhbSB7SFRNTERpdkVsZW1lbnR9IGNvbnRhaW5lciA9IGNvbnRhaW5lciBlbGVtZW50IGZvciBjYWxlbmRhclxuICovXG5mdW5jdGlvbiBTZXJ2aWNlQ2FsZW5kYXIob3B0aW9ucywgY29udGFpbmVyKSB7XG4gICAgLyoqXG4gICAgICog7ISc67mE7Iqk7JeQ7IScIOyCrOyaqeuQmOuKlCDrqqjrjbgg6rWs67aE7JqpIOyYteyFmCDtlajsiJhcbiAgICAgKiBAcGFyYW0ge0V2ZW50Vmlld01vZGVsfSB2aWV3TW9kZWwgLSBEb29yYXlFdmVudOulvCDrnpjtlZHtlZwg67ewIOuqqOuNuFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IOq1rOu2hCDtgqQg6rCSXG4gICAgICovXG4gICAgb3B0aW9ucy5ncm91cEZ1bmMgPSBmdW5jdGlvbih2aWV3TW9kZWwpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdmlld01vZGVsLm1vZGVsLFxuICAgICAgICAgICAgY2F0ZWdvcnkgPSBtb2RlbC5jYXRlZ29yeSxcbiAgICAgICAgICAgIGlzQWxsRGF5ID0gbW9kZWwuaXNBbGxEYXk7XG5cbiAgICAgICAgaWYgKGNhdGVnb3J5ID09PSBlbnVtcy5tb2RlbC5FVkVOVF9DQVRFR09SWS5UQVNLKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Rhc2snO1xuICAgICAgICB9IGVsc2UgaWYgKGNhdGVnb3J5ID09PSBlbnVtcy5tb2RlbC5FVkVOVF9DQVRFR09SWS5HRU5FUkFMKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBbGxEYXkgPyAnYWxsZGF5JyA6ICd0aW1lJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnbWlsZXN0b25lJztcbiAgICB9O1xuXG4gICAgLy8g7Luo7Yq466Gk65+sIOunjOuTpOq4sFxuICAgIG9wdGlvbnMuY29udHJvbGxlciA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBuZXcgRG9vcmF5QmFzZShvcHRpb25zKSxcbiAgICAgICAgICAgIG9yaWdpbkZpbmRCeURhdGVSYW5nZTtcblxuICAgICAgICBjb250cm9sbGVyLldlZWsgPSB7fTtcbiAgICAgICAgdXRpbC5mb3JFYWNoKFdlZWssIGZ1bmN0aW9uKG1ldGhvZCwgbWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5XZWVrW21ldGhvZE5hbWVdID0gdXRpbC5iaW5kKG1ldGhvZCwgY29udHJvbGxlcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIOuniOydvOyKpO2GpCwg7JeF66y0IOu3sCDsmqkg67ew66qo6424IOyymOumrOq4sCDstpTqsIBcbiAgICAgICAgb3JpZ2luRmluZEJ5RGF0ZVJhbmdlID0gY29udHJvbGxlci5XZWVrLmZpbmRCeURhdGVSYW5nZTtcbiAgICAgICAgY29udHJvbGxlci5XZWVrLmZpbmRCeURhdGVSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0cywgZW5kcykge1xuICAgICAgICAgICAgdmFyIGRhdGVSYW5nZSA9IHV0aWwubWFwKGRhdGV0aW1lLnJhbmdlKFxuICAgICAgICAgICAgICAgICAgICBkYXRldGltZS5zdGFydChzdGFydHMpLFxuICAgICAgICAgICAgICAgICAgICBkYXRldGltZS5lbmQoZW5kcyksXG4gICAgICAgICAgICAgICAgICAgIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZXG4gICAgICAgICAgICAgICAgKSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZXRpbWUuZm9ybWF0KGQsICdZWVlZLU1NLUREJyk7IH0pLFxuICAgICAgICAgICAgICAgIHZpZXdNb2RlbCA9IG9yaWdpbkZpbmRCeURhdGVSYW5nZShzdGFydHMsIGVuZHMpO1xuXG4gICAgICAgICAgICB1dGlsLmZvckVhY2godmlld01vZGVsLCBmdW5jdGlvbihjb2xsLCBrZXksIG9iaikge1xuICAgICAgICAgICAgICAgIHZhciBncm91cGVkQnlZTUQ7XG5cbiAgICAgICAgICAgICAgICAvLyDrp4jsnbzsiqTthqQsIOyXheustCDrt7Ag67ew66qo6424IOqwgOqztVxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICd0YXNrJyB8fCBrZXkgPT09ICdtaWxlc3RvbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwZWRCeVlNRCA9IGNvbGwuZ3JvdXBCeShkYXRlUmFuZ2UsIGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGV0aW1lLmZvcm1hdCh2aWV3TW9kZWwubW9kZWwuZW5kcywgJ1lZWVktTU0tREQnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3Rhc2snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmZvckVhY2goZ3JvdXBlZEJ5WU1ELCBmdW5jdGlvbihjb2xsLCB5bWQsIG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialt5bWRdID0gY29sbC5ncm91cEJ5KGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlld01vZGVsLm1vZGVsLmR1ZURhdGVDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSBncm91cGVkQnlZTUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB2aWV3TW9kZWw7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgfSkoKTtcblxuICAgIENhbGVuZGFyLmNhbGwodGhpcywgb3B0aW9ucywgY29udGFpbmVyKTtcblxuICAgIHRoaXMuYXBpID0gbmV3IEFQSSh7XG4gICAgICAgIG1lbWJlcjogb3B0aW9ucy5tZW1iZXIsXG4gICAgICAgIGJlZm9yZVJlcXVlc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2JlZm9yZScpO1xuICAgICAgICB9LFxuICAgICAgICBhZnRlclJlc3BvbnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhZnRlcicpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbnV0aWwuaW5oZXJpdChTZXJ2aWNlQ2FsZW5kYXIsIENhbGVuZGFyKTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuU2VydmljZUNhbGVuZGFyLnByb3RvdHlwZS50b2dnbGVWaWV3ID0gZnVuY3Rpb24odmlld05hbWUsIGZvcmNlKSB7XG4gICAgdmFyIHZpZXcgPSB0aGlzLnZpZXcsXG4gICAgICAgIGNvbnRyb2xsZXIgPSB0aGlzLmNvbnRyb2xsZXIsXG4gICAgICAgIGRyYWdIYW5kbGVyID0gdGhpcy5kcmFnSGFuZGxlcixcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmICghZm9yY2UgJiYgdGhpcy5jdXJyZW50Vmlld05hbWUgPT09IHZpZXdOYW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRWaWV3TmFtZSA9IHZpZXdOYW1lO1xuICAgIHZpZXcuY2xlYXIoKTtcblxuICAgIGlmICh2aWV3TmFtZSA9PT0gJ3dlZWsnKSB7XG4gICAgICAgIHZpZXcuYWRkQ2hpbGQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VydmljZVdlZWtWaWV3RmFjdG9yeShjb250cm9sbGVyLCB2aWV3LmNvbnRhaW5lciwgZHJhZ0hhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2VDYWxlbmRhcjtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEZhY3RvcnkgbW9kdWxlIGZvciBXZWVrVmlldyAoY3VzdG9taXplZCBmb3Igc2VydmljZSlcbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG5cbi8vIFBhcmVudCB2aWV3c1xudmFyIFdlZWsgPSByZXF1aXJlKCcuLi8uLi92aWV3L3dlZWsvd2VlaycpO1xuXG4vLyBTdWIgdmlld3NcbnZhciBEYXlOYW1lID0gcmVxdWlyZSgnLi4vLi4vdmlldy93ZWVrL2RheW5hbWUnKTtcbnZhciBNaWxlc3RvbmUgPSByZXF1aXJlKCcuLi92aWV3L21pbGVzdG9uZScpO1xudmFyIFRhc2tWaWV3ID0gcmVxdWlyZSgnLi4vdmlldy90YXNrdmlldycpO1xudmFyIFRpbWVHcmlkID0gcmVxdWlyZSgnLi4vLi4vdmlldy93ZWVrL3RpbWVHcmlkJyk7XG52YXIgQWxsZGF5ID0gcmVxdWlyZSgnLi4vLi4vdmlldy93ZWVrL2FsbGRheScpO1xuXG5cbi8vIEhhbmRsZXJzXG52YXIgQWxsZGF5Q3JlYXRpb24gPSByZXF1aXJlKCcuLi8uLi9oYW5kbGVyL2FsbGRheS9jcmVhdGlvbicpO1xudmFyIEFsbGRheU1vdmUgPSByZXF1aXJlKCcuLi8uLi9oYW5kbGVyL2FsbGRheS9tb3ZlJyk7XG52YXIgQWxsZGF5UmVzaXplID0gcmVxdWlyZSgnLi4vLi4vaGFuZGxlci9hbGxkYXkvcmVzaXplJyk7XG52YXIgVGltZUNyZWF0aW9uID0gcmVxdWlyZSgnLi4vLi4vaGFuZGxlci90aW1lL2NyZWF0aW9uJyk7XG52YXIgVGltZU1vdmUgPSByZXF1aXJlKCcuLi8uLi9oYW5kbGVyL3RpbWUvbW92ZScpO1xudmFyIFRpbWVSZXNpemUgPSByZXF1aXJlKCcuLi8uLi9oYW5kbGVyL3RpbWUvcmVzaXplJyk7XG5cbi8vIEJhc2UgVGVtcGxhdGVzXG52YXIgd2Vla1ZpZXdUbXBsID0gcmVxdWlyZSgnLi4vLi4vZG9vcmF5L3ZpZXcvdGVtcGxhdGUvZmFjdG9yeS93ZWVrVmlldy5oYnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiYXNlQ29udHJvbGxlciwgbGF5b3V0Q29udGFpbmVyLCBkcmFnSGFuZGxlciwgb3B0aW9ucykge1xuICAgIHZhciB3ZWVrVmlldyxcbiAgICAgICAgZGF5TmFtZVZpZXcsXG4gICAgICAgIG1pbGVzdG9uZVZpZXcsXG4gICAgICAgIHRhc2tWaWV3LFxuICAgICAgICBhbGxkYXlWaWV3LFxuICAgICAgICB0aW1lR3JpZFZpZXcsXG4gICAgICAgIGFsbGRheU9wdGlvbnMsXG4gICAgICAgIGFsbGRheUNyZWF0aW9uSGFuZGxlcixcbiAgICAgICAgYWxsZGF5TW92ZUhhbmRsZXIsXG4gICAgICAgIGFsbGRheVJlc2l6ZUhhbmRsZXIsXG4gICAgICAgIHRpbWVDcmVhdGlvbkhhbmRsZXIsXG4gICAgICAgIHRpbWVNb3ZlSGFuZGxlcixcbiAgICAgICAgdGltZVJlc2l6ZUhhbmRsZXI7XG5cbiAgICB3ZWVrVmlldyA9IG5ldyBXZWVrKG51bGwsIG9wdGlvbnMud2VlaywgbGF5b3V0Q29udGFpbmVyKTtcblxuICAgIHdlZWtWaWV3LmNvbnRhaW5lci5pbm5lckhUTUwgPSB3ZWVrVmlld1RtcGwoKTtcblxuICAgIC8vIERheW5hbWVcbiAgICBkYXlOYW1lVmlldyA9IG5ldyBEYXlOYW1lKG51bGwsIGRvbXV0aWwuZmluZCgnLnNjaGVkdWxlLXZpZXctZGF5bmFtZS1sYXlvdXQnLCB3ZWVrVmlldy5jb250YWluZXIpKTtcbiAgICB3ZWVrVmlldy5hZGRDaGlsZChkYXlOYW1lVmlldyk7XG5cbiAgICAvKioqKioqKioqKlxuICAgICAqIEFsbERheSBWaWV3XG4gICAgICoqKioqKioqKiovXG4gICAgYWxsZGF5T3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgdGl0bGU6IG51bGwsXG4gICAgICAgIGhlaWdodDogMjBcbiAgICB9LCBvcHRpb25zLndlZWspO1xuXG4gICAgZnVuY3Rpb24gZ2V0Vmlld01vZGVsRnVuYyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdNb2RlbC5ldmVudHNJbkRhdGVSYW5nZVtrZXldO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyDrp4jsnbzsiqTthqQg67ewXG4gICAgbWlsZXN0b25lVmlldyA9IG5ldyBNaWxlc3RvbmUob3B0aW9ucy53ZWVrLCBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LW1pbGVzdG9uZS1sYXlvdXQnKSk7XG4gICAgd2Vla1ZpZXcuYWRkQ2hpbGQobWlsZXN0b25lVmlldyk7XG5cbiAgICAvLyDsl4XrrLQg67ewXG4gICAgdGFza1ZpZXcgPSBuZXcgVGFza1ZpZXcob3B0aW9ucy53ZWVrLCBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LW1pbGVzdG9uZS1sYXlvdXQnKSk7XG4gICAgd2Vla1ZpZXcuYWRkQ2hpbGQodGFza1ZpZXcpO1xuXG4gICAgLy8gQWxsZGF5IC0gd2hvbGVEYXlcbiAgICBhbGxkYXlPcHRpb25zLnRpdGxlID0gJ+yiheydvOydvOyglSc7XG4gICAgYWxsZGF5T3B0aW9ucy5fZ2V0Vmlld01vZGVsRnVuYyA9IGdldFZpZXdNb2RlbEZ1bmMoJ2FsbGRheScpO1xuICAgIGFsbGRheVZpZXcgPSBuZXcgQWxsZGF5KG9wdGlvbnMud2VlaywgZG9tdXRpbC5maW5kKCcuc2NoZWR1bGUtdmlldy1hbGxkYXktbGF5b3V0Jywgd2Vla1ZpZXcuY29udGFpbmVyKSk7XG4gICAgYWxsZGF5Q3JlYXRpb25IYW5kbGVyID0gbmV3IEFsbGRheUNyZWF0aW9uKGRyYWdIYW5kbGVyLCBhbGxkYXlWaWV3LCBiYXNlQ29udHJvbGxlcik7XG4gICAgYWxsZGF5TW92ZUhhbmRsZXIgPSBuZXcgQWxsZGF5TW92ZShkcmFnSGFuZGxlciwgYWxsZGF5VmlldywgYmFzZUNvbnRyb2xsZXIpO1xuICAgIGFsbGRheVJlc2l6ZUhhbmRsZXIgPSBuZXcgQWxsZGF5UmVzaXplKGRyYWdIYW5kbGVyLCBhbGxkYXlWaWV3LCBiYXNlQ29udHJvbGxlcik7XG4gICAgd2Vla1ZpZXcuYWRkQ2hpbGQoYWxsZGF5Vmlldyk7XG5cbiAgICAvKioqKioqKioqKlxuICAgICAqIFRpbWVHcmlkIFZpZXdcbiAgICAgKioqKioqKioqKi9cbiAgICB0aW1lR3JpZFZpZXcgPSBuZXcgVGltZUdyaWQob3B0aW9ucy53ZWVrLCBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LXRpbWVncmlkLWxheW91dCcsIHdlZWtWaWV3LmNvbnRhaW5lcikpO1xuICAgIHRpbWVDcmVhdGlvbkhhbmRsZXIgPSBuZXcgVGltZUNyZWF0aW9uKGRyYWdIYW5kbGVyLCB0aW1lR3JpZFZpZXcsIGJhc2VDb250cm9sbGVyKTtcbiAgICB0aW1lTW92ZUhhbmRsZXIgPSBuZXcgVGltZU1vdmUoZHJhZ0hhbmRsZXIsIHRpbWVHcmlkVmlldywgYmFzZUNvbnRyb2xsZXIpO1xuICAgIHRpbWVSZXNpemVIYW5kbGVyID0gbmV3IFRpbWVSZXNpemUoZHJhZ0hhbmRsZXIsIHRpbWVHcmlkVmlldywgYmFzZUNvbnRyb2xsZXIpO1xuXG4gICAgd2Vla1ZpZXcuaGFuZGxlcnMgPSB7XG4gICAgICAgIGFsbGRheToge1xuICAgICAgICAgICAgY3JlYXRpb246IGFsbGRheUNyZWF0aW9uSGFuZGxlcixcbiAgICAgICAgICAgIG1vdmU6IGFsbGRheU1vdmVIYW5kbGVyLFxuICAgICAgICAgICAgcmVzaXplOiBhbGxkYXlSZXNpemVIYW5kbGVyXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWU6IHtcbiAgICAgICAgICAgIGNyZWF0aW9uOiB0aW1lQ3JlYXRpb25IYW5kbGVyLFxuICAgICAgICAgICAgbW92ZTogdGltZU1vdmVIYW5kbGVyLFxuICAgICAgICAgICAgcmVzaXplOiB0aW1lUmVzaXplSGFuZGxlclxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHdlZWtWaWV3LmFkZENoaWxkKHRpbWVHcmlkVmlldyk7XG5cbiAgICAvLyBhZGQgY29udHJvbGxlclxuICAgIHdlZWtWaWV3LmNvbnRyb2xsZXIgPSBiYXNlQ29udHJvbGxlci5XZWVrO1xuXG4gICAgLy8gYWRkIGRlc3Ryb3lcbiAgICB3ZWVrVmlldy5fYmVmb3JlRGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aW1lQ3JlYXRpb25IYW5kbGVyLm9mZigpO1xuICAgICAgICB0aW1lTW92ZUhhbmRsZXIub2ZmKCk7XG4gICAgICAgIHRpbWVSZXNpemVIYW5kbGVyLm9mZigpO1xuICAgICAgICB0aW1lQ3JlYXRpb25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGltZU1vdmVIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGltZVJlc2l6ZUhhbmRsZXIuZGVzdHJveSgpO1xuXG4gICAgICAgIGFsbGRheUNyZWF0aW9uSGFuZGxlci5vZmYoKTtcbiAgICAgICAgYWxsZGF5TW92ZUhhbmRsZXIub2ZmKCk7XG4gICAgICAgIGFsbGRheVJlc2l6ZUhhbmRsZXIub2ZmKCk7XG4gICAgICAgIGFsbGRheUNyZWF0aW9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgIGFsbGRheU1vdmVIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgYWxsZGF5UmVzaXplSGFuZGxlci5kZXN0cm95KCk7XG5cbiAgICAgICAgZGVsZXRlIHdlZWtWaWV3LmhhbmRsZXJzLnRpbWU7XG4gICAgICAgIGRlbGV0ZSB3ZWVrVmlldy5oYW5kbGVycy5hbGxkYXk7XG5cbiAgICAgICAgdGltZUNyZWF0aW9uSGFuZGxlciA9IHRpbWVNb3ZlSGFuZGxlciA9IHRpbWVSZXNpemVIYW5kbGVyID0gbnVsbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHdlZWtWaWV3O1xufTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBDYWxuZGFyIHJlZmVyZW5jZSBtb2RlbCBmb3IgRG9vcmF5IENhbGVuZGFyIHNlcnZpY2VcbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGVudW1zID0gcmVxdWlyZSgnLi4vZW51bXMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ2FsZW5kYXJSZWZlcmVuY2UoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9ICcnO1xuXG4gICAgLyoqXG4gICAgICog7LqY66aw642UIO2DgOyehSAo6riw67O46rCSOiBwcml2YXRlKVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gZW51bXMubW9kZWwuQ0FMRU5EQVJfSVRFTV9UWVBFLlBSSVZBVEU7XG5cbiAgICAvKipcbiAgICAgKiDsupjrprDrjZTsl5Ag64yA7ZWcIOyCrOyaqeyekOydmCDqtoztlZwgKOq4sOuzuOqwkjogb3duZXIpXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnBlcm1pc3Npb24gPSBlbnVtcy5tb2RlbC5DQUxFTkRBUl9JVEVNX1BFUk1JU1NJT04uT1dORVI7XG5cbiAgICAvKipcbiAgICAgKiDquLDrs7gg7LqY66aw642UIOyXrOu2gFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNEZWZhdWx0ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiDsupjrprDrjZQg7IOJ7IOBICPsnYQg7KCc7Jm47ZWcIDbsnpDrpqwgaGV47L2U65OcIOqwklxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jb2xvciA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnJhdyA9IG51bGw7XG59XG5cbi8qKlxuICogVW5tYXJzaGFsIG9iamVjdCBmcm9tIHNlcnZlciBBUEkgcmVzcG9uc2UgZGF0YVxuICogQHBhcmFtIHtvYmplY3R9IGRhdGFPYmplY3QgLSBkYXRhIG9iamVjdCBmcm9tIHNlcnZlciBBUEkgcmVzcG9uc2VcbiAqL1xuQ2FsZW5kYXJSZWZlcmVuY2UucHJvdG90eXBlLnVubWFyc2hhbCA9IGZ1bmN0aW9uKGRhdGFPYmplY3QpIHtcbiAgICB0aGlzLmlkID0gZGF0YU9iamVjdC5pZCB8fCAnJztcblxuICAgIHRoaXMubmFtZSA9IGRhdGFPYmplY3QubmFtZSB8fCAnJztcbiAgICB0aGlzLnR5cGUgPSBkYXRhT2JqZWN0LnR5cGUgfHwgJyc7XG4gICAgdGhpcy5wZXJtaXNzaW9uID0gZGF0YU9iamVjdC5wZXJtaXNzaW9uIHx8ICcnO1xuICAgIHRoaXMuaXNEZWZhdWx0ID0gZGF0YU9iamVjdFsnZGVmYXVsdCddID8gdHJ1ZSA6IGZhbHNlO1xuICAgIHRoaXMuY29sb3IgPSBkYXRhT2JqZWN0LmNvbG9yIHx8ICdmZmZmZmYnO1xuICAgIHRoaXMucmF3ID0gZGF0YU9iamVjdDtcbn07XG5cbi8qKlxuICogTWFyc2hhbCBvYmplY3QgdG8gY29tbXVuaWNhdGUgd2l0aCBkb29yYXkgdGFzayB0cmFja2VyIEFQSSBzZXJ2ZXJcbiAqIEByZXR1cm5zIHtvYmplY3R9IGRhdGEgb2JqZWN0IGNhbiBkb29yYXkgc2VydmVyIGFjY2VwdGFibGVcbiAqL1xuQ2FsZW5kYXJSZWZlcmVuY2UucHJvdG90eXBlLm1hcnNoYWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0gdXRpbC5leHRlbmQoe30sIHRoaXMucmF3KTtcblxuICAgIHJlc3VsdC5uYW1lID0gdGhpcy5uYW1lO1xuICAgIHJlc3VsdC50eXBlID0gdGhpcy50eXBlO1xuICAgIHJlc3VsdC5wZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uO1xuICAgIHJlc3VsdFsnZGVmYXVsdCddID0gdGhpcy5pc0RlZmF1bHQ7XG4gICAgcmVzdWx0LmNvbG9yID0gdGhpcy5jb2xvcjtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbGVuZGFyUmVmZXJlbmNlO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgRXh0ZW5kIG1vZGVsIGNsYXNzIGZvciBEb29yYXkgQ2FsZW5kYXIgcHJvamVjdC5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi9tb2RlbC9ldmVudCcpO1xudmFyIGVudW1zID0gcmVxdWlyZSgnLi4vZW51bXMnKTtcblxuLyoqXG4gKiBFdmVudCBjbGFzcyBmb3IgZG9vcmF5IHByb2plY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0V2ZW50fVxuICovXG5mdW5jdGlvbiBEb29yYXlFdmVudCgpIHtcbiAgICBFdmVudC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICog7J287KCVIOy5tO2FjOqzoOumrCAo66eI7J287Iqk7YakLCDsl4XrrLQsIOydvOuwmOydvOyglSlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY2F0ZWdvcnkgPSAnJztcblxuICAgIC8qKlxuICAgICAqIOyXheustCDsnbzsoJXsnZgg6rK97JqwIOq1rOu2hCAo7Lac6re87KCELCDsoJDsi6zsoIQsIO2HtOq3vOyghClcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZHVlRGF0ZUNsYXNzID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiDsnbzsoJUg64K07JqpIOuzuOusuCDsoJXrs7RcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuYm9keSA9IHtcbiAgICAgICAgbWltZVR5cGU6ICcnLFxuICAgICAgICBjb250ZW50OiAnJ1xuICAgIH07IFxuXG4gICAgLyoqXG4gICAgICog7IOB7IS47KCV67O0IHVybFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5kZXRhaWxVcmwgPSAnJztcblxuICAgIC8qKlxuICAgICAqIOyepeyGjOygleuztFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5sb2NhdGlvbiA9ICcnO1xuXG4gICAgLyoqXG4gICAgICog6riw7YOA7KCV67O0XG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnJhdyA9IG51bGw7XG59XG5cbnV0aWwuaW5oZXJpdChEb29yYXlFdmVudCwgRXZlbnQpO1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5Eb29yYXlFdmVudC5jcmVhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIGluc3QgPSBuZXcgRG9vcmF5RXZlbnQoKTtcbiAgICBpbnN0LmluaXQoZGF0YSk7XG5cbiAgICByZXR1cm4gaW5zdDtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBvcHRpb25zLlxuICovXG5Eb29yYXlFdmVudC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIEV2ZW50LnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmNhdGVnb3J5ID0gb3B0aW9ucy5jYXRlZ29yeSB8fCBlbnVtcy5tb2RlbC5FVkVOVF9DQVRFR09SWS5HRU5FUkFMO1xuICAgIHRoaXMuZHVlRGF0ZUNsYXNzID0gb3B0aW9ucy5kdWVEYXRlQ2xhc3MgfHwgJyc7XG59O1xuXG4vKipcbiAqIE1hcnNoYWwgZGF0YSB0byBjb21tdW5pY2F0ZSB3aXRoIGRvb3JheSBBUEkgc2VydmVyXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIGRhdGEgb2JqZWN0IHRoYXQgYWNjZXB0IGZyb20gZG9vcmF5IEFQSSBzZXJ2ZXJcbiAqL1xuRG9vcmF5RXZlbnQucHJvdG90eXBlLm1hcnNoYWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0gdXRpbC5leHRlbmQoe30sIHRoaXMucmF3KTtcblxuICAgIHJlc3VsdC5zdWJqZWN0ID0gdGhpcy50aXRsZTtcbiAgICByZXN1bHQuY2F0ZWdvcnkgPSB0aGlzLmNhdGVnb3J5O1xuICAgIHJlc3VsdC5kdWVEYXRlQ2xhc3MgPSB0aGlzLmR1ZURhdGVDbGFzcztcbiAgICByZXN1bHQud2hvbGVEYXlGbGFnID0gdGhpcy5pc0FsbERheTtcbiAgICByZXN1bHQuc3RhcnRlZEF0ID0gdGhpcy5zdGFydHMudG9JU09TdHJpbmcoKTtcbiAgICByZXN1bHQuZW5kZWRBdCA9IHRoaXMuZW5kcy50b0lTT1N0cmluZygpO1xuICAgIHJlc3VsdC5ib2R5ID0gdGhpcy5ib2R5O1xuICAgIHJlc3VsdC5kZXRhaWxVcmwgPSB0aGlzLmRldGFpbFVybDtcbiAgICByZXN1bHQubG9jYXRpb24gPSB0aGlzLmxvY2F0aW9uO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVW5tYXJzaGFsIGRhdGEgZnJvbSBzZXJ2ZXIgcmVzcG9uc2UgZGF0YSBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhT2JqZWN0IC0gZGF0YSBvYmplY3QgZnJvbSBkb29yYXkgQVBJIHNlcnZlclxuICovXG5Eb29yYXlFdmVudC5wcm90b3R5cGUudW5tYXJzaGFsID0gZnVuY3Rpb24oZGF0YU9iamVjdCkge1xuICAgIHZhciBzdGFydHMsXG4gICAgICAgIGVuZHMsXG4gICAgICAgIGJvZHk7XG5cbiAgICBkYXRhT2JqZWN0ID0gZGF0YU9iamVjdCB8fCB7fTtcblxuICAgIHRoaXMudGl0bGUgPSBkYXRhT2JqZWN0LnN1YmplY3Q7XG4gICAgdGhpcy5jYXRlZ29yeSA9IGRhdGFPYmplY3QuY2F0ZWdvcnk7XG4gICAgdGhpcy5kdWVEYXRlQ2xhc3MgPSBkYXRhT2JqZWN0LmR1ZURhdGVDbGFzcztcbiAgICB0aGlzLmlzQWxsRGF5ID0gdXRpbC5pc0V4aXN0eShkYXRhT2JqZWN0Lndob2xlRGF5RmxhZykgPyBkYXRhT2JqZWN0Lndob2xlRGF5RmxhZyA6IGZhbHNlO1xuICAgIHRoaXMuZGV0YWlsVXJsID0gZGF0YU9iamVjdC5kZXRhaWxVcmwgfHwgJyc7XG4gICAgdGhpcy5sb2NhdGlvbiA9IGRhdGFPYmplY3QubG9jYXRpb24gfHwgJyc7XG5cbiAgICBpZiAodGhpcy5jYXRlZ29yeSA9PT0gZW51bXMubW9kZWwuRVZFTlRfQ0FURUdPUlkuR0VORVJBTCkge1xuICAgICAgICBzdGFydHMgPSBuZXcgRGF0ZShkYXRhT2JqZWN0LnN0YXJ0ZWRBdCk7XG4gICAgICAgIGVuZHMgPSBuZXcgRGF0ZShkYXRhT2JqZWN0LmVuZGVkQXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIOuniOydvOyKpO2GpCwg7JeF66y0IOydvOygleydgCDsooXro4zsnbwg6riw7KSA7Jy866GcIOqzhOyCsFxuICAgICAgICBzdGFydHMgPSBuZXcgRGF0ZShkYXRhT2JqZWN0LmR1ZURhdGUpO1xuICAgICAgICBlbmRzID0gbmV3IERhdGUoK3N0YXJ0cylcblxuICAgICAgICAvLyDsnbzsoJUg7Iuc7J6R7Iuc6rCE7J2EIOyiheujjOyLnOqwhCAzMOu2hCDsoITsnLzroZwg7KeA7KCVXG4gICAgICAgIHN0YXJ0cy5zZXRNaW51dGVzKHN0YXJ0cy5nZXRNaW51dGVzKCkgLSAzMCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFydHMgPSBzdGFydHM7XG4gICAgdGhpcy5lbmRzID0gZW5kcztcblxuICAgIGJvZHkgPSB1dGlsLnBpY2soZGF0YU9iamVjdCwgJ2JvZHknKTtcbiAgICBpZiAoYm9keSkge1xuICAgICAgICB0aGlzLmJvZHkubWltZVR5cGUgPSBib2R5Lm1pbWVUeXBlO1xuICAgICAgICB0aGlzLmJvZHkuY29udGVudCA9IGJvZHkuY29udGVudDtcbiAgICB9XG5cbiAgICB0aGlzLnJhdyA9IGRhdGFPYmplY3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERvb3JheUV2ZW50O1xuXG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoe1wiMVwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMSwgaGVscGVyLCBhbGlhczE9ZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSwgYWxpYXMyPWhlbHBlcnMuaGVscGVyTWlzc2luZywgYWxpYXMzPVwiZnVuY3Rpb25cIiwgYWxpYXM0PWNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uO1xuXG4gIHJldHVybiBcIiAgICAgICAgICAgIDxsaT48bGFiZWw+PGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIiBkYXRhLWlkPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuaWQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmlkIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJpZFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJcXFwiIFwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaXNEZWZhdWx0IDogZGVwdGgwKSx7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgyLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCIvPiZuYnNwO1wiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5uYW1lIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5uYW1lIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJuYW1lXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIjwvbGFiZWw+PC9saT5cXG5cIjtcbn0sXCIyXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICByZXR1cm4gXCJjaGVja2VkXCI7XG59LFwiNFwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sIGFsaWFzMj1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGFsaWFzMz1cImZ1bmN0aW9uXCIsIGFsaWFzND1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbjtcblxuICByZXR1cm4gXCIgICAgICAgICAgICA8bGk+PGxhYmVsPjxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCIgZGF0YS1pZD1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLmlkIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5pZCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiaWRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiXFxcIi8+Jm5ic3A7XCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLm5hbWUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm5hbWUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIm5hbWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiPC9sYWJlbD48L2xpPlxcblwiO1xufSxcImNvbXBpbGVyXCI6WzcsXCI+PSA0LjAuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9O1xuXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctY2FsZW5kYXJzXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1jYWxlbmRhcnMtZ2VuZXJhbFxcXCI+XFxuICAgICAgICA8aDY+7J2867CYIOy6mOumsOuNlDwvaDY+XFxuICAgICAgICA8b2w+XFxuXCJcbiAgICArICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoYWxpYXMxLCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmdlbmVyYWwgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLml0ZW1zIDogc3RhY2sxKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDEsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIiAgICAgICAgPC9vbD5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctY2FsZW5kYXJzLXByb2plY3RcXFwiPlxcbiAgICAgICAgPGg2Pu2UhOuhnOygne2KuCDsupjrprDrjZQ8L2g2PlxcbiAgICAgICAgPG9sPlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGFsaWFzMSwoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5wcm9qZWN0IDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5pdGVtcyA6IHN0YWNrMSkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSg0LCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCIgICAgICAgIDwvb2w+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcg7ISc67mE7IqkIOyijOy4oSDsupjrprDrjZQg66qp66GdIOu3sFxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBWaWV3ID0gcmVxdWlyZSgnLi4vLi4vdmlldy92aWV3Jyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgZG9tZXZlbnQgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tZXZlbnQnKTtcbnZhciB0bXBsID0gcmVxdWlyZSgnLi9jYWxlbmRhcnMuaGJzJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7Vmlld31cbiAqIEBwYXJhbSB7SFRNTERpdkVsZW1lbnR9IGNvbnRhaW5lciAtIHZpZXcgY29udGFpbmVyXG4gKi9cbmZ1bmN0aW9uIENhbGVuZGFycyhjb250YWluZXIpIHtcbiAgICBWaWV3LmNhbGwodGhpcywgbnVsbCwgY29udGFpbmVyKTtcblxuICAgIC8vIGJpbmQgZXZlbnRcbiAgICBkb21ldmVudC5vbihjb250YWluZXIsICdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZSwgdGhpcyk7XG5cbiAgICB0aGlzLnJlbmRlcigpO1xufVxuXG51dGlsLmluaGVyaXQoQ2FsZW5kYXJzLCBWaWV3KTtcblxuLyoqXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb259IHZpZXdNb2RlbCAtIGNvbGxlY3Rpb24gZm9yIENhbGVuZGFyUmVmZXJlbmNlXG4gKiBAcmV0dXJucyB7b2JqZWN0fSB2aWV3IG1vZGVsXG4gKi9cbkNhbGVuZGFycy5wcm90b3R5cGUuX2dldFZpZXdNb2RlbCA9IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgIC8vIOydvOuwmCDsupjrprDrjZTsmYAg7ZSE66Gc7KCd7Yq4IOy6mOumsOuNlOulvCDrgpjriIjri6RcbiAgICB2YXIgZ3JvdXBlZCA9IHZpZXdNb2RlbC5ncm91cEJ5KGZ1bmN0aW9uKGNhbGVuZGFyUmVmKSB7XG4gICAgICAgIHZhciByYXcgPSBjYWxlbmRhclJlZi5yYXc7XG5cbiAgICAgICAgaWYgKHJhdy5vd25lcikge1xuICAgICAgICAgICAgcmV0dXJuICdnZW5lcmFsJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAncHJvamVjdCdcbiAgICB9KTtcblxuICAgIHJldHVybiBncm91cGVkO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqIEBwYXJhbSB7Q29sbGVjdGlvbn0gdmlld01vZGVsIC0gY29sbGVjdGlvbiBmb3IgQ2FsZW5kYXJSZWZlcmVuY2VcbiAqL1xuQ2FsZW5kYXJzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbih2aWV3TW9kZWwpIHtcbiAgICBpZiAodmlld01vZGVsKSB7XG4gICAgICAgIHZpZXdNb2RlbCA9IHRoaXMuX2dldFZpZXdNb2RlbCh2aWV3TW9kZWwpO1xuICAgIH1cblxuICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9IHRtcGwodmlld01vZGVsKTtcbn07XG5cbi8qKlxuICog7ZiE7J6sIOu3sOulvCDssLjsobDtlbQg7LK07YGs65CcIOy6mOumsOuNlCBJROuwsOyXtOydhCDrsJjtmZjtlZzri6QuXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IOyEoO2DneuQnCDsupjrprDrjZQgaWQg67Cw7Je0XG4gKi9cbkNhbGVuZGFycy5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRDYWxlbmRhcklEID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLFxuICAgICAgICBpbnB1dHMgPSBkb211dGlsLmZpbmQoJ2lucHV0JywgY29udGFpbmVyLCBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsLmNoZWNrZWQ7XG4gICAgICAgIH0pO1xuXG4gICAgcmV0dXJuIHV0aWwubWFwKGlucHV0cywgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgcmV0dXJuIGRvbXV0aWwuZ2V0RGF0YShlbCwgJ2lkJyk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIGNhbGVuZGFyIGNoZWNrYm94IG9uY2hhbmdlIGV2ZW50IGhhbmRsZXJcbiAqIEBlbWl0cyBDYWxlbmRhcnMjY2hhbmdlQ2FsZW5kYXJTZWxlY3Rpb25cbiAqIEBwYXJhbSB7RXZlbnR9IGNoYW5nZUV2ZW50RGF0YSAtIGlucHV0IGV2ZW50XG4gKi9cbkNhbGVuZGFycy5wcm90b3R5cGUuX29uQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgLyoqXG4gICAgICogQGV2ZW50cyBDYWxlbmRhcnMjY2hhbmdlQ2FsZW5kYXJTZWxlY3Rpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nW119IGNhbGVuZGFyIGlkIGxpc3RcbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ2NoYW5nZUNhbGVuZGFyU2VsZWN0aW9uJywgdGhpcy5nZXRTZWxlY3RlZENhbGVuZGFySUQoKSk7XG59O1xuXG51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihDYWxlbmRhcnMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbGVuZGFycztcblxuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcIjFcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHJldHVybiBcIuunjOuTpOq4sFwiO1xufSxcIjNcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHJldHVybiBcIuyImOygle2VmOq4sFwiO1xufSxcIjVcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSxibG9ja1BhcmFtcyxkZXB0aHMpIHtcbiAgICB2YXIgc3RhY2sxLCBoZWxwZXIsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LCBhbGlhczI9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBhbGlhczM9XCJmdW5jdGlvblwiLCBhbGlhczQ9Y29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgcmV0dXJuIFwiPHA+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctZm9ybS10aXRsZVxcXCIgZm9yPVxcXCJwcm9qZWN0TmFtZVxcXCI+7ZSE66Gc7KCd7Yq4PC9sYWJlbD5cXG4gICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJwcm9qZWN0TmFtZVxcXCIgcGxhY2Vob2xkZXI9XFxcIu2UhOuhnOygne2KuOuqhVxcXCIgdmFsdWU9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5wcm9qZWN0TmFtZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAucHJvamVjdE5hbWUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcInByb2plY3ROYW1lXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIlxcXCIgLz5cXG4gICAgICAgIDxpbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIG5hbWU9XFxcInByb2plY3RDb2RlXFxcIiB2YWx1ZT1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnByb2plY3RDb2RlIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5wcm9qZWN0Q29kZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwicHJvamVjdENvZGVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiXFxcIiAvPlxcbiAgICA8L3A+XFxuICAgIDxwPlxcbiAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LWZvcm0tdGl0bGVcXFwiIGZvcj1cXFwibmFtZVxcXCI+7J2066aEPC9sYWJlbD5cXG4gICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJuYW1lXFxcIiBwbGFjZWhvbGRlcj1cXFwi7LqY66aw642UIOydtOumhFxcXCIgdmFsdWU9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5uYW1lIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5uYW1lIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJuYW1lXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIlxcXCIgLz5cXG4gICAgPC9wPlxcbiAgICA8cD5cXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1mb3JtLXRpdGxlXFxcIiBmb3I9XFxcImNvbG9yXFxcIj7sg4nsg4E8L2xhYmVsPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctY2FsZW5kYXItZm9ybS1jb2xvcnNcXFwiPlxcbiAgICAgICAgICAgIFwiXG4gICAgKyAoKHN0YWNrMSA9IChoZWxwZXJzLnJhZGlvQ2FsZW5kYXJDb2xvciB8fCAoZGVwdGgwICYmIGRlcHRoMC5yYWRpb0NhbGVuZGFyQ29sb3IpIHx8IGFsaWFzMikuY2FsbChhbGlhczEsXCJjb2xvclwiLCgoc3RhY2sxID0gKGRhdGEgJiYgZGF0YS5yb290KSkgJiYgc3RhY2sxLmNvbG9yTGlzdCksKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNvbG9yIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJyYWRpb0NhbGVuZGFyQ29sb3JcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCJcXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgbmFtZT1cXFwiY29sb3JIZXhcXFwiIHBsYWNlaG9sZGVyPVxcXCJIRVggdmFsdWVcXFwiIHZhbHVlPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuY29sb3JIZXggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNvbG9ySGV4IDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJjb2xvckhleFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJcXFwiIG1heGxlbmd0aD1cXFwiNlxcXCIgLz5cXG4gICAgICAgIDwvc3Bhbj5cXG4gICAgPC9wPlxcbiAgICA8cD5cXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1mb3JtLXRpdGxlXFxcIiBmb3I9XFxcInR5cGVcXFwiPuycoO2YlTwvbGFiZWw+XFxuICAgICAgICBcIlxuICAgICsgKChzdGFjazEgPSAoaGVscGVycy5zZWxlY3Rib3ggfHwgKGRlcHRoMCAmJiBkZXB0aDAuc2VsZWN0Ym94KSB8fCBhbGlhczIpLmNhbGwoYWxpYXMxLFwidHlwZVwiLCgoc3RhY2sxID0gKGRhdGEgJiYgZGF0YS5yb290KSkgJiYgc3RhY2sxLmNhbGVuZGFyTGlzdCksKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnR5cGUgOiBkZXB0aDApLHtcIm5hbWVcIjpcInNlbGVjdGJveFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIlxcbiAgICA8L3A+XFxuICAgIDxkaXY+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctZm9ybS10aXRsZVxcXCI+6rO17Jyg7ISk7KCVPGlucHV0IHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctY3JlYXRlY2FsZW5kYXItYWRkc2hhcmVcXFwiIHZhbHVlPVxcXCIrXFxcIiAvPjwvbGFiZWw+XFxuICAgICAgICA8dGFibGU+XFxuICAgICAgICAgICAgPGNvbGdyb3VwPjxjb2wgc3Bhbj1cXFwiMVxcXCIgc3R5bGU9XFxcIndpZHRoOjYwJVxcXCIgLz48Y29sIHNwYW49XFxcIjFcXFwiIHN0eWxlPVxcXCJ3aWR0aDo0MCVcXFwiIC8+PC9jb2xncm91cD5cXG4gICAgICAgICAgICA8dGJvZHk+XFxuICAgICAgICAgICAgPHRyIGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LWNyZWF0ZWNhbGVuZGFyLW1hc3RlclxcXCI+PHRkPuuCmDwvdGQ+PHRkPuuniOyKpO2EsDwvdGQ+PC90cj5cXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnNoYXJlIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDYsIGRhdGEsIDAsIGJsb2NrUGFyYW1zLCBkZXB0aHMpLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIiAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICA8L3RhYmxlPlxcbiAgICA8L2Rpdj5cXG5cIjtcbn0sXCI2XCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEsYmxvY2tQYXJhbXMsZGVwdGhzKSB7XG4gICAgdmFyIHN0YWNrMSwgaGVscGVyLCBhbGlhczE9ZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSwgYWxpYXMyPWhlbHBlcnMuaGVscGVyTWlzc2luZztcblxuICByZXR1cm4gXCIgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgIDx0ZD5cXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJ1c2VySWRbXVxcXCIgcGxhY2Vob2xkZXI9XFxcIuyCrOyaqeyekOuqhVxcXCIgdmFsdWU9XFxcIlwiXG4gICAgKyBjb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLmlkIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5pZCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBcImZ1bmN0aW9uXCIgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiaWRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiXFxcIi8+XFxuICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgICAgIDx0ZD5cXG5cIlxuICAgICsgKChzdGFjazEgPSAoaGVscGVycy5maSB8fCAoZGVwdGgwICYmIGRlcHRoMC5maSkgfHwgYWxpYXMyKS5jYWxsKGFsaWFzMSwoZGVwdGhzWzFdICE9IG51bGwgPyBkZXB0aHNbMV0udHlwZSA6IGRlcHRoc1sxXSksXCI9PT1cIixcInByaXZhdGVcIix7XCJuYW1lXCI6XCJmaVwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSg3LCBkYXRhLCAwLCBibG9ja1BhcmFtcywgZGVwdGhzKSxcImludmVyc2VcIjpjb250YWluZXIucHJvZ3JhbSg5LCBkYXRhLCAwLCBibG9ja1BhcmFtcywgZGVwdGhzKSxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L3RkPlxcbiAgICAgICAgICAgIDwvdHI+XFxuXCI7XG59LFwiN1wiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMTtcblxuICByZXR1cm4gKChzdGFjazEgPSAoaGVscGVycy5zZWxlY3Rib3ggfHwgKGRlcHRoMCAmJiBkZXB0aDAuc2VsZWN0Ym94KSB8fCBoZWxwZXJzLmhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSxcImF1dGhvcml0eVtdXCIsKChzdGFjazEgPSAoZGF0YSAmJiBkYXRhLnJvb3QpKSAmJiBzdGFjazEucHJpdmF0ZUxpc3QpLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5hdXRob3JpdHkgOiBkZXB0aDApLHtcIm5hbWVcIjpcInNlbGVjdGJveFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIlxcblwiO1xufSxcIjlcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazE7XG5cbiAgcmV0dXJuICgoc3RhY2sxID0gKGhlbHBlcnMuc2VsZWN0Ym94IHx8IChkZXB0aDAgJiYgZGVwdGgwLnNlbGVjdGJveCkgfHwgaGVscGVycy5oZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sXCJhdXRob3JpdHlbXVwiLCgoc3RhY2sxID0gKGRhdGEgJiYgZGF0YS5yb290KSkgJiYgc3RhY2sxLnNoYXJlTGlzdCksKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmF1dGhvcml0eSA6IGRlcHRoMCkse1wibmFtZVwiOlwic2VsZWN0Ym94XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiXFxuXCI7XG59LFwiMTFcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHJldHVybiBcIjxpbnB1dCB0eXBlPVxcXCJzdWJtaXRcXFwiIHZhbHVlPVxcXCLrp4zrk6TquLBcXFwiIC8+XFxuXCI7XG59LFwiMTNcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHJldHVybiBcIjxpbnB1dCB0eXBlPVxcXCJzdWJtaXRcXFwiIHZhbHVlPVxcXCLsiJjsoJXtlZjquLBcXFwiIC8+XFxuXCI7XG59LFwiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhLGJsb2NrUGFyYW1zLGRlcHRocykge1xuICAgIHZhciBzdGFjazEsIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sIGFsaWFzMj1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGFsaWFzMz1cImZ1bmN0aW9uXCIsIGFsaWFzND1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbjtcblxuICByZXR1cm4gXCI8Zm9ybSBuYW1lPVxcXCJjcmVhdGUtY2FsZW5kYXJcXFwiIG1ldGhvZD1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLm1ldGhvZCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubWV0aG9kIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJtZXRob2RcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiXFxcIiBhY3Rpb249XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5hY3Rpb24gfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmFjdGlvbiA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiYWN0aW9uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIlxcXCI+XFxuICAgIDxsZWdlbmQ+7LqY66aw642UIFwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaXNDcmVhdGVNb2RlIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgxLCBkYXRhLCAwLCBibG9ja1BhcmFtcywgZGVwdGhzKSxcImludmVyc2VcIjpjb250YWluZXIucHJvZ3JhbSgzLCBkYXRhLCAwLCBibG9ja1BhcmFtcywgZGVwdGhzKSxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L2xlZ2VuZD5cXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzW1wid2l0aFwiXS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZm9ybURhdGEgOiBkZXB0aDApLHtcIm5hbWVcIjpcIndpdGhcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oNSwgZGF0YSwgMCwgYmxvY2tQYXJhbXMsIGRlcHRocyksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiPHA+XFxuXCJcbiAgICArICgoc3RhY2sxID0gaGVscGVyc1tcImlmXCJdLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5pc0NyZWF0ZU1vZGUgOiBkZXB0aDApLHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDExLCBkYXRhLCAwLCBibG9ja1BhcmFtcywgZGVwdGhzKSxcImludmVyc2VcIjpjb250YWluZXIucHJvZ3JhbSgxMywgZGF0YSwgMCwgYmxvY2tQYXJhbXMsIGRlcHRocyksXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiPC9wPlxcbjwvZm9ybT5cXG5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZSxcInVzZURlcHRoc1wiOnRydWV9KTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyDsupjrprDrjZQg7IOd7ISxL+yImOyglSDtj7wg7Lu07Y+s64SM7Yq4XG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIGRvbWV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vY29tbW9uL2RvbWV2ZW50Jyk7XG52YXIgVmlldyA9IHJlcXVpcmUoJy4uLy4uLy4uL3ZpZXcvdmlldycpO1xudmFyIHRtcGwgPSByZXF1aXJlKCcuL2NhbGVuZGFyLmhicycpO1xuXG4vLyDsupjrprDrjZQg7Jyg7ZiVIOyFgOugie2KuOuwleyKpCDrpqzsiqTtirhcbnZhciBDQUxFTkRBUl9UWVBFX0xJU1QgPSBbe1xuICAgIHZhbHVlOiAncHJpdmF0ZScsXG4gICAgbGFiZWw6ICfqsJzsnbgg7LqY66aw642UJ1xufSwge1xuICAgIHZhbHVlOiAnc2hhcmVkJyxcbiAgICBsYWJlbDogJ+qzteycoCDsupjrprDrjZQnXG59XTtcblxuLy8g6rCc7J24IOy6mOumsOuNlCDqs7XsnKAg7IucIOyCrOyaqeyekCDqtoztlZwg66as7Iqk7Yq4XG52YXIgUFJJVkFURV9MSVNUID0gW3tcbiAgICB2YWx1ZTogJ29wYXF1ZV92aWV3JyxcbiAgICBsYWJlbDogJ+uLqOyInCDsobDtmownXG59LCB7XG4gICAgdmFsdWU6ICd2aWV3JyxcbiAgICBsYWJlbDogJ+yhsO2ajCdcbn0sIHtcbiAgICB2YWx1ZTogJ3JlYWRfd3JpdGUnLFxuICAgIGxhYmVsOiAn7JyE7J6EJ1xufV07XG5cbi8vIOqzteycoCDsupjrprDrjZQg6rO17JygIOyLnCDsgqzsmqnsnpAg6raM7ZWcIOumrOyKpO2KuFxudmFyIFNIQVJFX0xJU1QgPSBbe1xuICAgIHZhbHVlOiAndmlldycsXG4gICAgbGFiZWw6ICfsobDtmownXG59LCB7XG4gICAgdmFsdWU6ICdyZWFkX3dyaXRlJyxcbiAgICBsYWJlbDogJ+yImOyglS/sgq3soJwnXG59LCB7XG4gICAgdmFsdWU6ICdhbGwnLFxuICAgIGxhYmVsOiAn66qo65Og6raM7ZWcJ1xufV07XG5cbi8vIOudvOuUlOyYpOuwleyKpCDrpqzsiqTtirgg7ZSE66as7IWLXG52YXIgQ09MT1JfTElTVCA9IFt7XG4gICAgdmFsdWU6ICdlZDIzMjcnLFxuICAgIGxhYmVsOiAnZWQyMzI3J1xufSwge1xuICAgIHZhbHVlOiAnZWU1MzA3JyxcbiAgICBsYWJlbDogJ2VlNTMwNydcbn0sIHtcbiAgICB2YWx1ZTogJ2Y0YzMwYScsXG4gICAgbGFiZWw6ICdmNGMzMGEnXG59LCB7XG4gICAgdmFsdWU6ICc1NWQ3MmInLFxuICAgIGxhYmVsOiAnNTVkNzJiJ1xufSwge1xuICAgIHZhbHVlOiAnM2Q5YWY2JyxcbiAgICBsYWJlbDogJzNkOWFmNidcbn0sIHtcbiAgICB2YWx1ZTogJ2JlNTVkYScsXG4gICAgbGFiZWw6ICdiZTU1ZGEnXG59LCB7XG4gICAgdmFsdWU6ICc5NDY2NTEnLFxuICAgIGxhYmVsOiAnOTQ2NjUxJ1xufV07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7Vmlld31cbiAqIEBwYXJhbSB7U2VydmljZUNhbGVuZGFyfSBjYWxlbmRhciAtIGluc3RhbmNlIG9mIERvb3JheUNhbGVuZGFyXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnNcbiAqICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJvamVjdENvZGVdIC0gcHJvamVjdCBjb2RlIGZvciBjcmVhdGlvblxuICogIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaXNDcmVhdGVNb2RlPXRydWVdIC0gbW9kZS4gc2V0IHRydWUgdGhlbiBgY3JlYXRpb25gLCBmYWxzZSB0aGVuIGBtb2RpZnlgXG4gKiAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pc1ByaXZhdGVdIC0g6rCc7J24IOy6mOumsOuNlCDsl6zrtoBcbiAqICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWV0aG9kPVBPU1RdIC0gaHR0cCBtZXRob2RcbiAqICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYWN0aW9uXSAtIHVybFxuICogIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5mb3JtRGF0YV0gLSDrr7jrpqwg7LGE7JuMIOuRmCDtj7wg642w7J207YSwICjsl4bslrTrj4Qg66y067CpKVxuICogQHBhcmFtIHtIVE1MRWxlbmVudH0gY29udGFpbmVyIC0gY29udGFpbmVyIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gQ2FsZW5kYXJGb3JtKGNhbGVuZGFyLCBvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb250YWluZXIgPSBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KFxuICAgICAgICAnZGl2JywgY29udGFpbmVyLCAnc2NoZWR1bGUtdmlldy1jYWxlbmRhci1mb3JtJyk7XG5cbiAgICBWaWV3LmNhbGwodGhpcywgb3B0aW9ucywgY29udGFpbmVyKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBUEl9XG4gICAgICovXG4gICAgdGhpcy5hcGkgPSBjYWxlbmRhci5hcGk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgcHJvamVjdENvZGU6ICcqJyxcbiAgICAgICAgaXNDcmVhdGVNb2RlOiB0cnVlLFxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYWN0aW9uOiAnL3dhcGkvdGFzay10cmFja2VyL3Byb2plY3RzL3t7cHJvamVjdENvZGV9fS9jYWxlbmRhcnMnLFxuICAgICAgICBcbiAgICAgICAgY2FsZW5kYXJMaXN0OiBDQUxFTkRBUl9UWVBFX0xJU1QsXG4gICAgICAgIHByaXZhdGVMaXN0IDogUFJJVkFURV9MSVNULFxuICAgICAgICBzaGFyZUxpc3Q6IFNIQVJFX0xJU1QsXG4gICAgICAgIGNvbG9yTGlzdDogQ09MT1JfTElTVCxcbiAgICAgICAgZm9ybURhdGE6IHtcbiAgICAgICAgICAgIHR5cGU6ICdwcml2YXRlJ1xuICAgICAgICB9IFxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgZG9tZXZlbnQub24oY29udGFpbmVyLCB7XG4gICAgICAgICdzdWJtaXQnOiB0aGlzLl9vblN1Ym1pdCxcbiAgICAgICAgJ2NoYW5nZSc6IHRoaXMuX29uQ2hhbmdlLFxuICAgICAgICAnY2xpY2snOiB0aGlzLl9vbkNsaWNrXG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLnJlbmRlcigpO1xufVxuXG51dGlsLmluaGVyaXQoQ2FsZW5kYXJGb3JtLCBWaWV3KTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQ2FsZW5kYXJGb3JtLnByb3RvdHlwZS5fYmVmb3JlRGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvbWV2ZW50Lm9mZih0aGlzLmNvbnRhaW5lciwge1xuICAgICAgICAnc3VibWl0JzogdGhpcy5fb25TdWJtaXQsXG4gICAgICAgICdjaGFuZ2UnOiB0aGlzLl9vbkNoYW5nZSxcbiAgICAgICAgJ2NsaWNrJzogdGhpcy5fb25DbGlja1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5hcGkgPSB0aGlzLm9wdGlvbnMgPSBudWxsO1xufTtcblxuLyoqXG4gKiDsupjrprDrjZQg7Y+87Jy866Gc67aA7YSwIOqwneyytCDtmJXtg5zsnZgg642w7J207YSw66W8IOy2lOy2nO2VqFxuICogQHJldHVybnMge29iamVjdH0g7Y+8IOuNsOydtO2EsFxuICovXG5DYWxlbmRhckZvcm0ucHJvdG90eXBlLmdldEZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZvcm1EYXRhID0gZG9tdXRpbC5nZXRGb3JtRGF0YShkb211dGlsLmZpbmQoJ2Zvcm0nLCB0aGlzLmNvbnRhaW5lcikpLFxuICAgICAgICB1c2VySWQgPSBmb3JtRGF0YVsndXNlcklkW10nXSB8fCBbXSxcbiAgICAgICAgYXV0aG9yaXR5ID0gZm9ybURhdGFbJ2F1dGhvcml0eVtdJ10gfHwgW10sXG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHByb2plY3ROYW1lOiBmb3JtRGF0YS5wcm9qZWN0TmFtZSxcbiAgICAgICAgICAgIHByb2plY3RDb2RlOiBmb3JtRGF0YS5wcm9qZWN0Q29kZSxcbiAgICAgICAgICAgIG5hbWU6IGZvcm1EYXRhLm5hbWUsXG4gICAgICAgICAgICBjb2xvcjogZm9ybURhdGEuY29sb3IsXG4gICAgICAgICAgICBjb2xvckhleDogZm9ybURhdGEuY29sb3JIZXgsXG4gICAgICAgICAgICB0eXBlOiBmb3JtRGF0YS50eXBlLFxuICAgICAgICAgICAgc2hhcmU6IFtdXG4gICAgICAgIH07XG5cbiAgICB1c2VySWQgPSB1dGlsLmlzQXJyYXkodXNlcklkKSA/IHVzZXJJZCA6IFt1c2VySWRdO1xuICAgIGF1dGhvcml0eSA9IHV0aWwuaXNBcnJheShhdXRob3JpdHkpID8gYXV0aG9yaXR5IDogW2F1dGhvcml0eV07XG5cbiAgICB1dGlsLmZvckVhY2godXNlcklkLCBmdW5jdGlvbihpZCwgaW5kZXgpIHtcbiAgICAgICAgcmVzdWx0LnNoYXJlLnB1c2goe1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgYXV0aG9yaXR5OiBhdXRob3JpdHlbaW5kZXhdXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKiBAcGFyYW0ge29iamVjdH0gW2Zvcm1EYXRhXSAtIO2PvCDrjbDsnbTthLDrpbwg64SY6riw66m0IOugjOuNlOungSDsi5wg7KCB7Jqp7ZWc64ukXG4gKi9cbkNhbGVuZGFyRm9ybS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oZm9ybURhdGEpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmIChmb3JtRGF0YSkge1xuICAgICAgICBvcHRpb25zLmZvcm1EYXRhID0gZm9ybURhdGE7XG4gICAgfVxuXG4gICAgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gdG1wbChvcHRpb25zKTtcbn07XG5cbi8qKlxuICog7LqY66aw642UIOycoO2YlSDrs4Dqsr0g7IucIO2VuOuTpOufrFxuICogQHBhcmFtIHtFdmVudH0gZSAtIOy6mOumsOuNlCDsnKDtmJUg7IWA66CJ7Yq467CV7IqkIOuzgOqyvSDsnbTrsqTtirgg6rCd7LK0XG4gKi9cbkNhbGVuZGFyRm9ybS5wcm90b3R5cGUuX29uQ2hhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgdGFyZ2V0ID0gZS50YXJnZXQsXG4gICAgICAgIG5ld0FjdGlvbixcbiAgICAgICAgZm9ybTtcblxuICAgIGlmICh0YXJnZXQubmFtZSA9PT0gJ3R5cGUnKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKHRoaXMuZ2V0Rm9ybURhdGEoKSk7XG5cbiAgICAgICAgdXRpbC5kZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3QgPSBkb211dGlsLmZpbmQoJ3NlbGVjdCcsIHRoYXQuY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3QuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMCkoKTtcbiAgICB9XG5cbiAgICAvLyDtlITroZzsoJ3tirgg7L2U65OcIOuzgOqyvSDsi5wg7LKY66asXG4gICAgaWYgKHRhcmdldC5uYW1lID09PSAncHJvamVjdE5hbWUnKSB7XG4gICAgICAgIGZvcm0gPSBkb211dGlsLmZpbmQoJ2Zvcm0nLCB0aGF0LmNvbnRhaW5lcik7XG4gICAgICAgIGlmIChmb3JtKSB7XG4gICAgICAgICAgICAvL1RPRE86IO2UhOuhnOygne2KuCDsvZTrk5wg67Cb7JWE7JmA7JW8IO2VqFxuICAgICAgICAgICAgbmV3QWN0aW9uID0gdGhhdC5vcHRpb25zLmFjdGlvbi5yZXBsYWNlKCd7e3Byb2plY3RDb2RlfX0nLCB3aW5kb3cuZW5jb2RlVVJJQ29tcG9uZW50KHRhcmdldC52YWx1ZSkpO1xuICAgICAgICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2FjdGlvbicsIG5ld0FjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIOqzteycoOyEpOyglSDstpTqsIAg67KE7Yq8IO2BtOumrSDtlbjrk6Trn6xcbiAqIEBwYXJhbSB7RXZlbnR9IGUgLSDrsoTtirwg7YG066atIOydtOuypO2KuFxuICovXG5DYWxlbmRhckZvcm0ucHJvdG90eXBlLl9vbkNsaWNrID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgZm9ybURhdGE7XG5cbiAgICBpZiAoZS50YXJnZXQudHlwZSA9PT0gJ2J1dHRvbicpIHtcbiAgICAgICAgZm9ybURhdGEgPSB0aGF0LmdldEZvcm1EYXRhKCk7XG4gICAgICAgIGZvcm1EYXRhLnNoYXJlLnB1c2goe2lkOiAnJywgYXV0aG9yaXR5OiAnJ30pO1xuICAgICAgICB0aGF0LnJlbmRlcihmb3JtRGF0YSk7XG5cbiAgICAgICAgdXRpbC5kZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRvbXV0aWwuZmluZCgnaW5wdXQnLCB0aGF0LmNvbnRhaW5lciwgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwubmFtZSA9PT0gJ3VzZXJJZFtdJztcbiAgICAgICAgICAgIH0pLnBvcCgpLmZvY3VzKCk7XG4gICAgICAgIH0sIDApKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiDsg53shLEv7IiY7KCVIOuyhO2KvCDtgbTrpq0g7IucIO2VuOuTpOufrFxuICogQHBhcmFtIHtFdmVudH0gZSAtIOyghOyGoSDsnbTrsqTtirgg6rCd7LK0XG4gKi9cbkNhbGVuZGFyRm9ybS5wcm90b3R5cGUuX29uU3VibWl0ID0gZnVuY3Rpb24oZSkge1xuICAgIGRvbWV2ZW50LnN0b3AoZSk7XG4gICAgLy9UT0RPOiBzdWJtaXQgZGF0YSB0byBBUEkgc2VydmVyLlxuICAgIGNvbnNvbGUubG9nKHRoaXMuZ2V0Rm9ybURhdGEoKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbGVuZGFyRm9ybTtcblxuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcIjFcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGFsaWFzMT1jb250YWluZXIubGFtYmRhLCBhbGlhczI9Y29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb24sIGFsaWFzMz1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9O1xuXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctbWlsZXN0b25lLWRheVxcXCIgXFxuICAgICAgICBzdHlsZT1cXFwid2lkdGg6XCJcbiAgICArIGFsaWFzMihhbGlhczEoKChzdGFjazEgPSAoZGF0YSAmJiBkYXRhLnJvb3QpKSAmJiBzdGFjazEud2lkdGgpLCBkZXB0aDApKVxuICAgICsgXCIlO2xlZnQ6XCJcbiAgICArIGFsaWFzMigoaGVscGVycy5tdWx0aXBseSB8fCAoZGVwdGgwICYmIGRlcHRoMC5tdWx0aXBseSkgfHwgaGVscGVycy5oZWxwZXJNaXNzaW5nKS5jYWxsKGFsaWFzMywoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS53aWR0aCksKGRhdGEgJiYgZGF0YS5pbmRleCkse1wibmFtZVwiOlwibXVsdGlwbHlcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpXG4gICAgKyBcIiU7bWluLWhlaWdodDpcIlxuICAgICsgYWxpYXMyKGFsaWFzMSgoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS5oZWlnaHQpLCBkZXB0aDApKVxuICAgICsgXCJweFxcXCI+XFxuICAgICAgICA8dWwgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctbWlsZXN0b25lLWxpc3RcXFwiPlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGFsaWFzMywoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaXRlbXMgOiBkZXB0aDApLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMiwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiPC91bD5cXG4gICAgPC9kaXY+XFxuXCI7XG59LFwiMlwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMSwgYWxpYXMxPWNvbnRhaW5lci5sYW1iZGEsIGFsaWFzMj1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbjtcblxuICByZXR1cm4gXCI8bGkgZGF0YS10aXRsZT1cXFwiXCJcbiAgICArIGFsaWFzMihhbGlhczEoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubW9kZWwgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLnRpdGxlIDogc3RhY2sxKSwgZGVwdGgwKSlcbiAgICArIFwiXFxcIiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1taWxlc3RvbmUtaXRlbVxcXCI+XCJcbiAgICArIGFsaWFzMihhbGlhczEoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubW9kZWwgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLnRpdGxlIDogc3RhY2sxKSwgZGVwdGgwKSlcbiAgICArIFwiPC9saT5cXG5cIjtcbn0sXCJjb21waWxlclwiOls3LFwiPj0gNC4wLjBcIl0sXCJtYWluXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxO1xuXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctbWlsZXN0b25lLWxlZnRcXFwiPlxcbiAgICA8c3Bhbj7rp4jsnbzsiqTthqQ8L3NwYW4+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1taWxlc3RvbmUtcmlnaHRcXFwiPlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmV2ZW50cyA6IGRlcHRoMCkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgxLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L2Rpdj5cXG5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IOuniOydvOyKpO2GpCDrt7BcbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciBWaWV3ID0gcmVxdWlyZSgnLi4vLi4vdmlldy92aWV3Jyk7XG52YXIgdG1wbCA9IHJlcXVpcmUoJy4vbWlsZXN0b25lLmhicycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge1ZpZXd9XG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJlbmRlclN0YXJ0RGF0ZSAtIHN0YXJ0IGRhdGUgb2YgYWxsZGF5IHZpZXcncyByZW5kZXIgZGF0ZS4gWVlZWS1NTS1ERFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucmVuZGVyRW5kRGF0ZSAtIGVuZCBkYXRlIG9mIGFsbGRheSB2aWV3J3MgcmVuZGVyIGRhdGUuIFlZWVktTU0tRERcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5taW5IZWlnaHQ9NDBdIC0gbWluLWhlaWdodCBvZiBtaWxlc3RvbmUgdmlldyBcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIGNvbnRhaW5lciBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIE1pbGVzdG9uZShvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICBjb250YWluZXIgPSBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAnc2NoZWR1bGUtdmlldy1taWxlc3RvbmUtY29udGFpbmVyJ1xuICAgICk7XG5cbiAgICBWaWV3LmNhbGwodGhpcywgb3B0aW9ucywgY29udGFpbmVyKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICByZW5kZXJTdGFydERhdGU6ICcnLFxuICAgICAgICByZW5kZXJFbmREYXRlOiAnJyxcbiAgICAgICAgbWluSGVpZ2h0OiA0MFxuICAgIH0sIG9wdGlvbnMpO1xufVxuXG51dGlsLmluaGVyaXQoTWlsZXN0b25lLCBWaWV3KTtcblxuLyoqXG4gKiBHZXQgYmFzZSB2aWV3bW9kZWwgZm9yIHRhc2sgdmlld1xuICogQHBhcmFtIHtvYmplY3R9IFt2aWV3TW9kZWxdIC0gdmlldyBtb2RlbCBmcm9tIHBhcmVudCB2aWV3XG4gKiBAcmV0dXJucyB7b2JqZWN0fSB2aWV3IG1vZGVsIGZvciB0YXNrIHZpZXdcbiAqL1xuTWlsZXN0b25lLnByb3RvdHlwZS5fZ2V0QmFzZVZpZXdNb2RlbCA9IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBldmVudHMgPSB7fSxcbiAgICAgICAgcmFuZ2UgPSBkYXRldGltZS5yYW5nZShcbiAgICAgICAgICAgIGRhdGV0aW1lLnN0YXJ0KGRhdGV0aW1lLnBhcnNlKG9wdGlvbnMucmVuZGVyU3RhcnREYXRlKSksXG4gICAgICAgICAgICBkYXRldGltZS5lbmQoZGF0ZXRpbWUucGFyc2Uob3B0aW9ucy5yZW5kZXJFbmREYXRlKSksXG4gICAgICAgICAgICBkYXRldGltZS5NSUxMSVNFQ09ORFNfUEVSX0RBWVxuICAgICAgICApO1xuXG4gICAgdXRpbC5mb3JFYWNoKHJhbmdlLCBmdW5jdGlvbihkKSB7XG4gICAgICAgIGV2ZW50c1tkYXRldGltZS5mb3JtYXQoZCwgJ1lZWVktTU0tREQnKV0gPSB7fTtcbiAgICB9KTtcblxuICAgIHV0aWwuZXh0ZW5kKGV2ZW50cywgdmlld01vZGVsKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGV2ZW50czogZXZlbnRzLFxuICAgICAgICB3aWR0aDogMTAwIC8gcmFuZ2UubGVuZ3RoLFxuICAgICAgICBoZWlnaHQ6IG9wdGlvbnMubWluSGVpZ2h0XG4gICAgfTtcbn07XG5cbi8qKlxuICog66eI7J287Iqk7YakIOu3sCDroIzrjZTrp4FcbiAqIEBvdmVycmlkZVxuICovXG5NaWxlc3RvbmUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgYmFzZVZpZXdNb2RlbCA9IHRoaXMuX2dldEJhc2VWaWV3TW9kZWwodXRpbC5waWNrKHZpZXdNb2RlbC5ldmVudHNJbkRhdGVSYW5nZSwgJ21pbGVzdG9uZScpKTtcblxuICAgIGNvbnRhaW5lci5zdHlsZS5taW5IZWlnaHQgPSB0aGlzLm9wdGlvbnMubWluSGVpZ2h0ICsgJ3B4JztcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gdG1wbChiYXNlVmlld01vZGVsKTtcblxuICAgIHV0aWwuZm9yRWFjaChkb211dGlsLmZpbmQoJ2xpJywgY29udGFpbmVyLCB0cnVlKSwgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgaWYgKGVsLm9mZnNldFdpZHRoIDwgZWwuc2Nyb2xsV2lkdGgpIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBkb211dGlsLmdldERhdGEoZWwsICd0aXRsZScpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNaWxlc3RvbmU7XG5cbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZSh7XCIxXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICByZXR1cm4gXCI8dGg+XCJcbiAgICArIGNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uKGNvbnRhaW5lci5sYW1iZGEoZGVwdGgwLCBkZXB0aDApKVxuICAgICsgXCI8L3RoPlxcblwiO1xufSxcIjNcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazE7XG5cbiAgcmV0dXJuIFwiPHRyPlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sZGVwdGgwLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oNCwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiPC90cj5cXG5cIjtcbn0sXCI0XCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxLCBoZWxwZXIsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LCBhbGlhczI9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBhbGlhczM9XCJmdW5jdGlvblwiLCBhbGlhczQ9Y29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgcmV0dXJuIFwiPHRkIGNsYXNzPVxcXCJcIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzW1wiaWZcIl0uY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmlzT3RoZXJEYXRlIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSg1LCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzW1wiaWZcIl0uY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmZvY3VzZWQgOiBkZXB0aDApLHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDcsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudG9kYXkgOiBkZXB0aDApLHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDksIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaGFzRXZlbnRzIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgxMSwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArICgoc3RhY2sxID0gaGVscGVyc1tcImlmXCJdLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC53ZWVrZW5kIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgxMywgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiXFxcIiBkYXRhLXk9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy55IHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC55IDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJ5XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIlxcXCIgZGF0YS1tPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMubSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwibVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJcXFwiIGRhdGEtZD1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLmQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmQgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcImRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiXFxcIj5cXG48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1taW5pY2FsZW5kYXItZGF0ZVxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctbWluaWNhbGVuZGFyLWxhYmVsXFxcIj48c3Bhbj5cIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuZCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiZFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCI8L3NwYW4+PC9kaXY+XFxuPC9idXR0b24+XFxuPC90ZD5cXG5cIjtcbn0sXCI1XCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICByZXR1cm4gXCJzY2hlZHVsZS12aWV3LW1pbmljYWxlbmRhci1vdGhlciBcIjtcbn0sXCI3XCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICByZXR1cm4gXCJzY2hlZHVsZS12aWV3LW1pbmljYWxlbmRhci1mb2N1c2VkIFwiO1xufSxcIjlcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHJldHVybiBcInNjaGVkdWxlLXZpZXctbWluaWNhbGVuZGFyLXRvZGF5IFwiO1xufSxcIjExXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICByZXR1cm4gXCJzY2hlZHVsZS12aWV3LW1pbmljYWxlbmRhci1oYXMtZXZlbnRzIFwiO1xufSxcIjEzXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICByZXR1cm4gXCJzY2hlZHVsZS12aWV3LW1pbmljYWxlbmRhci13ZWVrZW5kIFwiO1xufSxcImNvbXBpbGVyXCI6WzcsXCI+PSA0LjAuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge307XG5cbiAgcmV0dXJuIFwiPHRhYmxlPlxcbjxjYXB0aW9uPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctbWluaWNhbGVuZGFyLW5hdiBzY2hlZHVsZS12aWV3LW1pbmljYWxlbmRhci1wcmV2XFxcIj48c3Bhbj4mbHQ7PC9zcGFuPjwvYnV0dG9uPlxcbiAgICA8c3BhbiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1taW5pY2FsZW5kYXItdGl0bGVcXFwiPlwiXG4gICAgKyBjb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnRpdGxlIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50aXRsZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJzLmhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBcImZ1bmN0aW9uXCIgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwidGl0bGVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiPC9zcGFuPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctbWluaWNhbGVuZGFyLW5hdiBzY2hlZHVsZS12aWV3LW1pbmljYWxlbmRhci1uZXh0XFxcIj48c3Bhbj4mZ3Q7PC9zcGFuPjwvYnV0dG9uPlxcbjwvY2FwdGlvbj5cXG48dGhlYWQ+PHRyPlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZGF5bmFtZSA6IGRlcHRoMCkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgxLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L3RyPjwvdGhlYWQ+XFxuPHRib2R5PlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuY2FsZW5kYXIgOiBkZXB0aDApLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMywgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiPC90Ym9keT5cXG48L3RhYmxlPlxcblwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWluaWNhbGVuZGFyIHZpZXcuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIFZpZXcgPSByZXF1aXJlKCcuLi8uLi92aWV3L3ZpZXcnKTtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciBkb21ldmVudCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb21ldmVudCcpO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgdG1wbCA9IHJlcXVpcmUoJy4vbWluaWNhbGVuZGFyLmhicycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge1ZpZXd9XG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIG1pbmljYWxlbmRhciB2aWV3XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RhcnREYXlPZldlZWs9MF0gLSBzdGFydCBkYXkgb2Ygd2Vlay4gZGVmYXVsdCAwIChzdW5kYXkpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucmVuZGVyTW9udGhdIC0gWVlZWS1NTSBmb3JtYXR0ZWQgZGF0ZSB0byByZW5kZXIuIFxuICogaWYgbm90IHN1cHBsaWVkIHVzZSBjdXJyZW50IG1vbnRoXG4gKiBAcGFyYW0ge0hUTUxEaXZFbGVtZW50fSBjb250YWluZXIgLSBlbGVtZW50IHRvIHVzZSBjb250YWluZXJcbiAqL1xuZnVuY3Rpb24gTWluaUNhbGVuZGFyKG9wdGlvbnMsIGNvbnRhaW5lcikge1xuICAgIHZhciBkZWZhdWx0TW9udGg7XG5cbiAgICBWaWV3LmNhbGwodGhpcywgb3B0aW9ucywgY29udGFpbmVyKTtcblxuICAgIGRvbXV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnc2NoZWR1bGUtdmlldy1taW5pY2FsZW5kYXInKTtcblxuICAgIGRlZmF1bHRNb250aCA9IHV0aWwucGljayhvcHRpb25zLCAncmVuZGVyTW9udGgnKTtcbiAgICBpZiAoZGVmYXVsdE1vbnRoKSB7XG4gICAgICAgIGRlZmF1bHRNb250aCA9IGRhdGV0aW1lLnBhcnNlKGRlZmF1bHRNb250aCArICctMDEnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkZWZhdWx0TW9udGggPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICBkZWZhdWx0TW9udGguc2V0SG91cnMoMCwgMCwgMCk7XG5cbiAgICBkb21ldmVudC5vbih0aGlzLmNvbnRhaW5lciwgJ2NsaWNrJywgdGhpcy5fb25DbGljaywgdGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgc3RhcnREYXlPZldlZWs6IDAsXG4gICAgICAgIGRheW5hbWVzOiBbJ+ydvCcsICfsm5QnLCAn7ZmUJywgJ+yImCcsICfrqqknLCAn6riIJywgJ+2GoCddXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLm9wdGlvbnMucmVuZGVyTW9udGggPSBkZWZhdWx0TW9udGg7XG59XG5cbnV0aWwuaW5oZXJpdChNaW5pQ2FsZW5kYXIsIFZpZXcpO1xuXG4vKipcbiAqIE5leHQsIFByZXYgYnV0dG9uIGV2ZW50IGhhbmRsZXJcbiAqIEBwYXJhbSB7SFRNTEJ1dHRvbkVsZW1lbnR9IGJ1dHRvbkVsZW1lbnQgLSBuZXh0LCBwcmV2IGJ1dHRvbiBmcm9tIF9vbkNsaWNrIGV2ZW50IGhhbmRsZXJcbiAqL1xuTWluaUNhbGVuZGFyLnByb3RvdHlwZS5uYXYgPSBmdW5jdGlvbihidXR0b25FbGVtZW50KSB7XG4gICAgdmFyIGlzTmV4dCA9IGRvbXV0aWwuaGFzQ2xhc3MoYnV0dG9uRWxlbWVudCwgJ3NjaGVkdWxlLXZpZXctbWluaWNhbGVuZGFyLW5leHQnKSxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgb2Zmc2V0ID0gaXNOZXh0ID8gMSA6IC0xO1xuXG4gICAgb3B0aW9ucy5yZW5kZXJNb250aC5zZXRNb250aChvcHRpb25zLnJlbmRlck1vbnRoLmdldE1vbnRoKCkgKyBvZmZzZXQpO1xuXG4gICAgdGhpcy5yZW5kZXIoKTtcbn07XG5cbi8qKlxuICogRGF0ZSBidXR0b24gZXZlbnQgaGFuZGxlclxuICogQHBhcmFtIHtIVE1MQnV0dG9uRWxlbWVudH0gYnV0dG9uRWxlbWVudCAtIGRhdGUgYnV0dG9uIGZyb20gX29uQ2xpY2sgZXZlbnQgaGFuZGxlclxuICovXG5NaW5pQ2FsZW5kYXIucHJvdG90eXBlLmRhdGUgPSBmdW5jdGlvbihidXR0b25FbGVtZW50KSB7XG4gICAgdmFyIHRkID0gZG9tdXRpbC5jbG9zZXN0KGJ1dHRvbkVsZW1lbnQsICd0ZCcpLFxuICAgICAgICBwcmV2aW91cztcblxuICAgIGlmICh0ZCkge1xuICAgICAgICBwcmV2aW91cyA9IGRvbXV0aWwuZmluZCgnLnNjaGVkdWxlLXZpZXctbWluaWNhbGVuZGFyLWZvY3VzZWQnLCB0aGlzLmNvbnRhaW5lcik7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgICAgICBkb211dGlsLnJlbW92ZUNsYXNzKHByZXZpb3VzLCAnc2NoZWR1bGUtdmlldy1taW5pY2FsZW5kYXItZm9jdXNlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9tdXRpbC5hZGRDbGFzcyh0ZCwgJ3NjaGVkdWxlLXZpZXctbWluaWNhbGVuZGFyLWZvY3VzZWQnKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENsaWNrIGV2ZW50IGhhbmRsZXJcbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gY2xpY2tFdmVudCAtIGNsaWNrIG1vdXNlIGV2ZW50IG9iamVjdFxuICovXG5NaW5pQ2FsZW5kYXIucHJvdG90eXBlLl9vbkNsaWNrID0gZnVuY3Rpb24oY2xpY2tFdmVudCkge1xuICAgIHZhciB0YXJnZXQgPSBjbGlja0V2ZW50LnNyY0VsZW1lbnQgfHwgY2xpY2tFdmVudC50YXJnZXQsXG4gICAgICAgIGJ1dHRvbiA9IGRvbXV0aWwuY2xvc2VzdCh0YXJnZXQsICdidXR0b24nKTtcblxuICAgIGlmICghYnV0dG9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZG9tdXRpbC5oYXNDbGFzcyhidXR0b24sICdzY2hlZHVsZS12aWV3LW1pbmljYWxlbmRhci1kYXRlJykpIHtcbiAgICAgICAgdGhpcy5kYXRlKGJ1dHRvbik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZG9tdXRpbC5oYXNDbGFzcyhidXR0b24sICdzY2hlZHVsZS12aWV3LW1pbmljYWxlbmRhci1uYXYnKSkge1xuICAgICAgICB0aGlzLm5hdihidXR0b24pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgc2VsZWN0ZWQgZGF0YVxuICogQHJldHVybnMge0RhdGV9IHNlbGVjdGVkIGRhdGVcbiAqL1xuTWluaUNhbGVuZGFyLnByb3RvdHlwZS5nZXRTZWxlY3RlZERhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LW1pbmljYWxlbmRhci1mb2N1c2VkJywgdGhpcy5jb250YWluZXIpLFxuICAgICAgICB5LCBtLCBkO1xuXG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB5ID0gZG9tdXRpbC5nZXREYXRhKHNlbGVjdGVkLCAneScpO1xuICAgIG0gPSBkb211dGlsLmdldERhdGEoc2VsZWN0ZWQsICdtJyk7XG4gICAgZCA9IGRvbXV0aWwuZ2V0RGF0YShzZWxlY3RlZCwgJ2QnKTtcblxuICAgIHJldHVybiBuZXcgRGF0ZSh5LCBtLCBkKTtcbn07XG5cbi8qKlxuICogR2V0IG1pbmljYWxlbmRhciB2aWV3IG1vZGVsXG4gKiBAcGFyYW0ge0RhdGV9IHJlbmRlckRhdGUgLSBEYXRlIHRvIHJlbmRlciBtaW5pY2FsZW5kYXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydERheU9mV2VlayAtIG51bWJlciBvZiBzdGFydCBvZiB3ZWVrICgwOnN1biAuLi4pXG4gKiBAcGFyYW0ge0RhdGV9IHRvZGF5IC0gdG9kYXkgRGF0ZSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGFycmF5Pn0gZXZlbnRzSW5Nb250aCAtIGV2ZW50cyBhcnJheSB0byByZXByZXNlbnQgZG90cyBpbiBtaW5pY2FsZW5kYXJcbiAqIEByZXR1cm5zIHtvYmplY3R9IHZpZXdtb2RlbFxuICovXG5NaW5pQ2FsZW5kYXIucHJvdG90eXBlLl9nZXRWaWV3TW9kZWwgPSBmdW5jdGlvbihyZW5kZXJEYXRlLCBzdGFydERheU9mV2VlaywgdG9kYXksIGV2ZW50c0luTW9udGgpIHtcbiAgICB2YXIgdmlld01vZGVsID0ge1xuICAgICAgICAgICAgdGl0bGU6IGRhdGV0aW1lLmZvcm1hdChyZW5kZXJEYXRlLCAnWVlZWS5NTScpLFxuICAgICAgICAgICAgc3RhcnREYXlPZldlZWs6IHN0YXJ0RGF5T2ZXZWVrLFxuICAgICAgICAgICAgZGF5bmFtZTogbnVsbCxcbiAgICAgICAgICAgIGNhbGVuZGFyOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGRheW5hbWVzID0gdGhpcy5vcHRpb25zLmRheW5hbWVzLFxuICAgICAgICByZW5kZXJNb250aCA9IHJlbmRlckRhdGUuZ2V0TW9udGgoKSxcbiAgICAgICAgcmVuZGVyWWVhciA9IHJlbmRlckRhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgdG9kYXlEYXRlID0gdG9kYXkuZ2V0RGF0ZSgpLFxuICAgICAgICB0b2RheU1vbnRoID0gdG9kYXkuZ2V0TW9udGgoKSxcbiAgICAgICAgdG9kYXlZZWFyID0gdG9kYXkuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgdG9kYXlJc1JlbmRlcmVkTW9udGggPSAocmVuZGVyWWVhciA9PT0gdG9kYXlZZWFyICYmIHJlbmRlck1vbnRoID09PSB0b2RheU1vbnRoKTtcblxuICAgIHZpZXdNb2RlbC5kYXluYW1lID0gdXRpbC5tYXAoXG4gICAgICAgIHV0aWwucmFuZ2Uoc3RhcnREYXlPZldlZWssIDcpLmNvbmNhdCh1dGlsLnJhbmdlKDcpKS5zbGljZSgwLCA3KSwgXG4gICAgICAgIGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGRheW5hbWVzW2ldOyB9XG4gICAgKTtcblxuICAgIHZpZXdNb2RlbC5jYWxlbmRhciA9IGRhdGV0aW1lLmFycjJkQ2FsZW5kYXIocmVuZGVyRGF0ZSwgc3RhcnREYXlPZldlZWssIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIG1vbnRoID0gZC5nZXRNb250aCgpLFxuICAgICAgICAgICAgeWVhciA9IGQuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICAgIGRhdGUgPSBkLmdldERhdGUoKSxcbiAgICAgICAgICAgIGRheSA9IGQuZ2V0RGF5KCksXG4gICAgICAgICAgICBpc090aGVyRGF0ZSA9IHllYXIgIT09IHJlbmRlclllYXIgfHwgbW9udGggIT09IHJlbmRlck1vbnRoLFxuICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHk6IHllYXIsXG4gICAgICAgICAgICAgICAgbTogbW9udGgsXG4gICAgICAgICAgICAgICAgZDogZC5nZXREYXRlKCksXG4gICAgICAgICAgICAgICAgaXNPdGhlckRhdGU6IGlzT3RoZXJEYXRlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmICghaXNPdGhlckRhdGUpIHtcbiAgICAgICAgICAgIC8vIGRhdGVzIGluIHJlbmRlcmVkIG1vbnRoXG4gICAgICAgICAgICBpZiAodG9kYXlJc1JlbmRlcmVkTW9udGggJiYgZGF0ZSA9PT0gdG9kYXlEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnRvZGF5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIHRvZGF5IGlzIGluY2x1ZGUgaW4gcmVuZGVyZWQgbW9udGggdGhlbiBhdXRvc2VsZWN0IHRvZGF5IGRhdGVcbiAgICAgICAgICAgICAgICByZXN1bHQuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghdG9kYXlJc1JlbmRlcmVkTW9udGggJiYgZGF0ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIHRvZGF5IGlzIG5vdCBpbmNsdWRlIGluIHJlbmRlcmVkIG1vbnRoIHRoZW4gYXV0b3NlbGVjdCBmaXJzdCBkYXRlIG9mIG1vbnRoXG4gICAgICAgICAgICAgICAgcmVzdWx0LmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRheSA9PT0gMCB8fCBkYXkgPT09IDYpIHtcbiAgICAgICAgICAgIHJlc3VsdC53ZWVrZW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudHNJbk1vbnRoICYmIH51dGlsLmluQXJyYXkoZGF0ZXRpbWUuZm9ybWF0KGQsICdZWVlZLU1NLUREJyksIGV2ZW50c0luTW9udGgpKSB7XG4gICAgICAgICAgICByZXN1bHQuaGFzRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdmlld01vZGVsO1xufTtcblxuLyoqXG4gKiBSZW5kZXIgdmlld1xuICovXG5NaW5pQ2FsZW5kYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgcmVuZGVyRGF0ZSA9IG9wdGlvbnMucmVuZGVyTW9udGgsXG4gICAgICAgIHN0YXJ0RGF5T2ZXZWVrID0gb3B0aW9ucy5zdGFydERheU9mV2VlayxcbiAgICAgICAgLy9UT0RPOiB0aGlzIHdpbGwgcHJvdmlkZSBieSBjb250cm9sbGVyXG4gICAgICAgIGV2ZW50cyA9IFsnMjAxNS0xMC0wMicsICcyMDE1LTEwLTE4J10sXG4gICAgICAgIHZpZXdNb2RlbDtcblxuICAgIHZpZXdNb2RlbCA9IHRoaXMuX2dldFZpZXdNb2RlbChyZW5kZXJEYXRlLCBzdGFydERheU9mV2VlaywgbmV3IERhdGUoKSwgZXZlbnRzKTtcblxuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSB0bXBsKHZpZXdNb2RlbCk7XG59O1xuXG51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihNaW5pQ2FsZW5kYXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1pbmlDYWxlbmRhcjtcblxuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcIjFcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGFsaWFzMT1jb250YWluZXIubGFtYmRhLCBhbGlhczI9Y29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb24sIGFsaWFzMz1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9O1xuXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctdGFzay1kYXlcXFwiIHN0eWxlPVxcXCJ3aWR0aDpcIlxuICAgICsgYWxpYXMyKGFsaWFzMSgoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS53aWR0aCksIGRlcHRoMCkpXG4gICAgKyBcIiU7bGVmdDpcIlxuICAgICsgYWxpYXMyKChoZWxwZXJzLm11bHRpcGx5IHx8IChkZXB0aDAgJiYgZGVwdGgwLm11bHRpcGx5KSB8fCBoZWxwZXJzLmhlbHBlck1pc3NpbmcpLmNhbGwoYWxpYXMzLCgoc3RhY2sxID0gKGRhdGEgJiYgZGF0YS5yb290KSkgJiYgc3RhY2sxLndpZHRoKSwoZGF0YSAmJiBkYXRhLmluZGV4KSx7XCJuYW1lXCI6XCJtdWx0aXBseVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSlcbiAgICArIFwiJTttaW4taGVpZ2h0OlwiXG4gICAgKyBhbGlhczIoYWxpYXMxKCgoc3RhY2sxID0gKGRhdGEgJiYgZGF0YS5yb290KSkgJiYgc3RhY2sxLmhlaWdodCksIGRlcHRoMCkpXG4gICAgKyBcInB4XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy10YXNrLWRheS13cmFwXFxcIj5cXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzW1wiaWZcIl0uY2FsbChhbGlhczMsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1vcm5pbmcgOiBkZXB0aDApLHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDIsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMywoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubHVuY2ggOiBkZXB0aDApLHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDUsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMywoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZXZlbmluZyA6IGRlcHRoMCkse1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oNywgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG59LFwiMlwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMTtcblxuICByZXR1cm4gXCI8aDY+7Lac6re8IOyghDwvaDY+XFxuICAgICAgICA8dWw+XFxuXCJcbiAgICArICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSwoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tb3JuaW5nIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5pdGVtcyA6IHN0YWNrMSkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgzLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L3VsPlxcblwiO1xufSxcIjNcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGFsaWFzMT1jb250YWluZXIubGFtYmRhLCBhbGlhczI9Y29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgcmV0dXJuIFwiPGxpIGRhdGEtdGl0bGU9XFxcIlwiXG4gICAgKyBhbGlhczIoYWxpYXMxKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1vZGVsIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS50aXRsZSA6IHN0YWNrMSksIGRlcHRoMCkpXG4gICAgKyBcIlxcXCIgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctdGFzay1pdGVtXFxcIj5cIlxuICAgICsgYWxpYXMyKGFsaWFzMSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tb2RlbCA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEudGl0bGUgOiBzdGFjazEpLCBkZXB0aDApKVxuICAgICsgXCI8L2xpPlxcblwiO1xufSxcIjVcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazE7XG5cbiAgcmV0dXJuIFwiPGg2PuygkOyLrCDsoIQ8L2g2PlxcbiAgICAgICAgPHVsPlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubHVuY2ggOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLml0ZW1zIDogc3RhY2sxKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDMsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIjwvdWw+XFxuXCI7XG59LFwiN1wiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMTtcblxuICByZXR1cm4gXCI8aDY+7Ye06re8IOyghDwvaDY+XFxuICAgICAgICA8dWw+XFxuXCJcbiAgICArICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSwoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5ldmVuaW5nIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5pdGVtcyA6IHN0YWNrMSkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgzLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L3VsPlxcblwiO1xufSxcImNvbXBpbGVyXCI6WzcsXCI+PSA0LjAuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazE7XG5cbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy10YXNrLWxlZnRcXFwiPlxcbiAgICA8c3Bhbj7sl4XrrLQ8L3NwYW4+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy10YXNrLXJpZ2h0XFxcIj5cXG5cXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5ldmVudHMgOiBkZXB0aDApLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMSwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiPC9kaXY+XFxuXCI7XG59LFwidXNlRGF0YVwiOnRydWV9KTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBUYXNrIHZpZXcgZm9yIHVwcGVyIGFyZWEgb2YgV2VlayB2aWV3LlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBkYXRldGltZSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kYXRldGltZScpO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIFZpZXcgPSByZXF1aXJlKCcuLi8uLi92aWV3L3ZpZXcnKTtcbnZhciB0bXBsID0gcmVxdWlyZSgnLi90YXNrdmlldy5oYnMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtWaWV3fVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGZvciBUYXNrVmlld1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucmVuZGVyU3RhcnREYXRlIC0gc3RhcnQgZGF0ZSBvZiBhbGxkYXkgdmlldydzIHJlbmRlciBkYXRlLiBZWVlZLU1NLUREXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yZW5kZXJFbmREYXRlIC0gZW5kIGRhdGUgb2YgYWxsZGF5IHZpZXcncyByZW5kZXIgZGF0ZS4gWVlZWS1NTS1ERFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1pbkhlaWdodD00MF0gLSBtaW4taGVpZ2h0IG9mIHRhc2t2aWV3XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgLSBjb250YWluZXIgZWxlbWVudFxuICovXG5mdW5jdGlvbiBUYXNrVmlldyhvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICBjb250YWluZXIgPSBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAnc2NoZWR1bGUtdmlldy10YXNrLWNvbnRhaW5lcidcbiAgICApO1xuXG4gICAgVmlldy5jYWxsKHRoaXMsIG9wdGlvbnMsIGNvbnRhaW5lcik7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgcmVuZGVyU3RhcnREYXRlOiAnJyxcbiAgICAgICAgcmVuZGVyRW5kRGF0ZTogJycsXG4gICAgICAgIG1pbkhlaWdodDogNDBcbiAgICB9LCBvcHRpb25zKTtcbn1cblxudXRpbC5pbmhlcml0KFRhc2tWaWV3LCBWaWV3KTtcblxuLyoqXG4gKiBHZXQgYmFzZSB2aWV3bW9kZWwgZm9yIHRhc2sgdmlld1xuICogQHBhcmFtIHtvYmplY3R9IFt2aWV3TW9kZWxdIC0gdmlldyBtb2RlbCBmcm9tIHBhcmVudCB2aWV3XG4gKiBAcmV0dXJucyB7b2JqZWN0fSB2aWV3IG1vZGVsIGZvciB0YXNrIHZpZXdcbiAqL1xuVGFza1ZpZXcucHJvdG90eXBlLl9nZXRCYXNlVmlld01vZGVsID0gZnVuY3Rpb24odmlld01vZGVsKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGV2ZW50cyA9IHt9LFxuICAgICAgICByYW5nZSA9IGRhdGV0aW1lLnJhbmdlKFxuICAgICAgICAgICAgZGF0ZXRpbWUuc3RhcnQoZGF0ZXRpbWUucGFyc2Uob3B0aW9ucy5yZW5kZXJTdGFydERhdGUpKSxcbiAgICAgICAgICAgIGRhdGV0aW1lLmVuZChkYXRldGltZS5wYXJzZShvcHRpb25zLnJlbmRlckVuZERhdGUpKSxcbiAgICAgICAgICAgIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZXG4gICAgICAgICk7XG5cbiAgICB1dGlsLmZvckVhY2gocmFuZ2UsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgZXZlbnRzW2RhdGV0aW1lLmZvcm1hdChkLCAnWVlZWS1NTS1ERCcpXSA9IHt9O1xuICAgIH0pO1xuXG4gICAgdXRpbC5leHRlbmQoZXZlbnRzLCB2aWV3TW9kZWwpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICAgIHdpZHRoOiAxMDAgLyByYW5nZS5sZW5ndGgsXG4gICAgICAgIGhlaWdodDogb3B0aW9ucy5taW5IZWlnaHRcbiAgICB9O1xufTtcblxuLyoqXG4gKiDsl4XrrLQg67ewIOugjOuNlOungVxuICogQG92ZXJyaWRlXG4gKi9cblRhc2tWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbih2aWV3TW9kZWwpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIsXG4gICAgICAgIGJhc2VWaWV3TW9kZWwgPSB0aGlzLl9nZXRCYXNlVmlld01vZGVsKHV0aWwucGljayh2aWV3TW9kZWwuZXZlbnRzSW5EYXRlUmFuZ2UsICd0YXNrJykpO1xuXG4gICAgY29udGFpbmVyLnN0eWxlLm1pbkhlaWdodCA9IHRoaXMub3B0aW9ucy5taW5IZWlnaHQgKyAncHgnO1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSB0bXBsKGJhc2VWaWV3TW9kZWwpO1xuXG4gICAgdXRpbC5mb3JFYWNoKGRvbXV0aWwuZmluZCgnbGknLCBjb250YWluZXIsIHRydWUpLCBmdW5jdGlvbihlbCkge1xuICAgICAgICBpZiAoZWwub2Zmc2V0V2lkdGggPCBlbC5zY3JvbGxXaWR0aCkge1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCd0aXRsZScsIGRvbXV0aWwuZ2V0RGF0YShlbCwgJ3RpdGxlJykpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRhc2tWaWV3O1xuXG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoe1wiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1kaXNwbGF5LXRhYmxlXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1kaXNwbGF5LXRhYmxlLXJvd1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LWRpc3BsYXktdGFibGUtY2VsbFxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1zY3JvbGwteSBzY2hlZHVsZS12aWV3LWRheW5hbWUtbGF5b3V0XFxcIj48L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1kaXNwbGF5LXRhYmxlLXJvd1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LWRpc3BsYXktdGFibGUtY2VsbFxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1zY3JvbGwteSBzY2hlZHVsZS12aWV3LW1pbGVzdG9uZS1sYXlvdXRcXFwiIHN0eWxlPVxcXCJtaW4taGVpZ2h0OjgwcHg7bWF4LWhlaWdodDoxMDBweFxcXCI+PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctZGlzcGxheS10YWJsZS1yb3dcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1kaXNwbGF5LXRhYmxlLWNlbGxcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctc2Nyb2xsLXkgc2NoZWR1bGUtdmlldy1hbGxkYXktbGF5b3V0XFxcIj48L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1kaXNwbGF5LXRhYmxlLXJvd1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LWRpc3BsYXktdGFibGUtY2VsbCBzY2hlZHVsZS12aWV3LXRpbWVncmlkLWxheW91dFxcXCI+PC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgRmFjdG9yeSBtb2R1bGUgZm9yIGNvbnRyb2wgYWxsIG90aGVyIGZhY3RvcnkuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgTGF5b3V0ID0gcmVxdWlyZSgnLi4vdmlldy9sYXlvdXQnKTtcbnZhciBEcmFnID0gcmVxdWlyZSgnLi4vaGFuZGxlci9kcmFnJyk7XG52YXIgY29udHJvbGxlckZhY3RvcnkgPSByZXF1aXJlKCcuL2NvbnRyb2xsZXInKTtcbnZhciB3ZWVrVmlld0ZhY3RvcnkgPSByZXF1aXJlKCcuL3dlZWtWaWV3Jyk7XG5cbi8qKlxuICogQ2FsZW5kYXIgY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGZvciBjYWxlbmRhclxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZ3JvdXBGdW5jXSAtIGZ1bmN0aW9uIGZvciBncm91cCBldmVudCBtb2RlbHMge0BzZWUgQ29sbGVjdGlvbiNncm91cEJ5fVxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuY29udHJvbGxlcl0gLSBjb250cm9sbGVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGVmYXVsdFZpZXc9J3dlZWsnXSAtIGRlZmF1bHQgdmlldyBvZiBjYWxlbmRhclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLndlZWtdIC0gb3B0aW9ucyBmb3Igd2VlayB2aWV3XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy53ZWVrLnJlbmRlclN0YXJ0RGF0ZSAtIFlZWVktTU0tREQgcmVuZGVyIHN0YXJ0IGRhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLndlZWsucmVuZGVyRW5kRGF0ZSAtIFlZWVktTU0tREQgcmVuZGVyIGVuZCBkYXRlXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMubW9udGhdIC0gb3B0aW9ucyBmb3IgbW9udGggdmlld1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubW9udGgucmVuZGVyTW9udGggLSBZWVlZLU1NIHJlbmRlciBtb250aFxuICogQHBhcmFtIHtIVE1MRGl2RWxlbWVudH0gY29udGFpbmVyID0gY29udGFpbmVyIGVsZW1lbnQgZm9yIGNhbGVuZGFyXG4gKi9cbmZ1bmN0aW9uIENhbGVuZGFyKG9wdGlvbnMsIGNvbnRhaW5lcikge1xuICAgIC8qKlxuICAgICAqIGJhc2UgZGF0ZSBvZiB2aWV3ICh0b2RheSgpIHdpbGwgdXNlIHRoaXMgcHJvcGVydHkpXG4gICAgICogQHR5cGUge0RhdGV9XG4gICAgICovXG4gICAgdGhpcy5iYXNlRGF0ZSA9IGRhdGV0aW1lLnN0YXJ0KG5ldyBEYXRlKCkpO1xuXG4gICAgLyoqXG4gICAgICogZGVmYXVsdCBvcHRpb24gZnJvbSBzZXJ2aWNlIHBhZ2VcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIG9yaWdpbmFsIG9wdGlvbnMgZm9yIHJlZmVyZW5jZSB3aGVuIHVpIHJlc2V0XG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbk9wdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMub3B0aW9ucykpO1xuXG4gICAgLyoqXG4gICAgICogYmFzZSBjb250cm9sbGVyXG4gICAgICogQHR5cGUge0Jhc2V9XG4gICAgICovXG4gICAgdGhpcy5jb250cm9sbGVyID0gb3B0aW9ucy5jb250cm9sbGVyIHx8IGNvbnRyb2xsZXJGYWN0b3J5KG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogbGF5b3V0IHZpZXcgKGxheW91dCBtYW5hZ2VyKVxuICAgICAqIEB0eXBlIHtMYXlvdXR9XG4gICAgICovXG4gICAgdGhpcy52aWV3ID0gbmV3IExheW91dChjb250YWluZXIpO1xuXG4gICAgLyoqXG4gICAgICogZ2xvYmFsIGRyYWcgaGFuZGxlclxuICAgICAqIEB0eXBlIHtEcmFnfVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBuZXcgRHJhZyh0aGlzLnZpZXcpO1xuXG4gICAgLyoqXG4gICAgICogY3VycmVudCByZW5kZXJlZCB2aWV3IG5hbWUuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRWaWV3TmFtZSA9IG9wdGlvbnMuZGVmYXVsdFZpZXcgfHwgJ3dlZWsnO1xuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiBTRVRUSU5HXG4gICAgICoqKioqKioqKiovXG4gICAgdGhpcy52aWV3LmNvbnRyb2xsZXIgPSB0aGlzLmNvbnRyb2xsZXI7XG5cbiAgICBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgICB0aGlzLnJlZnJlc2hDaGlsZFZpZXcoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyb2xsZXIub24oe1xuICAgICAgICB1cGRhdGVFdmVudDogcmVmcmVzaCxcbiAgICAgICAgY3JlYXRlZEV2ZW50OiByZWZyZXNoXG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLnRvZ2dsZVZpZXcob3B0aW9ucy5kZWZhdWx0VmlldywgdHJ1ZSk7XG59XG5cbi8qKlxuICogRGVsZXRlIGFsbCBkYXRhIGFuZCBjbGVhciB2aWV3LlxuICovXG5DYWxlbmRhci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXIuZGF0ZU1hdHJpeCA9IHt9O1xuICAgIHRoaXMuY29udHJvbGxlci5ldmVudHMuY2xlYXIoKTtcbiAgICB0aGlzLnZpZXcucmVuZGVyKCk7XG59O1xuXG4vKipcbiAqIE1vdmUgbmV4dC5cbiAqL1xuQ2FsZW5kYXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vdmUoMSk7XG59O1xuXG4vKipcbiAqIE1vdmUgcHJldmlvdXMuXG4gKi9cbkNhbGVuZGFyLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb3ZlKC0xKTtcbn07XG5cbi8qKlxuICogTW92ZSB0byB0b2RheS5cbiAqL1xuQ2FsZW5kYXIucHJvdG90eXBlLnRvZGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1cnJlbnRWaWV3ID0gdGhpcy5nZXRDdXJyZW50VmlldygpLFxuICAgICAgICBvcmlnaW5PcHRpb25zID0gdGhpcy5vcmlnaW5PcHRpb25zO1xuXG4gICAgaWYgKGN1cnJlbnRWaWV3LnZpZXdOYW1lID09PSAnd2VlaycpIHtcbiAgICAgICAgb3JpZ2luT3B0aW9ucyA9IG9yaWdpbk9wdGlvbnMud2VlaztcbiAgICAgICAgdGhpcy5vcHRpb25zLndlZWsgPSB7XG4gICAgICAgICAgICByZW5kZXJTdGFydERhdGU6IG9yaWdpbk9wdGlvbnMucmVuZGVyU3RhcnREYXRlLFxuICAgICAgICAgICAgcmVuZGVyRW5kRGF0ZTogb3JpZ2luT3B0aW9ucy5yZW5kZXJFbmREYXRlIFxuICAgICAgICB9O1xuICAgICAgICBjdXJyZW50Vmlldy5yZWN1cnNpdmUoZnVuY3Rpb24odmlldykge1xuICAgICAgICAgICAgaWYgKCF2aWV3Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZpZXcub3B0aW9ucy5yZW5kZXJTdGFydERhdGUgPSBvcmlnaW5PcHRpb25zLnJlbmRlclN0YXJ0RGF0ZTtcbiAgICAgICAgICAgIHZpZXcub3B0aW9ucy5yZW5kZXJFbmREYXRlID0gb3JpZ2luT3B0aW9ucy5yZW5kZXJFbmREYXRlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnJlZnJlc2hDaGlsZFZpZXcoY3VycmVudFZpZXcudmlld05hbWUpO1xufTtcblxuLyoqXG4gKiBNb3ZlIGNhbGVuZGFyIGJ5IGRpcmVjdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiAtIHRoZSBudW1iZXIgdGhhdCB3YW50IHRvIG1vdmUgKCsxLCAtMSlcbiAqL1xuQ2FsZW5kYXIucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbihkaXJlY3Rpb24pIHtcbiAgICB2YXIgY3VycmVudFZpZXcgPSB0aGlzLmdldEN1cnJlbnRWaWV3KCksXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cbiAgICAgICAgZGF0ZU9mZnNldCxcbiAgICAgICAgbmV3U3RhcnQsXG4gICAgICAgIG5ld0VuZDtcblxuICAgIGlmIChjdXJyZW50Vmlldy52aWV3TmFtZSA9PT0gJ3dlZWsnKSB7XG4gICAgICAgIG5ld1N0YXJ0ID0gZGF0ZXRpbWUuc3RhcnQoZGF0ZXRpbWUucGFyc2Uob3B0aW9ucy53ZWVrLnJlbmRlclN0YXJ0RGF0ZSkpO1xuICAgICAgICBuZXdFbmQgPSBkYXRldGltZS5lbmQoZGF0ZXRpbWUucGFyc2Uob3B0aW9ucy53ZWVrLnJlbmRlckVuZERhdGUpKTtcbiAgICAgICAgZGF0ZU9mZnNldCA9IGRhdGV0aW1lLnJhbmdlKG5ld1N0YXJ0LCBuZXdFbmQsIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZKS5sZW5ndGggKiBkaXJlY3Rpb247XG4gICAgICAgIG5ld1N0YXJ0ID0gZGF0ZXRpbWUuZm9ybWF0KG5ldyBEYXRlKG5ld1N0YXJ0LnNldERhdGUobmV3U3RhcnQuZ2V0RGF0ZSgpICsgZGF0ZU9mZnNldCkpLCAnWVlZWS1NTS1ERCcpO1xuICAgICAgICBuZXdFbmQgPSBkYXRldGltZS5mb3JtYXQobmV3IERhdGUobmV3RW5kLnNldERhdGUobmV3RW5kLmdldERhdGUoKSArIGRhdGVPZmZzZXQpKSwgJ1lZWVktTU0tREQnKTtcblxuICAgICAgICBvcHRpb25zLndlZWsgPSB7XG4gICAgICAgICAgICByZW5kZXJTdGFydERhdGU6IG5ld1N0YXJ0LFxuICAgICAgICAgICAgcmVuZGVyRW5kRGF0ZTogbmV3RW5kXG4gICAgICAgIH07XG4gICAgICAgIGN1cnJlbnRWaWV3LnJlY3Vyc2l2ZShmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgICAgICBpZiAoIXZpZXcub3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmlldy5vcHRpb25zLnJlbmRlclN0YXJ0RGF0ZSA9IG5ld1N0YXJ0O1xuICAgICAgICAgICAgdmlldy5vcHRpb25zLnJlbmRlckVuZERhdGUgPSBuZXdFbmQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMucmVmcmVzaENoaWxkVmlldyhjdXJyZW50Vmlldy52aWV3TmFtZSk7XG59XG5cbi8qKlxuICogUmV0dXJuIGN1cnJlbnQgcmVuZGVyZWQgdmlldy5cbiAqIEByZXR1cm5zIHtWaWV3fSBjdXJyZW50IHZpZXcgaW5zdGFuY2VcbiAqL1xuQ2FsZW5kYXIucHJvdG90eXBlLmdldEN1cnJlbnRWaWV3ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHV0aWwucGljayh0aGlzLnZpZXcuY2hpbGRzLml0ZW1zLCB0aGlzLmN1cnJlbnRWaWV3TmFtZSk7XG59XG5cbi8qKlxuICogVG9nZ2xlIGN1cnJlbnQgdmlld1xuICogQHBhcmFtIHtzdHJpbmd9IHZpZXdOYW1lIC0gdGhlIG5hbWUgb2Ygdmlldy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgLSBmb3JjZSByZW5kZXIgZGVzcGl0ZSBvZiBjdXJyZW50IHZpZXcgYW5kIG5ldyB2aWV3IGFyZSBlcXVhbFxuICovXG5DYWxlbmRhci5wcm90b3R5cGUudG9nZ2xlVmlldyA9IGZ1bmN0aW9uKHZpZXdOYW1lLCBmb3JjZSkge1xuICAgIHZhciB2aWV3ID0gdGhpcy52aWV3LFxuICAgICAgICBjb250cm9sbGVyID0gdGhpcy5jb250cm9sbGVyLFxuICAgICAgICBkcmFnSGFuZGxlciA9IHRoaXMuZHJhZ0hhbmRsZXIsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAoIWZvcmNlICYmIHRoaXMuY3VycmVudFZpZXdOYW1lID09PSB2aWV3TmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50Vmlld05hbWUgPSB2aWV3TmFtZTtcbiAgICB2aWV3LmNsZWFyKCk7XG5cbiAgICBpZiAodmlld05hbWUgPT09ICd3ZWVrJykge1xuICAgICAgICB2aWV3LmFkZENoaWxkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtWaWV3RmFjdG9yeShjb250cm9sbGVyLCB2aWV3LmNvbnRhaW5lciwgZHJhZ0hhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogRGVzdHJveSBjYWxlbmRhciBpbnN0YW5jZS5cbiAqL1xuQ2FsZW5kYXIucHJvdG90eXBlLmRlc3RvcnkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRyYWdIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmNvbnRyb2xsZXIub2ZmKCk7XG4gICAgdGhpcy52aWV3LmNsZWFyKCk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmJhc2VEYXRlID0gdGhpcy5jb250cm9sbGVyID1cbiAgICAgICAgdGhpcy52aWV3ID0gdGhpcy5kcmFnSGFuZGxlciA9IG51bGw7XG59XG5cbi8qKlxuICogUmVmcmVzaCBjaGlsZCB2aWV3c1xuICogQHBhcmFtIHtzdHJpbmd9IFt2aWV3TmFtZV0gLSB0aGUgbmFtZSBvZiB2aWV3IHRvIHJlbmRlci4gaWYgbm90IHN1cHBsaWVkIHRoZW4gcmVmcmVzaCBhbGwuXG4gKi9cbkNhbGVuZGFyLnByb3RvdHlwZS5yZWZyZXNoQ2hpbGRWaWV3ID0gZnVuY3Rpb24odmlld05hbWUpIHtcbiAgICBpZiAoIXZpZXdOYW1lKSB7XG4gICAgICAgIHRoaXMudmlldy5yZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudmlldy5jaGlsZHMuaXRlbXNbdmlld05hbWVdLnJlbmRlcigpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgZGVmYXVsdCBvcHRpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uIGZyb20gc2VydmljZSBwYWdlXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBkZWZhdWx0IG9wdGlvbi4gXG4gKi9cbkNhbGVuZGFyLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciB0b2RheSA9IHRoaXMuYmFzZURhdGUsXG4gICAgICAgIGRhdGVSYW5nZTtcblxuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgIGRlZmF1bHRWaWV3OiAnd2VlaycsICAgIC8vIOq4sOuzuCDso7zqsIQg67ewIOyEpOyglVxuICAgICAgICB3ZWVrOiBudWxsLFxuICAgICAgICBtb250aDogbnVsbCBcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIGlmICghb3B0aW9ucy53ZWVrKSB7XG4gICAgICAgIGRhdGVSYW5nZSA9IGRhdGV0aW1lLnJhbmdlKFxuICAgICAgICAgICAgZGF0ZXRpbWUuc3RhcnQobmV3IERhdGUobmV3IERhdGUodG9kYXkpLnNldERhdGUodG9kYXkuZ2V0RGF0ZSgpIC0gMykpKSxcbiAgICAgICAgICAgIGRhdGV0aW1lLmVuZChuZXcgRGF0ZShuZXcgRGF0ZSh0b2RheSkuc2V0RGF0ZSh0b2RheS5nZXREYXRlKCkgKyAzKSkpLFxuICAgICAgICAgICAgZGF0ZXRpbWUuTUlMTElTRUNPTkRTX1BFUl9EQVlcbiAgICAgICAgKTtcblxuICAgICAgICBvcHRpb25zLndlZWsgPSB7XG4gICAgICAgICAgICByZW5kZXJTdGFydERhdGU6IGRhdGV0aW1lLmZvcm1hdChkYXRlUmFuZ2VbMF0sICdZWVlZLU1NLUREJyksXG4gICAgICAgICAgICByZW5kZXJFbmREYXRlOiBkYXRldGltZS5mb3JtYXQoZGF0ZVJhbmdlWzZdLCAnWVlZWS1NTS1ERCcpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLm1vbnRoKSB7XG4gICAgICAgIG9wdGlvbnMubW9udGggPSB7XG4gICAgICAgICAgICByZW5kZXJNb250aDogZGF0ZXRpbWUuZm9ybWF0KHRvZGF5LCAnWVlZWS1NTScpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbGVuZGFyO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29udHJvbGxlciBmYWN0b3J5IG1vZHVsZS5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL2NvbnRyb2xsZXIvYmFzZScpO1xudmFyIFdlZWsgPSByZXF1aXJlKCcuLi9jb250cm9sbGVyL3ZpZXdNaXhpbi93ZWVrJyk7XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGZvciBiYXNlIGNvbnRyb2xsZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmdyb3VwRnVuY10gLSBmdW5jdGlvbiBmb3IgZ3JvdXAgZWFjaCBtb2RlbHMge0BzZWUgQ29sbGVjdGlvbiNncm91cEJ5fVxuICogQHJldHVybnMge0Jhc2V9IFRoZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgY29udHJvbGxlciA9IG5ldyBCYXNlKG9wdGlvbnMpO1xuXG4gICAgY29udHJvbGxlci5XZWVrID0ge307XG4gICAgdXRpbC5mb3JFYWNoKFdlZWssIGZ1bmN0aW9uKG1ldGhvZCwgbWV0aG9kTmFtZSkge1xuICAgICAgICBjb250cm9sbGVyLldlZWtbbWV0aG9kTmFtZV0gPSB1dGlsLmJpbmQobWV0aG9kLCBjb250cm9sbGVyKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb250cm9sbGVyO1xufTtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEZhY3RvcnkgbW9kdWxlIGZvciBXZWVrVmlld1xuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi9jb21tb24vZG9tdXRpbCcpO1xuXG4vLyBQYXJlbnQgdmlld3NcbnZhciBXZWVrID0gcmVxdWlyZSgnLi4vdmlldy93ZWVrL3dlZWsnKTtcblxuLy8gU3ViIHZpZXdzXG52YXIgRGF5TmFtZSA9IHJlcXVpcmUoJy4uL3ZpZXcvd2Vlay9kYXluYW1lJyk7XG52YXIgVGltZUdyaWQgPSByZXF1aXJlKCcuLi92aWV3L3dlZWsvdGltZUdyaWQnKTtcbnZhciBBbGxkYXkgPSByZXF1aXJlKCcuLi92aWV3L3dlZWsvYWxsZGF5Jyk7XG5cbi8vIEhhbmRsZXJzXG52YXIgQWxsZGF5Q3JlYXRpb24gPSByZXF1aXJlKCcuLi9oYW5kbGVyL2FsbGRheS9jcmVhdGlvbicpO1xudmFyIEFsbGRheU1vdmUgPSByZXF1aXJlKCcuLi9oYW5kbGVyL2FsbGRheS9tb3ZlJyk7XG52YXIgQWxsZGF5UmVzaXplID0gcmVxdWlyZSgnLi4vaGFuZGxlci9hbGxkYXkvcmVzaXplJyk7XG52YXIgVGltZUNyZWF0aW9uID0gcmVxdWlyZSgnLi4vaGFuZGxlci90aW1lL2NyZWF0aW9uJyk7XG52YXIgVGltZU1vdmUgPSByZXF1aXJlKCcuLi9oYW5kbGVyL3RpbWUvbW92ZScpO1xudmFyIFRpbWVSZXNpemUgPSByZXF1aXJlKCcuLi9oYW5kbGVyL3RpbWUvcmVzaXplJyk7XG5cbi8vIEJhc2UgVGVtcGxhdGVzXG52YXIgd2Vla1ZpZXdUbXBsID0gcmVxdWlyZSgnLi4vdmlldy90ZW1wbGF0ZS9mYWN0b3J5L3dlZWtWaWV3LmhicycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJhc2VDb250cm9sbGVyLCBsYXlvdXRDb250YWluZXIsIGRyYWdIYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIHdlZWtWaWV3LFxuICAgICAgICBkYXlOYW1lVmlldyxcbiAgICAgICAgYWxsZGF5VmlldyxcbiAgICAgICAgdGltZUdyaWRWaWV3LFxuICAgICAgICBhbGxkYXlDcmVhdGlvbkhhbmRsZXIsXG4gICAgICAgIGFsbGRheU1vdmVIYW5kbGVyLFxuICAgICAgICBhbGxkYXlSZXNpemVIYW5kbGVyLFxuICAgICAgICB0aW1lQ3JlYXRpb25IYW5kbGVyLFxuICAgICAgICB0aW1lTW92ZUhhbmRsZXIsXG4gICAgICAgIHRpbWVSZXNpemVIYW5kbGVyO1xuXG4gICAgd2Vla1ZpZXcgPSBuZXcgV2VlayhudWxsLCBvcHRpb25zLndlZWssIGxheW91dENvbnRhaW5lcik7XG5cbiAgICB3ZWVrVmlldy5jb250YWluZXIuaW5uZXJIVE1MID0gd2Vla1ZpZXdUbXBsKCk7XG5cbiAgICAvLyBEYXluYW1lXG4gICAgZGF5TmFtZVZpZXcgPSBuZXcgRGF5TmFtZShudWxsLCBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LWRheW5hbWUtbGF5b3V0Jywgd2Vla1ZpZXcuY29udGFpbmVyKSk7XG4gICAgd2Vla1ZpZXcuYWRkQ2hpbGQoZGF5TmFtZVZpZXcpO1xuXG4gICAgLy8gQWxsZGF5XG4gICAgYWxsZGF5VmlldyA9IG5ldyBBbGxkYXkob3B0aW9ucy53ZWVrLCBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LWFsbGRheS1sYXlvdXQnLCB3ZWVrVmlldy5jb250YWluZXIpKTtcbiAgICBhbGxkYXlDcmVhdGlvbkhhbmRsZXIgPSBuZXcgQWxsZGF5Q3JlYXRpb24oZHJhZ0hhbmRsZXIsIGFsbGRheVZpZXcsIGJhc2VDb250cm9sbGVyKTtcbiAgICBhbGxkYXlNb3ZlSGFuZGxlciA9IG5ldyBBbGxkYXlNb3ZlKGRyYWdIYW5kbGVyLCBhbGxkYXlWaWV3LCBiYXNlQ29udHJvbGxlcik7XG4gICAgYWxsZGF5UmVzaXplSGFuZGxlciA9IG5ldyBBbGxkYXlSZXNpemUoZHJhZ0hhbmRsZXIsIGFsbGRheVZpZXcsIGJhc2VDb250cm9sbGVyKTtcblxuICAgIHdlZWtWaWV3LmFkZENoaWxkKGFsbGRheVZpZXcpO1xuXG4gICAgLy8gVGltZUdyaWRcbiAgICB0aW1lR3JpZFZpZXcgPSBuZXcgVGltZUdyaWQob3B0aW9ucy53ZWVrLCBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LXRpbWVncmlkLWxheW91dCcsIHdlZWtWaWV3LmNvbnRhaW5lcikpO1xuICAgIHRpbWVDcmVhdGlvbkhhbmRsZXIgPSBuZXcgVGltZUNyZWF0aW9uKGRyYWdIYW5kbGVyLCB0aW1lR3JpZFZpZXcsIGJhc2VDb250cm9sbGVyKTtcbiAgICB0aW1lTW92ZUhhbmRsZXIgPSBuZXcgVGltZU1vdmUoZHJhZ0hhbmRsZXIsIHRpbWVHcmlkVmlldywgYmFzZUNvbnRyb2xsZXIpO1xuICAgIHRpbWVSZXNpemVIYW5kbGVyID0gbmV3IFRpbWVSZXNpemUoZHJhZ0hhbmRsZXIsIHRpbWVHcmlkVmlldywgYmFzZUNvbnRyb2xsZXIpO1xuXG4gICAgd2Vla1ZpZXcuaGFuZGxlcnMgPSB7XG4gICAgICAgIGFsbGRheToge1xuICAgICAgICAgICAgY3JlYXRpb246IGFsbGRheUNyZWF0aW9uSGFuZGxlcixcbiAgICAgICAgICAgIG1vdmU6IGFsbGRheU1vdmVIYW5kbGVyLFxuICAgICAgICAgICAgcmVzaXplOiBhbGxkYXlSZXNpemVIYW5kbGVyXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWU6IHtcbiAgICAgICAgICAgIGNyZWF0aW9uOiB0aW1lQ3JlYXRpb25IYW5kbGVyLFxuICAgICAgICAgICAgbW92ZTogdGltZU1vdmVIYW5kbGVyLFxuICAgICAgICAgICAgcmVzaXplOiB0aW1lUmVzaXplSGFuZGxlclxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHdlZWtWaWV3LmFkZENoaWxkKHRpbWVHcmlkVmlldyk7XG5cbiAgICAvLyBhZGQgY29udHJvbGxlclxuICAgIHdlZWtWaWV3LmNvbnRyb2xsZXIgPSBiYXNlQ29udHJvbGxlci5XZWVrO1xuXG4gICAgLy8gYWRkIGRlc3Ryb3lcbiAgICB3ZWVrVmlldy5fYmVmb3JlRGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aW1lQ3JlYXRpb25IYW5kbGVyLm9mZigpO1xuICAgICAgICB0aW1lTW92ZUhhbmRsZXIub2ZmKCk7XG4gICAgICAgIHRpbWVSZXNpemVIYW5kbGVyLm9mZigpO1xuICAgICAgICB0aW1lQ3JlYXRpb25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGltZU1vdmVIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGltZVJlc2l6ZUhhbmRsZXIuZGVzdHJveSgpO1xuXG4gICAgICAgIGFsbGRheUNyZWF0aW9uSGFuZGxlci5vZmYoKTtcbiAgICAgICAgYWxsZGF5TW92ZUhhbmRsZXIub2ZmKCk7XG4gICAgICAgIGFsbGRheVJlc2l6ZUhhbmRsZXIub2ZmKCk7XG4gICAgICAgIGFsbGRheUNyZWF0aW9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgIGFsbGRheU1vdmVIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgYWxsZGF5UmVzaXplSGFuZGxlci5kZXN0cm95KCk7XG5cbiAgICAgICAgZGVsZXRlIHdlZWtWaWV3LmhhbmRsZXJzLnRpbWU7XG4gICAgICAgIGRlbGV0ZSB3ZWVrVmlldy5oYW5kbGVycy5hbGxkYXk7XG5cbiAgICAgICAgdGltZUNyZWF0aW9uSGFuZGxlciA9IHRpbWVNb3ZlSGFuZGxlciA9IHRpbWVSZXNpemVIYW5kbGVyID0gbnVsbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHdlZWtWaWV3O1xufTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBCYXNlIG1peGluIG9iamVjdCBmb3IgaGFuZGxlci9hbGxkYXlcbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgZG9tZXZlbnQgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tZXZlbnQnKTtcbnZhciBkYXRldGltZSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kYXRldGltZScpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9jb21tb24nKTtcblxudmFyIG1tYXggPSBNYXRoLm1heCxcbiAgICBtbWluID0gTWF0aC5taW4sXG4gICAgQ09OVEFJTkVSX1BBRERJTkdfTEVGVCA9IDYwO1xuXG4vKipcbiAqIEBtaXhpbiBBbGxkYXkuQ29yZVxuICovXG52YXIgYWxsZGF5Q29yZSA9IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FsbGRheX0gYWxsZGF5VmlldyAtIHZpZXcgaW5zdGFuY2Ugb2YgYWxsZGF5LlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gbW91c2VFdmVudCAtIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259IGZ1bmN0aW9uIHRoYXQgcmV0dXJuIGV2ZW50IGRhdGEgYnkgbW91c2UgZXZlbnRzLlxuICAgICAqL1xuICAgIF9yZXRyaXZlRXZlbnREYXRhOiBmdW5jdGlvbihhbGxkYXlWaWV3LCBtb3VzZUV2ZW50KSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBhbGxkYXlWaWV3LmNvbnRhaW5lcixcbiAgICAgICAgICAgIHJlbmRlclN0YXJ0RGF0ZSxcbiAgICAgICAgICAgIHJlbmRlckVuZERhdGUsXG4gICAgICAgICAgICBkYXRlc0luUmFuZ2UsXG4gICAgICAgICAgICBjb250YWluZXJXaWR0aCxcbiAgICAgICAgICAgIG1vdXNlUG9zLFxuICAgICAgICAgICAgZHJhZ1N0YXJ0WEluZGV4O1xuXG4gICAgICAgIHJlbmRlclN0YXJ0RGF0ZSA9IGRhdGV0aW1lLnBhcnNlKGFsbGRheVZpZXcub3B0aW9ucy5yZW5kZXJTdGFydERhdGUpO1xuICAgICAgICByZW5kZXJFbmREYXRlID0gZGF0ZXRpbWUuZW5kKGRhdGV0aW1lLnBhcnNlKGFsbGRheVZpZXcub3B0aW9ucy5yZW5kZXJFbmREYXRlKSk7XG4gICAgICAgIGRhdGVzSW5SYW5nZSA9IGRhdGV0aW1lLnJhbmdlKHJlbmRlclN0YXJ0RGF0ZSwgcmVuZGVyRW5kRGF0ZSwgZGF0ZXRpbWUuTUlMTElTRUNPTkRTX1BFUl9EQVkpLmxlbmd0aDtcbiAgICAgICAgY29udGFpbmVyV2lkdGggPSBkb211dGlsLmdldFNpemUoY29udGFpbmVyKVswXSAtIENPTlRBSU5FUl9QQURESU5HX0xFRlQ7ICAgIC8vIHN1YnRyYWN0IGNvbnRhaW5lciBsZWZ0IHBhZGRpbmcuXG5cbiAgICAgICAgbW91c2VQb3MgPSBkb21ldmVudC5nZXRNb3VzZVBvc2l0aW9uKG1vdXNlRXZlbnQsIGNvbnRhaW5lcik7XG4gICAgICAgIGRyYWdTdGFydFhJbmRleCA9IGNvbW1vbi5yYXRpbyhjb250YWluZXJXaWR0aCwgZGF0ZXNJblJhbmdlLCBtb3VzZVBvc1swXSAtIENPTlRBSU5FUl9QQURESU5HX0xFRlQpIHwgMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50IC0gbW91c2UgZXZlbnQgaW4gZHJhZyBhY3Rpb25zLlxuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBldmVudCBkYXRhLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSBkb21ldmVudC5nZXRNb3VzZVBvc2l0aW9uKG1vdXNlRXZlbnQsIGNvbnRhaW5lciksXG4gICAgICAgICAgICAgICAgbW91c2VYID0gcG9zWzBdIC0gQ09OVEFJTkVSX1BBRERJTkdfTEVGVCxcbiAgICAgICAgICAgICAgICB4SW5kZXggPSBjb21tb24ucmF0aW8oY29udGFpbmVyV2lkdGgsIGRhdGVzSW5SYW5nZSwgbW91c2VYKSB8IDA7XG5cbiAgICAgICAgICAgIC8vIGFwcGx5IGxpbWl0YXRpb24gb2YgY3JlYXRpb24gZXZlbnQgWCBpbmRleC5cbiAgICAgICAgICAgIHhJbmRleCA9IG1tYXgoeEluZGV4LCAwKTtcbiAgICAgICAgICAgIHhJbmRleCA9IG1taW4oeEluZGV4LCBkYXRlc0luUmFuZ2UgLSAxKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZWxhdGVkVmlldzogYWxsZGF5VmlldyxcbiAgICAgICAgICAgICAgICBkcmFnU3RhcnRYSW5kZXg6IGRyYWdTdGFydFhJbmRleCxcbiAgICAgICAgICAgICAgICBkYXRlc0luUmFuZ2U6IGRhdGVzSW5SYW5nZSxcbiAgICAgICAgICAgICAgICB4SW5kZXg6IHhJbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFsbGRheUNvcmU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBIYW5kbGVyIG1vZHVsZSBmb3IgTW9udGhXZWVrIHZpZXcncyBjcmVhdGlvbiBhY3Rpb25zLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi8uLi9jb21tb24vY29tbW9uJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgYWxsZGF5Q29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIEFsbGRheUNyZWF0aW9uR3VpZGUgPSByZXF1aXJlKCcuL2NyZWF0aW9uR3VpZGUnKTtcblxudmFyIHBhcnNlVmlld0lEUnggPSAvXnNjaGVkdWxlLXZpZXctYWxsZGF5LW1vbnRod2Vla1tcXHNdc2NoZWR1bGUtdmlldy0oXFxkKykvO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge0hhbmRsZXJ9XG4gKiBAbWl4ZXMgQWxsZGF5Q29yZVxuICogQG1peGVzIEN1dG9tRXZlbnRzXG4gKiBAcGFyYW0ge0RyYWd9IFtkcmFnSGFuZGxlcl0gLSBEcmFnIGhhbmRsZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0FsbGRheX0gW2FsbGRheVZpZXddIC0gTW9udGhXZWVrIHZpZXcgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0Jhc2V9IFtiYXNlQ29udHJvbGxlcl0gLSBCYXNlIGNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIEFsbGRheUNyZWF0aW9uKGRyYWdIYW5kbGVyLCBhbGxkYXlWaWV3LCBiYXNlQ29udHJvbGxlcikgeyAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgLyoqXG4gICAgICogRHJhZyBoYW5kbGVyIGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtEcmFnfVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogYWxsZGF5IHZpZXcgaW5zdGFuY2UuXG4gICAgICogQHR5cGUge0FsbGRheX1cbiAgICAgKi9cbiAgICB0aGlzLmFsbGRheVZpZXcgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQmFzZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtCYXNlfVxuICAgICAqL1xuICAgIHRoaXMuYmFzZUNvbnRyb2xsZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuZ2V0RXZlbnREYXRhRnVuYyA9IG51bGw7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmNvbm5lY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QWxsZGF5Q3JlYXRpb25HdWlkZX1cbiAgICAgKi9cbiAgICB0aGlzLmd1aWRlID0gbmV3IEFsbGRheUNyZWF0aW9uR3VpZGUodGhpcyk7XG59XG5cbi8qKlxuICogRGVzdHJveSBtZXRob2RcbiAqL1xuQWxsZGF5Q3JlYXRpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmd1aWRlLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9mZih0aGlzKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gdGhpcy5hbGxkYXlWaWV3ID0gdGhpcy5iYXNlQ29udHJvbGxlciA9XG4gICAgICAgIHRoaXMuZ2V0RXZlbnREYXRhRnVuYyA9IG51bGw7XG59O1xuXG4vKipcbiAqIENoZWNrIGRyYWdzdGFydCB0YXJnZXQgaXMgZXhwZWN0ZWQgY29uZGl0aW9ucyBmb3IgdGhpcyBoYW5kbGVyLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gZHJhZ3N0YXJ0IGV2ZW50IGhhbmRsZXIncyB0YXJnZXQgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufE1vbnRoV2Vla30gcmV0dXJuIE1vbnRoV2VlayB2aWV3IGluc3RhbmNlIHdoZW4gc2F0aWF0ZSBjb25kaXRpb24uXG4gKi9cbkFsbGRheUNyZWF0aW9uLnByb3RvdHlwZS5jaGVja0V4cGVjdGVkQ29uZGl0aW9uID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgdmFyIGNzc0NsYXNzID0gZG9tdXRpbC5nZXRDbGFzcyh0YXJnZXQpLFxuICAgICAgICBtYXRjaGVzO1xuXG4gICAgaWYgKGNzc0NsYXNzICE9PSAnc2NoZWR1bGUtdmlldy1tb250aHdlZWstZXZlbnRzJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgY3NzQ2xhc3MgPSBkb211dGlsLmdldENsYXNzKHRhcmdldCk7XG4gICAgbWF0Y2hlcyA9IGNzc0NsYXNzLm1hdGNoKHBhcnNlVmlld0lEUngpO1xuXG4gICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWwucGljayh0aGlzLmFsbGRheVZpZXcuY2hpbGRzLml0ZW1zLCBtYXRjaGVzWzFdKTtcbn07XG5cbi8qKlxuICogQ29ubmVjdCBoYW5kbGVyLCB2aWV3LCBjb250cm9sbGVyLlxuICogQHBhcmFtIHtEcmFnfSBbZHJhZ0hhbmRsZXJdIC0gRHJhZyBoYW5kbGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHtBbGxkYXl9IFthbGxkYXlWaWV3XSAtIE1vbnRoV2VlayB2aWV3IGluc3RhbmNlLlxuICogQHBhcmFtIHtCYXNlfSBbYmFzZUNvbnRyb2xsZXJdIC0gQmFzZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICovXG5BbGxkYXlDcmVhdGlvbi5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKGRyYWdIYW5kbGVyLCBhbGxkYXlWaWV3LCBiYXNlQ29udHJvbGxlcikge1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBkcmFnSGFuZGxlcjtcbiAgICB0aGlzLmFsbGRheVZpZXcgPSBhbGxkYXlWaWV3O1xuICAgIHRoaXMuYmFzZUNvbnRyb2xsZXIgPSBiYXNlQ29udHJvbGxlcjtcblxuICAgIGRyYWdIYW5kbGVyLm9uKHtcbiAgICAgICAgZHJhZ1N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydFxuICAgIH0sIHRoaXMpO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IGV2ZW50IG1vZGVsIGNyZWF0aW9uIHRvIGNvbnRyb2xsZXIgYnkgY3VzdG9tIGV2ZW50cy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBldmVudERhdGEgLSBldmVudCBkYXRhIGZyb20gQWxsZGF5Q3JlYXRpb24gbW9kdWxlLlxuICovXG5BbGxkYXlDcmVhdGlvbi5wcm90b3R5cGUuX2NyZWF0ZUV2ZW50ID0gZnVuY3Rpb24oZXZlbnREYXRhKSB7XG4gICAgdmFyIHRpdGxlID0gd2luZG93LnByb21wdCgnTmFtZSBvZiBldmVudCB0byBjcmVhdGU6JyksXG4gICAgICAgIGN0cmwgPSB0aGlzLmJhc2VDb250cm9sbGVyLFxuICAgICAgICB2aWV3T3B0aW9ucyA9IGV2ZW50RGF0YS5yZWxhdGVkVmlldy5vcHRpb25zLFxuICAgICAgICBkYXRlUmFuZ2UgPSBkYXRldGltZS5yYW5nZShcbiAgICAgICAgICAgIGRhdGV0aW1lLnN0YXJ0KGRhdGV0aW1lLnBhcnNlKHZpZXdPcHRpb25zLnJlbmRlclN0YXJ0RGF0ZSkpLFxuICAgICAgICAgICAgZGF0ZXRpbWUuZW5kKGRhdGV0aW1lLnBhcnNlKHZpZXdPcHRpb25zLnJlbmRlckVuZERhdGUpKSxcbiAgICAgICAgICAgIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZXG4gICAgICAgICksXG4gICAgICAgIHN0YXJ0WEluZGV4ID0gZXZlbnREYXRhLmRyYWdTdGFydFhJbmRleCxcbiAgICAgICAgeEluZGV4ID0gZXZlbnREYXRhLnhJbmRleCxcbiAgICAgICAgbmV3U3RhcnRzLFxuICAgICAgICBuZXdFbmRzO1xuXG4gICAgdGhpcy5ndWlkZS5jbGVhckd1aWRlRWxlbWVudCgpO1xuXG4gICAgaWYgKCF0aXRsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gd2hlbiBpbnZlcnNlIHN0YXJ0LCBlbmQgdGhlbiBjaGFuZ2UgaXQuXG4gICAgaWYgKHhJbmRleCA8IHN0YXJ0WEluZGV4KSB7XG4gICAgICAgIHN0YXJ0WEluZGV4ID0geEluZGV4ICsgc3RhcnRYSW5kZXg7XG4gICAgICAgIHhJbmRleCA9IHN0YXJ0WEluZGV4IC0geEluZGV4O1xuICAgICAgICBzdGFydFhJbmRleCA9IHN0YXJ0WEluZGV4IC0geEluZGV4O1xuICAgIH1cblxuICAgIG5ld1N0YXJ0cyA9IG5ldyBEYXRlKGRhdGVSYW5nZVtzdGFydFhJbmRleF0uZ2V0VGltZSgpKTtcbiAgICBuZXdFbmRzID0gZGF0ZXRpbWUuZW5kKGRhdGVSYW5nZVt4SW5kZXhdKTtcblxuICAgIC8vIHJlcXVlc3QgZXZlbnQgY3JlYXRpb24gdG8gXCJiYXNlXCIgY29udHJvbGxlci5cbiAgICBjdHJsLmNyZWF0ZUV2ZW50KHtcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICBpc0FsbERheTogdHJ1ZSxcbiAgICAgICAgc3RhcnRzOiBuZXdTdGFydHMsXG4gICAgICAgIGVuZHM6IG5ld0VuZHNcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRHJhZ1N0YXJ0IGV2ZW50IGhhbmRsZXIgbWV0aG9kLlxuICogQGVtaXRzIEFsbGRheUNyZWF0aW9uI2FsbGRheV9jcmVhdGlvbl9kcmFnc3RhcnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnU3RhcnRFdmVudERhdGEgLSBEcmFnI2RyYWdTdGFydCBldmVudCBoYW5kbGVyIGV2ZW50IGRhdGEuXG4gKi9cbkFsbGRheUNyZWF0aW9uLnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbihkcmFnU3RhcnRFdmVudERhdGEpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZHJhZ1N0YXJ0RXZlbnREYXRhLnRhcmdldCxcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5jaGVja0V4cGVjdGVkQ29uZGl0aW9uKHRhcmdldCksXG4gICAgICAgIGdldEV2ZW50RGF0YUZ1bmMsXG4gICAgICAgIGV2ZW50RGF0YTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9uKHtcbiAgICAgICAgZHJhZzogdGhpcy5fb25EcmFnLFxuICAgICAgICBkcmFnRW5kOiB0aGlzLl9vbkRyYWdFbmQsXG4gICAgICAgIGNsaWNrOiB0aGlzLl9vbkNsaWNrXG4gICAgfSwgdGhpcyk7XG5cbiAgICBnZXRFdmVudERhdGFGdW5jID0gdGhpcy5nZXRFdmVudERhdGFGdW5jID0gdGhpcy5fcmV0cml2ZUV2ZW50RGF0YSh0aGlzLmFsbGRheVZpZXcsIGRyYWdTdGFydEV2ZW50RGF0YS5vcmlnaW5FdmVudCk7XG4gICAgZXZlbnREYXRhID0gZ2V0RXZlbnREYXRhRnVuYyhkcmFnU3RhcnRFdmVudERhdGEub3JpZ2luRXZlbnQpO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IEFsbGRheUNyZWF0aW9uI2FsbGRheV9jcmVhdGlvbl9kcmFnc3RhcnRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7QWxsZGF5Vmlld30gcmVsYXRlZFZpZXcgLSBhbGxkYXkgdmlldyBpbnN0YW5jZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGF0ZXNJblJhbmdlIC0gZGF0ZSBjb3VudCBvZiB0aGlzIHZpZXcuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRyYWdTdGFydFhJbmRleCAtIGluZGV4IG51bWJlciBvZiBkcmFnc3RhcnQgZ3JpZCBpbmRleC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIG1vdXNlIHBvc2l0aW9ucy5cbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ2FsbGRheV9jcmVhdGlvbl9kcmFnc3RhcnQnLCBldmVudERhdGEpO1xufTtcblxuLyoqXG4gKiBEcmFnIGV2ZW50IGhhbmRsZXIgbWV0aG9kLlxuICogQGVtaXRzIEFsbGRheUNyZWF0aW9uI2FsbGRheV9jcmVhdGlvbl9kcmFnXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ0V2ZW50RGF0YSAtIERyYWcjZHJhZyBldmVudCBoYW5kbGVyIGV2ZW50ZGF0YS5cbiAqL1xuQWxsZGF5Q3JlYXRpb24ucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbihkcmFnRXZlbnREYXRhKSB7XG4gICAgdmFyIGdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLmdldEV2ZW50RGF0YUZ1bmMsXG4gICAgICAgIGV2ZW50RGF0YTtcblxuICAgIGlmICghZ2V0RXZlbnREYXRhRnVuYykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnREYXRhID0gZ2V0RXZlbnREYXRhRnVuYyhkcmFnRXZlbnREYXRhLm9yaWdpbkV2ZW50KTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBBbGxkYXlDcmVhdGlvbiNhbGxkYXlfY3JlYXRpb25fZHJhZ1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtBbGxkYXlWaWV3fSByZWxhdGVkVmlldyAtIGFsbGRheSB2aWV3IGluc3RhbmNlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRlc0luUmFuZ2UgLSBkYXRlIGNvdW50IG9mIHRoaXMgdmlldy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZHJhZ1N0YXJ0WEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIGRyYWdzdGFydCBncmlkIGluZGV4LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4SW5kZXggLSBpbmRleCBudW1iZXIgb2YgbW91c2UgcG9zaXRpb25zLlxuICAgICAqL1xuICAgIHRoaXMuZmlyZSgnYWxsZGF5X2NyZWF0aW9uX2RyYWcnLCBldmVudERhdGEpO1xufTtcblxuLyoqXG4gKiBEcmFnRW5kIGV2ZW50IGhhbmRlciBtZXRob2QuXG4gKiBAZW1pdHMgQWxsZGF5Q3JlYXRpb24jYWxsZGF5X2NyZWF0aW9uX2RyYWdlbmRcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnRW5kRXZlbnREYXRhIC0gRHJhZyNEcmFnRW5kIGV2ZW50IGhhbmRsZXIgZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3ZlcnJpZGVFdmVudE5hbWVdIC0gb3ZlcnJpZGUgZW1pdHRlZCBldmVudCBuYW1lIHdoZW4gc3VwcGxpZWQuXG4gKi9cbkFsbGRheUNyZWF0aW9uLnByb3RvdHlwZS5fb25EcmFnRW5kID0gZnVuY3Rpb24oZHJhZ0VuZEV2ZW50RGF0YSwgb3ZlcnJpZGVFdmVudE5hbWUpIHtcbiAgICB2YXIgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuZ2V0RXZlbnREYXRhRnVuYyxcbiAgICAgICAgZXZlbnREYXRhO1xuXG4gICAgaWYgKCFnZXRFdmVudERhdGFGdW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9mZih7XG4gICAgICAgIGRyYWc6IHRoaXMuX29uRHJhZyxcbiAgICAgICAgZHJhZ0VuZDogdGhpcy5fb25EcmFnRW5kLFxuICAgICAgICBjbGljazogdGhpcy5fb25DbGlja1xuICAgIH0sIHRoaXMpO1xuXG4gICAgZXZlbnREYXRhID0gZ2V0RXZlbnREYXRhRnVuYyhkcmFnRW5kRXZlbnREYXRhLm9yaWdpbkV2ZW50KTtcblxuICAgIHRoaXMuX2NyZWF0ZUV2ZW50KGV2ZW50RGF0YSk7XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgQWxsZGF5Q3JlYXRpb24jYWxsZGF5X2NyZWF0aW9uX2RyYWdlbmRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7QWxsZGF5Vmlld30gcmVsYXRlZFZpZXcgLSBhbGxkYXkgdmlldyBpbnN0YW5jZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGF0ZXNJblJhbmdlIC0gZGF0ZSBjb3VudCBvZiB0aGlzIHZpZXcuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRyYWdTdGFydFhJbmRleCAtIGluZGV4IG51bWJlciBvZiBkcmFnc3RhcnQgZ3JpZCBpbmRleC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIG1vdXNlIHBvc2l0aW9ucy5cbiAgICAgKi9cbiAgICB0aGlzLmZpcmUob3ZlcnJpZGVFdmVudE5hbWUgfHwgJ2FsbGRheV9jcmVhdGlvbl9kcmFnZW5kJywgZXZlbnREYXRhKTtcblxuICAgIHRoaXMuZ2V0RXZlbnREYXRhRnVuYyA9IG51bGw7XG59O1xuXG4vKipcbiAqIENsaWNrIGV2ZW50IGhhbmRsZXIgbWV0aG9kLlxuICogQGVtaXRzIEFsbGRheUNyZWF0aW9uI2FsbGRheV9jcmVhdGlvbl9jbGlja1xuICogQHBhcmFtIHtvYmplY3R9IGNsaWNrRXZlbnREYXRhIC0gRHJhZyNDbGljayBldmVudCBoYW5kbGVyIGRhdGEuXG4gKi9cbkFsbGRheUNyZWF0aW9uLnByb3RvdHlwZS5fb25DbGljayA9IGZ1bmN0aW9uKGNsaWNrRXZlbnREYXRhKSB7XG4gICAgLyoqXG4gICAgICogQGV2ZW50IEFsbGRheUNyZWF0aW9uI2FsbGRheV9jcmVhdGlvbl9jbGlja1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtBbGxkYXlWaWV3fSByZWxhdGVkVmlldyAtIGFsbGRheSB2aWV3IGluc3RhbmNlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRlc0luUmFuZ2UgLSBkYXRlIGNvdW50IG9mIHRoaXMgdmlldy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZHJhZ1N0YXJ0WEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIGRyYWdzdGFydCBncmlkIGluZGV4LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4SW5kZXggLSBpbmRleCBudW1iZXIgb2YgbW91c2UgcG9zaXRpb25zLlxuICAgICAqL1xuICAgIHRoaXMuX29uRHJhZ0VuZChjbGlja0V2ZW50RGF0YSwgJ2FsbGRheV9jcmVhdGlvbl9jbGljaycpO1xufTtcblxuY29tbW9uLm1peGluKGFsbGRheUNvcmUsIEFsbGRheUNyZWF0aW9uKTtcbnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKEFsbGRheUNyZWF0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbGxkYXlDcmVhdGlvbjtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEd1aWRlIGVsZW1lbnQgZm9yIEFsbGRheS5DcmVhdGlvblxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciByZXFBbmltRnJhbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vcmVxQW5pbUZyYW1lJyk7XG5cbnZhciBDUkVBVEVfTkVXX0xBQkVMID0gJ+yDiCDsnbzsoJUnO1xuXG4vKipcbiAqIENsYXNzIGZvciBBbGxkYXkuQ3JlYXRpb24gZHJhZ2dpbmcgZWZmZWN0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FsbGRheUNyZWF0aW9ufSBhbGxkYXlDcmVhdGlvbiAtIGluc3RhbmNlIG9mIEFsbGRheUNyZWF0aW9uLlxuICovXG5mdW5jdGlvbiBBbGxkYXlDcmVhdGlvbkd1aWRlKGFsbGRheUNyZWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FsbGRheUNyZWF0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuYWxsZGF5Q3JlYXRpb24gPSBhbGxkYXlDcmVhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRElWRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmV2ZW50Q29udGFpbmVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRElWRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmd1aWRlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgdGhpcy5pbml0aWFsaXplR3VpZGVFbGVtZW50KCk7XG5cbiAgICBhbGxkYXlDcmVhdGlvbi5vbih7XG4gICAgICAgICdhbGxkYXlfY3JlYXRpb25fZHJhZ3N0YXJ0JzogdGhpcy5fb25EcmFnU3RhcnQsXG4gICAgICAgICdhbGxkYXlfY3JlYXRpb25fZHJhZyc6IHRoaXMuX29uRHJhZyxcbiAgICAgICAgLy8gJ2FsbGRheV9jcmVhdGlvbl9kcmFnZW5kJzogdGhpcy5jbGVhckd1aWRlRWxlbWVudCxcbiAgICAgICAgJ2FsbGRheV9jcmVhdGlvbl9jbGljayc6IHRoaXMuY2xlYXJHdWlkZUVsZW1lbnRcbiAgICB9LCB0aGlzKTtcbn1cblxuLyoqXG4gKiBEZXN0cm95IG1ldGhvZFxuICovXG5BbGxkYXlDcmVhdGlvbkd1aWRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhckd1aWRlRWxlbWVudCgpO1xuICAgIHRoaXMuYWxsZGF5Q3JlYXRpb24ub2ZmKHRoaXMpO1xuICAgIHRoaXMuYWxsZGF5Q3JlYXRpb24gPSB0aGlzLmV2ZW50Q29udGFpbmVyID1cbiAgICAgICAgdGhpcy5ndWlkZUVsZW1lbnQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBpbml0aWFsaXplIGd1aWRlIGVsZW1lbnQncyBkZWZhdWx0IHN0eWxlLlxuICovXG5BbGxkYXlDcmVhdGlvbkd1aWRlLnByb3RvdHlwZS5pbml0aWFsaXplR3VpZGVFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGd1aWRlRWxlbWVudCA9IHRoaXMuZ3VpZGVFbGVtZW50LFxuICAgICAgICBhbGxkYXlWaWV3ID0gdGhpcy5hbGxkYXlDcmVhdGlvbi5hbGxkYXlWaWV3LFxuICAgICAgICBldmVudEJsb2NrSGVpZ2h0ID0gYWxsZGF5Vmlldy5vcHRpb25zLmV2ZW50QmxvY2tIZWlnaHQsXG4gICAgICAgIHNwYW5FbGVtZW50O1xuXG4gICAgZG9tdXRpbC5hZGRDbGFzcyhndWlkZUVsZW1lbnQsICdzY2hlZHVsZS12aWV3LWFsbGRheS1jcmVhdGlvbi1ndWlkZS1ibG9jaycpO1xuICAgIGRvbXV0aWwuYXBwZW5kSFRNTEVsZW1lbnQoJ2RpdicsIGd1aWRlRWxlbWVudCwgJ3NjaGVkdWxlLXZpZXctYWxsZGF5LWNyZWF0aW9uLWd1aWRlJyk7XG5cbiAgICBzcGFuRWxlbWVudCA9IGRvbXV0aWwuYXBwZW5kSFRNTEVsZW1lbnQoJ3NwYW4nLCBndWlkZUVsZW1lbnQpO1xuICAgIHNwYW5FbGVtZW50LmlubmVySFRNTCA9IENSRUFURV9ORVdfTEFCRUw7XG59O1xuXG4vKipcbiAqIFJlZnJlc2ggZ3VpZGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBldmVudERhdGEgLSBldmVudCBkYXRhIGZyb20gQWxsZGF5LkNyZWF0aW9uIGhhbmRsZXIuXG4gKi9cbkFsbGRheUNyZWF0aW9uR3VpZGUucHJvdG90eXBlLl9yZWZyZXNoR3VpZGVFbGVtZW50ID0gZnVuY3Rpb24oZXZlbnREYXRhKSB7XG4gICAgdmFyIGd1aWRlRWxlbWVudCA9IHRoaXMuZ3VpZGVFbGVtZW50LFxuICAgICAgICBiYXNlV2lkdGhQZXJjZW50ID0gKDEwMCAvIGV2ZW50RGF0YS5kYXRlc0luUmFuZ2UpLFxuICAgICAgICBkcmFnU3RhcnRYSW5kZXggPSBldmVudERhdGEuZHJhZ1N0YXJ0WEluZGV4LFxuICAgICAgICB4SW5kZXggPSBldmVudERhdGEueEluZGV4LFxuICAgICAgICBsZW5ndGggPSB4SW5kZXggLSBkcmFnU3RhcnRYSW5kZXgsXG4gICAgICAgIGxlZnRQZXJjZW50LFxuICAgICAgICB3aWR0aFBlcmNlbnQ7XG5cbiAgICAvLyB3aGVuIHJldmVydCBkcmFnZ2luZy5cbiAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICBkcmFnU3RhcnRYSW5kZXggPSB4SW5kZXg7XG4gICAgICAgIGxlbmd0aCA9IE1hdGguYWJzKGxlbmd0aCk7XG4gICAgfVxuXG4gICAgbGVmdFBlcmNlbnQgPSBiYXNlV2lkdGhQZXJjZW50ICogZHJhZ1N0YXJ0WEluZGV4O1xuICAgIHdpZHRoUGVyY2VudCA9IGJhc2VXaWR0aFBlcmNlbnQgKiAobGVuZ3RoICsgMSk7XG5cbiAgICByZXFBbmltRnJhbWUucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgZ3VpZGVFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICBndWlkZUVsZW1lbnQuc3R5bGUubGVmdCA9IGxlZnRQZXJjZW50ICsgJyUnO1xuICAgICAgICBndWlkZUVsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aFBlcmNlbnQgKyAnJSc7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENsZWFyIGd1aWRlIGVsZW1lbnQuXG4gKi9cbkFsbGRheUNyZWF0aW9uR3VpZGUucHJvdG90eXBlLmNsZWFyR3VpZGVFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGd1aWRlRWxlbWVudCA9IHRoaXMuZ3VpZGVFbGVtZW50O1xuXG4gICAgZG9tdXRpbC5yZW1vdmUoZ3VpZGVFbGVtZW50KTtcblxuICAgIGd1aWRlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGd1aWRlRWxlbWVudC5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgZ3VpZGVFbGVtZW50LnN0eWxlLndpZHRoID0gJyc7XG59O1xuXG4vKipcbiAqIERyYWdTdGFydCBldmVudCBoYW5kbGVyLlxuICogQHBhcmFtIHtvYmplY3R9IGRyYWdTdGFydEV2ZW50RGF0YSAtIGV2ZW50IGRhdGEgb2JqZWN0IG9mIEFsbGRheS5DcmVhdGlvbi5cbiAqL1xuQWxsZGF5Q3JlYXRpb25HdWlkZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZHJhZ1N0YXJ0RXZlbnREYXRhKSB7XG4gICAgdmFyIGFsbGRheUNyZWF0aW9uID0gdGhpcy5hbGxkYXlDcmVhdGlvbixcbiAgICAgICAgYWxsZGF5VmlldyA9IGFsbGRheUNyZWF0aW9uLmFsbGRheVZpZXcsXG4gICAgICAgIGFsbGRheUNvbnRhaW5lckVsZW1lbnQgPSBhbGxkYXlWaWV3LmNvbnRhaW5lcixcbiAgICAgICAgZXZlbnRDb250YWluZXIgPSBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LW1vbnRod2Vlay1ldmVudHMnLCBhbGxkYXlDb250YWluZXJFbGVtZW50KTtcblxuICAgIGV2ZW50Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZ3VpZGVFbGVtZW50KTtcbiAgICB0aGlzLl9yZWZyZXNoR3VpZGVFbGVtZW50KGRyYWdTdGFydEV2ZW50RGF0YSk7XG59O1xuXG4vKipcbiAqIERyYWcgZXZlbnQgaGFuZGxlci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnRXZlbnREYXRhIC0gZXZlbnQgZGF0YSBvYmplY3Qgb2YgQWxsZGF5LkNyZWF0aW9uLlxuICovXG5BbGxkYXlDcmVhdGlvbkd1aWRlLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24oZHJhZ0V2ZW50RGF0YSkge1xuICAgIHRoaXMuX3JlZnJlc2hHdWlkZUVsZW1lbnQoZHJhZ0V2ZW50RGF0YSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFsbGRheUNyZWF0aW9uR3VpZGU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBNb3ZlIGhhbmRsZXIgZm9yIEFsbGRheSB2aWV3LlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2NvbW1vbicpO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIEFsbGRheUNvcmUgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBBbGxkYXlNb3ZlR3VpZGUgPSByZXF1aXJlKCcuL21vdmVHdWlkZScpO1xuXG52YXIgY2hlY2tFeHBlY3RlZENvbmRpdGlvbklEUnggPSAvXnNjaGVkdWxlLXZpZXctYWxsZGF5LWV2ZW50KC10aXRsZSk/JC87XG52YXIgcGFyc2VWaWV3SURSeCA9IC9ec2NoZWR1bGUtdmlldy1hbGxkYXktbW9udGh3ZWVrW1xcc11zY2hlZHVsZS12aWV3LShcXGQrKS87XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7SGFuZGxlcn1cbiAqIEBtaXhlcyBBbGxkYXlDb3JlXG4gKiBAbWl4ZXMgQ3VzdG9tRXZlbnRzXG4gKiBAcGFyYW0ge0RyYWd9IFtkcmFnSGFuZGxlcl0gLSBEcmFnIGhhbmRsZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0FsbGRheX0gW2FsbGRheVZpZXddIC0gTW9udGhXZWVrIHZpZXcgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0Jhc2V9IFtiYXNlQ29udHJvbGxlcl0gLSBCYXNlIGNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIEFsbGRheU1vdmUoZHJhZ0hhbmRsZXIsIGFsbGRheVZpZXcsIGJhc2VDb250cm9sbGVyKSB7XG4gICAgLyoqXG4gICAgICogRHJhZyBoYW5kbGVyIGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtEcmFnfVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBkcmFnSGFuZGxlcjtcblxuICAgIC8qKlxuICAgICAqIGFsbGRheSB2aWV3IGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtBbGxkYXl9XG4gICAgICovXG4gICAgdGhpcy5hbGxkYXlWaWV3ID0gYWxsZGF5VmlldztcblxuICAgIC8qKlxuICAgICAqIEJhc2UgY29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7QmFzZX1cbiAgICAgKi9cbiAgICB0aGlzLmJhc2VDb250cm9sbGVyID0gYmFzZUNvbnRyb2xsZXI7XG5cbiAgICAvKipcbiAgICAgKiBUZW1wb3JhcnkgdmFyaWFibGUgZm9yIGRyYWdzdGFydCBldmVudCBkYXRhLlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5fZHJhZ1N0YXJ0ID0gbnVsbDtcblxuICAgIGRyYWdIYW5kbGVyLm9uKHtcbiAgICAgICAgZHJhZ1N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydFxuICAgIH0sIHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FsbGRheU1vdmVHdWlkZX1cbiAgICAgKi9cbiAgICB0aGlzLmd1aWRlID0gbmV3IEFsbGRheU1vdmVHdWlkZSh0aGlzKTtcbn1cblxuQWxsZGF5TW92ZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZ3VpZGUuZGVzdHJveSgpO1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIub2ZmKHRoaXMpO1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSB0aGlzLmFsbGRheVZpZXcgPSB0aGlzLmJhc2VDb250cm9sbGVyID1cbiAgICAgICAgdGhpcy5ndWlkZSA9IHRoaXMuX2RyYWdTdGFydCA9IG51bGw7XG59O1xuXG4vKipcbiAqIENoZWNrIGRyYWdzdGFydCB0YXJnZXQgaXMgZXhwZWN0ZWQgY29uZGl0aW9ucyBmb3IgdGhpcyBoYW5kbGVyLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gZHJhZ3N0YXJ0IGV2ZW50IGhhbmRsZXIncyB0YXJnZXQgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufE1vbnRoV2Vla30gcmV0dXJuIE1vbnRoV2VlayB2aWV3IGluc3RhbmNlIHdoZW4gc2F0aWF0ZSBjb25kaXRpb24uXG4gKi9cbkFsbGRheU1vdmUucHJvdG90eXBlLmNoZWNrRXhwZWN0ZWRDb25kaXRpb24gPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICB2YXIgY3NzQ2xhc3MgPSBkb211dGlsLmdldENsYXNzKHRhcmdldCksXG4gICAgICAgIHBhcmVudFZpZXcsXG4gICAgICAgIG1hdGNoZXM7XG5cbiAgICBpZiAoIWNoZWNrRXhwZWN0ZWRDb25kaXRpb25JRFJ4LnRlc3QoY3NzQ2xhc3MpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwYXJlbnRWaWV3ID0gZG9tdXRpbC5jbG9zZXN0KHRhcmdldCwgJy5zY2hlZHVsZS12aWV3LWFsbGRheS1tb250aHdlZWsnKTtcblxuICAgIGlmICghcGFyZW50Vmlldykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY3NzQ2xhc3MgPSBkb211dGlsLmdldENsYXNzKHBhcmVudFZpZXcpO1xuICAgIG1hdGNoZXMgPSBjc3NDbGFzcy5tYXRjaChwYXJzZVZpZXdJRFJ4KTtcblxuICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlsLnBpY2sodGhpcy5hbGxkYXlWaWV3LmNoaWxkcy5pdGVtcywgbWF0Y2hlc1sxXSk7XG59O1xuXG4vKipcbiAqIERyYWdTdGFydCBldmVudCBoYW5kbGVyIG1ldGhvZC5cbiAqIEBlbWl0cyBBbGxkYXlNb3ZlI2FsbGRheV9tb3ZlX2RyYWdzdGFydFxuICogQHBhcmFtIHtvYmplY3R9IGRyYWdTdGFydEV2ZW50RGF0YSAtIERyYWcjZHJhZ1N0YXJ0IGV2ZW50IGhhbmRsZXIgZXZlbnQgZGF0YS5cbiAqL1xuQWxsZGF5TW92ZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZHJhZ1N0YXJ0RXZlbnREYXRhKSB7XG4gICAgdmFyIHRhcmdldCA9IGRyYWdTdGFydEV2ZW50RGF0YS50YXJnZXQsXG4gICAgICAgIHJlc3VsdCA9IHRoaXMuY2hlY2tFeHBlY3RlZENvbmRpdGlvbih0YXJnZXQpLFxuICAgICAgICBjb250cm9sbGVyID0gdGhpcy5iYXNlQ29udHJvbGxlcixcbiAgICAgICAgZXZlbnRCbG9ja0VsZW1lbnQsXG4gICAgICAgIG1vZGVsSUQsXG4gICAgICAgIHRhcmdldE1vZGVsLFxuICAgICAgICBnZXRFdmVudERhdGFGdW5jLFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnRCbG9ja0VsZW1lbnQgPSBkb211dGlsLmNsb3Nlc3QodGFyZ2V0LCAnLnNjaGVkdWxlLXZpZXctYWxsZGF5LWV2ZW50LWJsb2NrJyk7XG4gICAgbW9kZWxJRCA9IGRvbXV0aWwuZ2V0RGF0YShldmVudEJsb2NrRWxlbWVudCwgJ2lkJyk7XG4gICAgdGFyZ2V0TW9kZWwgPSBjb250cm9sbGVyLmV2ZW50cy5pdGVtc1ttb2RlbElEXTtcblxuICAgIGlmICghdGFyZ2V0TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLmdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9yZXRyaXZlRXZlbnREYXRhKHRoaXMuYWxsZGF5VmlldywgZHJhZ1N0YXJ0RXZlbnREYXRhLm9yaWdpbkV2ZW50KTtcbiAgICBldmVudERhdGEgPSB0aGlzLl9kcmFnU3RhcnQgPSBnZXRFdmVudERhdGFGdW5jKGRyYWdTdGFydEV2ZW50RGF0YS5vcmlnaW5FdmVudCk7XG5cbiAgICB1dGlsLmV4dGVuZChldmVudERhdGEsIHtcbiAgICAgICAgZXZlbnRCbG9ja0VsZW1lbnQ6IGV2ZW50QmxvY2tFbGVtZW50LFxuICAgICAgICBtb2RlbDogdGFyZ2V0TW9kZWxcbiAgICB9KTtcblxuICAgIHRoaXMuZHJhZ0hhbmRsZXIub24oe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBBbGxkYXlNb3ZlI2FsbGRheV9tb3ZlX2RyYWdzdGFydFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtBbGxkYXlWaWV3fSByZWxhdGVkVmlldyAtIGFsbGRheSB2aWV3IGluc3RhbmNlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRlc0luUmFuZ2UgLSBkYXRlIGNvdW50IG9mIHRoaXMgdmlldy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZHJhZ1N0YXJ0WEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIGRyYWdzdGFydCBncmlkIGluZGV4LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4SW5kZXggLSBpbmRleCBudW1iZXIgb2YgbW91c2UgcG9zaXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IG1vZGVsIC0gZGF0YSBvYmplY3Qgb2YgbW9kZWwgaXNudGFuY2UuXG4gICAgICogQHByb3BlcnR5IHtIVE1MRGl2RWxlbWVudH0gZXZlbnRCbG9ja0VsZW1lbnQgLSB0YXJnZXQgZXZlbnQgYmxvY2sgZWxlbWVudC5cbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ2FsbGRheV9tb3ZlX2RyYWdzdGFydCcsIGV2ZW50RGF0YSk7XG59O1xuXG5cbi8qKlxuICogRHJhZyBldmVudCBoYW5kbGVyIG1ldGhvZC5cbiAqIEBlbWl0cyBBbGxkYXlNb3ZlI2FsbGRheV9tb3ZlX2RyYWdcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnRXZlbnREYXRhIC0gRHJhZyNkcmFnIGV2ZW50IGhhbmRsZXIgZXZlbnRkYXRhLlxuICovXG5BbGxkYXlNb3ZlLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24oZHJhZ0V2ZW50RGF0YSkge1xuICAgIHZhciBnZXRFdmVudERhdGFGdW5jID0gdGhpcy5nZXRFdmVudERhdGFGdW5jO1xuXG4gICAgaWYgKCFnZXRFdmVudERhdGFGdW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgQWxsZGF5TW92ZSNhbGxkYXlfbW92ZV9kcmFnXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0FsbGRheVZpZXd9IHJlbGF0ZWRWaWV3IC0gYWxsZGF5IHZpZXcgaW5zdGFuY2UuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGVzSW5SYW5nZSAtIGRhdGUgY291bnQgb2YgdGhpcyB2aWV3LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkcmFnU3RhcnRYSW5kZXggLSBpbmRleCBudW1iZXIgb2YgZHJhZ3N0YXJ0IGdyaWQgaW5kZXguXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHhJbmRleCAtIGluZGV4IG51bWJlciBvZiBtb3VzZSBwb3NpdGlvbnMuXG4gICAgICovXG4gICAgdGhpcy5maXJlKCdhbGxkYXlfbW92ZV9kcmFnJywgZ2V0RXZlbnREYXRhRnVuYyhkcmFnRXZlbnREYXRhLm9yaWdpbkV2ZW50KSk7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgdXBkYXRlIGV2ZW50IG1vZGVsIHRvIGJhc2UgY29udHJvbGxlci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBldmVudERhdGEgLSBldmVudCBkYXRhIGZyb20gQWxsZGF5TW92ZSBoYW5kbGVyIG1vZHVsZS5cbiAqL1xuQWxsZGF5TW92ZS5wcm90b3R5cGUuX3VwZGF0ZUV2ZW50ID0gZnVuY3Rpb24oZXZlbnREYXRhKSB7XG4gICAgdmFyIGN0cmwgPSB0aGlzLmJhc2VDb250cm9sbGVyLFxuICAgICAgICBtb2RlbCA9IGV2ZW50RGF0YS50YXJnZXRNb2RlbCxcbiAgICAgICAgZGF0ZU9mZnNldCA9IGV2ZW50RGF0YS54SW5kZXggLSBldmVudERhdGEuZHJhZ1N0YXJ0WEluZGV4LFxuICAgICAgICBuZXdTdGFydHMgPSBuZXcgRGF0ZShtb2RlbC5zdGFydHMuZ2V0VGltZSgpKSxcbiAgICAgICAgbmV3RW5kcyA9IG5ldyBEYXRlKG1vZGVsLmVuZHMuZ2V0VGltZSgpKTtcblxuICAgIG5ld1N0YXJ0cyA9IG5ldyBEYXRlKG5ld1N0YXJ0cy5zZXREYXRlKG5ld1N0YXJ0cy5nZXREYXRlKCkgKyBkYXRlT2Zmc2V0KSk7XG4gICAgbmV3RW5kcyA9IG5ldyBEYXRlKG5ld0VuZHMuc2V0RGF0ZShuZXdFbmRzLmdldERhdGUoKSArIGRhdGVPZmZzZXQpKTtcblxuICAgIGN0cmwudXBkYXRlRXZlbnQobW9kZWwuaWQoKSwge1xuICAgICAgICBzdGFydHM6IG5ld1N0YXJ0cyxcbiAgICAgICAgZW5kczogbmV3RW5kc1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBEcmFnRW5kIGV2ZW50IGhhbmRlciBtZXRob2QuXG4gKiBAZW1pdHMgQWxsZGF5TW92ZSNhbGxkYXlfbW92ZV9kcmFnZW5kXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ0VuZEV2ZW50RGF0YSAtIERyYWcjRHJhZ0VuZCBldmVudCBoYW5kbGVyIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gW292ZXJyaWRlRXZlbnROYW1lXSAtIG92ZXJyaWRlIGVtaXR0ZWQgZXZlbnQgbmFtZSB3aGVuIHN1cHBsaWVkLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gc2tpcFVwZGF0ZSAtIHRydWUgdGhlbiBza2lwIHVwZGF0ZSBldmVudCBtb2RlbC5cbiAqL1xuQWxsZGF5TW92ZS5wcm90b3R5cGUuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uKGRyYWdFbmRFdmVudERhdGEsIG92ZXJyaWRlRXZlbnROYW1lLCBza2lwVXBkYXRlKSB7XG4gICAgdmFyIGdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLmdldEV2ZW50RGF0YUZ1bmMsXG4gICAgICAgIGRyYWdTdGFydCA9IHRoaXMuX2RyYWdTdGFydCxcbiAgICAgICAgZXZlbnREYXRhO1xuXG4gICAgaWYgKCFnZXRFdmVudERhdGFGdW5jIHx8ICFkcmFnU3RhcnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZHJhZ0hhbmRsZXIub2ZmKHtcbiAgICAgICAgZHJhZzogdGhpcy5fb25EcmFnLFxuICAgICAgICBkcmFnRW5kOiB0aGlzLl9vbkRyYWdFbmQsXG4gICAgICAgIGNsaWNrOiB0aGlzLl9vbkNsaWNrXG4gICAgfSwgdGhpcyk7XG5cbiAgICBldmVudERhdGEgPSBnZXRFdmVudERhdGFGdW5jKGRyYWdFbmRFdmVudERhdGEub3JpZ2luRXZlbnQpO1xuICAgIHV0aWwuZXh0ZW5kKGV2ZW50RGF0YSwge1xuICAgICAgICB0YXJnZXRNb2RlbDogZHJhZ1N0YXJ0Lm1vZGVsXG4gICAgfSk7XG4gICAgXG4gICAgaWYgKCFza2lwVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUV2ZW50KGV2ZW50RGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IEFsbGRheU1vdmUjYWxsZGF5X21vdmVfZHJhZ2VuZFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtBbGxkYXlWaWV3fSByZWxhdGVkVmlldyAtIGFsbGRheSB2aWV3IGluc3RhbmNlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRlc0luUmFuZ2UgLSBkYXRlIGNvdW50IG9mIHRoaXMgdmlldy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZHJhZ1N0YXJ0WEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIGRyYWdzdGFydCBncmlkIGluZGV4LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4SW5kZXggLSBpbmRleCBudW1iZXIgb2YgbW91c2UgcG9zaXRpb25zLlxuICAgICAqL1xuICAgIHRoaXMuZmlyZShvdmVycmlkZUV2ZW50TmFtZSB8fCAnYWxsZGF5X21vdmVfZHJhZ2VuZCcsIGV2ZW50RGF0YSk7XG5cbiAgICB0aGlzLmdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9kcmFnU3RhcnQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDbGljayBldmVudCBoYW5kbGVyIG1ldGhvZC5cbiAqIEBlbWl0cyBBbGxkYXlNb3ZlI2FsbGRheV9tb3ZlX2NsaWNrXG4gKiBAcGFyYW0ge29iamVjdH0gY2xpY2tFdmVudERhdGEgLSBEcmFnI0NsaWNrIGV2ZW50IGhhbmRsZXIgZGF0YS5cbiAqL1xuQWxsZGF5TW92ZS5wcm90b3R5cGUuX29uQ2xpY2sgPSBmdW5jdGlvbihjbGlja0V2ZW50RGF0YSkge1xuICAgIC8qKlxuICAgICAqIEBldmVudCBBbGxkYXlNb3ZlI2FsbGRheV9tb3ZlX2NsaWNrXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0FsbGRheVZpZXd9IHJlbGF0ZWRWaWV3IC0gYWxsZGF5IHZpZXcgaW5zdGFuY2UuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGVzSW5SYW5nZSAtIGRhdGUgY291bnQgb2YgdGhpcyB2aWV3LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkcmFnU3RhcnRYSW5kZXggLSBpbmRleCBudW1iZXIgb2YgZHJhZ3N0YXJ0IGdyaWQgaW5kZXguXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHhJbmRleCAtIGluZGV4IG51bWJlciBvZiBtb3VzZSBwb3NpdGlvbnMuXG4gICAgICovXG4gICAgdGhpcy5fb25EcmFnRW5kKGNsaWNrRXZlbnREYXRhLCAnYWxsZGF5X21vdmVfY2xpY2snLCB0cnVlKTtcbn07XG5cbmNvbW1vbi5taXhpbihBbGxkYXlDb3JlLCBBbGxkYXlNb3ZlKTtcbnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKEFsbGRheU1vdmUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFsbGRheU1vdmU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBFZmZlY3QgbW9kdWxlIGZvciBBbGxkYXkuTW92ZVxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciByZXFBbmltRnJhbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vcmVxQW5pbUZyYW1lJyk7XG5cbi8qKlxuICogQ2xhc3MgZm9yIEFsbGRheS5Nb3ZlIGRyYWdnaW5nIGVmZmVjdC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBbGxkYXlNb3ZlfSBhbGxkYXlNb3ZlIC0gaW5zdGFuY2Ugb2YgQWxsZGF5TW92ZS5cbiAqL1xuZnVuY3Rpb24gQWxsZGF5TW92ZUd1aWRlKGFsbGRheU1vdmUpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QWxsZGF5TW92ZX1cbiAgICAgKi9cbiAgICB0aGlzLmFsbGRheU1vdmUgPSBhbGxkYXlNb3ZlO1xuXG4gICAgLyoqXG4gICAgICog7Iuk7KCc66GcIOydtOuypO2KuCDsl5jrpqzrqLztirjrpbwg64u064qUIOyXmOumrOuovO2KuFxuICAgICAqIEB0eXBlIHtIVE1MRElWRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmV2ZW50Q29udGFpbmVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fZHJhZ1N0YXJ0WEluZGV4ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRElWRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmd1aWRlRWxlbWVudCA9IG51bGw7XG5cbiAgICBhbGxkYXlNb3ZlLm9uKHtcbiAgICAgICAgJ2FsbGRheV9tb3ZlX2RyYWdzdGFydCc6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuICAgICAgICAnYWxsZGF5X21vdmVfZHJhZyc6IHRoaXMuX29uRHJhZyxcbiAgICAgICAgJ2FsbGRheV9tb3ZlX2RyYWdlbmQnOiB0aGlzLl9jbGVhckd1aWRlRWxlbWVudCxcbiAgICAgICAgJ2FsbGRheV9tb3ZlX2NsaWNrJzogdGhpcy5fY2xlYXJHdWlkZUVsZW1lbnRcbiAgICB9LCB0aGlzKTtcbn1cblxuLyoqXG4gKiBEZXN0cm95IG1ldGhvZFxuICovXG5BbGxkYXlNb3ZlR3VpZGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jbGVhckd1aWRlRWxlbWVudCgpO1xuICAgIHRoaXMuYWxsZGF5TW92ZS5vZmYodGhpcyk7XG4gICAgdGhpcy5hbGxkYXlNb3ZlID0gdGhpcy5ldmVudENvbnRhaW5lciA9IHRoaXMuX2RyYWdTdGFydFhJbmRleCA9XG4gICAgICAgIHRoaXMuZ3VpZGVFbGVtZW50ID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xlYXIgZ3VpZGUgZWxlbWVudC5cbiAqL1xuQWxsZGF5TW92ZUd1aWRlLnByb3RvdHlwZS5fY2xlYXJHdWlkZUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICBkb211dGlsLnJlbW92ZSh0aGlzLmd1aWRlRWxlbWVudCk7XG5cbiAgICBpZiAoIXV0aWwuYnJvd3Nlci5tc2llKSB7XG4gICAgICAgIGRvbXV0aWwucmVtb3ZlQ2xhc3MoZ2xvYmFsLmRvY3VtZW50LmJvZHksICdzY2hlZHVsZS12aWV3LWRyYWdnaW5nJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fZHJhZ1N0YXJ0WEluZGV4ID0gdGhpcy5nZXRFdmVudERhdGFGdW5jID0gdGhpcy5ndWlkZUVsZW1lbnQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBSZWZyZXNoIGd1aWRlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdFBlcmNlbnQgLSBsZWZ0IHBlcmNlbnQgb2YgZ3VpZGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFBlcmNlbnQgLSB3aWR0aCBwZXJjZW50IG9mIGd1aWRlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRXhjZWVkZWRMZWZ0IC0gZXZlbnQgc3RhcnRzIGlzIGZhc3RlciB0aGVuIHJlbmRlciBzdGFydCBkYXRlP1xuICogQHBhcmFtIHtib29sZWFufSBpc0V4Y2VlZGVkUmlnaHQgLSBldmVudCBlbmRzIGlzIGxhdGVyIHRoZW4gcmVuZGVyIGVuZCBkYXRlP1xuICovXG5BbGxkYXlNb3ZlR3VpZGUucHJvdG90eXBlLnJlZnJlc2hHdWlkZUVsZW1lbnQgPSBmdW5jdGlvbihsZWZ0UGVyY2VudCwgd2lkdGhQZXJjZW50LCBpc0V4Y2VlZGVkTGVmdCwgaXNFeGNlZWRlZFJpZ2h0KSB7XG4gICAgdmFyIGd1aWRlRWxlbWVudCA9IHRoaXMuZ3VpZGVFbGVtZW50O1xuXG4gICAgcmVxQW5pbUZyYW1lLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgIGd1aWRlRWxlbWVudC5zdHlsZS5sZWZ0ID0gbGVmdFBlcmNlbnQgKyAnJSc7XG4gICAgICAgIGd1aWRlRWxlbWVudC5zdHlsZS53aWR0aCA9IHdpZHRoUGVyY2VudCArICclJztcblxuICAgICAgICBpZiAoaXNFeGNlZWRlZExlZnQpIHtcbiAgICAgICAgICAgIGRvbXV0aWwuYWRkQ2xhc3MoZ3VpZGVFbGVtZW50LCAnc2NoZWR1bGUtdmlldy1hbGxkYXktZXhjZWVkLWxlZnQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbXV0aWwucmVtb3ZlQ2xhc3MoZ3VpZGVFbGVtZW50LCAnc2NoZWR1bGUtdmlldy1hbGxkYXktZXhjZWVkLWxlZnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0V4Y2VlZGVkUmlnaHQpIHtcbiAgICAgICAgICAgIGRvbXV0aWwuYWRkQ2xhc3MoZ3VpZGVFbGVtZW50LCAnc2NoZWR1bGUtdmlldy1hbGxkYXktZXhjZWVkLXJpZ2h0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb211dGlsLnJlbW92ZUNsYXNzKGd1aWRlRWxlbWVudCwgJ3NjaGVkdWxlLXZpZXctYWxsZGF5LWV4Y2VlZC1yaWdodCcpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEdldCBldmVudCBibG9jayBpbmZvcm1hdGlvbiBmcm9tIGV2ZW50IGRhdGEuXG4gKlxuICogRm9yIGV4YW1wbGUsIHRoZXJlIGlzIHNpbmdsZSBldmVudCBoYXMgMTAgbGVuZ3RoLiBidXQgcmVuZGVyIHJhbmdlIGluIHZpZXcgaXMgNSB0aGVuXG4gKiByZW5kZXJlZCBibG9jayBtdXN0IGJlIGN1dCBvdXQgdG8gcmVuZGVyIHByb3Blcmx5LiBpbiB0aGlzIGNhc2UsIHRoaXMgbWV0aG9kIHJldHVyblxuICogaG93IG1hbnkgYmxvY2sgYXJlIGN1dCBiZWZvcmUgcmVuZGVyaW5nLlxuICogXG4gKiDsnbTrsqTtirgg642w7J207YSw7JeQ7IScIOydtOuypO2KuCDruJTroZ0g7JeY66as66i87Yq4IOugjOuNlOungeyXkCDrjIDtlZwg7ZWE7JqUIOygleuztOulvCDstpTstpztlZzri6QuXG4gKlxuICogZXgpIOugjOuNlOungSDrkJwg67iU66Gd7J2YIOq4uOydtOuKlCA17KeA66eMIOyLpOygnCDsnbQg7J2067Kk7Yq464qUIDEw7J2YIOq4uOydtOulvCDqsIDsp4Dqs6Ag7J6I7J2EIOuVjFxuICog7KKMIOyasOuhnCDrqocg66eM7YG8IOyemOugpOyeiOuKlOyngOyXkCDqtIDtlZwg7KCV67O066W8IOuwmO2ZmO2VqC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnU3RhcnRFdmVudERhdGEgLSBldmVudCBkYXRhIGZyb20gQWxsZGF5Lk1vdmUgaGFuZGxlci5cbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gZnVuY3Rpb24gdGhhdCByZXR1cm4gZXZlbnQgYmxvY2sgaW5mb3JtYXRpb24uXG4gKi9cbkFsbGRheU1vdmVHdWlkZS5wcm90b3R5cGUuX2dldEV2ZW50QmxvY2tEYXRhRnVuYyA9IGZ1bmN0aW9uKGRyYWdTdGFydEV2ZW50RGF0YSkge1xuICAgIHZhciBtb2RlbCA9IGRyYWdTdGFydEV2ZW50RGF0YS5tb2RlbCxcbiAgICAgICAgZGF0ZXNJblJhbmdlID0gZHJhZ1N0YXJ0RXZlbnREYXRhLmRhdGVzSW5SYW5nZSxcbiAgICAgICAgYmFzZVdpZHRoUGVyY2VudCA9ICgxMDAgLyBkYXRlc0luUmFuZ2UpLFxuICAgICAgICBvcmlnaW5FdmVudFN0YXJ0cyA9IGRhdGV0aW1lLnN0YXJ0KG1vZGVsLnN0YXJ0cyksXG4gICAgICAgIG9yaWdpbkV2ZW50RW5kcyA9IGRhdGV0aW1lLmVuZChtb2RlbC5lbmRzKSxcbiAgICAgICAgdmlld09wdGlvbnMgPSB0aGlzLmFsbGRheU1vdmUuYWxsZGF5Vmlldy5vcHRpb25zLFxuICAgICAgICByZW5kZXJTdGFydERhdGUgPSBkYXRldGltZS5zdGFydChkYXRldGltZS5wYXJzZSh2aWV3T3B0aW9ucy5yZW5kZXJTdGFydERhdGUpKSxcbiAgICAgICAgcmVuZGVyRW5kRGF0ZSA9IGRhdGV0aW1lLmVuZChkYXRldGltZS5wYXJzZSh2aWV3T3B0aW9ucy5yZW5kZXJFbmREYXRlKSksXG4gICAgICAgIGZyb21MZWZ0ID0gKG5ldyBEYXRlKG9yaWdpbkV2ZW50U3RhcnRzLmdldFRpbWUoKSAtIHJlbmRlclN0YXJ0RGF0ZS5nZXRUaW1lKCkpKSAvIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZIHwgMCxcbiAgICAgICAgZnJvbVJpZ2h0ID0gKG5ldyBEYXRlKG9yaWdpbkV2ZW50RW5kcy5nZXRUaW1lKCkgLSByZW5kZXJFbmREYXRlLmdldFRpbWUoKSkpIC8gZGF0ZXRpbWUuTUlMTElTRUNPTkRTX1BFUl9EQVkgfCAwO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGluZGV4T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiYXNlV2lkdGhQZXJjZW50OiBiYXNlV2lkdGhQZXJjZW50LFxuICAgICAgICAgICAgZnJvbUxlZnQ6IGZyb21MZWZ0ICsgaW5kZXhPZmZzZXQsXG4gICAgICAgICAgICBmcm9tUmlnaHQ6IGZyb21SaWdodCArIGluZGV4T2Zmc2V0XG4gICAgICAgIH07XG4gICAgfTtcbn07XG5cbi8qKlxuICogRHJhZ1N0YXJ0IGV2ZW50IGhhbmRsZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ1N0YXJ0RXZlbnREYXRhIC0gZXZlbnQgZGF0YS5cbiAqL1xuQWxsZGF5TW92ZUd1aWRlLnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbihkcmFnU3RhcnRFdmVudERhdGEpIHtcbiAgICB2YXIgYWxsZGF5Vmlld0NvbnRhaW5lciA9IHRoaXMuYWxsZGF5TW92ZS5hbGxkYXlWaWV3LmNvbnRhaW5lcixcbiAgICAgICAgZ3VpZGVFbGVtZW50ID0gdGhpcy5ndWlkZUVsZW1lbnQgPSBkcmFnU3RhcnRFdmVudERhdGEuZXZlbnRCbG9ja0VsZW1lbnQuY2xvbmVOb2RlKHRydWUpLFxuICAgICAgICBldmVudENvbnRhaW5lcjtcblxuICAgIGlmICghdXRpbC5icm93c2VyLm1zaWUpIHtcbiAgICAgICAgZG9tdXRpbC5hZGRDbGFzcyhnbG9iYWwuZG9jdW1lbnQuYm9keSwgJ3NjaGVkdWxlLXZpZXctZHJhZ2dpbmcnKTtcbiAgICB9XG5cbiAgICBldmVudENvbnRhaW5lciA9IGRvbXV0aWwuZmluZCgnLnNjaGVkdWxlLXZpZXctbW9udGh3ZWVrLWV2ZW50cycsIGFsbGRheVZpZXdDb250YWluZXIpO1xuICAgIGRvbXV0aWwuYWRkQ2xhc3MoZ3VpZGVFbGVtZW50LCAnc2NoZWR1bGUtdmlldy1hbGxkYXktbW92ZS1ndWlkZScpO1xuICAgIGV2ZW50Q29udGFpbmVyLmFwcGVuZENoaWxkKGd1aWRlRWxlbWVudCk7XG5cbiAgICB0aGlzLl9kcmFnU3RhcnRYSW5kZXggPSBkcmFnU3RhcnRFdmVudERhdGEueEluZGV4O1xuICAgIHRoaXMuZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX2dldEV2ZW50QmxvY2tEYXRhRnVuYyhkcmFnU3RhcnRFdmVudERhdGEpO1xufTtcblxuLyoqXG4gKiBEcmFnIGV2ZW50IGhhbmRsZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ0V2ZW50RGF0YSAtIGV2ZW50IGRhdGEuXG4gKi9cbkFsbGRheU1vdmVHdWlkZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uKGRyYWdFdmVudERhdGEpIHtcbiAgICB2YXIgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuZ2V0RXZlbnREYXRhRnVuYyxcbiAgICAgICAgZHJhZ1N0YXJ0WEluZGV4ID0gdGhpcy5fZHJhZ1N0YXJ0WEluZGV4LFxuICAgICAgICBkYXRlc0luUmFuZ2UgPSBkcmFnRXZlbnREYXRhLmRhdGVzSW5SYW5nZSxcbiAgICAgICAgZXZlbnREYXRhLFxuICAgICAgICBpc0V4Y2VlZGVkTGVmdCxcbiAgICAgICAgaXNFeGNlZWRlZFJpZ2h0LFxuICAgICAgICBvcmlnaW5MZW5ndGgsXG4gICAgICAgIG5ld0xlZnQsXG4gICAgICAgIG5ld1dpZHRoO1xuXG4gICAgaWYgKCFnZXRFdmVudERhdGFGdW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudERhdGEgPSBnZXRFdmVudERhdGFGdW5jKGRyYWdFdmVudERhdGEueEluZGV4IC0gZHJhZ1N0YXJ0WEluZGV4KTtcbiAgICBpc0V4Y2VlZGVkTGVmdCA9IGV2ZW50RGF0YS5mcm9tTGVmdCA8IDA7XG4gICAgaXNFeGNlZWRlZFJpZ2h0ID0gZXZlbnREYXRhLmZyb21SaWdodCA+IDA7XG5cbiAgICBuZXdMZWZ0ID0gTWF0aC5tYXgoMCwgZXZlbnREYXRhLmZyb21MZWZ0KTtcbiAgICBvcmlnaW5MZW5ndGggPSAoZXZlbnREYXRhLmZyb21MZWZ0ICogLTEpICsgKGRhdGVzSW5SYW5nZSArIGV2ZW50RGF0YS5mcm9tUmlnaHQpO1xuICAgIG5ld1dpZHRoID0gaXNFeGNlZWRlZExlZnQgPyAob3JpZ2luTGVuZ3RoICsgZXZlbnREYXRhLmZyb21MZWZ0KSA6IG9yaWdpbkxlbmd0aDtcbiAgICBuZXdXaWR0aCA9IGlzRXhjZWVkZWRSaWdodCA/IChuZXdXaWR0aCAtIGV2ZW50RGF0YS5mcm9tUmlnaHQpIDogbmV3V2lkdGg7XG5cbiAgICBuZXdMZWZ0ICo9IGV2ZW50RGF0YS5iYXNlV2lkdGhQZXJjZW50O1xuICAgIG5ld1dpZHRoICo9IGV2ZW50RGF0YS5iYXNlV2lkdGhQZXJjZW50O1xuXG4gICAgdGhpcy5yZWZyZXNoR3VpZGVFbGVtZW50KG5ld0xlZnQsIG5ld1dpZHRoLCBpc0V4Y2VlZGVkTGVmdCwgaXNFeGNlZWRlZFJpZ2h0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWxsZGF5TW92ZUd1aWRlO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVzaXplIGhhbmRsZXIgbW9kdWxlIGZvciBBbGxkYXkgdmlldy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2NvbW1vbicpO1xudmFyIEFsbGRheUNvcmUgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBBbGxkYXlSZXNpemVHdWlkZSA9IHJlcXVpcmUoJy4vcmVzaXplR3VpZGUnKTtcblxudmFyIHBhcnNlVmlld0lEUnggPSAvXnNjaGVkdWxlLXZpZXctYWxsZGF5LW1vbnRod2Vla1tcXHNdc2NoZWR1bGUtdmlldy0oXFxkKykvO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge0hhbmRsZXJ9XG4gKiBAbWl4ZXMgQWxsZGF5Q29yZVxuICogQG1peGVzIEN1c3RvbUV2ZW50c1xuICogQHBhcmFtIHtEcmFnfSBbZHJhZ0hhbmRsZXJdIC0gRHJhZyBoYW5kbGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHtBbGxkYXl9IFthbGxkYXlWaWV3XSAtIE1vbnRoV2VlayB2aWV3IGluc3RhbmNlLlxuICogQHBhcmFtIHtCYXNlfSBbYmFzZUNvbnRyb2xsZXJdIC0gQmFzZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBBbGxkYXlSZXNpemUoZHJhZ0hhbmRsZXIsIGFsbGRheVZpZXcsIGJhc2VDb250cm9sbGVyKSB7XG4gICAgLyoqXG4gICAgICogRHJhZyBoYW5kbGVyIGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtEcmFnfVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBkcmFnSGFuZGxlcjtcblxuICAgIC8qKlxuICAgICAqIGFsbGRheSB2aWV3IGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtBbGxkYXl9XG4gICAgICovXG4gICAgdGhpcy5hbGxkYXlWaWV3ID0gYWxsZGF5VmlldztcblxuICAgIC8qKlxuICAgICAqIEJhc2UgY29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7QmFzZX1cbiAgICAgKi9cbiAgICB0aGlzLmJhc2VDb250cm9sbGVyID0gYmFzZUNvbnRyb2xsZXI7XG5cbiAgICAvKipcbiAgICAgKiBUZW1wb3JhcnkgdmFyaWFibGUgZm9yIGRyYWdTdGFydCBldmVudCBkYXRhLlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5fZHJhZ1N0YXJ0ID0gbnVsbDtcblxuICAgIGRyYWdIYW5kbGVyLm9uKHtcbiAgICAgICAgZHJhZ1N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydFxuICAgIH0sIHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FsbGRheVJlc2l6ZUd1aWRlfVxuICAgICAqL1xuICAgIHRoaXMuZ3VpZGUgPSBuZXcgQWxsZGF5UmVzaXplR3VpZGUodGhpcyk7XG59XG5cbi8qKlxuICogRGVzdHJveSBtZXRob2RcbiAqL1xuQWxsZGF5UmVzaXplLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5ndWlkZS5kZXN0cm95KCk7XG4gICAgdGhpcy5kcmFnSGFuZGxlci5vZmYodGhpcyk7XG4gICAgdGhpcy5kcmFnSGFuZGxlciA9IHRoaXMuYWxsZGF5VmlldyA9IHRoaXMuYmFzZUNvbnRyb2xsZXIgPVxuICAgICAgICB0aGlzLmd1aWRlID0gdGhpcy5fZHJhZ1N0YXJ0ID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2hlY2sgZHJhZ3N0YXJ0IHRhcmdldCBpcyBleHBlY3RlZCBjb25kaXRpb25zIGZvciB0aGlzIGhhbmRsZXIuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBkcmFnc3RhcnQgZXZlbnQgaGFuZGxlcidzIHRhcmdldCBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW58TW9udGhXZWVrfSByZXR1cm4gTW9udGhXZWVrIHZpZXcgaW5zdGFuY2Ugd2hlbiBzYXRpYXRlIGNvbmRpdGlvbi5cbiAqL1xuQWxsZGF5UmVzaXplLnByb3RvdHlwZS5jaGVja0V4cGVjdGVkQ29uZGl0aW9uID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgdmFyIGNzc0NsYXNzID0gZG9tdXRpbC5nZXRDbGFzcyh0YXJnZXQpLFxuICAgICAgICBtYXRjaGVzO1xuXG4gICAgaWYgKCF+Y3NzQ2xhc3MuaW5kZXhPZignc2NoZWR1bGUtdmlldy1hbGxkYXktcmVzaXplLWhhbmRsZScpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSBkb211dGlsLmNsb3Nlc3QodGFyZ2V0LCAnLnNjaGVkdWxlLXZpZXctYWxsZGF5LW1vbnRod2VlaycpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNzc0NsYXNzID0gZG9tdXRpbC5nZXRDbGFzcyh0YXJnZXQpO1xuICAgIG1hdGNoZXMgPSBjc3NDbGFzcy5tYXRjaChwYXJzZVZpZXdJRFJ4KTtcblxuICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlsLnBpY2sodGhpcy5hbGxkYXlWaWV3LmNoaWxkcy5pdGVtcywgbWF0Y2hlc1sxXSk7XG59O1xuXG4vKipcbiAqIERyYWdTdGFydCBldmVudCBoYW5kbGVyLlxuICogQGVtaXRzIEFsbGRheVJlc2l6ZSNhbGxkYXlfcmVzaXplX2RyYWdzdGFydFxuICogQHBhcmFtIHtvYmplY3R9IGRyYWdTdGFydEV2ZW50RGF0YSAtIGV2ZW50IGRhdGEuXG4gKi9cbkFsbGRheVJlc2l6ZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZHJhZ1N0YXJ0RXZlbnREYXRhKSB7XG4gICAgdmFyIHRhcmdldCA9IGRyYWdTdGFydEV2ZW50RGF0YS50YXJnZXQsXG4gICAgICAgIHJlc3VsdCA9IHRoaXMuY2hlY2tFeHBlY3RlZENvbmRpdGlvbih0YXJnZXQpLFxuICAgICAgICBjb250cm9sbGVyID0gdGhpcy5iYXNlQ29udHJvbGxlcixcbiAgICAgICAgZXZlbnRCbG9ja0VsZW1lbnQsXG4gICAgICAgIG1vZGVsSUQsXG4gICAgICAgIHRhcmdldE1vZGVsLFxuICAgICAgICBnZXRFdmVudERhdGFGdW5jLFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnRCbG9ja0VsZW1lbnQgPSBkb211dGlsLmNsb3Nlc3QodGFyZ2V0LCAnLnNjaGVkdWxlLXZpZXctYWxsZGF5LWV2ZW50LWJsb2NrJyk7XG4gICAgbW9kZWxJRCA9IGRvbXV0aWwuZ2V0RGF0YShldmVudEJsb2NrRWxlbWVudCwgJ2lkJyk7XG4gICAgdGFyZ2V0TW9kZWwgPSBjb250cm9sbGVyLmV2ZW50cy5pdGVtc1ttb2RlbElEXTtcblxuICAgIGlmICghdGFyZ2V0TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLmdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9yZXRyaXZlRXZlbnREYXRhKHRoaXMuYWxsZGF5VmlldywgZHJhZ1N0YXJ0RXZlbnREYXRhLm9yaWdpbkV2ZW50KTtcbiAgICBldmVudERhdGEgPSB0aGlzLl9kcmFnU3RhcnQgPSBnZXRFdmVudERhdGFGdW5jKGRyYWdTdGFydEV2ZW50RGF0YS5vcmlnaW5FdmVudCk7XG5cbiAgICB1dGlsLmV4dGVuZChldmVudERhdGEsIHtcbiAgICAgICAgZXZlbnRCbG9ja0VsZW1lbnQ6IGV2ZW50QmxvY2tFbGVtZW50LFxuICAgICAgICBtb2RlbDogdGFyZ2V0TW9kZWxcbiAgICB9KTtcblxuICAgIHRoaXMuZHJhZ0hhbmRsZXIub24oe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBBbGxkYXlSZXNpemUjYWxsZGF5X3Jlc2l6ZV9kcmFnc3RhcnRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7QWxsZGF5Vmlld30gcmVsYXRlZFZpZXcgLSBhbGxkYXkgdmlldyBpbnN0YW5jZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGF0ZXNJblJhbmdlIC0gZGF0ZSBjb3VudCBvZiB0aGlzIHZpZXcuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRyYWdTdGFydFhJbmRleCAtIGluZGV4IG51bWJlciBvZiBkcmFnc3RhcnQgZ3JpZCBpbmRleC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIG1vdXNlIHBvc2l0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBtb2RlbCAtIGRhdGEgb2JqZWN0IG9mIG1vZGVsIGlzbnRhbmNlLlxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTERpdkVsZW1lbnR9IGV2ZW50QmxvY2tFbGVtZW50IC0gdGFyZ2V0IGV2ZW50IGJsb2NrIGVsZW1lbnQuXG4gICAgICovXG4gICAgdGhpcy5maXJlKCdhbGxkYXlfcmVzaXplX2RyYWdzdGFydCcsIGV2ZW50RGF0YSk7XG59O1xuXG4vKipcbiAqIERyYWcgZXZlbnQgaGFuZGxlciBtZXRob2QuXG4gKiBAZW1pdHMgQWxsZGF5UmVzaXplI2FsbGRheV9yZXNpemVfZHJhZ1xuICogQHBhcmFtIHtvYmplY3R9IGRyYWdFdmVudERhdGEgLSBEcmFnI2RyYWcgZXZlbnQgaGFuZGxlciBldmVudGRhdGEuXG4gKi9cbkFsbGRheVJlc2l6ZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uKGRyYWdFdmVudERhdGEpIHtcbiAgICB2YXIgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuZ2V0RXZlbnREYXRhRnVuYztcblxuICAgIGlmICghZ2V0RXZlbnREYXRhRnVuYykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IEFsbGRheVJlc2l6ZSNhbGxkYXlfcmVzaXplX2RyYWdcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7QWxsZGF5Vmlld30gcmVsYXRlZFZpZXcgLSBhbGxkYXkgdmlldyBpbnN0YW5jZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGF0ZXNJblJhbmdlIC0gZGF0ZSBjb3VudCBvZiB0aGlzIHZpZXcuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRyYWdTdGFydFhJbmRleCAtIGluZGV4IG51bWJlciBvZiBkcmFnc3RhcnQgZ3JpZCBpbmRleC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIG1vdXNlIHBvc2l0aW9ucy5cbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ2FsbGRheV9yZXNpemVfZHJhZycsIGdldEV2ZW50RGF0YUZ1bmMoZHJhZ0V2ZW50RGF0YS5vcmlnaW5FdmVudCkpO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IHVwZGF0ZSBldmVudCBpbnN0YW5jZSB0byBiYXNlIGNvbnRyb2xsZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gZXZlbnREYXRhIC0gZXZlbnQgZGF0YSBmcm9tIEFsbGRheVJlc2l6ZSBoYW5kbGVyLlxuICovXG5BbGxkYXlSZXNpemUucHJvdG90eXBlLl91cGRhdGVFdmVudCA9IGZ1bmN0aW9uKGV2ZW50RGF0YSkge1xuICAgIHZhciBjdHJsID0gdGhpcy5iYXNlQ29udHJvbGxlcixcbiAgICAgICAgbW9kZWwgPSBldmVudERhdGEudGFyZ2V0TW9kZWwsXG4gICAgICAgIGRhdGVPZmZzZXQgPSBldmVudERhdGEueEluZGV4IC0gZXZlbnREYXRhLmRyYWdTdGFydFhJbmRleCxcbiAgICAgICAgbmV3RW5kcyA9IG5ldyBEYXRlKG1vZGVsLmVuZHMuZ2V0VGltZSgpKTtcblxuICAgIG5ld0VuZHMgPSBuZXcgRGF0ZShuZXdFbmRzLnNldERhdGUobmV3RW5kcy5nZXREYXRlKCkgKyBkYXRlT2Zmc2V0KSk7XG4gICAgbmV3RW5kcyA9IG5ldyBEYXRlKE1hdGgubWF4KGRhdGV0aW1lLmVuZChtb2RlbC5zdGFydHMpLmdldFRpbWUoKSwgbmV3RW5kcy5nZXRUaW1lKCkpKTtcblxuICAgIGN0cmwudXBkYXRlRXZlbnQobW9kZWwuaWQoKSwge1xuICAgICAgICBlbmRzOiBuZXdFbmRzXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIERyYWdFbmQgZXZlbnQgaGFuZGVyIG1ldGhvZC5cbiAqIEBlbWl0cyBBbGxkYXlSZXNpemUjYWxsZGF5X3Jlc2l6ZV9kcmFnZW5kXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ0VuZEV2ZW50RGF0YSAtIERyYWcjRHJhZ0VuZCBldmVudCBoYW5kbGVyIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gW292ZXJyaWRlRXZlbnROYW1lXSAtIG92ZXJyaWRlIGVtaXR0ZWQgZXZlbnQgbmFtZSB3aGVuIHN1cHBsaWVkLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gc2tpcFVwZGF0ZSAtIHRydWUgdGhlbiBza2lwIHVwZGF0ZSBldmVudCBtb2RlbC5cbiAqL1xuQWxsZGF5UmVzaXplLnByb3RvdHlwZS5fb25EcmFnRW5kID0gZnVuY3Rpb24oZHJhZ0VuZEV2ZW50RGF0YSwgb3ZlcnJpZGVFdmVudE5hbWUsIHNraXBVcGRhdGUpIHtcbiAgICB2YXIgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuZ2V0RXZlbnREYXRhRnVuYyxcbiAgICAgICAgZHJhZ1N0YXJ0ID0gdGhpcy5fZHJhZ1N0YXJ0LFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICBpZiAoIWdldEV2ZW50RGF0YUZ1bmMgfHwgIWRyYWdTdGFydCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnSGFuZGxlci5vZmYoe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIGV2ZW50RGF0YSA9IGdldEV2ZW50RGF0YUZ1bmMoZHJhZ0VuZEV2ZW50RGF0YS5vcmlnaW5FdmVudCk7XG4gICAgdXRpbC5leHRlbmQoZXZlbnREYXRhLCB7XG4gICAgICAgIHRhcmdldE1vZGVsOiBkcmFnU3RhcnQubW9kZWxcbiAgICB9KTtcblxuICAgIGlmICghc2tpcFVwZGF0ZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVFdmVudChldmVudERhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBldmVudCBBbGxkYXlSZXNpemUjYWxsZGF5X3Jlc2l6ZV9kcmFnZW5kXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0FsbGRheVZpZXd9IHJlbGF0ZWRWaWV3IC0gYWxsZGF5IHZpZXcgaW5zdGFuY2UuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGVzSW5SYW5nZSAtIGRhdGUgY291bnQgb2YgdGhpcyB2aWV3LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkcmFnU3RhcnRYSW5kZXggLSBpbmRleCBudW1iZXIgb2YgZHJhZ3N0YXJ0IGdyaWQgaW5kZXguXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHhJbmRleCAtIGluZGV4IG51bWJlciBvZiBtb3VzZSBwb3NpdGlvbnMuXG4gICAgICovXG4gICAgdGhpcy5maXJlKG92ZXJyaWRlRXZlbnROYW1lIHx8ICdhbGxkYXlfcmVzaXplX2RyYWdlbmQnLCBldmVudERhdGEpO1xuXG4gICAgdGhpcy5nZXRFdmVudERhdGFGdW5jID0gdGhpcy5fZHJhZ1N0YXJ0ID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xpY2sgZXZlbnQgaGFuZGxlciBtZXRob2QuXG4gKiBAZW1pdHMgQWxsZGF5UmVzaXplI2FsbGRheV9yZXNpemVfY2xpY2tcbiAqIEBwYXJhbSB7b2JqZWN0fSBjbGlja0V2ZW50RGF0YSAtIERyYWcjQ2xpY2sgZXZlbnQgaGFuZGxlciBkYXRhLlxuICovXG5BbGxkYXlSZXNpemUucHJvdG90eXBlLl9vbkNsaWNrID0gZnVuY3Rpb24oY2xpY2tFdmVudERhdGEpIHtcbiAgICAvKipcbiAgICAgKiBAZXZlbnQgQWxsZGF5UmVzaXplI2FsbGRheV9yZXNpemVfY2xpY2tcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7QWxsZGF5Vmlld30gcmVsYXRlZFZpZXcgLSBhbGxkYXkgdmlldyBpbnN0YW5jZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGF0ZXNJblJhbmdlIC0gZGF0ZSBjb3VudCBvZiB0aGlzIHZpZXcuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRyYWdTdGFydFhJbmRleCAtIGluZGV4IG51bWJlciBvZiBkcmFnc3RhcnQgZ3JpZCBpbmRleC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIG1vdXNlIHBvc2l0aW9ucy5cbiAgICAgKi9cbiAgICB0aGlzLl9vbkRyYWdFbmQoY2xpY2tFdmVudERhdGEsICdhbGxkYXlfcmVzaXplX2NsaWNrJywgdHJ1ZSk7XG59O1xuXG5jb21tb24ubWl4aW4oQWxsZGF5Q29yZSwgQWxsZGF5UmVzaXplKTtcbnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKEFsbGRheVJlc2l6ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWxsZGF5UmVzaXplO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVzaXplIEd1aWRlIG1vZHVsZS5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgdXRpbCA9IHdpbmRvdy5uZS51dGlsO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgcmVxQW5pbUZyYW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL3JlcUFuaW1GcmFtZScpO1xuXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FsbGRheVJlc2l6ZX0gYWxsZGF5UmVzaXplIC0gaW5zdGFuY2Ugb2YgQWxsZGF5UmVzaXplXG4gKi9cbmZ1bmN0aW9uIEFsbGRheVJlc2l6ZUd1aWRlKGFsbGRheVJlc2l6ZSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBbGxkYXlSZXNpemV9XG4gICAgICovXG4gICAgdGhpcy5hbGxkYXlSZXNpemUgPSBhbGxkYXlSZXNpemU7XG5cbiAgICAvKipcbiAgICAgKiDsi6TsoJzroZwg7J2067Kk7Yq4IOyXmOumrOuovO2KuOulvCDri7TripQg7JeY66as66i87Yq4XG4gICAgICogQHR5cGUge0hUTUxESVZFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRDb250YWluZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuZ2V0RXZlbnREYXRhRnVuYyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTERJVkVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5ndWlkZUVsZW1lbnQgPSBudWxsO1xuXG4gICAgYWxsZGF5UmVzaXplLm9uKHtcbiAgICAgICAgJ2FsbGRheV9yZXNpemVfZHJhZ3N0YXJ0JzogdGhpcy5fb25EcmFnU3RhcnQsXG4gICAgICAgICdhbGxkYXlfcmVzaXplX2RyYWcnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgICdhbGxkYXlfcmVzaXplX2RyYWdlbmQnOiB0aGlzLl9jbGVhckd1aWRlRWxlbWVudCxcbiAgICAgICAgJ2FsbGRheV9yZXNpemVfY2xpY2snOiB0aGlzLl9jbGVhckd1aWRlRWxlbWVudFxuICAgIH0sIHRoaXMpO1xufVxuXG4vKipcbiAqIERlc3Ryb3kgbWV0aG9kXG4gKi9cbkFsbGRheVJlc2l6ZUd1aWRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2xlYXJHdWlkZUVsZW1lbnQoKTtcbiAgICB0aGlzLmFsbGRheVJlc2l6ZS5vZmYodGhpcyk7XG4gICAgdGhpcy5hbGxkYXlSZXNpemUgPSB0aGlzLmV2ZW50Q29udGFpbmVyID0gdGhpcy5nZXRFdmVudERhdGFGdW5jID1cbiAgICAgICAgdGhpcy5ndWlkZUVsZW1lbnQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhciBndWlkZSBlbGVtZW50LlxuICovXG5BbGxkYXlSZXNpemVHdWlkZS5wcm90b3R5cGUuX2NsZWFyR3VpZGVFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgZG9tdXRpbC5yZW1vdmUodGhpcy5ndWlkZUVsZW1lbnQpO1xuXG4gICAgaWYgKCF1dGlsLmJyb3dzZXIubXNpZSkge1xuICAgICAgICBkb211dGlsLnJlbW92ZUNsYXNzKGdsb2JhbC5kb2N1bWVudC5ib2R5LCAnc2NoZWR1bGUtdmlldy1yZXNpemluZy14Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5nZXRFdmVudERhdGFGdW5jID0gbnVsbDtcbn07XG5cbi8qKlxuICogUmVmcmVzaCBndWlkZSBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gbmV3V2lkdGggLSBuZXcgd2lkdGggcGVyY2VudGFnZSB2YWx1ZSB0byByZXNpemUgZ3VpZGUgZWxlbWVudC5cbiAqL1xuQWxsZGF5UmVzaXplR3VpZGUucHJvdG90eXBlLnJlZnJlc2hHdWlkZUVsZW1lbnQgPSBmdW5jdGlvbihuZXdXaWR0aCkge1xuICAgIHZhciBndWlkZUVsZW1lbnQgPSB0aGlzLmd1aWRlRWxlbWVudDtcblxuICAgIHJlcUFuaW1GcmFtZS5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICBndWlkZUVsZW1lbnQuc3R5bGUud2lkdGggPSBuZXdXaWR0aCArICclJztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGZ1bmN0aW9uIHRoYXQgY2FsY3VsYXRlIGd1aWRlIGVsZW1lbnQncyBuZXcgd2lkdGggcGVyY2VudGFnZSB2YWx1ZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnU3RhcnRFdmVudERhdGEgLSBkcmFnc3RhcnQgZXZlbnQgZGF0YS5cbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gcmV0dXJuIGZ1bmN0aW9uIHRoYXQgY2FsY3VsYXRlIGd1aWRlIGVsZW1lbnQgbmV3IHdpZHRoIHBlcmNlbnRhZ2UuXG4gKi9cbkFsbGRheVJlc2l6ZUd1aWRlLnByb3RvdHlwZS5nZXRHdWlkZUVsZW1lbnRXaWR0aEZ1bmMgPSBmdW5jdGlvbihkcmFnU3RhcnRFdmVudERhdGEpIHtcbiAgICB2YXIgbW9kZWwgPSBkcmFnU3RhcnRFdmVudERhdGEubW9kZWwsXG4gICAgICAgIHZpZXdPcHRpb25zID0gdGhpcy5hbGxkYXlSZXNpemUuYWxsZGF5Vmlldy5vcHRpb25zLFxuICAgICAgICBzdGFydERhdGUgPSBkYXRldGltZS5zdGFydChuZXcgRGF0ZShNYXRoLm1heChtb2RlbC5zdGFydHMuZ2V0VGltZSgpLCBkYXRldGltZS5wYXJzZSh2aWV3T3B0aW9ucy5yZW5kZXJTdGFydERhdGUpLmdldFRpbWUoKSkpKSxcbiAgICAgICAgZW5kRGF0ZSA9IGRhdGV0aW1lLmVuZChuZXcgRGF0ZShNYXRoLm1pbihtb2RlbC5lbmRzLmdldFRpbWUoKSwgZGF0ZXRpbWUucGFyc2Uodmlld09wdGlvbnMucmVuZGVyRW5kRGF0ZSkuZ2V0VGltZSgpKSkpLFxuICAgICAgICBvcmlnaW5MZW5ndGggPSBkYXRldGltZS5yYW5nZShzdGFydERhdGUsIGVuZERhdGUsIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZKS5sZW5ndGgsXG4gICAgICAgIGJhc2VXaWR0aFBlcmNlbnQgPSAxMDAgLyBkcmFnU3RhcnRFdmVudERhdGEuZGF0ZXNJblJhbmdlLFxuICAgICAgICBkcmFnU3RhcnRJbmRleCA9IGRyYWdTdGFydEV2ZW50RGF0YS54SW5kZXg7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oeEluZGV4KSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB4SW5kZXggLSBkcmFnU3RhcnRJbmRleCxcbiAgICAgICAgICAgIG5ld0xlbmd0aCA9IG9yaWdpbkxlbmd0aCArIG9mZnNldDtcblxuICAgICAgICBuZXdMZW5ndGggPSBNYXRoLm1heCgxLCBuZXdMZW5ndGgpO1xuXG4gICAgICAgIHJldHVybiBuZXdMZW5ndGggKiBiYXNlV2lkdGhQZXJjZW50O1xuICAgIH1cbn07XG5cbi8qKlxuICogRHJhZ1N0YXJ0IGV2ZW50IGhhbmRsZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ1N0YXJ0RXZlbnREYXRhIC0gZXZlbnQgZGF0YS5cbiAqL1xuQWxsZGF5UmVzaXplR3VpZGUucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGRyYWdTdGFydEV2ZW50RGF0YSkge1xuICAgIHZhciBhbGxkYXlWaWV3Q29udGFpbmVyID0gdGhpcy5hbGxkYXlSZXNpemUuYWxsZGF5Vmlldy5jb250YWluZXIsXG4gICAgICAgIGd1aWRlRWxlbWVudCA9IHRoaXMuZ3VpZGVFbGVtZW50ID0gZHJhZ1N0YXJ0RXZlbnREYXRhLmV2ZW50QmxvY2tFbGVtZW50LmNsb25lTm9kZSh0cnVlKSxcbiAgICAgICAgZXZlbnRDb250YWluZXI7XG5cbiAgICBpZiAoIXV0aWwuYnJvd3Nlci5tc2llKSB7XG4gICAgICAgIGRvbXV0aWwuYWRkQ2xhc3MoZ2xvYmFsLmRvY3VtZW50LmJvZHksICdzY2hlZHVsZS12aWV3LXJlc2l6aW5nLXgnKTtcbiAgICB9XG5cbiAgICBldmVudENvbnRhaW5lciA9IGRvbXV0aWwuZmluZCgnLnNjaGVkdWxlLXZpZXctbW9udGh3ZWVrLWV2ZW50cycsIGFsbGRheVZpZXdDb250YWluZXIpO1xuICAgIGRvbXV0aWwuYWRkQ2xhc3MoZ3VpZGVFbGVtZW50LCAnc2NoZWR1bGUtdmlldy1hbGxkYXktbW92ZS1ndWlkZScpO1xuICAgIGV2ZW50Q29udGFpbmVyLmFwcGVuZENoaWxkKGd1aWRlRWxlbWVudCk7XG5cbiAgICB0aGlzLmdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLmdldEd1aWRlRWxlbWVudFdpZHRoRnVuYyhkcmFnU3RhcnRFdmVudERhdGEpO1xufTtcblxuLyoqXG4gKiBEcmFnIGV2ZW50IGhhbmRsZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ0V2ZW50RGF0YSAtIGV2ZW50IGRhdGEuXG4gKi9cbkFsbGRheVJlc2l6ZUd1aWRlLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24oZHJhZ0V2ZW50RGF0YSkge1xuICAgIHZhciBmdW5jID0gdGhpcy5nZXRFdmVudERhdGFGdW5jO1xuXG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlZnJlc2hHdWlkZUVsZW1lbnQoZnVuYyhkcmFnRXZlbnREYXRhLnhJbmRleCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbGxkYXlSZXNpemVHdWlkZTtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERyYWcgaGFuZGxlciBmb3IgY2FsZW5kYXIuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIGRvbWV2ZW50ID0gcmVxdWlyZSgnLi4vY29tbW9uL2RvbWV2ZW50Jyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAbWl4ZXMgQ3VzdG9tRXZlbnRzXG4gKiBAcGFyYW0ge0xheW91dFZpZXd9IGxheW91dFZpZXcgTGF5b3V0IHZpZXcgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIERyYWcobGF5b3V0Vmlldykge1xuICAgIHZhciBjb250YWluZXIgPSBsYXlvdXRWaWV3LmNvbnRhaW5lcjtcblxuICAgIGRvbWV2ZW50Lm9uKGNvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuX2lzTW92ZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBEZXN0cm95IG1ldGhvZC5cbiAqL1xuRHJhZy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvbWV2ZW50Lm9mZih0aGlzLmNvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcbiAgICB0aGlzLl9pc01vdmVkID0gbnVsbDtcbiAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG59O1xuXG4vKipcbiAqIFRvZ2dsZSBldmVudHMgZm9yIG1vdXNlIGRyYWdnaW5nLlxuICogQHBhcmFtIHtib29sZWFufSB0b0JpbmQgLSBiaW5kIGV2ZW50cyByZWxhdGVkIHdpdGggZHJhZ2dpbmcgd2hlbiBzdXBwbGllZCBcInRydWVcIlxuICovXG5EcmFnLnByb3RvdHlwZS5fdG9nZ2xlRHJhZ0V2ZW50ID0gZnVuY3Rpb24odG9CaW5kKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLFxuICAgICAgICBkb21NZXRob2QsXG4gICAgICAgIG1ldGhvZDtcblxuICAgIGlmICh0b0JpbmQpIHtcbiAgICAgICAgZG9tTWV0aG9kID0gJ29uJztcbiAgICAgICAgbWV0aG9kID0gJ2Rpc2FibGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbU1ldGhvZCA9ICdvZmYnO1xuICAgICAgICBtZXRob2QgPSAnZW5hYmxlJztcbiAgICB9XG5cbiAgICBkb211dGlsW21ldGhvZCArICdUZXh0U2VsZWN0aW9uJ10oY29udGFpbmVyKTtcbiAgICBkb211dGlsW21ldGhvZCArICdJbWFnZURyYWcnXShjb250YWluZXIpO1xuICAgIGRvbWV2ZW50W2RvbU1ldGhvZF0oZ2xvYmFsLCB7XG4gICAgICAgIG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG4gICAgICAgIG1vdXNldXA6IHRoaXMuX29uTW91c2VVcFxuICAgIH0sIHRoaXMpO1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgbW91c2UgZXZlbnQgb2JqZWN0LlxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50IC0gbW91c2UgZXZlbnQgb2JqZWN0LlxuICogQHJldHVybnMge29iamVjdH0gbm9ybWFsaXplZCBtb3VzZSBldmVudCBkYXRhLlxuICovXG5EcmFnLnByb3RvdHlwZS5fZ2V0RXZlbnREYXRhID0gZnVuY3Rpb24obW91c2VFdmVudCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogbW91c2VFdmVudC50YXJnZXQgfHwgbW91c2VFdmVudC5zcmNFbGVtZW50LFxuICAgICAgICBvcmlnaW5FdmVudDogbW91c2VFdmVudFxuICAgIH07XG59O1xuXG4vKipcbiAqIE1vdXNlRG93biBET00gZXZlbnQgaGFuZGxlci5cbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gbW91c2VEb3duRXZlbnQgTW91c2VEb3duIGV2ZW50IG9iamVjdC5cbiAqIEBlbWl0cyBEcmFnI2RyYWdTdGFydFxuICovXG5EcmFnLnByb3RvdHlwZS5fb25Nb3VzZURvd24gPSBmdW5jdGlvbihtb3VzZURvd25FdmVudCkge1xuICAgIC8vIG9ubHkgcHJpbWFyeSBidXR0b24gY2FuIHN0YXJ0IGRyYWcuXG4gICAgaWYgKGRvbWV2ZW50LmdldE1vdXNlQnV0dG9uKG1vdXNlRG93bkV2ZW50KSAhPT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhZyBzdGFydHMgZXZlbnRzLiBjYW5jZWxhYmxlLlxuICAgICAqIEBldmVudCBEcmFnI2RyYWdTdGFydFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gdGFyZ2V0IGVsZW1lbnQgaW4gdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge01vdXNlRXZlbnR9IG9yaWdpbkV2ZW50IC0gb3JpZ2luYWwgbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqL1xuICAgIGlmICghdGhpcy5pbnZva2UoJ2RyYWdTdGFydCcsIHRoaXMuX2dldEV2ZW50RGF0YShtb3VzZURvd25FdmVudCkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl90b2dnbGVEcmFnRXZlbnQodHJ1ZSk7XG59O1xuXG4vKipcbiAqIE1vdXNlTW92ZSBET00gZXZlbnQgaGFuZGxlci5cbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gbW91c2VNb3ZlRXZlbnQgTW91c2VNb3ZlIGV2ZW50IG9iamVjdC5cbiAqIEBlbWl0cyBEcmFnI2RyYWdcbiAqL1xuRHJhZy5wcm90b3R5cGUuX29uTW91c2VNb3ZlID0gZnVuY3Rpb24obW91c2VNb3ZlRXZlbnQpIHtcbiAgICAvLyBwcmV2ZW50IGF1dG9tYXRpYyBzY3JvbGxpbmcuXG4gICAgZG9tZXZlbnQucHJldmVudERlZmF1bHQobW91c2VNb3ZlRXZlbnQpO1xuXG4gICAgdGhpcy5faXNNb3ZlZCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudHMgd2hpbGUgZHJhZ2dpbmcuXG4gICAgICogQGV2ZW50IERyYWcjZHJhZ1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gdGFyZ2V0IGVsZW1lbnQgaW4gdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge01vdXNlRXZlbnR9IG9yaWdpbkV2ZW50IC0gb3JpZ2luYWwgbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqL1xuICAgIHRoaXMuZmlyZSgnZHJhZycsIHRoaXMuX2dldEV2ZW50RGF0YShtb3VzZU1vdmVFdmVudCkpO1xufTtcblxuLyoqXG4gKiBNb3VzZVVwIERPTSBldmVudCBoYW5kbGVyLlxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZVVwRXZlbnQgTW91c2VVcCBldmVudCBvYmplY3QuXG4gKiBAZW1pdHMgRHJhZyNkcmFnRW5kXG4gKiBAZW1pdHMgRHJhZyNjbGlja1xuICovXG5EcmFnLnByb3RvdHlwZS5fb25Nb3VzZVVwID0gZnVuY3Rpb24obW91c2VVcEV2ZW50KSB7XG4gICAgdGhpcy5fdG9nZ2xlRHJhZ0V2ZW50KGZhbHNlKTtcblxuICAgIC8vIGVtaXQgXCJjbGlja1wiIGV2ZW50IHdoZW4gbm90IGVtaXR0ZWQgZHJhZyBldmVudCBiZXR3ZWVuIG1vdXNlZG93biBhbmQgbW91c2V1cC5cbiAgICBpZiAodGhpcy5faXNNb3ZlZCkge1xuICAgICAgICB0aGlzLl9pc01vdmVkID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyYWcgZW5kIGV2ZW50cy5cbiAgICAgICAgICogQGV2ZW50IERyYWcjZHJhZ0VuZFxuICAgICAgICAgKiBAdHlwZSB7TW91c2VFdmVudH1cbiAgICAgICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gdGFyZ2V0IGVsZW1lbnQgaW4gdGhpcyBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBvcmlnaW5FdmVudCAtIG9yaWdpbmFsIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlyZSgnZHJhZ0VuZCcsIHRoaXMuX2dldEV2ZW50RGF0YShtb3VzZVVwRXZlbnQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsaWNrIGV2ZW50cy5cbiAgICAgKiBAZXZlbnQgRHJhZyNjbGlja1xuICAgICAqIEB0eXBlIHtNb3VzZUV2ZW50fVxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIHRhcmdldCBlbGVtZW50IGluIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBvcmlnaW5FdmVudCAtIG9yaWdpbmFsIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ2NsaWNrJywgdGhpcy5fZ2V0RXZlbnREYXRhKG1vdXNlVXBFdmVudCkpO1xufTtcblxudXRpbC5DdXN0b21FdmVudHMubWl4aW4oRHJhZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRHJhZztcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvcmUgbWV0aG9kcyBmb3IgZHJhZ2dpbmcgYWN0aW9uc1xuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi8uLi9jb21tb24vY29tbW9uJyk7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBkb21ldmVudCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb21ldmVudCcpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL3BvaW50Jyk7XG5cbi8qKlxuICogQG1peGluIFRpbWUuQ29yZVxuICovXG52YXIgdGltZUNvcmUgPSB7XG4gICAgLyoqXG4gICAgICogR2V0IFkgaW5kZXggcmF0aW8oaG91cikgaW4gdGltZSBncmlkcyBieSBzdXBwbGllZCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlTWlsIC0gYmFzZSBtaWxsaXNlY29uZHMgbnVtYmVyIGZvciBzdXBwbGllZCBoZWlnaHQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIGNvbnRhaW5lciBlbGVtZW50IGhlaWdodC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFkgY29vcmRpbmF0ZSB0byBjYWxjdWxhdGUgaG91ciByYXRpby5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBob3VyIGluZGV4IHJhdGlvIHZhbHVlLlxuICAgICAqL1xuICAgIF9jYWxjR3JpZFlJbmRleDogZnVuY3Rpb24oYmFzZU1pbCwgaGVpZ2h0LCB5KSB7XG4gICAgICAgIC8vIGdldCByYXRpbyBmcm9tIHJpZ2h0IGV4cHJlc3Npb24gPiBwb2ludC55IDogeCA9IHNlc3Npb24uaGVpZ2h0IDogYmFzZU1pbFxuICAgICAgICAvLyBhbmQgY29udmVydCBtaWxsaXNlY29uZHMgdmFsdWUgdG8gaG91cnMuXG4gICAgICAgIHZhciByZXN1bHQgPSBkYXRldGltZS5taWxsaXNlY29uZHNUbygnaG91cicsICh5ICogYmFzZU1pbCkgLyBoZWlnaHQpLFxuICAgICAgICAgICAgZmxvb3JlZCA9IHJlc3VsdCB8IDAsXG4gICAgICAgICAgICBuZWFyZXN0ID0gY29tbW9uLm5lYXJlc3QocmVzdWx0IC0gZmxvb3JlZCwgWzAsIDFdKTtcblxuICAgICAgICByZXR1cm4gZmxvb3JlZCArIChuZWFyZXN0ID8gMC41IDogMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBmdW5jdGlvbiB0byBtYWtlcyBldmVudCBkYXRhIGZyb20gVGltZSBhbmQgbW91c2VFdmVudFxuICAgICAqIEBwYXJhbSB7VGltZX0gdGltZVZpZXcgLSBJbnN0YW5jZSBvZiB0aW1lIHZpZXcuXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9ufSAtIEZ1bmN0aW9uIHRoYXQgcmV0dXJuIGV2ZW50IGRhdGEgZnJvbSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBfcmV0cml2ZUV2ZW50RGF0YTogZnVuY3Rpb24odGltZVZpZXcpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRpbWVWaWV3LmNvbnRhaW5lcixcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0aW1lVmlldy5vcHRpb25zLFxuICAgICAgICAgICAgdmlld0hlaWdodCA9IHRpbWVWaWV3LmdldFZpZXdCb3VuZCgpLmhlaWdodCxcbiAgICAgICAgICAgIHZpZXdUaW1lID0gK3RpbWVWaWV3LmdldERhdGUoKSxcbiAgICAgICAgICAgIGhvdXJMZW5ndGggPSBvcHRpb25zLmhvdXJFbmQgLSBvcHRpb25zLmhvdXJTdGFydCxcbiAgICAgICAgICAgIGJhc2VNaWwgPSBkYXRldGltZS5taWxsaXNlY29uZHNGcm9tKCdob3VyJywgaG91ckxlbmd0aCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gbW91c2VFdmVudCAtIG1vdXNlIGV2ZW50IG9iamVjdCB0byBnZXQgY29tbW9uIGV2ZW50IGRhdGEuXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZXh0ZW5kXSAtIG9iamVjdCB0byBleHRlbmQgZXZlbnQgZGF0YSBiZWZvcmUgcmV0dXJuLlxuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAtIGNvbW1vbiBldmVudCBkYXRhIGZvciB0aW1lLipcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiB1dGlsLmJpbmQoZnVuY3Rpb24obW91c2VFdmVudCwgZXh0ZW5kKSB7XG4gICAgICAgICAgICB2YXIgbW91c2VZID0gUG9pbnQubihkb21ldmVudC5nZXRNb3VzZVBvc2l0aW9uKG1vdXNlRXZlbnQsIGNvbnRhaW5lcikpLnksXG4gICAgICAgICAgICAgICAgZ3JpZFkgPSBjb21tb24ucmF0aW8odmlld0hlaWdodCwgaG91ckxlbmd0aCwgbW91c2VZKSxcbiAgICAgICAgICAgICAgICB0aW1lWSA9IHZpZXdUaW1lICsgZGF0ZXRpbWUubWlsbGlzZWNvbmRzRnJvbSgnaG91cicsIGdyaWRZKSxcbiAgICAgICAgICAgICAgICBuZWFyZXN0R3JpZFkgPSB0aGlzLl9jYWxjR3JpZFlJbmRleChiYXNlTWlsLCB2aWV3SGVpZ2h0LCBtb3VzZVkpLFxuICAgICAgICAgICAgICAgIG5lYXJlc3RHcmlkVGltZVkgPSB2aWV3VGltZSArIGRhdGV0aW1lLm1pbGxpc2Vjb25kc0Zyb20oJ2hvdXInLCBuZWFyZXN0R3JpZFkgKyBvcHRpb25zLmhvdXJTdGFydCk7XG5cbiAgICAgICAgICAgIHJldHVybiB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBtb3VzZUV2ZW50LnRhcmdldCB8fCBtb3VzZUV2ZW50LnNyY0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgcmVsYXRlZFZpZXc6IHRpbWVWaWV3LFxuICAgICAgICAgICAgICAgIG9yaWdpbkV2ZW50OiBtb3VzZUV2ZW50LFxuICAgICAgICAgICAgICAgIG1vdXNlWTogbW91c2VZLFxuICAgICAgICAgICAgICAgIGdyaWRZOiBncmlkWSxcbiAgICAgICAgICAgICAgICB0aW1lWTogdGltZVksXG4gICAgICAgICAgICAgICAgbmVhcmVzdEdyaWRZOiBuZWFyZXN0R3JpZFksXG4gICAgICAgICAgICAgICAgbmVhcmVzdEdyaWRUaW1lWTogbmVhcmVzdEdyaWRUaW1lWVxuICAgICAgICAgICAgfSwgZXh0ZW5kKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1peGluIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0geyhUaW1lQ3JlYXRpb258VGltZU1vdmUpfSBvYmogLSBDb25zdHJ1Y3RvciBmdW5jdGlvbnNcbiAgICAgKi9cbiAgICBtaXhpbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciBwcm90byA9IG9iai5wcm90b3R5cGU7XG4gICAgICAgIHV0aWwuZm9yRWFjaCh0aW1lQ29yZSwgZnVuY3Rpb24obWV0aG9kLCBtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ21peGluJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvdG9bbWV0aG9kTmFtZV0gPSBtZXRob2Q7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdGltZUNvcmU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBIYW5kbGluZyBjcmVhdGlvbiBldmVudHMgZnJvbSBkcmFnIGhhbmRsZXIgYW5kIHRpbWUgZ3JpZCB2aWV3XG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGFycmF5ID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2FycmF5Jyk7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciBUaW1lQ3JlYXRpb25HdWlkZSA9IHJlcXVpcmUoJy4vY3JlYXRpb25HdWlkZScpO1xudmFyIHRpbWVDb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbnZhciBwYXJzZVZpZXdJRFJ4ID0gL15zY2hlZHVsZS12aWV3LXRpbWUtZGF0ZVtcXHNdc2NoZWR1bGUtdmlldy0oXFxkKykvO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge0hhbmRsZXJ9XG4gKiBAbWl4ZXMgdGltZUNvcmVcbiAqIEBtaXhlcyBDdXN0b21FdmVudHNcbiAqIEBwYXJhbSB7RHJhZ30gW2RyYWdIYW5kbGVyXSAtIERyYWcgaGFuZGxlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7VGltZUdyaWR9IFt0aW1lR3JpZFZpZXddIC0gVGltZUdyaWQgdmlldyBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7QmFzZX0gW2Jhc2VDb250cm9sbGVyXSAtIEJhc2UgY29udHJvbGxlciBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gVGltZUNyZWF0aW9uKGRyYWdIYW5kbGVyLCB0aW1lR3JpZFZpZXcsIGJhc2VDb250cm9sbGVyKSB7XG4gICAgLyoqXG4gICAgICogRHJhZyBoYW5kbGVyIGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtEcmFnfVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGltZUdyaWQgdmlldyBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7VGltZUdyaWR9XG4gICAgICovXG4gICAgdGhpcy50aW1lR3JpZFZpZXcgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQmFzZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtCYXNlfVxuICAgICAqL1xuICAgIHRoaXMuYmFzZUNvbnRyb2xsZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1RpbWVDcmVhdGlvbkd1aWRlfVxuICAgICAqL1xuICAgIHRoaXMuZ3VpZGUgPSBuZXcgVGltZUNyZWF0aW9uR3VpZGUodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUZW1wb3JhcnkgZnVuY3Rpb24gZm9yIHNpbmdsZSBkcmFnIHNlc3Npb24ncyBjYWxjLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLl9nZXRFdmVudERhdGFGdW5jID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRlbXBvcmFyeSBmdW5jdGlvbiBmb3IgZHJhZyBzdGFydCBkYXRhIGNhY2hlLlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5fZHJhZ1N0YXJ0ID0gbnVsbDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEZXN0cm95IG1ldGhvZFxuICovXG5UaW1lQ3JlYXRpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmd1aWRlLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9mZih0aGlzKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gdGhpcy50aW1lR3JpZFZpZXcgPSB0aGlzLmJhc2VDb250cm9sbGVyID1cbiAgICAgICAgdGhpcy5fZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX2RyYWdTdGFydCA9IHRoaXMuZ3VpZGUgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDb25uZWN0IGhhbmRsZXIsIHZpZXcsIGNvbnRyb2xsZXJzIGZvciBldmVudCBjcmVhdGlvbnMuXG4gKiBAcGFyYW0ge0RyYWd9IFtkcmFnSGFuZGxlcl0gLSBEcmFnIGhhbmRsZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge1RpbWVHcmlkfSBbdGltZUdyaWRWaWV3XSAtIFRpbWVHcmlkIHZpZXcgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0Jhc2V9IFtiYXNlQ29udHJvbGxlcl0gLSBCYXNlIGNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gKi9cblRpbWVDcmVhdGlvbi5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKGRyYWdIYW5kbGVyLCB0aW1lR3JpZFZpZXcsIGJhc2VDb250cm9sbGVyKSB7XG4gICAgdGhpcy5kcmFnSGFuZGxlciA9IGRyYWdIYW5kbGVyO1xuICAgIHRoaXMudGltZUdyaWRWaWV3ID0gdGltZUdyaWRWaWV3O1xuICAgIHRoaXMuYmFzZUNvbnRyb2xsZXIgPSBiYXNlQ29udHJvbGxlcjtcblxuICAgIGRyYWdIYW5kbGVyLm9uKHtcbiAgICAgICAgZHJhZ1N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydFxuICAgIH0sIHRoaXMpO1xufTtcblxuLyoqXG4gKiBDaGVjayB0YXJnZXQgZWxlbWVudCBpcyBleHBlY3RlZCBjb25kaXRpb24gZm9yIGFjdGl2YXRlIHRoaXMgcGx1Z2lucy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIFRoZSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7KGJvb2xlYW58VGltZSl9IC0gcmV0dXJuIFRpbWUgdmlldyBpbnN0YW5jZSB3aGVuIHNhdGlhdGUgY29uZGl0aW9uLlxuICovXG5UaW1lQ3JlYXRpb24ucHJvdG90eXBlLmNoZWNrRXhwZWN0ZWRDb25kaXRpb24gPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICB2YXIgY3NzQ2xhc3MgPSBkb211dGlsLmdldENsYXNzKHRhcmdldCksXG4gICAgICAgIG1hdGNoZXM7XG5cbiAgICBpZiAoY3NzQ2xhc3MgPT09ICdzY2hlZHVsZS12aWV3LXRpbWUtZGF0ZS1ldmVudC1ibG9jaycpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgIGNzc0NsYXNzID0gZG9tdXRpbC5nZXRDbGFzcyh0YXJnZXQpO1xuICAgIH1cblxuICAgIG1hdGNoZXMgPSBjc3NDbGFzcy5tYXRjaChwYXJzZVZpZXdJRFJ4KTtcblxuICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlsLnBpY2sodGhpcy50aW1lR3JpZFZpZXcuY2hpbGRzLml0ZW1zLCBtYXRjaGVzWzFdKTtcbn07XG5cbi8qKlxuICogRHJhZyNkcmFnU3RhcnQgZXZlbnQgaGFuZGxlci5cbiAqIEBlbWl0cyBUaW1lQ3JlYXRpb24jdGltZV9jcmVhdGlvbl9kcmFnc3RhcnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnU3RhcnRFdmVudERhdGEgLSBEcmFnI2RyYWdTdGFydCBldmVudCBkYXRhLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvdmVycmlkZUV2ZW50TmFtZV0gLSBvdmVycmlkZSBlbWl0dGVkIGV2ZW50IG5hbWUgd2hlbiBzdXBwbGllZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtyZXZpc2VdIC0gc3VwcGx5IGZ1bmN0aW9uIGZvciByZXZpc2UgZXZlbnQgZGF0YSBiZWZvcmUgZW1pdC5cbiAqL1xuVGltZUNyZWF0aW9uLnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbihkcmFnU3RhcnRFdmVudERhdGEsIG92ZXJyaWRlRXZlbnROYW1lLCByZXZpc2UpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZHJhZ1N0YXJ0RXZlbnREYXRhLnRhcmdldCxcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5jaGVja0V4cGVjdGVkQ29uZGl0aW9uKHRhcmdldCksXG4gICAgICAgIGdldEV2ZW50RGF0YUZ1bmMsXG4gICAgICAgIGV2ZW50RGF0YTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBnZXRFdmVudERhdGFGdW5jID0gdGhpcy5fZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX3JldHJpdmVFdmVudERhdGEocmVzdWx0KTtcbiAgICBldmVudERhdGEgPSB0aGlzLl9kcmFnU3RhcnQgPSBnZXRFdmVudERhdGFGdW5jKGRyYWdTdGFydEV2ZW50RGF0YS5vcmlnaW5FdmVudCk7XG5cbiAgICBpZiAocmV2aXNlKSB7XG4gICAgICAgIHJldmlzZShldmVudERhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuZHJhZ0hhbmRsZXIub24oe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBUaW1lQ3JlYXRpb24jdGltZV9jcmVhdGlvbl9kcmFnc3RhcnRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7VGltZX0gcmVsYXRlZFZpZXcgLSB0aW1lIHZpZXcgaW5zdGFuY2UgcmVsYXRlZCB3aXRoIG1vdXNlIHBvc2l0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7TW91c2VFdmVudH0gb3JpZ2luRXZlbnQgLSBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1vdXNlWSAtIG1vdXNlIFkgcHggbW91c2UgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGdyaWRZIC0gZ3JpZCBZIGluZGV4IHZhbHVlIHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVZIC0gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIG1vdXNlWSBwb2ludHMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkWSAtIG5lYXJlc3QgZ3JpZCBpbmRleCByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFRpbWVZIC0gdGltZSB2YWx1ZSBmb3IgbmVhcmVzdEdyaWRZLlxuICAgICAqL1xuICAgIHRoaXMuZmlyZShvdmVycmlkZUV2ZW50TmFtZSB8fCAndGltZV9jcmVhdGlvbl9kcmFnc3RhcnQnLCBldmVudERhdGEpO1xufTtcblxuLyoqXG4gKiBEcmFnI2RyYWcgZXZlbnQgaGFuZGxlclxuICogQGVtaXRzIFRpbWVDcmVhdGlvbiN0aW1lX2NyZWF0aW9uX2RyYWdcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnRXZlbnREYXRhIC0gZXZlbnQgZGF0YSBmcm9tIERyYWcjZHJhZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3ZlcnJpZGVFdmVudE5hbWVdIC0gb3ZlcnJpZGUgZW1pdHRlZCBldmVudCBuYW1lIHdoZW4gc3VwcGxpZWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcmV2aXNlXSAtIHN1cHBseSBmdW5jdGlvbiBmb3IgcmV2aXNlIGV2ZW50IGRhdGEgYmVmb3JlIGVtaXQuXG4gKi9cblRpbWVDcmVhdGlvbi5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uKGRyYWdFdmVudERhdGEsIG92ZXJyaWRlRXZlbnROYW1lLCByZXZpc2UpIHtcbiAgICB2YXIgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX2dldEV2ZW50RGF0YUZ1bmMsXG4gICAgICAgIGV2ZW50RGF0YTtcblxuICAgIGlmICghZ2V0RXZlbnREYXRhRnVuYykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnREYXRhID0gZ2V0RXZlbnREYXRhRnVuYyhkcmFnRXZlbnREYXRhLm9yaWdpbkV2ZW50KTtcblxuICAgIGlmIChyZXZpc2UpIHtcbiAgICAgICAgcmV2aXNlKGV2ZW50RGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFRpbWVDcmVhdGlvbiN0aW1lX2NyZWF0aW9uX2RyYWdcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7VGltZX0gcmVsYXRlZFZpZXcgLSB0aW1lIHZpZXcgaW5zdGFuY2UgcmVsYXRlZCB3aXRoIG1vdXNlIHBvc2l0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7TW91c2VFdmVudH0gb3JpZ2luRXZlbnQgLSBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1vdXNlWSAtIG1vdXNlIFkgcHggbW91c2UgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGdyaWRZIC0gZ3JpZCBZIGluZGV4IHZhbHVlIHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVZIC0gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIG1vdXNlWSBwb2ludHMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkWSAtIG5lYXJlc3QgZ3JpZCBpbmRleCByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFRpbWVZIC0gdGltZSB2YWx1ZSBmb3IgbmVhcmVzdEdyaWRZLlxuICAgICAqL1xuICAgIHRoaXMuZmlyZShvdmVycmlkZUV2ZW50TmFtZSB8fCAndGltZV9jcmVhdGlvbl9kcmFnJywgZXZlbnREYXRhKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGV2ZW50RGF0YSAtIGV2ZW50IGRhdGEgb2JqZWN0IGZyb20gVGltZUNyZWF0aW9uI3RpbWVfY3JlYXRpb25fZHJhZ2VuZFxuICogb3IgVGltZUNyZWF0aW9uI3RpbWVfY3JlYXRpb25fY2xpY2tcbiAqL1xuVGltZUNyZWF0aW9uLnByb3RvdHlwZS5fY3JlYXRlRXZlbnQgPSBmdW5jdGlvbihldmVudERhdGEpIHtcbiAgICB2YXIgdGl0bGUgPSB3aW5kb3cucHJvbXB0KCdOYW1lIG9mIGV2ZW50IHRvIGNyZWF0ZTonKSxcbiAgICAgICAgY3RybCA9IHRoaXMuYmFzZUNvbnRyb2xsZXIsXG4gICAgICAgIHJlbGF0ZWRWaWV3ID0gZXZlbnREYXRhLnJlbGF0ZWRWaWV3LFxuICAgICAgICBjcmVhdGVSYW5nZSA9IGV2ZW50RGF0YS5jcmVhdGVSYW5nZSxcbiAgICAgICAgbmVhcmVzdEdyaWRUaW1lWSA9IGV2ZW50RGF0YS5uZWFyZXN0R3JpZFRpbWVZLFxuICAgICAgICBiYXNlRGF0ZSxcbiAgICAgICAgZGF0ZVN0YXJ0LFxuICAgICAgICBkYXRlRW5kLFxuICAgICAgICBuZXdTdGFydHMsXG4gICAgICAgIG5ld0VuZHM7XG5cbiAgICB0aGlzLmd1aWRlLmNsZWFyR3VpZGVFbGVtZW50KCk7XG5cbiAgICBpZiAoIXRpdGxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNyZWF0ZVJhbmdlKSB7XG4gICAgICAgIGNyZWF0ZVJhbmdlID0gW1xuICAgICAgICAgICAgbmVhcmVzdEdyaWRUaW1lWSxcbiAgICAgICAgICAgIG5lYXJlc3RHcmlkVGltZVkgKyBkYXRldGltZS5taWxsaXNlY29uZHNGcm9tKCdtaW51dGVzJywgMzApXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYmFzZURhdGUgPSBuZXcgRGF0ZShyZWxhdGVkVmlldy5nZXREYXRlKCkpO1xuICAgIGRhdGVTdGFydCA9IGRhdGV0aW1lLnN0YXJ0KGJhc2VEYXRlKTtcbiAgICBkYXRlRW5kID0gZGF0ZXRpbWUuZW5kKGJhc2VEYXRlKTtcbiAgICBuZXdTdGFydHMgPSBNYXRoLm1heChkYXRlU3RhcnQuZ2V0VGltZSgpLCBjcmVhdGVSYW5nZVswXSk7XG4gICAgbmV3RW5kcyA9IE1hdGgubWluKGRhdGVFbmQuZ2V0VGltZSgpLCBjcmVhdGVSYW5nZVsxXSk7XG5cbiAgICBjdHJsLmNyZWF0ZUV2ZW50KHtcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICBpc0FsbERheTogZmFsc2UsXG4gICAgICAgIHN0YXJ0czogbmV3IERhdGUobmV3U3RhcnRzKSxcbiAgICAgICAgZW5kczogbmV3IERhdGUobmV3RW5kcylcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRHJhZyNkcmFnRW5kIGV2ZW50IGhhbmRsZXJcbiAqIEBlbWl0cyBUaW1lQ3JlYXRpb24jdGltZV9jcmVhdGlvbl9kcmFnZW5kXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ0VuZEV2ZW50RGF0YSAtIGV2ZW50IGRhdGEgZnJvbSBEcmFnI2RyYWdlbmRcbiAqL1xuVGltZUNyZWF0aW9uLnByb3RvdHlwZS5fb25EcmFnRW5kID0gZnVuY3Rpb24oZHJhZ0VuZEV2ZW50RGF0YSkge1xuICAgIHZhciBkcmFnU3RhcnQgPSB0aGlzLl9kcmFnU3RhcnQ7XG5cbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9mZih7XG4gICAgICAgIGRyYWc6IHRoaXMuX29uRHJhZyxcbiAgICAgICAgZHJhZ0VuZDogdGhpcy5fb25EcmFnRW5kLFxuICAgICAgICBjbGljazogdGhpcy5fb25DbGlja1xuICAgIH0sIHRoaXMpO1xuXG4gICAgZnVuY3Rpb24gcmV2aXNlRnVuYyhldmVudERhdGEpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gW1xuICAgICAgICAgICAgZHJhZ1N0YXJ0Lm5lYXJlc3RHcmlkVGltZVksXG4gICAgICAgICAgICBldmVudERhdGEubmVhcmVzdEdyaWRUaW1lWVxuICAgICAgICBdLnNvcnQoYXJyYXkuY29tcGFyZS5udW0uYXNjKTtcbiAgICAgICAgcmFuZ2VbMV0gKz0gZGF0ZXRpbWUubWlsbGlzZWNvbmRzRnJvbSgnaG91cicsIDAuNSk7XG5cbiAgICAgICAgZXZlbnREYXRhLmNyZWF0ZVJhbmdlID0gcmFuZ2U7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlRXZlbnQoZXZlbnREYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgVGltZUNyZWF0aW9uI3RpbWVfY3JlYXRpb25fZHJhZ2VuZFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtUaW1lfSByZWxhdGVkVmlldyAtIHRpbWUgdmlldyBpbnN0YW5jZSByZWxhdGVkIHdpdGggbW91c2UgcG9zaXRpb24uXG4gICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBvcmlnaW5FdmVudCAtIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW91c2VZIC0gbW91c2UgWSBweCBtb3VzZSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZ3JpZFkgLSBncmlkIFkgaW5kZXggdmFsdWUgcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZVkgLSBtaWxsaXNlY29uZHMgdmFsdWUgb2YgbW91c2VZIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRZIC0gbmVhcmVzdCBncmlkIGluZGV4IHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkVGltZVkgLSB0aW1lIHZhbHVlIGZvciBuZWFyZXN0R3JpZFkuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJbXX0gY3JlYXRlUmFuZ2UgLSBtaWxsaXNlY29uZHMgcmFuZ2UgYmV0d2VlbiBkcmFnIHN0YXJ0IGFuZCBlbmQgdG8gY3JlYXRlLlxuICAgICAqL1xuICAgIHRoaXMuX29uRHJhZyhkcmFnRW5kRXZlbnREYXRhLCAndGltZV9jcmVhdGlvbl9kcmFnZW5kJywgdXRpbC5iaW5kKHJldmlzZUZ1bmMsIHRoaXMpKTtcblxuICAgIHRoaXMuX2RyYWdTdGFydCA9IHRoaXMuX2dldEV2ZW50RGF0YUZ1bmMgPSBudWxsO1xufTtcblxuLyoqXG4gKiBEcmFnI2NsaWNrIGV2ZW50IGhhbmRsZXJcbiAqIEBlbWl0cyBUaW1lQ3JlYXRpb24jdGltZV9jcmVhdGlvbl9jbGlja1xuICogQHBhcmFtIHtvYmplY3R9IGNsaWNrRXZlbnREYXRhIC0gZXZlbnQgZGF0YSBmcm9tIERyYWcjY2xpY2suXG4gKi9cblRpbWVDcmVhdGlvbi5wcm90b3R5cGUuX29uQ2xpY2sgPSBmdW5jdGlvbihjbGlja0V2ZW50RGF0YSkge1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIub2ZmKHtcbiAgICAgICAgZHJhZzogdGhpcy5fb25EcmFnLFxuICAgICAgICBkcmFnRW5kOiB0aGlzLl9vbkRyYWdFbmQsXG4gICAgICAgIGNsaWNrOiB0aGlzLl9vbkNsaWNrXG4gICAgfSwgdGhpcyk7XG5cbiAgICBmdW5jdGlvbiByZXZpc2VGdW5jKGV2ZW50RGF0YSkge1xuICAgICAgICB0aGlzLl9jcmVhdGVFdmVudChldmVudERhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBldmVudCBUaW1lQ3JlYXRpb24jdGltZV9jcmVhdGlvbl9jbGlja1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtUaW1lfSByZWxhdGVkVmlldyAtIHRpbWUgdmlldyBpbnN0YW5jZSByZWxhdGVkIHdpdGggbW91c2UgcG9zaXRpb24uXG4gICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBvcmlnaW5FdmVudCAtIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW91c2VZIC0gbW91c2UgWSBweCBtb3VzZSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZ3JpZFkgLSBncmlkIFkgaW5kZXggdmFsdWUgcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZVkgLSBtaWxsaXNlY29uZHMgdmFsdWUgb2YgbW91c2VZIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRZIC0gbmVhcmVzdCBncmlkIGluZGV4IHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkVGltZVkgLSB0aW1lIHZhbHVlIGZvciBuZWFyZXN0R3JpZFkuXG4gICAgICovXG4gICAgdGhpcy5fb25EcmFnKGNsaWNrRXZlbnREYXRhLCAndGltZV9jcmVhdGlvbl9jbGljaycsIHV0aWwuYmluZChyZXZpc2VGdW5jLCB0aGlzKSk7XG5cbiAgICB0aGlzLl9kcmFnU3RhcnQgPSB0aGlzLl9nZXRFdmVudERhdGFGdW5jID0gbnVsbDtcbn07XG5cbnRpbWVDb3JlLm1peGluKFRpbWVDcmVhdGlvbik7XG51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihUaW1lQ3JlYXRpb24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVDcmVhdGlvbjtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1vZHVsZSBmb3IgVGltZS5DcmVhdGlvbiBlZmZlY3Qgd2hpbGUgZHJhZ2dpbmcuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIHJlcUFuaW1GcmFtZSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9yZXFBbmltRnJhbWUnKTtcblxudmFyIHJhdGlvID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2NvbW1vbicpLnJhdGlvO1xuXG4vKipcbiAqIENsYXNzIGZvciBUaW1lLkNyZWF0aW9uIGRyYWdnaW5nIGVmZmVjdC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtUaW1lQ3JlYXRpb259IHRpbWVDcmVhdGlvbiAtIGluc3RhbmNlIG9mIFRpbWVDcmVhdGlvbi5cbiAqL1xuZnVuY3Rpb24gVGltZUNyZWF0aW9uR3VpZGUodGltZUNyZWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogR3VpZGUgZWxlbWVudCBmb3IgY3JlYXRpb24gZWZmZWN0LlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmd1aWRlRWxlbWVudCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtUaW1lQ3JlYXRpb259XG4gICAgICovXG4gICAgdGhpcy50aW1lQ3JlYXRpb24gPSB0aW1lQ3JlYXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX3N0YXJ0R3JpZFkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuX2dldFRvcEZ1bmMgPSBudWxsO1xuXG4gICAgZG9tdXRpbC5hZGRDbGFzcyh0aGlzLmd1aWRlRWxlbWVudCwgJ3NjaGVkdWxlLXZpZXctdGltZS1jcmVhdGlvbi1ndWlkZScpO1xuXG4gICAgdGltZUNyZWF0aW9uLm9uKHtcbiAgICAgICAgJ3RpbWVfY3JlYXRpb25fZHJhZ3N0YXJ0JzogdGhpcy5fb25EcmFnU3RhcnQsXG4gICAgICAgICd0aW1lX2NyZWF0aW9uX2RyYWcnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIC8vICd0aW1lX2NyZWF0aW9uX2RyYWdlbmQnOiB0aGlzLmNsZWFyR3VpZGVFbGVtZW50LFxuICAgICAgICAndGltZV9jcmVhdGlvbl9jbGljayc6IHRoaXMuY2xlYXJHdWlkZUVsZW1lbnRcbiAgICB9LCB0aGlzKTtcbn1cblxuLyoqXG4gKiBEZXN0cm95IG1ldGhvZC5cbiAqL1xuVGltZUNyZWF0aW9uR3VpZGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyR3VpZGVFbGVtZW50KCk7XG4gICAgdGhpcy50aW1lQ3JlYXRpb24ub2ZmKHRoaXMpO1xuICAgIHRoaXMuZ3VpZGVFbGVtZW50ID0gdGhpcy50aW1lQ3JlYXRpb24gPSB0aGlzLl9zdGFydEdyaWRZID1cbiAgICAgICAgdGhpcy5fZ2V0VG9wRnVuYyA9IG51bGw7XG59O1xuXG4vKipcbiAqIENsZWFyIGd1aWRlIGVsZW1lbnQuXG4gKi9cblRpbWVDcmVhdGlvbkd1aWRlLnByb3RvdHlwZS5jbGVhckd1aWRlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBndWlkZUVsZW1lbnQgPSB0aGlzLmd1aWRlRWxlbWVudDtcblxuICAgIGRvbXV0aWwucmVtb3ZlKGd1aWRlRWxlbWVudCk7XG5cbiAgICByZXFBbmltRnJhbWUucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgZ3VpZGVFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGd1aWRlRWxlbWVudC5zdHlsZS50b3AgPSAnJztcbiAgICAgICAgZ3VpZGVFbGVtZW50LnN0eWxlLmhlaWdodCA9ICcnO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSZWZyZXNoIGd1aWRlIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgLSBUaGUgbnVtYmVyIG9mIGd1aWRlIGVsZW1lbnQncyBzdHlsZSB0b3AuXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIG51bWJlciBvZiBndWlkZSBlbGVtZW50J3Mgc3R5bGUgaGVpZ2h0LlxuICovXG5UaW1lQ3JlYXRpb25HdWlkZS5wcm90b3R5cGUuX3JlZnJlc2hHdWlkZUVsZW1lbnQgPSBmdW5jdGlvbih0b3AsIGhlaWdodCkge1xuICAgIHZhciBndWlkZUVsZW1lbnQgPSB0aGlzLmd1aWRlRWxlbWVudDtcblxuICAgIHJlcUFuaW1GcmFtZS5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICBndWlkZUVsZW1lbnQuc3R5bGUudG9wID0gdG9wICsgJ3B4JztcbiAgICAgICAgZ3VpZGVFbGVtZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgIGd1aWRlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRHJhZ1N0YXJ0IGV2ZW50IGhhbmRsZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnU3RhcnRFdmVudERhdGEgLSBkcmFnU3RhcnQgZXZlbnQgZGF0YS5cbiAqL1xuVGltZUNyZWF0aW9uR3VpZGUucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGRyYWdTdGFydEV2ZW50RGF0YSkge1xuICAgIHZhciB0aW1lVmlldyA9IGRyYWdTdGFydEV2ZW50RGF0YS5yZWxhdGVkVmlldyxcbiAgICAgICAgdmlld09wdGlvbnMgPSB0aW1lVmlldy5vcHRpb25zLFxuICAgICAgICB2aWV3SGVpZ2h0ID0gdGltZVZpZXcuZ2V0Vmlld0JvdW5kKCkuaGVpZ2h0LFxuICAgICAgICBob3VyTGVuZ3RoID0gdmlld09wdGlvbnMuaG91ckVuZCAtIHZpZXdPcHRpb25zLmhvdXJTdGFydCxcbiAgICAgICAgZ2V0VG9wRnVuYztcblxuICAgIGdldFRvcEZ1bmMgPSB0aGlzLl9nZXRUb3BGdW5jID0gdXRpbC5iaW5kKGZ1bmN0aW9uKGluZGV4WSkge1xuICAgICAgICAvLyBtZW1vXG4gICAgICAgIGlmIChnZXRUb3BGdW5jW2luZGV4WV0pIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRUb3BGdW5jW2luZGV4WV07XG4gICAgICAgIH1cblxuICAgICAgICBnZXRUb3BGdW5jW2luZGV4WV0gPSByYXRpbyhob3VyTGVuZ3RoLCB2aWV3SGVpZ2h0LCBpbmRleFkpO1xuXG4gICAgICAgIHJldHVybiBnZXRUb3BGdW5jW2luZGV4WV07XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLl9zdGFydEdyaWRZID0gZ2V0VG9wRnVuYyhkcmFnU3RhcnRFdmVudERhdGEubmVhcmVzdEdyaWRZKTtcblxuICAgIHRoaXMuX3JlZnJlc2hHdWlkZUVsZW1lbnQoXG4gICAgICAgIHRoaXMuX3N0YXJ0R3JpZFksXG4gICAgICAgIGdldFRvcEZ1bmMoMC41KVxuICAgICk7XG5cbiAgICB0aW1lVmlldy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5ndWlkZUVsZW1lbnQpO1xufTtcblxuLyoqXG4gKiBEcmFnIGV2ZW50IGhhbmRsZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnRXZlbnREYXRhIC0gZHJhZyBldmVudCBkYXRhLlxuICovXG5UaW1lQ3JlYXRpb25HdWlkZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uKGRyYWdFdmVudERhdGEpIHtcbiAgICB2YXIgZ2V0VG9wRnVuYyA9IHRoaXMuX2dldFRvcEZ1bmMsXG4gICAgICAgIHN0YXJ0R3JpZFkgPSB0aGlzLl9zdGFydEdyaWRZLFxuICAgICAgICBlbmRHcmlkWTtcblxuICAgIGlmICghZ2V0VG9wRnVuYykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZHJhd2luZyBndWlkZSBmcm9tIHN0YXJ0IHBvaW50IHRvIGF0IGxlYXN0IDMwbWluIHBvaW50cy5cbiAgICBlbmRHcmlkWSA9IGdldFRvcEZ1bmMoZHJhZ0V2ZW50RGF0YS5uZWFyZXN0R3JpZFkpICsgZ2V0VG9wRnVuYygwLjUpO1xuXG4gICAgaWYgKGVuZEdyaWRZID4gc3RhcnRHcmlkWSkge1xuICAgICAgICB0aGlzLl9yZWZyZXNoR3VpZGVFbGVtZW50KHN0YXJ0R3JpZFksIGVuZEdyaWRZIC0gc3RhcnRHcmlkWSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWZyZXNoR3VpZGVFbGVtZW50KFxuICAgICAgICBlbmRHcmlkWSAtIGdldFRvcEZ1bmMoMC41KSxcbiAgICAgICAgKHN0YXJ0R3JpZFkgKyBnZXRUb3BGdW5jKDEpKSAtIGVuZEdyaWRZXG4gICAgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZUNyZWF0aW9uR3VpZGU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBIYW5kbGluZyBtb3ZlIGV2ZW50cyBmcm9tIGRyYWcgaGFuZGxlciBhbmQgdGltZSBncmlkIHZpZXdcbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciB0aW1lQ29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIFRpbWVNb3ZlR3VpZGUgPSByZXF1aXJlKCcuL21vdmVHdWlkZScpO1xuXG52YXIgcGFyc2VUaW1lVmlld0lEUnggPSAvXnNjaGVkdWxlLXZpZXctdGltZS1kYXRlW1xcc11zY2hlZHVsZS12aWV3LShcXGQrKS87XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7SGFuZGxlcn1cbiAqIEBtaXhlcyB0aW1lQ29yZVxuICogQG1peGVzIHV0aWwuQ3VzdG9tRXZlbnRzXG4gKiBAcGFyYW0ge0RyYWd9IFtkcmFnSGFuZGxlcl0gLSBEcmFnIGhhbmRsZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge1RpbWVHcmlkfSBbdGltZUdyaWRWaWV3XSAtIFRpbWVHcmlkIHZpZXcgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0Jhc2V9IFtiYXNlQ29udHJvbGxlcl0gLSBCYXNlIGNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIFRpbWVNb3ZlKGRyYWdIYW5kbGVyLCB0aW1lR3JpZFZpZXcsIGJhc2VDb250cm9sbGVyKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0RyYWd9XG4gICAgICovXG4gICAgdGhpcy5kcmFnSGFuZGxlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VGltZUdyaWR9XG4gICAgICovXG4gICAgdGhpcy50aW1lR3JpZFZpZXcgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Jhc2V9XG4gICAgICovXG4gICAgdGhpcy5iYXNlQ29udHJvbGxlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5fZ2V0RXZlbnREYXRhRnVuYyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuX2RyYWdTdGFydCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VGltZU1vdmVHdWlkZX1cbiAgICAgKi9cbiAgICB0aGlzLl9ndWlkZSA9IG5ldyBUaW1lTW92ZUd1aWRlKHRoaXMpO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxufVxuXG4vKipcbiAqIERlc3Ryb3kgbWV0aG9kLlxuICovXG5UaW1lTW92ZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2d1aWRlLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9mZih0aGlzKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gdGhpcy50aW1lR3JpZFZpZXcgPSB0aGlzLmJhc2VDb250cm9sbGVyID1cbiAgICAgICAgdGhpcy5fZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX2RyYWdTdGFydCA9IHRoaXMuX2d1aWRlID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ29ubmVjdCBoYW5kbGVyLCB2aWV3LCBjb250cm9sbGVycyBmb3IgZXZlbnQgY3JlYXRpb25zLlxuICogQHBhcmFtIHtEcmFnfSBbZHJhZ0hhbmRsZXJdIC0gRHJhZyBoYW5kbGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHtUaW1lR3JpZH0gW3RpbWVHcmlkVmlld10gLSBUaW1lR3JpZCB2aWV3IGluc3RhbmNlLlxuICogQHBhcmFtIHtCYXNlfSBbYmFzZUNvbnRyb2xsZXJdIC0gQmFzZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICovXG5UaW1lTW92ZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKGRyYWdIYW5kbGVyLCB0aW1lR3JpZFZpZXcsIGJhc2VDb250cm9sbGVyKSB7XG4gICAgdGhpcy5kcmFnSGFuZGxlciA9IGRyYWdIYW5kbGVyO1xuICAgIHRoaXMudGltZUdyaWRWaWV3ID0gdGltZUdyaWRWaWV3O1xuICAgIHRoaXMuYmFzZUNvbnRyb2xsZXIgPSBiYXNlQ29udHJvbGxlcjtcblxuICAgIGRyYWdIYW5kbGVyLm9uKHtcbiAgICAgICAgZHJhZ1N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydFxuICAgIH0sIHRoaXMpO1xufTtcblxuLyoqXG4gKiBDaGVjayB0YXJnZXQgZWxlbWVudCBpcyBleHBlY3RlZCBjb25kaXRpb24gZm9yIGFjdGl2YXRlIHRoaXMgcGx1Z2lucy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIFRoZSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbnxvYmplY3R9IC0gcmV0dXJuIG9iamVjdCB3aGVuIHNhdGlhdGUgY29uZGl0aW9uLlxuICovXG5UaW1lTW92ZS5wcm90b3R5cGUuY2hlY2tFeHBlY3RDb25kaXRpb24gPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICBpZiAoZG9tdXRpbC5nZXRDbGFzcyh0YXJnZXQpICE9PSAnc2NoZWR1bGUtdmlldy10aW1lLWV2ZW50Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2dldFRpbWVWaWV3KHRhcmdldCk7XG59O1xuXG4vKipcbiAqIEdldCBUaW1lIHZpZXcgY29udGFpbmVyIGZyb20gc3VwcGxpZWQgZWxlbWVudC5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIGVsZW1lbnQgdG8gZmluZCB0aW1lIHZpZXcgY29udGFpbmVyLlxuICogQHJldHVybnMge29iamVjdHxib29sZWFufSAtIHJldHVybiB0aW1lIHZpZXcgaW5zdGFuY2Ugd2hlbiBmaW5kZWQuXG4gKi9cblRpbWVNb3ZlLnByb3RvdHlwZS5fZ2V0VGltZVZpZXcgPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9tdXRpbC5jbG9zZXN0KHRhcmdldCwgJy5zY2hlZHVsZS12aWV3LXRpbWUtZGF0ZScpLFxuICAgICAgICBtYXRjaGVzO1xuXG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG1hdGNoZXMgPSBkb211dGlsLmdldENsYXNzKGNvbnRhaW5lcikubWF0Y2gocGFyc2VUaW1lVmlld0lEUngpO1xuXG4gICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWwucGljayh0aGlzLnRpbWVHcmlkVmlldy5jaGlsZHMuaXRlbXMsICttYXRjaGVzWzFdKTtcbn07XG5cbi8qKlxuICogQGVtaXRzIFRpbWVNb3ZlI3RpbWVfbW92ZV9kcmFnc3RhcnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnU3RhcnRFdmVudERhdGEgLSBEcmFnI2RyYWdTdGFydCBldmVudCBkYXRhLlxuICovXG5UaW1lTW92ZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZHJhZ1N0YXJ0RXZlbnREYXRhKSB7XG4gICAgdmFyIHRhcmdldCA9IGRyYWdTdGFydEV2ZW50RGF0YS50YXJnZXQsXG4gICAgICAgIHRpbWVWaWV3ID0gdGhpcy5jaGVja0V4cGVjdENvbmRpdGlvbih0YXJnZXQpLFxuICAgICAgICBibG9ja0VsZW1lbnQgPSBkb211dGlsLmNsb3Nlc3QodGFyZ2V0LCAnLnNjaGVkdWxlLXZpZXctdGltZS1kYXRlLWV2ZW50LWJsb2NrJyksXG4gICAgICAgIGdldEV2ZW50RGF0YUZ1bmMsXG4gICAgICAgIGV2ZW50RGF0YTtcblxuICAgIGlmICghdGltZVZpZXcgfHwgIWJsb2NrRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX2dldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9yZXRyaXZlRXZlbnREYXRhKHRpbWVWaWV3KTtcbiAgICBldmVudERhdGEgPSB0aGlzLl9kcmFnU3RhcnQgPSBnZXRFdmVudERhdGFGdW5jKFxuICAgICAgICBkcmFnU3RhcnRFdmVudERhdGEub3JpZ2luRXZlbnQsIHtcbiAgICAgICAgICAgIHRhcmdldE1vZGVsSUQ6IGRvbXV0aWwuZ2V0RGF0YShibG9ja0VsZW1lbnQsICdpZCcpXG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy5kcmFnSGFuZGxlci5vbih7XG4gICAgICAgIGRyYWc6IHRoaXMuX29uRHJhZyxcbiAgICAgICAgZHJhZ0VuZDogdGhpcy5fb25EcmFnRW5kLFxuICAgICAgICBjbGljazogdGhpcy5fb25DbGlja1xuICAgIH0sIHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFRpbWVNb3ZlI3RpbWVfbW92ZV9kcmFnc3RhcnRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIGN1cnJlbnQgdGFyZ2V0IGluIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge1RpbWV9IHJlbGF0ZWRWaWV3IC0gdGltZSB2aWV3IGluc3RhbmNlIHJlbGF0ZWQgd2l0aCBtb3VzZSBwb3NpdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge01vdXNlRXZlbnR9IG9yaWdpbkV2ZW50IC0gbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb3VzZVkgLSBtb3VzZSBZIHB4IG1vdXNlIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBncmlkWSAtIGdyaWQgWSBpbmRleCB2YWx1ZSByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lWSAtIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiBtb3VzZVkgcG9pbnRzLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFkgLSBuZWFyZXN0IGdyaWQgaW5kZXggcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRUaW1lWSAtIHRpbWUgdmFsdWUgZm9yIG5lYXJlc3RHcmlkWS5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdGFyZ2V0TW9kZWxJRCAtIFRoZSBtb2RlbCB1bmlxdWUgaWQgZW1pdHRlZCBtb3ZlIGV2ZW50LlxuICAgICAqL1xuICAgIHRoaXMuZmlyZSgndGltZV9tb3ZlX2RyYWdzdGFydCcsIGV2ZW50RGF0YSk7XG59O1xuXG4vKipcbiAqIEBlbWl0cyBUaW1lTW92ZSN0aW1lX21vdmVfZHJhZ1xuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBkcmFnRXZlbnREYXRhIC0gbW91c2Vtb3ZlIGV2ZW50IG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IFtvdmVycmlkZUV2ZW50TmFtZV0gLSBuYW1lIG9mIGVtaXR0aW5nIGV2ZW50IHRvIG92ZXJyaWRlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3JldmlzZV0gLSBzdXBwbHkgZnVuY3Rpb24gZm9yIHJldmlzZSBldmVudCBkYXRhIGJlZm9yZSBlbWl0LlxuICovXG5UaW1lTW92ZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uKGRyYWdFdmVudERhdGEsIG92ZXJyaWRlRXZlbnROYW1lLCByZXZpc2UpIHtcbiAgICB2YXIgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX2dldEV2ZW50RGF0YUZ1bmMsXG4gICAgICAgIHRpbWVWaWV3ID0gdGhpcy5fZ2V0VGltZVZpZXcoZHJhZ0V2ZW50RGF0YS50YXJnZXQpLFxuICAgICAgICBkcmFnU3RhcnQgPSB0aGlzLl9kcmFnU3RhcnQsXG4gICAgICAgIGV2ZW50RGF0YTtcblxuICAgIGlmICghdGltZVZpZXcgfHwgIWdldEV2ZW50RGF0YUZ1bmMgfHwgIWRyYWdTdGFydCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnREYXRhID0gZ2V0RXZlbnREYXRhRnVuYyhkcmFnRXZlbnREYXRhLm9yaWdpbkV2ZW50LCB7XG4gICAgICAgIGN1cnJlbnRWaWV3OiB0aW1lVmlldyxcbiAgICAgICAgdGFyZ2V0TW9kZWxJRDogZHJhZ1N0YXJ0LnRhcmdldE1vZGVsSURcbiAgICB9KTtcblxuICAgIGlmIChyZXZpc2UpIHtcbiAgICAgICAgcmV2aXNlKGV2ZW50RGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFRpbWVNb3ZlI3RpbWVfbW92ZV9kcmFnXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBjdXJyZW50IHRhcmdldCBpbiBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtUaW1lfSByZWxhdGVkVmlldyAtIHRpbWUgdmlldyBpbnN0YW5jZSByZWxhdGVkIHdpdGggZHJhZyBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge01vdXNlRXZlbnR9IG9yaWdpbkV2ZW50IC0gbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb3VzZVkgLSBtb3VzZSBZIHB4IG1vdXNlIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBncmlkWSAtIGdyaWQgWSBpbmRleCB2YWx1ZSByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lWSAtIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiBtb3VzZVkgcG9pbnRzLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFkgLSBuZWFyZXN0IGdyaWQgaW5kZXggcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRUaW1lWSAtIHRpbWUgdmFsdWUgZm9yIG5lYXJlc3RHcmlkWS5cbiAgICAgKiBAcHJvcGVydHkge1RpbWV9IGN1cnJlbnRWaWV3IC0gdGltZSB2aWV3IGluc3RhbmNlIHJlbGF0ZWQgd2l0aCBjdXJyZW50IG1vdXNlIHBvc2l0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0YXJnZXRNb2RlbElEIC0gVGhlIG1vZGVsIHVuaXF1ZSBpZCBlbWl0dGVkIG1vdmUgZXZlbnQuXG4gICAgICovXG4gICAgdGhpcy5maXJlKG92ZXJyaWRlRXZlbnROYW1lIHx8ICd0aW1lX21vdmVfZHJhZycsIGV2ZW50RGF0YSk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBtb2RlbCBpbnN0YW5jZSBieSBkcmFnZW5kIGV2ZW50IHJlc3VsdHMuXG4gKiBAcGFyYW0ge29iamVjdH0gZXZlbnREYXRhIC0gZXZlbnQgZGF0YSBmcm9tIFRpbWVNb3ZlI3RpbWVfbW92ZV9kcmFnZW5kXG4gKi9cblRpbWVNb3ZlLnByb3RvdHlwZS5fdXBkYXRlRXZlbnQgPSBmdW5jdGlvbihldmVudERhdGEpIHtcbiAgICB2YXIgY3RybCA9IHRoaXMuYmFzZUNvbnRyb2xsZXIsXG4gICAgICAgIG1vZGVsSUQgPSBldmVudERhdGEudGFyZ2V0TW9kZWxJRCxcbiAgICAgICAgcmFuZ2UgPSBldmVudERhdGEubmVhcmVzdFJhbmdlLFxuICAgICAgICB0aW1lRGlmZiA9IHJhbmdlWzFdIC0gcmFuZ2VbMF0sXG4gICAgICAgIGRhdGVEaWZmID0gMCxcbiAgICAgICAgbW9kZWwgPSBjdHJsLmV2ZW50cy5pdGVtc1ttb2RlbElEXSxcbiAgICAgICAgcmVsYXRlZFZpZXcgPSBldmVudERhdGEucmVsYXRlZFZpZXcsXG4gICAgICAgIGN1cnJlbnRWaWV3ID0gZXZlbnREYXRhLmN1cnJlbnRWaWV3LFxuICAgICAgICBldmVudER1cmF0aW9uLFxuICAgICAgICBkYXRlU3RhcnQsXG4gICAgICAgIGRhdGVFbmQsXG4gICAgICAgIG5ld1N0YXJ0cyxcbiAgICAgICAgbmV3RW5kcyxcbiAgICAgICAgYmFzZURhdGU7XG5cbiAgICBpZiAoIW1vZGVsIHx8ICFjdXJyZW50Vmlldykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGltZURpZmYgLT0gZGF0ZXRpbWUubWlsbGlzZWNvbmRzRnJvbSgnbWludXRlcycsIDMwKTtcbiAgICBiYXNlRGF0ZSA9IG5ldyBEYXRlKHJlbGF0ZWRWaWV3LmdldERhdGUoKSk7XG4gICAgZGF0ZVN0YXJ0ID0gZGF0ZXRpbWUuc3RhcnQoYmFzZURhdGUpO1xuICAgIGRhdGVFbmQgPSBkYXRldGltZS5lbmQoYmFzZURhdGUpO1xuICAgIG5ld1N0YXJ0cyA9IG5ldyBEYXRlKG1vZGVsLmdldFN0YXJ0cygpLmdldFRpbWUoKSArIHRpbWVEaWZmKTtcbiAgICBuZXdFbmRzID0gbmV3IERhdGUobW9kZWwuZ2V0RW5kcygpLmdldFRpbWUoKSArIHRpbWVEaWZmKTtcbiAgICBldmVudER1cmF0aW9uID0gbW9kZWwuZHVyYXRpb24oKTtcblxuICAgIGlmIChjdXJyZW50Vmlldykge1xuICAgICAgICBkYXRlRGlmZiA9IGN1cnJlbnRWaWV3LmdldERhdGUoKSAtIHJlbGF0ZWRWaWV3LmdldERhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAobmV3U3RhcnRzIDwgZGF0ZVN0YXJ0KSB7XG4gICAgICAgIG5ld1N0YXJ0cyA9IG5ldyBEYXRlKGRhdGVTdGFydC5nZXRUaW1lKCkpO1xuICAgICAgICBuZXdFbmRzID0gbmV3IERhdGUobmV3U3RhcnRzLmdldFRpbWUoKSArIGV2ZW50RHVyYXRpb24uZ2V0VGltZSgpKTtcbiAgICB9IGVsc2UgaWYgKG5ld0VuZHMgPiBkYXRlRW5kKSB7XG4gICAgICAgIG5ld0VuZHMgPSBuZXcgRGF0ZShkYXRlRW5kLmdldFRpbWUoKSk7XG4gICAgICAgIG5ld1N0YXJ0cyA9IG5ldyBEYXRlKG5ld0VuZHMuZ2V0VGltZSgpIC0gZXZlbnREdXJhdGlvbi5nZXRUaW1lKCkpO1xuICAgIH1cblxuICAgIG5ld1N0YXJ0cyA9IG5ldyBEYXRlKG5ld1N0YXJ0cy5nZXRUaW1lKCkgKyBkYXRlRGlmZik7XG4gICAgbmV3RW5kcyA9IG5ldyBEYXRlKG5ld0VuZHMuZ2V0VGltZSgpICsgZGF0ZURpZmYpO1xuXG4gICAgY3RybC51cGRhdGVFdmVudChtb2RlbElELCB7XG4gICAgICAgIHN0YXJ0czogbmV3U3RhcnRzLFxuICAgICAgICBlbmRzOiBuZXdFbmRzXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBlbWl0cyBUaW1lTW92ZSN0aW1lX21vdmVfZHJhZ2VuZFxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBkcmFnRW5kRXZlbnREYXRhIC0gbW91c2V1cCBtb3VzZSBldmVudCBvYmplY3QuXG4gKi9cblRpbWVNb3ZlLnByb3RvdHlwZS5fb25EcmFnRW5kID0gZnVuY3Rpb24oZHJhZ0VuZEV2ZW50RGF0YSkge1xuICAgIHZhciBnZXRFdmVudERhdGFGdW5jID0gdGhpcy5fZ2V0RXZlbnREYXRhRnVuYyxcbiAgICAgICAgY3VycmVudFZpZXcgPSB0aGlzLl9nZXRUaW1lVmlldyhkcmFnRW5kRXZlbnREYXRhLnRhcmdldCksXG4gICAgICAgIGRyYWdTdGFydCA9IHRoaXMuX2RyYWdTdGFydCxcbiAgICAgICAgZXZlbnREYXRhO1xuXG4gICAgdGhpcy5kcmFnSGFuZGxlci5vZmYoe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIGlmICghZ2V0RXZlbnREYXRhRnVuYyB8fCAhZHJhZ1N0YXJ0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudERhdGEgPSBnZXRFdmVudERhdGFGdW5jKGRyYWdFbmRFdmVudERhdGEub3JpZ2luRXZlbnQsIHtcbiAgICAgICAgY3VycmVudFZpZXc6IGN1cnJlbnRWaWV3LFxuICAgICAgICB0YXJnZXRNb2RlbElEOiBkcmFnU3RhcnQudGFyZ2V0TW9kZWxJRFxuICAgIH0pO1xuXG4gICAgZXZlbnREYXRhLnJhbmdlID0gW1xuICAgICAgICBkcmFnU3RhcnQudGltZVksXG4gICAgICAgIGV2ZW50RGF0YS50aW1lWSArIGRhdGV0aW1lLm1pbGxpc2Vjb25kc0Zyb20oJ2hvdXInLCAwLjUpXG4gICAgXTtcblxuICAgIGV2ZW50RGF0YS5uZWFyZXN0UmFuZ2UgPSBbXG4gICAgICAgIGRyYWdTdGFydC5uZWFyZXN0R3JpZFRpbWVZLFxuICAgICAgICBldmVudERhdGEubmVhcmVzdEdyaWRUaW1lWSArIGRhdGV0aW1lLm1pbGxpc2Vjb25kc0Zyb20oJ2hvdXInLCAwLjUpXG4gICAgXTtcblxuICAgIHRoaXMuX3VwZGF0ZUV2ZW50KGV2ZW50RGF0YSk7XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgVGltZU1vdmUjdGltZV9tb3ZlX2RyYWdlbmRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIGN1cnJlbnQgdGFyZ2V0IGluIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge1RpbWV9IHJlbGF0ZWRWaWV3IC0gdGltZSB2aWV3IGluc3RhbmNlIHJlbGF0ZWQgd2l0aCBkcmFnIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7VGltZX0gY3VycmVudFZpZXcgLSB0aW1lIHZpZXcgaW5zdGFuY2UgcmVsYXRlZCB3aXRoIGN1cnJlbnQgbW91c2UgcG9zaXRpb24uXG4gICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBvcmlnaW5FdmVudCAtIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW91c2VZIC0gbW91c2UgWSBweCBtb3VzZSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZ3JpZFkgLSBncmlkIFkgaW5kZXggdmFsdWUgcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZVkgLSBtaWxsaXNlY29uZHMgdmFsdWUgb2YgbW91c2VZIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRZIC0gbmVhcmVzdCBncmlkIGluZGV4IHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkVGltZVkgLSB0aW1lIHZhbHVlIGZvciBuZWFyZXN0R3JpZFkuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHRhcmdldE1vZGVsSUQgLSBUaGUgbW9kZWwgdW5pcXVlIGlkIGVtaXR0ZWQgbW92ZSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcltdfSByYW5nZSAtIG1pbGxpc2Vjb25kcyByYW5nZSBiZXR3ZWVuIGRyYWcgc3RhcnQgYW5kIGVuZC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcltdfSBuZWFyZXN0UmFuZ2UgLSBtaWxsaXNlY29uZHMgcmFuZ2UgcmVsYXRlZCB3aXRoIG5lYXJlc3RHcmlkWSBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQuXG4gICAgICovXG4gICAgdGhpcy5maXJlKCd0aW1lX21vdmVfZHJhZ2VuZCcsIGV2ZW50RGF0YSk7XG59O1xuXG4vKipcbiAqIEBlbWl0cyBUaW1lTW92ZSN0aW1lX21vdmVfY2xpY2tcbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gY2xpY2tFdmVudERhdGEgLSBjbGljayBtb3VzZSBldmVudCBvYmplY3QuXG4gKi9cblRpbWVNb3ZlLnByb3RvdHlwZS5fb25DbGljayA9IGZ1bmN0aW9uKGNsaWNrRXZlbnREYXRhKSB7XG4gICAgdmFyIGdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9nZXRFdmVudERhdGFGdW5jLFxuICAgICAgICBkcmFnU3RhcnQgPSB0aGlzLl9kcmFnU3RhcnQsXG4gICAgICAgIGV2ZW50RGF0YTtcblxuICAgIHRoaXMuZHJhZ0hhbmRsZXIub2ZmKHtcbiAgICAgICAgZHJhZzogdGhpcy5fb25EcmFnLFxuICAgICAgICBkcmFnRW5kOiB0aGlzLl9vbkRyYWdFbmQsXG4gICAgICAgIGNsaWNrOiB0aGlzLl9vbkNsaWNrXG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoIWdldEV2ZW50RGF0YUZ1bmMgfHwgIWRyYWdTdGFydCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnREYXRhID0gZ2V0RXZlbnREYXRhRnVuYyhjbGlja0V2ZW50RGF0YS5vcmlnaW5FdmVudCwge1xuICAgICAgICB0YXJnZXRNb2RlbElEOiBkcmFnU3RhcnQudGFyZ2V0TW9kZWxJRFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFRpbWVNb3ZlI3RpbWVfbW92ZV9jbGlja1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gY3VycmVudCB0YXJnZXQgaW4gbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqIEBwcm9wZXJ0eSB7VGltZX0gcmVsYXRlZFZpZXcgLSB0aW1lIHZpZXcgaW5zdGFuY2UgcmVsYXRlZCB3aXRoIGRyYWcgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBvcmlnaW5FdmVudCAtIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW91c2VZIC0gbW91c2UgWSBweCBtb3VzZSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZ3JpZFkgLSBncmlkIFkgaW5kZXggdmFsdWUgcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZVkgLSBtaWxsaXNlY29uZHMgdmFsdWUgb2YgbW91c2VZIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRZIC0gbmVhcmVzdCBncmlkIGluZGV4IHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkVGltZVkgLSB0aW1lIHZhbHVlIGZvciBuZWFyZXN0R3JpZFkuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHRhcmdldE1vZGVsSUQgLSBUaGUgbW9kZWwgdW5pcXVlIGlkIGVtaXR0ZWQgbW92ZSBldmVudC5cbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ3RpbWVfbW92ZV9jbGljaycsIGV2ZW50RGF0YSk7XG59O1xuXG50aW1lQ29yZS5taXhpbihUaW1lTW92ZSk7XG51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihUaW1lTW92ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZU1vdmU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBNb2R1bGUgZm9yIFRpbWUuTW92ZSBlZmZlY3Qgd2hpbGUgZHJhZ2dpbmcuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIHJlcUFuaW1GcmFtZSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9yZXFBbmltRnJhbWUnKTtcblxudmFyIHJhdGlvID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2NvbW1vbicpLnJhdGlvO1xuXG4vKipcbiAqIENsYXNzIGZvciBUaW1lLk1vdmUgZWZmZWN0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1RpbWVNb3ZlfSB0aW1lTW92ZSAtIFRoZSBpbnN0YW5jZSBvZiBUaW1lTW92ZS5cbiAqL1xuZnVuY3Rpb24gVGltZU1vdmVHdWlkZSh0aW1lTW92ZSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmd1aWRlRWxlbWVudCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VGltZU1vdmV9XG4gICAgICovXG4gICAgdGhpcy50aW1lTW92ZSA9IHRpbWVNb3ZlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5fZ2V0VG9wRnVuYyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX3N0YXJ0R3JpZFkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9zdGFydFRvcFBpeGVsID0gMDtcblxuICAgIHRpbWVNb3ZlLm9uKHtcbiAgICAgICAgJ3RpbWVfbW92ZV9kcmFnc3RhcnQnOiB0aGlzLl9vbkRyYWdTdGFydCxcbiAgICAgICAgJ3RpbWVfbW92ZV9kcmFnJzogdGhpcy5fb25EcmFnLFxuICAgICAgICAndGltZV9tb3ZlX2RyYWdlbmQnOiB0aGlzLl9jbGVhckd1aWRlRWxlbWVudCxcbiAgICAgICAgJ3RpbWVfbW92ZV9jbGljayc6IHRoaXMuX2NsZWFyR3VpZGVFbGVtZW50XG4gICAgfSwgdGhpcyk7XG59XG5cbi8qKlxuICogRGVzdHJveSBtZXRob2RcbiAqL1xuVGltZU1vdmVHdWlkZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NsZWFyR3VpZGVFbGVtZW50KCk7XG4gICAgdGhpcy50aW1lTW92ZS5vZmYodGhpcyk7XG4gICAgdGhpcy5ndWlkZUVsZW1lbnQgPSB0aGlzLnRpbWVNb3ZlID0gdGhpcy5fY29udGFpbmVyID1cbiAgICAgICAgdGhpcy5fZ2V0VG9wRnVuYyA9IHRoaXMuX3N0YXJ0R3JpZFkgPSB0aGlzLl9zdGFydFRvcFBpeGVsID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xlYXIgZ3VpZGUgZWxlbWVudC5cbiAqL1xuVGltZU1vdmVHdWlkZS5wcm90b3R5cGUuX2NsZWFyR3VpZGVFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGd1aWRlRWxlbWVudCA9IHRoaXMuZ3VpZGVFbGVtZW50O1xuXG4gICAgaWYgKCF1dGlsLmJyb3dzZXIubXNpZSkge1xuICAgICAgICBkb211dGlsLnJlbW92ZUNsYXNzKGdsb2JhbC5kb2N1bWVudC5ib2R5LCAnc2NoZWR1bGUtdmlldy1kcmFnZ2luZycpO1xuICAgIH1cblxuICAgIGRvbXV0aWwucmVtb3ZlKGd1aWRlRWxlbWVudCk7XG5cbiAgICB0aGlzLmd1aWRlRWxlbWVudCA9IHRoaXMuX2dldFRvcEZ1bmMgPVxuICAgICAgICB0aGlzLl9zdGFydEdyaWRZID0gdGhpcy5fc3RhcnRUb3BQaXhlbCA9IG51bGw7XG59O1xuXG4vKipcbiAqIFJlZnJlc2ggZ3VpZGUgZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHRvcCAtIGd1aWRlIGVsZW1lbnQncyBzdHlsZSB0b3AuXG4gKi9cblRpbWVNb3ZlR3VpZGUucHJvdG90eXBlLl9yZWZyZXNoR3VpZGVFbGVtZW50ID0gZnVuY3Rpb24odG9wKSB7XG4gICAgdmFyIGd1aWRlRWxlbWVudCA9IHRoaXMuZ3VpZGVFbGVtZW50O1xuXG4gICAgaWYgKCFndWlkZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlcUFuaW1GcmFtZS5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICBndWlkZUVsZW1lbnQuc3R5bGUudG9wID0gdG9wICsgJ3B4JztcbiAgICAgICAgZ3VpZGVFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBUaW1lTW92ZSN0aW1lX21vdmVfZHJhZ3N0YXJ0IGV2ZW50IGhhbmRsZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnU3RhcnRFdmVudERhdGEgLSBkcmFnc3RhcnQgZXZlbnQgZGF0YVxuICovXG5UaW1lTW92ZUd1aWRlLnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbihkcmFnU3RhcnRFdmVudERhdGEpIHtcbiAgICB2YXIgZ3VpZGVFbGVtZW50ID0gZG9tdXRpbC5jbG9zZXN0KFxuICAgICAgICBkcmFnU3RhcnRFdmVudERhdGEudGFyZ2V0LFxuICAgICAgICAnLnNjaGVkdWxlLXZpZXctdGltZS1kYXRlLWV2ZW50LWJsb2NrJ1xuICAgICk7XG5cbiAgICBpZiAoIWd1aWRlRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ3VpZGVFbGVtZW50ID0gZ3VpZGVFbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgICBkb211dGlsLmFkZENsYXNzKGd1aWRlRWxlbWVudCwgJ3NjaGVkdWxlLXZpZXctdGltZS1tb3ZlLWd1aWRlJyk7XG5cbiAgICB0aGlzLl9zdGFydFRvcFBpeGVsID0gcGFyc2VGbG9hdChndWlkZUVsZW1lbnQuc3R5bGUudG9wKTtcbiAgICB0aGlzLl9zdGFydEdyaWRZID0gZHJhZ1N0YXJ0RXZlbnREYXRhLm5lYXJlc3RHcmlkWTtcbiAgICB0aGlzLmd1aWRlRWxlbWVudCA9IGd1aWRlRWxlbWVudDtcbiAgICB0aGlzLl9jb250YWluZXIgPSBkcmFnU3RhcnRFdmVudERhdGEucmVsYXRlZFZpZXcuY29udGFpbmVyO1xuICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChndWlkZUVsZW1lbnQpO1xufTtcblxuLyoqXG4gKiBUaW1lTW92ZSN0aW1lX21vdmVfZHJhZyBldmVudCBoYW5kbGVyXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ0V2ZW50RGF0YSAtIGRyYWcgZXZlbnQgZGF0YVxuICovXG5UaW1lTW92ZUd1aWRlLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24oZHJhZ0V2ZW50RGF0YSkge1xuICAgIHZhciB0aW1lVmlldyA9IGRyYWdFdmVudERhdGEuY3VycmVudFZpZXcsXG4gICAgICAgIHZpZXdPcHRpb25zID0gdGltZVZpZXcub3B0aW9ucyxcbiAgICAgICAgdmlld0hlaWdodCA9IHRpbWVWaWV3LmdldFZpZXdCb3VuZCgpLmhlaWdodCxcbiAgICAgICAgZ3VpZGVIZWlnaHQgPSBwYXJzZUZsb2F0KHRoaXMuZ3VpZGVFbGVtZW50LnN0eWxlLmhlaWdodCksXG4gICAgICAgIGhvdXJMZW5ndGggPSB2aWV3T3B0aW9ucy5ob3VyRW5kIC0gdmlld09wdGlvbnMuaG91clN0YXJ0LFxuICAgICAgICBncmlkWU9mZnNldCA9IGRyYWdFdmVudERhdGEubmVhcmVzdEdyaWRZIC0gdGhpcy5fc3RhcnRHcmlkWSxcbiAgICAgICAgLy8gaG91ckxlbmd0aCA6IHZpZXdIZWlnaHQgPSBncmlkWU9mZnNldCA6IFg7XG4gICAgICAgIGdyaWRZT2Zmc2V0UGl4ZWwgPSByYXRpbyhob3VyTGVuZ3RoLCB2aWV3SGVpZ2h0LCBncmlkWU9mZnNldCksXG4gICAgICAgIGJvdHRvbUxpbWl0LFxuICAgICAgICB0b3A7XG5cbiAgICBpZiAoIXV0aWwuYnJvd3Nlci5tc2llKSB7XG4gICAgICAgIGRvbXV0aWwuYWRkQ2xhc3MoZ2xvYmFsLmRvY3VtZW50LmJvZHksICdzY2hlZHVsZS12aWV3LWRyYWdnaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbnRhaW5lciAhPT0gdGltZVZpZXcuY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IHRpbWVWaWV3LmNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZ3VpZGVFbGVtZW50KTtcbiAgICB9XG5cbiAgICB0b3AgPSB0aGlzLl9zdGFydFRvcFBpeGVsICsgZ3JpZFlPZmZzZXRQaXhlbDtcbiAgICBib3R0b21MaW1pdCA9IHZpZXdIZWlnaHQgLSBndWlkZUhlaWdodDtcblxuICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgMCk7XG4gICAgdG9wID0gTWF0aC5taW4odG9wLCBib3R0b21MaW1pdCk7XG5cbiAgICB0aGlzLl9yZWZyZXNoR3VpZGVFbGVtZW50KHRvcCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVNb3ZlR3VpZGU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBIYW5kbGluZyByZXNpemUgZXZlbnRzIGZyb20gZHJhZyBoYW5kbGVyIGFuZCB0aW1lIGdyaWQgdmlld1xuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciB0aW1lQ29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIFRpbWVSZXNpemVHdWlkZSA9IHJlcXVpcmUoJy4vcmVzaXplR3VpZGUnKTtcblxudmFyIHBhcnNlVGltZVZpZXdJRFJ4ID0gL15zY2hlZHVsZS12aWV3LXRpbWUtZGF0ZVtcXHNdc2NoZWR1bGUtdmlldy0oXFxkKykvO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge0hhbmRsZXJ9XG4gKiBAbWl4ZXMgdGltZUNvcmVcbiAqIEBtaXhlcyB1dGlsLkN1c3RvbUV2ZW50c1xuICogQHBhcmFtIHtEcmFnfSBbZHJhZ0hhbmRsZXJdIC0gRHJhZyBoYW5kbGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHtUaW1lR3JpZH0gW3RpbWVHcmlkVmlld10gLSBUaW1lR3JpZCB2aWV3IGluc3RhbmNlLlxuICogQHBhcmFtIHtCYXNlfSBbYmFzZUNvbnRyb2xsZXJdIC0gQmFzZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBUaW1lUmVzaXplKGRyYWdIYW5kbGVyLCB0aW1lR3JpZFZpZXcsIGJhc2VDb250cm9sbGVyKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0RyYWd9XG4gICAgICovXG4gICAgdGhpcy5kcmFnSGFuZGxlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VGltZUdyaWR9XG4gICAgICovXG4gICAgdGhpcy50aW1lR3JpZFZpZXcgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Jhc2V9XG4gICAgICovXG4gICAgdGhpcy5iYXNlQ29udHJvbGxlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5fZ2V0RXZlbnREYXRhRnVuYyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuX2RyYWdTdGFydCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VGltZVJlc2l6ZUd1aWRlfVxuICAgICAqL1xuICAgIHRoaXMuX2d1aWRlID0gbmV3IFRpbWVSZXNpemVHdWlkZSh0aGlzKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEZXN0cm95IG1ldGhvZFxuICovXG5UaW1lUmVzaXplLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZ3VpZGUuZGVzdHJveSgpO1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIub2ZmKHRoaXMpO1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSB0aGlzLnRpbWVHcmlkVmlldyA9IHRoaXMuYmFzZUNvbnRyb2xsZXIgPVxuICAgICAgICB0aGlzLl9nZXRFdmVudERhdGFGdW5jID0gdGhpcy5fZHJhZ1N0YXJ0ID0gdGhpcy5fZ3VpZGUgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDb25uZWN0IGhhbmRsZXIsIHZpZXcsIGNvbnRyb2xsZXJzIGZvciBldmVudCBjcmVhdGlvbnMuXG4gKiBAcGFyYW0ge0RyYWd9IFtkcmFnSGFuZGxlcl0gLSBEcmFnIGhhbmRsZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge1RpbWVHcmlkfSBbdGltZUdyaWRWaWV3XSAtIFRpbWVHcmlkIHZpZXcgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0Jhc2V9IFtiYXNlQ29udHJvbGxlcl0gLSBCYXNlIGNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gKi9cblRpbWVSZXNpemUucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihkcmFnSGFuZGxlciwgdGltZUdyaWRWaWV3LCBiYXNlQ29udHJvbGxlcikge1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBkcmFnSGFuZGxlcjtcbiAgICB0aGlzLnRpbWVHcmlkVmlldyA9IHRpbWVHcmlkVmlldztcbiAgICB0aGlzLmJhc2VDb250cm9sbGVyID0gYmFzZUNvbnRyb2xsZXI7XG5cbiAgICBkcmFnSGFuZGxlci5vbih7XG4gICAgICAgIGRyYWdTdGFydDogdGhpcy5fb25EcmFnU3RhcnRcbiAgICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gZWxlbWVudCB0byBjaGVjayBjb25kaXRpb24uXG4gKiBAcmV0dXJucyB7b2JqZWN0fGJvb2xlYW59IC0gcmV0dXJuIHRpbWUgdmlldyBpbnN0YW5jZSBvciBmYWxzZVxuICovXG5UaW1lUmVzaXplLnByb3RvdHlwZS5jaGVja0V4cGVjdENvbmRpdGlvbiA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgIHZhciBjb250YWluZXIsXG4gICAgICAgIG1hdGNoZXM7XG5cbiAgICBpZiAoIWRvbXV0aWwuaGFzQ2xhc3ModGFyZ2V0LCAnc2NoZWR1bGUtdmlldy10aW1lLXJlc2l6ZS1oYW5kbGUnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29udGFpbmVyID0gZG9tdXRpbC5jbG9zZXN0KHRhcmdldCwgJy5zY2hlZHVsZS12aWV3LXRpbWUtZGF0ZScpO1xuXG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG1hdGNoZXMgPSBkb211dGlsLmdldENsYXNzKGNvbnRhaW5lcikubWF0Y2gocGFyc2VUaW1lVmlld0lEUngpO1xuXG4gICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWwucGljayh0aGlzLnRpbWVHcmlkVmlldy5jaGlsZHMuaXRlbXMsICttYXRjaGVzWzFdKTtcbn07XG5cbi8qKlxuICogQGVtaXRzIFRpbWVSZXNpemUjdGltZV9yZXNpemVfZHJhZ3N0YXJ0XG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ1N0YXJ0RXZlbnREYXRhIC0gZXZlbnQgZGF0YSBvZiBEcmFnI2RyYWdzdGFydFxuICovXG5UaW1lUmVzaXplLnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbihkcmFnU3RhcnRFdmVudERhdGEpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZHJhZ1N0YXJ0RXZlbnREYXRhLnRhcmdldCxcbiAgICAgICAgdGltZVZpZXcgPSB0aGlzLmNoZWNrRXhwZWN0Q29uZGl0aW9uKHRhcmdldCksXG4gICAgICAgIGJsb2NrRWxlbWVudCA9IGRvbXV0aWwuY2xvc2VzdCh0YXJnZXQsICcuc2NoZWR1bGUtdmlldy10aW1lLWRhdGUtZXZlbnQtYmxvY2snKSxcbiAgICAgICAgZ2V0RXZlbnREYXRhRnVuYyxcbiAgICAgICAgZXZlbnREYXRhO1xuXG4gICAgaWYgKCF0aW1lVmlldyB8fCAhYmxvY2tFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBnZXRFdmVudERhdGFGdW5jID0gdGhpcy5fZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX3JldHJpdmVFdmVudERhdGEodGltZVZpZXcpO1xuICAgIGV2ZW50RGF0YSA9IHRoaXMuX2RyYWdTdGFydCA9IGdldEV2ZW50RGF0YUZ1bmMoXG4gICAgICAgIGRyYWdTdGFydEV2ZW50RGF0YS5vcmlnaW5FdmVudCwge1xuICAgICAgICAgICAgdGFyZ2V0TW9kZWxJRDogZG9tdXRpbC5nZXREYXRhKGJsb2NrRWxlbWVudCwgJ2lkJylcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9uKHtcbiAgICAgICAgZHJhZzogdGhpcy5fb25EcmFnLFxuICAgICAgICBkcmFnRW5kOiB0aGlzLl9vbkRyYWdFbmQsXG4gICAgICAgIGNsaWNrOiB0aGlzLl9vbkNsaWNrXG4gICAgfSwgdGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgVGltZVJlc2l6ZSN0aW1lX3Jlc2l6ZV9kcmFnc3RhcnRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIGN1cnJlbnQgdGFyZ2V0IGluIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge1RpbWV9IHJlbGF0ZWRWaWV3IC0gdGltZSB2aWV3IGluc3RhbmNlIHJlbGF0ZWQgd2l0aCBtb3VzZSBwb3NpdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge01vdXNlRXZlbnR9IG9yaWdpbkV2ZW50IC0gbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb3VzZVkgLSBtb3VzZSBZIHB4IG1vdXNlIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBncmlkWSAtIGdyaWQgWSBpbmRleCB2YWx1ZSByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lWSAtIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiBtb3VzZVkgcG9pbnRzLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFkgLSBuZWFyZXN0IGdyaWQgaW5kZXggcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRUaW1lWSAtIHRpbWUgdmFsdWUgZm9yIG5lYXJlc3RHcmlkWS5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdGFyZ2V0TW9kZWxJRCAtIFRoZSBtb2RlbCB1bmlxdWUgaWQgZW1pdHRlZCBtb3ZlIGV2ZW50LlxuICAgICAqL1xuICAgIHRoaXMuZmlyZSgndGltZV9yZXNpemVfZHJhZ3N0YXJ0JywgZXZlbnREYXRhKTtcbn07XG5cbi8qKlxuICogRHJhZyNkcmFnIGV2ZW50IGhhbmRsZXJcbiAqIEBlbWl0cyBUaW1lUmVzaXplI3RpbWVfcmVzaXplX2RyYWdcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnRXZlbnREYXRhIC0gZXZlbnQgZGF0YSBvZiBEcmFnI2RyYWcgY3VzdG9tIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IFtvdmVycmlkZUV2ZW50TmFtZV0gLSBvdmVycmlkZSBlbWl0dGVkIGV2ZW50IG5hbWUgd2hlbiBzdXBwbGllZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtyZXZpc2VdIC0gc3VwcGx5IGZ1bmN0aW9uIGZvciByZXZpc2UgZXZlbnQgZGF0YSBiZWZvcmUgZW1pdC5cbiAqL1xuVGltZVJlc2l6ZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uKGRyYWdFdmVudERhdGEsIG92ZXJyaWRlRXZlbnROYW1lLCByZXZpc2UpIHtcbiAgICB2YXIgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX2dldEV2ZW50RGF0YUZ1bmMsXG4gICAgICAgIHN0YXJ0RXZlbnREYXRhID0gdGhpcy5fZHJhZ1N0YXJ0LFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICBpZiAoIWdldEV2ZW50RGF0YUZ1bmMgfHwgIXN0YXJ0RXZlbnREYXRhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudERhdGEgPSBnZXRFdmVudERhdGFGdW5jKGRyYWdFdmVudERhdGEub3JpZ2luRXZlbnQsIHtcbiAgICAgICAgdGFyZ2V0TW9kZWxJRDogc3RhcnRFdmVudERhdGEudGFyZ2V0TW9kZWxJRFxuICAgIH0pO1xuXG4gICAgaWYgKHJldmlzZSkge1xuICAgICAgICByZXZpc2UoZXZlbnREYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgVGltZVJlc2l6ZSN0aW1lX3Jlc2l6ZV9kcmFnXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBjdXJyZW50IHRhcmdldCBpbiBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtUaW1lfSByZWxhdGVkVmlldyAtIHRpbWUgdmlldyBpbnN0YW5jZSByZWxhdGVkIHdpdGggZHJhZyBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge01vdXNlRXZlbnR9IG9yaWdpbkV2ZW50IC0gbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb3VzZVkgLSBtb3VzZSBZIHB4IG1vdXNlIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBncmlkWSAtIGdyaWQgWSBpbmRleCB2YWx1ZSByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lWSAtIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiBtb3VzZVkgcG9pbnRzLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFkgLSBuZWFyZXN0IGdyaWQgaW5kZXggcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRUaW1lWSAtIHRpbWUgdmFsdWUgZm9yIG5lYXJlc3RHcmlkWS5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdGFyZ2V0TW9kZWxJRCAtIFRoZSBtb2RlbCB1bmlxdWUgaWQgZW1pdHRlZCBtb3ZlIGV2ZW50LlxuICAgICAqL1xuICAgIHRoaXMuZmlyZShvdmVycmlkZUV2ZW50TmFtZSB8fCAndGltZV9yZXNpemVfZHJhZycsIGV2ZW50RGF0YSk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBtb2RlbCBpbnN0YW5jZSBieSBkcmFnZW5kIGV2ZW50IHJlc3VsdHMuXG4gKiBAcGFyYW0ge29iamVjdH0gZXZlbnREYXRhIC0gZXZlbnQgZGF0YSBmcm9tIFRpbWVSZXNpemUjdGltZV9yZXNpemVfZHJhZ2VuZFxuICovXG5UaW1lUmVzaXplLnByb3RvdHlwZS5fdXBkYXRlRXZlbnQgPSBmdW5jdGlvbihldmVudERhdGEpIHtcbiAgICB2YXIgY3RybCA9IHRoaXMuYmFzZUNvbnRyb2xsZXIsXG4gICAgICAgIG1vZGVsSUQgPSBldmVudERhdGEudGFyZ2V0TW9kZWxJRCxcbiAgICAgICAgcmFuZ2UgPSBldmVudERhdGEubmVhcmVzdFJhbmdlLFxuICAgICAgICB0aW1lRGlmZiA9IHJhbmdlWzFdIC0gcmFuZ2VbMF0sXG4gICAgICAgIG1vZGVsID0gY3RybC5ldmVudHMuaXRlbXNbbW9kZWxJRF0sXG4gICAgICAgIHJlbGF0ZWRWaWV3ID0gZXZlbnREYXRhLnJlbGF0ZWRWaWV3LFxuICAgICAgICBkYXRlRW5kLFxuICAgICAgICBuZXdFbmRzLFxuICAgICAgICBiYXNlRGF0ZTtcblxuICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRpbWVEaWZmIC09IGRhdGV0aW1lLm1pbGxpc2Vjb25kc0Zyb20oJ21pbnV0ZXMnLCAzMCk7XG5cbiAgICBiYXNlRGF0ZSA9IG5ldyBEYXRlKHJlbGF0ZWRWaWV3LmdldERhdGUoKSk7XG4gICAgZGF0ZUVuZCA9IGRhdGV0aW1lLmVuZChiYXNlRGF0ZSk7XG4gICAgbmV3RW5kcyA9IG5ldyBEYXRlKG1vZGVsLmdldEVuZHMoKS5nZXRUaW1lKCkgKyB0aW1lRGlmZik7XG5cbiAgICBpZiAobmV3RW5kcyA+IGRhdGVFbmQpIHtcbiAgICAgICAgbmV3RW5kcyA9IG5ldyBEYXRlKGRhdGVFbmQuZ2V0VGltZSgpKTtcbiAgICB9XG5cbiAgICBpZiAobmV3RW5kcy5nZXRUaW1lKCkgLSBtb2RlbC5nZXRTdGFydHMoKS5nZXRUaW1lKCkgPCBkYXRldGltZS5taWxsaXNlY29uZHNGcm9tKCdtaW51dGVzJywgMzApKSB7XG4gICAgICAgIG5ld0VuZHMgPSBuZXcgRGF0ZShtb2RlbC5nZXRTdGFydHMoKS5nZXRUaW1lKCkgKyBkYXRldGltZS5taWxsaXNlY29uZHNGcm9tKCdtaW51dGVzJywgMzApKTtcbiAgICB9XG5cbiAgICBjdHJsLnVwZGF0ZUV2ZW50KG1vZGVsSUQsIHtcbiAgICAgICAgZW5kczogbmV3RW5kc1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBEcmFnI2RyYWdFbmQgZXZlbnQgaGFuZGxlclxuICogQGVtaXRzIFRpbWVSZXNpemUjdGltZV9yZXNpemVfZHJhZ2VuZFxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBkcmFnRW5kRXZlbnREYXRhIC0gTW91c2UgZXZlbnQgb2YgRHJhZyNkcmFnRW5kIGN1c3RvbSBldmVudC5cbiAqL1xuVGltZVJlc2l6ZS5wcm90b3R5cGUuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uKGRyYWdFbmRFdmVudERhdGEpIHtcbiAgICB2YXIgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX2dldEV2ZW50RGF0YUZ1bmMsXG4gICAgICAgIGRyYWdTdGFydCA9IHRoaXMuX2RyYWdTdGFydCxcbiAgICAgICAgZXZlbnREYXRhO1xuXG4gICAgdGhpcy5kcmFnSGFuZGxlci5vZmYoe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIGlmICghZ2V0RXZlbnREYXRhRnVuYyB8fCAhZHJhZ1N0YXJ0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudERhdGEgPSBnZXRFdmVudERhdGFGdW5jKGRyYWdFbmRFdmVudERhdGEub3JpZ2luRXZlbnQsIHtcbiAgICAgICAgdGFyZ2V0TW9kZWxJRDogZHJhZ1N0YXJ0LnRhcmdldE1vZGVsSURcbiAgICB9KTtcblxuICAgIGV2ZW50RGF0YS5yYW5nZSA9IFtcbiAgICAgICAgZHJhZ1N0YXJ0LnRpbWVZLFxuICAgICAgICBldmVudERhdGEudGltZVkgKyBkYXRldGltZS5taWxsaXNlY29uZHNGcm9tKCdob3VyJywgMC41KVxuICAgIF07XG5cbiAgICBldmVudERhdGEubmVhcmVzdFJhbmdlID0gW1xuICAgICAgICBkcmFnU3RhcnQubmVhcmVzdEdyaWRUaW1lWSxcbiAgICAgICAgZXZlbnREYXRhLm5lYXJlc3RHcmlkVGltZVkgKyBkYXRldGltZS5taWxsaXNlY29uZHNGcm9tKCdob3VyJywgMC41KVxuICAgIF07XG5cbiAgICB0aGlzLl91cGRhdGVFdmVudChldmVudERhdGEpO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFRpbWVSZXNpemUjdGltZV9yZXNpemVfZHJhZ2VuZFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gY3VycmVudCB0YXJnZXQgaW4gbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqIEBwcm9wZXJ0eSB7VGltZX0gcmVsYXRlZFZpZXcgLSB0aW1lIHZpZXcgaW5zdGFuY2UgcmVsYXRlZCB3aXRoIGRyYWcgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBvcmlnaW5FdmVudCAtIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW91c2VZIC0gbW91c2UgWSBweCBtb3VzZSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZ3JpZFkgLSBncmlkIFkgaW5kZXggdmFsdWUgcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZVkgLSBtaWxsaXNlY29uZHMgdmFsdWUgb2YgbW91c2VZIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRZIC0gbmVhcmVzdCBncmlkIGluZGV4IHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkVGltZVkgLSB0aW1lIHZhbHVlIGZvciBuZWFyZXN0R3JpZFkuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHRhcmdldE1vZGVsSUQgLSBUaGUgbW9kZWwgdW5pcXVlIGlkIGVtaXR0ZWQgbW92ZSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcltdfSByYW5nZSAtIG1pbGxpc2Vjb25kcyByYW5nZSBiZXR3ZWVuIGRyYWcgc3RhcnQgYW5kIGVuZC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcltdfSBuZWFyZXN0UmFuZ2UgLSBtaWxsaXNlY29uZHMgcmFuZ2UgcmVsYXRlZCB3aXRoIG5lYXJlc3RHcmlkWSBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQuXG4gICAgICovXG4gICAgdGhpcy5maXJlKCd0aW1lX3Jlc2l6ZV9kcmFnZW5kJywgZXZlbnREYXRhKTtcblxuICAgIHRoaXMuX2dldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9kcmFnU3RhcnQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAZW1pdHMgVGltZVJlc2l6ZSN0aW1lX3Jlc2l6ZV9jbGlja1xuICovXG5UaW1lUmVzaXplLnByb3RvdHlwZS5fb25DbGljayA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIub2ZmKHtcbiAgICAgICAgZHJhZzogdGhpcy5fb25EcmFnLFxuICAgICAgICBkcmFnRW5kOiB0aGlzLl9vbkRyYWdFbmQsXG4gICAgICAgIGNsaWNrOiB0aGlzLl9vbkNsaWNrXG4gICAgfSwgdGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgVGltZVJlc2l6ZSN0aW1lX3Jlc2l6ZV9jbGlja1xuICAgICAqL1xuICAgIHRoaXMuZmlyZSgndGltZV9yZXNpemVfY2xpY2snKTtcbn07XG5cbnRpbWVDb3JlLm1peGluKFRpbWVSZXNpemUpO1xudXRpbC5DdXN0b21FdmVudHMubWl4aW4oVGltZVJlc2l6ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZVJlc2l6ZTtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1vZHVsZSBmb3IgVGltZS5SZXNpemUgZWZmZWN0IHdoaWxlIGRyYWdnaW5nLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgcmVxQW5pbUZyYW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL3JlcUFuaW1GcmFtZScpO1xuXG52YXIgcmF0aW8gPSByZXF1aXJlKCcuLi8uLi9jb21tb24vY29tbW9uJykucmF0aW87XG5cbi8qKlxuICogQ2xhc3MgZm9yIFRpbWUuUmVzaXplIGVmZmVjdC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtUaW1lUmVzaXplfSB0aW1lUmVzaXplIC0gdGhlIGluc3RhbmNlIG9mIFRpbWVSZXNpemUgaGFuZGxlci5cbiAqL1xuZnVuY3Rpb24gVGltZVJlc2l6ZUd1aWRlKHRpbWVSZXNpemUpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5ndWlkZUVsZW1lbnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1RpbWVSZXNpemV9XG4gICAgICovXG4gICAgdGhpcy50aW1lUmVzaXplID0gdGltZVJlc2l6ZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLl9nZXRUb3BGdW5jID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLl9vcmlnaW5FdmVudEVsZW1lbnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9zdGFydFRvcFBpeGVsID0gMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fc3RhcnRIZWlnaHRQaXhlbCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX3N0YXJ0R3JpZFkgPSAwO1xuXG4gICAgdGltZVJlc2l6ZS5vbih7XG4gICAgICAgICd0aW1lX3Jlc2l6ZV9kcmFnc3RhcnQnOiB0aGlzLl9vbkRyYWdTdGFydCxcbiAgICAgICAgJ3RpbWVfcmVzaXplX2RyYWcnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgICd0aW1lX3Jlc2l6ZV9kcmFnZW5kJzogdGhpcy5fY2xlYXJHdWlkZUVsZW1lbnQsXG4gICAgICAgICd0aW1lX3Jlc2l6ZV9jbGljayc6IHRoaXMuX2NsZWFyR3VpZGVFbGVtZW50XG4gICAgfSwgdGhpcyk7XG59XG5cbi8qKlxuICogRGVzdHJveSBtZXRob2RcbiAqL1xuVGltZVJlc2l6ZUd1aWRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2xlYXJHdWlkZUVsZW1lbnQoKTtcbiAgICB0aGlzLnRpbWVSZXNpemUub2ZmKHRoaXMpO1xuICAgIHRoaXMuZ3VpZGVFbGVtZW50ID0gdGhpcy50aW1lUmVzaXplID0gdGhpcy5fZ2V0VG9wRnVuYyA9XG4gICAgICAgIHRoaXMuX29yaWdpbkV2ZW50RWxlbWVudCA9IHRoaXMuX3N0YXJ0SGVpZ2h0UGl4ZWwgPVxuICAgICAgICB0aGlzLl9zdGFydEdyaWRZID0gdGhpcy5fc3RhcnRUb3BQaXhlbCA9IG51bGw7XG59O1xuXG4vKipcbiAqIENsZWFyIGd1aWRlIGVsZW1lbnQuXG4gKi9cblRpbWVSZXNpemVHdWlkZS5wcm90b3R5cGUuX2NsZWFyR3VpZGVFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGd1aWRlRWxlbWVudCA9IHRoaXMuZ3VpZGVFbGVtZW50LFxuICAgICAgICBvcmlnaW5FbGVtZW50ID0gdGhpcy5fb3JpZ2luRXZlbnRFbGVtZW50O1xuXG4gICAgaWYgKCF1dGlsLmJyb3dzZXIubXNpZSkge1xuICAgICAgICBkb211dGlsLnJlbW92ZUNsYXNzKGdsb2JhbC5kb2N1bWVudC5ib2R5LCAnc2NoZWR1bGUtdmlldy1yZXNpemluZycpO1xuICAgIH1cblxuICAgIGlmIChvcmlnaW5FbGVtZW50KSB7XG4gICAgICAgIG9yaWdpbkVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfVxuXG4gICAgZG9tdXRpbC5yZW1vdmUoZ3VpZGVFbGVtZW50KTtcblxuICAgIHRoaXMuZ3VpZGVFbGVtZW50ID0gdGhpcy5fZ2V0VG9wRnVuYyA9IHRoaXMuX29yaWdpbkV2ZW50RWxlbWVudCA9XG4gICAgICAgIHRoaXMuX3N0YXJ0SGVpZ2h0UGl4ZWwgPSB0aGlzLl9zdGFydEdyaWRZID0gdGhpcy5fc3RhcnRUb3BQaXhlbCA9IG51bGw7XG59O1xuXG4vKipcbiAqIFJlZnJlc2ggZ3VpZGUgZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGhlaWdodCAtIGd1aWRlIGVsZW1lbnQncyBzdHlsZSBoZWlnaHQuXG4gKi9cblRpbWVSZXNpemVHdWlkZS5wcm90b3R5cGUuX3JlZnJlc2hHdWlkZUVsZW1lbnQgPSBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICB2YXIgZ3VpZGVFbGVtZW50ID0gdGhpcy5ndWlkZUVsZW1lbnQ7XG5cbiAgICBpZiAoIWd1aWRlRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVxQW5pbUZyYW1lLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgIGd1aWRlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICBndWlkZUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfSk7XG59O1xuXG5cbi8qKlxuICogVGltZU1vdmUjdGltZV9tb3ZlX2RyYWdzdGFydCBldmVudCBoYW5kbGVyXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ1N0YXJ0RXZlbnREYXRhIC0gZHJhZ3N0YXJ0IGV2ZW50IGRhdGFcbiAqL1xuVGltZVJlc2l6ZUd1aWRlLnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbihkcmFnU3RhcnRFdmVudERhdGEpIHtcbiAgICB2YXIgb3JpZ2luRWxlbWVudCA9IGRvbXV0aWwuY2xvc2VzdChcbiAgICAgICAgICAgIGRyYWdTdGFydEV2ZW50RGF0YS50YXJnZXQsXG4gICAgICAgICAgICAnLnNjaGVkdWxlLXZpZXctdGltZS1kYXRlLWV2ZW50LWJsb2NrJ1xuICAgICAgICApLFxuICAgICAgICBndWlkZUVsZW1lbnQ7XG5cbiAgICBpZiAoIXV0aWwuYnJvd3Nlci5tc2llKSB7XG4gICAgICAgIGRvbXV0aWwuYWRkQ2xhc3MoZ2xvYmFsLmRvY3VtZW50LmJvZHksICdzY2hlZHVsZS12aWV3LXJlc2l6aW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKCFvcmlnaW5FbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGFydEdyaWRZID0gZHJhZ1N0YXJ0RXZlbnREYXRhLm5lYXJlc3RHcmlkWTtcbiAgICB0aGlzLl9zdGFydEhlaWdodFBpeGVsID0gcGFyc2VGbG9hdChvcmlnaW5FbGVtZW50LnN0eWxlLmhlaWdodCk7XG4gICAgdGhpcy5fc3RhcnRUb3BQaXhlbCA9IHBhcnNlRmxvYXQob3JpZ2luRWxlbWVudC5zdHlsZS50b3ApO1xuXG4gICAgdGhpcy5fb3JpZ2luRXZlbnRFbGVtZW50ID0gb3JpZ2luRWxlbWVudDtcbiAgICBndWlkZUVsZW1lbnQgPSB0aGlzLmd1aWRlRWxlbWVudCA9IG9yaWdpbkVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xuICAgIGRvbXV0aWwuYWRkQ2xhc3MoZ3VpZGVFbGVtZW50LCAnc2NoZWR1bGUtdmlldy10aW1lLXJlc2l6ZS1ndWlkZScpO1xuXG4gICAgb3JpZ2luRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGRyYWdTdGFydEV2ZW50RGF0YS5yZWxhdGVkVmlldy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZ3VpZGVFbGVtZW50KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRyYWdFdmVudERhdGEgLSBldmVudCBkYXRhIGZyb20gRHJhZyNkcmFnLlxuICovXG5UaW1lUmVzaXplR3VpZGUucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbihkcmFnRXZlbnREYXRhKSB7XG4gICAgdmFyIHRpbWVWaWV3ID0gZHJhZ0V2ZW50RGF0YS5yZWxhdGVkVmlldyxcbiAgICAgICAgdmlld09wdGlvbnMgPSB0aW1lVmlldy5vcHRpb25zLFxuICAgICAgICB2aWV3SGVpZ2h0ID0gdGltZVZpZXcuZ2V0Vmlld0JvdW5kKCkuaGVpZ2h0LFxuICAgICAgICBob3VyTGVuZ3RoID0gdmlld09wdGlvbnMuaG91ckVuZCAtIHZpZXdPcHRpb25zLmhvdXJTdGFydCxcbiAgICAgICAgZ3VpZGVFbGVtZW50ID0gdGhpcy5ndWlkZUVsZW1lbnQsXG4gICAgICAgIGd1aWRlVG9wID0gcGFyc2VGbG9hdChndWlkZUVsZW1lbnQuc3R5bGUudG9wKSxcbiAgICAgICAgZ3JpZFlPZmZzZXQgPSBkcmFnRXZlbnREYXRhLm5lYXJlc3RHcmlkWSAtIHRoaXMuX3N0YXJ0R3JpZFksXG4gICAgICAgIC8vIGhvdXJMZW5ndGggOiB2aWV3SGVpZ2h0ID0gZ3JpZFlPZmZzZXQgOiBYO1xuICAgICAgICBncmlkWU9mZnNldFBpeGVsID0gcmF0aW8oaG91ckxlbmd0aCwgdmlld0hlaWdodCwgZ3JpZFlPZmZzZXQpLFxuICAgICAgICBtaW5IZWlnaHQsXG4gICAgICAgIG1heEhlaWdodCxcbiAgICAgICAgaGVpZ2h0O1xuXG4gICAgaGVpZ2h0ID0gKHRoaXMuX3N0YXJ0SGVpZ2h0UGl4ZWwgKyBncmlkWU9mZnNldFBpeGVsKTtcbiAgICAvLyBhdCBsZWFzdCBsYXJnZSB0aGFuIDMwbWluIGZyb20gZXZlbnQgc3RhcnQgdGltZS5cbiAgICBtaW5IZWlnaHQgPSBndWlkZVRvcCArIHJhdGlvKGhvdXJMZW5ndGgsIHZpZXdIZWlnaHQsIDAuNSk7XG4gICAgbWluSGVpZ2h0IC09IHRoaXMuX3N0YXJ0VG9wUGl4ZWw7XG4gICAgLy8gc21hbGxlciB0aGFuIDI0aFxuICAgIG1heEhlaWdodCA9IHZpZXdIZWlnaHQgLSBndWlkZVRvcDtcblxuICAgIGhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgbWluSGVpZ2h0KTtcbiAgICBoZWlnaHQgPSBNYXRoLm1pbihoZWlnaHQsIG1heEhlaWdodCk7XG5cbiAgICB0aGlzLl9yZWZyZXNoR3VpZGVFbGVtZW50KGhlaWdodCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVSZXNpemVHdWlkZTtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1vZGVsIG9mIGV2ZW50LlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBkYXRldGltZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9kYXRldGltZScpO1xudmFyIGRpcnR5ID0gcmVxdWlyZSgnLi4vY29tbW9uL2RpcnR5Jyk7XG52YXIgbW9kZWwgPSByZXF1aXJlKCcuLi9jb21tb24vbW9kZWwnKTtcblxuLyoqXG4gKiBUaGUgbW9kZWwgb2YgY2FsZW5kYXIgZXZlbnRzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAbWl4ZXMgZGlydHlcbiAqIEBtaXhlcyBtb2RlbFxuICovXG5mdW5jdGlvbiBFdmVudCgpIHtcbiAgICAvKipcbiAgICAgKiB0aXRsZSBmb3IgZXZlbnQuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnRpdGxlID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBpcyBldmVudCBpcyBhbGwgZGF5IGV2ZW50P1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNBbGxEYXkgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIGV2ZW50IHN0YXJ0c1xuICAgICAqIEB0eXBlIHtEYXRlfVxuICAgICAqL1xuICAgIHRoaXMuc3RhcnRzID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIGV2ZW50IGVuZHNcbiAgICAgKiBAdHlwZSB7RGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmVuZHMgPSBudWxsO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBtb2RlbCBpZFxuICAgIHV0aWwuc3RhbXAodGhpcyk7XG59XG5cbi8qKioqKioqKioqXG4gKiBzdGF0aWMgcHJvcHNcbiAqKioqKioqKioqL1xuXG5FdmVudC5zY2hlbWEgPSB7XG4gICAgcmVxdWlyZWQ6IFsndGl0bGUnXSxcbiAgICBkYXRlUmFuZ2U6IFsnc3RhcnRzJywgJ2VuZHMnXVxufTtcblxuLyoqXG4gKiBjcmVhdGUgZXZlbnQgbW9kZWwgZnJvbSBqc29uKG9iamVjdCkgZGF0YS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIG9iamVjdCBmb3IgbW9kZWwuXG4gKiBAcmV0dXJucyB7RXZlbnR9IEV2ZW50IG1vZGVsIGluc3RhbmNlLlxuICovXG5FdmVudC5jcmVhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIGluc3QgPSBuZXcgRXZlbnQoKTtcbiAgICBpbnN0LmluaXQoZGF0YSk7XG5cbiAgICByZXR1cm4gaW5zdDtcbn07XG5cbi8qKioqKioqKioqXG4gKiBwcm90b3R5cGUgcHJvcHNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIEluaXRpYWxpemUgZXZlbnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBvcHRpb25zLlxuICovXG5FdmVudC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMudGl0bGUgPSBvcHRpb25zLnRpdGxlIHx8ICcnO1xuICAgIHRoaXMuaXNBbGxEYXkgPSB1dGlsLmlzRXhpc3R5KG9wdGlvbnMuaXNBbGxEYXkpID8gb3B0aW9ucy5pc0FsbERheSA6IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnRzKSB7XG4gICAgICAgIHRoaXMuc3RhcnRzID0gbmV3IERhdGUob3B0aW9ucy5zdGFydHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnRzID0gbmV3IERhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5lbmRzKSB7XG4gICAgICAgIHRoaXMuZW5kcyA9IG5ldyBEYXRlKG9wdGlvbnMuZW5kcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbmRzID0gbmV3IERhdGUodGhpcy5zdGFydHMuZ2V0VGltZSgpKTtcbiAgICAgICAgdGhpcy5lbmRzLnNldE1pbnV0ZXModGhpcy5lbmRzLmdldE1pbnV0ZXMoKSArIDMwKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtEYXRlfSByZW5kZXIgc3RhcnQgZGF0ZS5cbiAqL1xuRXZlbnQucHJvdG90eXBlLmdldFN0YXJ0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0cztcbn07XG5cbi8qKlxuICogQHJldHVybnMge0RhdGV9IHJlbmRlciBlbmQgZGF0ZS5cbiAqL1xuRXZlbnQucHJvdG90eXBlLmdldEVuZHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lbmRzO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBpbnN0YW5jZSB1bmlxdWUgaWQuXG4gKi9cbkV2ZW50LnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB1dGlsLnN0YW1wKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDaGVjayB0d28gZXZlbnQgYXJlIGVxdWFscyAobWVhbnMgdGl0bGUsIGlzQWxsRGF5LCBzdGFydHMsIGVuZHMgYXJlIHNhbWUpXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBFdmVudCBtb2RlbCBpbnN0YW5jZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybiBmYWxzZSB3aGVuIG5vdCBzYW1lLlxuICovXG5FdmVudC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy50aXRsZSAhPT0gZXZlbnQudGl0bGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzQWxsRGF5ICE9PSBldmVudC5pc0FsbERheSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGRhdGV0aW1lLmNvbXBhcmUodGhpcy5nZXRTdGFydHMoKSwgZXZlbnQuZ2V0U3RhcnRzKCkpICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0ZXRpbWUuY29tcGFyZSh0aGlzLmdldEVuZHMoKSwgZXZlbnQuZ2V0RW5kcygpKSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIHJldHVybiBkdXJhdGlvbiBiZXR3ZWVuIHN0YXJ0cyBhbmQgZW5kcy5cbiAqIEByZXR1cm5zIHtEYXRlfSBkdXJhdGlvbiAoVVRDKVxuICovXG5FdmVudC5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhcnRzID0gdGhpcy5nZXRTdGFydHMoKSxcbiAgICAgICAgZW5kcyA9IHRoaXMuZ2V0RW5kcygpLFxuICAgICAgICBkdXJhdGlvbjtcblxuICAgIGlmICh0aGlzLmlzQWxsRGF5KSB7XG4gICAgICAgIGR1cmF0aW9uID0gbmV3IERhdGUoZGF0ZXRpbWUuZW5kKGVuZHMpIC0gZGF0ZXRpbWUuc3RhcnQoc3RhcnRzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZHVyYXRpb24gPSBuZXcgRGF0ZShlbmRzIC0gc3RhcnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZHVyYXRpb247XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gRXZlbnQgY29pbmNpZGVzIHdpdGggdGhlIHNhbWUgdGltZSBhcyB0aGVcbiAqIGNhbGxpbmcgRXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgb3RoZXIgZXZlbnQgdG8gY29tcGFyZSB3aXRoIHRoaXMgRXZlbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgdGhlIG90aGVyIGV2ZW50IG9jY3VycyB3aXRoaW4gdGhlIHNhbWUgdGltZSBhcyB0aGUgZmlyc3Qgb2JqZWN0LlxuICovXG5FdmVudC5wcm90b3R5cGUuY29sbGlkZXNXaXRoID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgb3duU3RhcnRzID0gdGhpcy5nZXRTdGFydHMoKSxcbiAgICAgICAgb3duRW5kcyA9IHRoaXMuZ2V0RW5kcygpLFxuICAgICAgICBzdGFydHMgPSBldmVudC5nZXRTdGFydHMoKSxcbiAgICAgICAgZW5kcyA9IGV2ZW50LmdldEVuZHMoKTtcblxuICAgIGlmICgoc3RhcnRzID4gb3duU3RhcnRzICYmIHN0YXJ0cyA8IG93bkVuZHMpIHx8XG4gICAgICAgIChlbmRzID4gb3duU3RhcnRzICYmIGVuZHMgPCBvd25FbmRzKSB8fFxuICAgICAgICAoc3RhcnRzIDw9IG93blN0YXJ0cyAmJiBlbmRzID49IG93bkVuZHMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5tb2RlbC5taXhpbihFdmVudC5wcm90b3R5cGUpO1xuZGlydHkubWl4aW4oRXZlbnQucHJvdG90eXBlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudDtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1vZGVsIGZvciB2aWV3c1xuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcblxuLyoqXG4gKiBFdmVudCBWaWV3TW9kZWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgRXZlbnQgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIEV2ZW50Vmlld01vZGVsKGV2ZW50KSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGVsIG9mIGV2ZW50LlxuICAgICAqIEB0eXBlIHtFdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLm1vZGVsID0gZXZlbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudG9wID0gMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZWZ0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudCBldmVudCBoYXMgY29sbGlkZSB3aXRoIG90aGVyIGV2ZW50cyB3aGVuIHJlbmRlcmluZy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmhhc0NvbGxpZGUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEV4dHJhIHNwYWNlIGF0IHJpZ3RoIHNpZGUgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZXh0cmFTcGFjZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiByZXByZXNlbnQgdGhpcyBldmVudCBibG9jayBpcyBub3QgdmlzaWJsZSBhZnRlciByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIGluIG1vbnRoIHZpZXcsIHNvbWUgdmlld21vZGVsIGluIGRhdGUgbmVlZCB0byBoaWRlIHdoZW4gYWxyZWFkeSByZW5kZXJlZCBiZWZvcmUgZGF0ZXMuXG4gICAgICpcbiAgICAgKiBzZXQgdHJ1ZSB0aGVuIGl0IGp1c3Qgc2hvd3MgZW1wdHkgc3BhY2UuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIHJlcHJlc2VudCByZW5kZXIgc3RhcnQgZGF0ZSB1c2VkIGF0IHJlbmRlcmluZy5cbiAgICAgKlxuICAgICAqIGlmIHNldCBudWxsIHRoZW4gdXNlIG1vZGVsJ3MgJ3N0YXJ0cycgcHJvcGVydHkuXG4gICAgICogQHR5cGUge0RhdGV9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJTdGFydHMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogcmVwcmVzZW50IHJlbmRlciBlbmQgZGF0ZSB1c2VkIGF0IHJlbmRlcmluZy5cbiAgICAgKlxuICAgICAqIGlmIHNldCBudWxsIHRoZW4gdXNlIG1vZGVsJ3MgJ2VuZHMnIHByb3BlcnR5LlxuICAgICAqIEB0eXBlIHtEYXRlfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyRW5kcyA9IG51bGw7XG59XG5cbi8qKioqKioqKioqXG4gKiBzdGF0aWMgcHJvcHNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIEV2ZW50Vmlld01vZGVsIGZhY3RvcnkgbWV0aG9kLlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgRXZlbnQgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7RXZlbnRWaWV3TW9kZWx9IEV2ZW50Vmlld01vZGVsIGluc3RhbmNlLlxuICovXG5FdmVudFZpZXdNb2RlbC5jcmVhdGUgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiBuZXcgRXZlbnRWaWV3TW9kZWwoZXZlbnQpO1xufTtcblxuXG4vKioqKioqKioqKlxuICogcHJvdG90eXBlIHByb3BzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiByZXR1cm4gcmVuZGVyU3RhcnRzIHByb3BlcnR5IHRvIHJlbmRlciBwcm9wZXJseSB3aGVuIHNwZWNpZmljIGV2ZW50IHRoYXQgZXhjZWVkIHJlbmRlcmluZyBkYXRlIHJhbmdlLlxuICpcbiAqIGlmIHJlbmRlclN0YXJ0cyBpcyBub3Qgc2V0LiByZXR1cm4gbW9kZWwncyBzdGFydHMgcHJvcGVydHkuXG4gKiBAb3ZlcnJpZGVcbiAqIEByZXR1cm5zIHtEYXRlfSByZW5kZXIgc3RhcnQgZGF0ZS5cbiAqL1xuRXZlbnRWaWV3TW9kZWwucHJvdG90eXBlLmdldFN0YXJ0cyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnJlbmRlclN0YXJ0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJTdGFydHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubW9kZWwuc3RhcnRzO1xufTtcblxuLyoqXG4gKiByZXR1cm4gcmVuZGVyU3RhcnRzIHByb3BlcnR5IHRvIHJlbmRlciBwcm9wZXJseSB3aGVuIHNwZWNpZmljIGV2ZW50IHRoYXQgZXhjZWVkIHJlbmRlcmluZyBkYXRlIHJhbmdlLlxuICpcbiAqIGlmIHJlbmRlckVuZHMgaXMgbm90IHNldC4gcmV0dXJuIG1vZGVsJ3MgZW5kcyBwcm9wZXJ0eS5cbiAqIEBvdmVycmlkZVxuICogQHJldHVybnMge0RhdGV9IHJlbmRlciBlbmQgZGF0ZS5cbiAqL1xuRXZlbnRWaWV3TW9kZWwucHJvdG90eXBlLmdldEVuZHMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJFbmRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckVuZHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubW9kZWwuZW5kcztcbn07XG5cbi8qKlxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlIG51bWJlciBmb3IgbW9kZWwuXG4gKi9cbkV2ZW50Vmlld01vZGVsLnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB1dGlsLnN0YW1wKHRoaXMubW9kZWwpO1xufTtcblxuLyoqXG4gKiBTaGFkb3dpbmcgdmFsdWVPZiBtZXRob2QgZm9yIGV2ZW50IHNvcnRpbmcuXG4gKiBAcmV0dXJucyB7RXZlbnR9IFRoZSBtb2RlbCBvZiBldmVudC5cbiAqL1xuRXZlbnRWaWV3TW9kZWwucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbDtcbn07XG5cbi8qKlxuICogTGluayBkdXJhdGlvbiBtZXRob2RcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEV2ZW50I2R1cmF0aW9uIHJlc3VsdC5cbiAqL1xuRXZlbnRWaWV3TW9kZWwucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZWwuZHVyYXRpb24oKTtcbn07XG5cbi8qKlxuICogTGluayBjb2xsaWRlc1dpdGggbWV0aG9kXG4gKiBAcGFyYW0ge0V2ZW50fEV2ZW50Vmlld01vZGVsfSB2aWV3TW9kZWwgLSBNb2RlbCBvciB2aWV3bW9kZWwgaW5zdGFuY2Ugb2YgRXZlbnRzLlxuICogQHJldHVybnMge2Jvb2xlYW59IEV2ZW50I2NvbGxpZGVzV2l0aCByZXN1bHQuXG4gKi9cbkV2ZW50Vmlld01vZGVsLnByb3RvdHlwZS5jb2xsaWRlc1dpdGggPSBmdW5jdGlvbih2aWV3TW9kZWwpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbC5jb2xsaWRlc1dpdGgodmlld01vZGVsLnZhbHVlT2YoKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50Vmlld01vZGVsO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTGF5b3V0IHZpZXcuIHdyYXAgYWxsIHZpZXcgY29udGFpbmVycyBhdCBvdXRzaWRlLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2NvbGxlY3Rpb24nKTtcbnZhciBWaWV3ID0gcmVxdWlyZSgnLi92aWV3Jyk7XG5cbi8qKlxuICogTGF5b3V0IHZpZXcgZm9yIHRvZ2dsZSBlYWNoIGNoaWxkIHZpZXcuIEl0IHdpbGwgY29udHJvbGxlZCB2aWEgbmF2aWdhdGlvbiBVSS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge1ZpZXd9XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgQ29udGFpbmVyIGVsZW1lbnQgdG8gdXNlIGxheW91dCB2aWV3LlxuICovXG5mdW5jdGlvbiBMYXlvdXQoY29udGFpbmVyKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSovXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb259IENoaWxkIHZpZXcgY29sbGVjdGlvbi5cbiAgICAgKi9cbiAgICB0aGlzLmNoaWxkcyA9IG5ldyBDb2xsZWN0aW9uKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICByZXR1cm4gY2hpbGRWaWV3LnZpZXdOYW1lO1xuICAgIH0pO1xuICAgIC8qZXNsaW50LWVuYWJsZSovXG5cbiAgICBkb211dGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ3NjaGVkdWxlLXZpZXctbGF5b3V0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG59XG5cbnV0aWwuaW5oZXJpdChMYXlvdXQsIFZpZXcpO1xuXG4vKipcbiAqIENsZWFyIGNoaWxkIHZpZXdzLlxuICovXG5MYXlvdXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jaGlsZHMuZWFjaChmdW5jdGlvbihjaGlsZFZpZXcpIHtcbiAgICAgICAgY2hpbGRWaWV3LmRlc3Ryb3koKTtcbiAgICB9KTtcblxuICAgIHRoaXMuY2hpbGRzLmNsZWFyKCk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiB2aWV3IG9iamVjdCBieSBjcmVhdGlvbiBmdW5jdGlvbiAqKihhZGRlckZ1bmMpKiouXG4gKlxuICogSW52b2NhdGlvbnMgb2YgYWRkZXJGdW5jIGlzIGNhbGxlZCB3aXRoIGxheW91dCB2aWV3J3MgY29udGFpbmVyLlxuICpcbiAqIEFzIHJlc3VsdCBvZiBhZGRlckZ1bmMuIGFkZGVkIGl0IHRvIGxheW91dCB2aWV3J3MgY2hpbGRzLlxuICogQG92ZXJyaWRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBhZGRlckZ1bmMgVGhlIGFkZGVyIGZ1bmN0aW9uLlxuICogQHJldHVybnMge1ZpZXd9IFZpZXcgaW5zdGFuY2UgYWRkZWQuXG4gKi9cbkxheW91dC5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbihhZGRlckZ1bmMpIHtcbiAgICB2YXIgY2hpbGRWaWV3ID0gYWRkZXJGdW5jKHRoaXMuY29udGFpbmVyKTtcbiAgICB0aGlzLmNoaWxkcy5hZGQoY2hpbGRWaWV3KTtcbiAgICByZXR1cm4gY2hpbGRWaWV3O1xufTtcblxuLyoqXG4gKiBSZW1vdmUgY2hpbGQgdmlldy5cbiAqIEBvdmVycmlkZVxuICogQHBhcmFtIHsoc3RyaW5nfFZpZXcpfSB2aWV3TmFtZSAtIG5hbWUgb2YgdmlldyBvciBpbnN0YW5jZS5cbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uKHZpZXdOYW1lKSB7XG4gICAgdGhpcy5jaGlsZHMucmVtb3ZlKHZpZXdOYW1lKTtcbn07XG5cbi8qKlxuICogVG9nZ2xlIGNoaWxkIHZpZXdzLlxuICogQHBhcmFtIHtzdHJpbmd9IHZpZXdOYW1lIC0gTmFtZSBvZiB2aWV3LlxuICovXG5MYXlvdXQucHJvdG90eXBlLnRvZ2dsZUNoaWxkVmlldyA9IGZ1bmN0aW9uKHZpZXdOYW1lKSB7XG4gICAgdmFyIGNvbnRhaW5lcixcbiAgICAgICAgcHJlZml4ID0gWydhZGQnLCAncmVtb3ZlJ10sXG4gICAgICAgIGZsYWc7XG5cbiAgICB0aGlzLmNoaWxkcy5lYWNoKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICBjb250YWluZXIgPSBjaGlsZFZpZXcuY29udGFpbmVyO1xuICAgICAgICBmbGFnID0gKyhjaGlsZFZpZXcudmlld05hbWUgPT09IHZpZXdOYW1lKTtcbiAgICAgICAgZG9tdXRpbFtwcmVmaXhbZmxhZ10gKyAnQ2xhc3MnXShjb250YWluZXIsICdzY2hlZHVsZS12aWV3LWhpZGRlbicpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMYXlvdXQ7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBWaWV3IG9mIHdlZWsgZXZlbnQgY29udGFpbmVyIGluc2lkZSBvZiBXZWVrIHZpZXcuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgVmlldyA9IHJlcXVpcmUoJy4vdmlldycpO1xudmFyIHRtcGwgPSByZXF1aXJlKCcuL3RlbXBsYXRlL21vbnRod2Vlay5oYnMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtWaWV3fVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSB2aWV3IG9wdGlvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29udGFpbmVySGVpZ2h0PTQwXSAtIG1pbmltdW0gaGVpZ2h0IG9mIGV2ZW50IGNvbnRhaW5lciBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbnRhaW5lckJ1dHRvbkd1dHRlcj04XSAtIGZyZWUgc3BhY2UgYXQgYm90dG9tIHRvIG1ha2UgY3JlYXRlIGVhc3kuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZXZlbnRIZWlnaHQ9MThdIC0gaGVpZ2h0IG9mIGVhY2ggZXZlbnQgYmxvY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZXZlbnRHdXR0ZXI9Ml0gLSBndXR0ZXIgaGVpZ2h0IG9mIGVhY2ggZXZlbnQgYmxvY2suXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5fZ2V0Vmlld01vZGVsRnVuY10gLSBmdW5jdGlvbiBmb3IgZXh0cmFjdCBwYXJ0aWFsIHZpZXcgbW9kZWwgZGF0YSBmcm9tIHdob2xlIHZpZXcgbW9kZWxzLlxuICogQHBhcmFtIHtIVE1MRElWRWxlbWVudH0gY29udGFpbmVyIC0gRE9NIGVsZW1lbnQgdG8gdXNlIGNvbnRhaW5lciBmb3IgdGhpcyB2aWV3LlxuICovXG5mdW5jdGlvbiBNb250aFdlZWsob3B0aW9ucywgY29udGFpbmVyKSB7XG4gICAgY29udGFpbmVyID0gZG9tdXRpbC5hcHBlbmRIVE1MRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgJ3NjaGVkdWxlLXZpZXctYWxsZGF5LW1vbnRod2VlaydcbiAgICApO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICBjb250YWluZXJIZWlnaHQ6IDQwLFxuICAgICAgICBjb250YWluZXJCb3R0b21HdXR0ZXI6IDgsXG4gICAgICAgIGV2ZW50SGVpZ2h0OiAxOCxcbiAgICAgICAgZXZlbnRHdXR0ZXI6IDJcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIG9wdGlvbnMubWluSGVpZ2h0ID0gb3B0aW9ucy5jb250YWluZXJIZWlnaHQgKyBvcHRpb25zLmNvbnRhaW5lckJvdHRvbUd1dHRlcjtcblxuICAgIFZpZXcuY2FsbCh0aGlzLCBudWxsLCBjb250YWluZXIpO1xufVxuXG51dGlsLmluaGVyaXQoTW9udGhXZWVrLCBWaWV3KTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gdmlld01vZGVsIC0gdmlld01vZGVsIGZyb20gcGFyZW50IHZpZXdzLlxuICogQHJldHVybnMge29iamVjdH0gdmlld01vZGVsIHRvIHJlbmRlcmluZy5cbiAqL1xuTW9udGhXZWVrLnByb3RvdHlwZS5fZ2V0QmFzZVZpZXdNb2RlbCA9IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICByYW5nZSA9IGRhdGV0aW1lLnJhbmdlKFxuICAgICAgICAgICAgdmlld01vZGVsLnJlbmRlclN0YXJ0RGF0ZSxcbiAgICAgICAgICAgIHZpZXdNb2RlbC5yZW5kZXJFbmREYXRlLFxuICAgICAgICAgICAgZGF0ZXRpbWUuTUlMTElTRUNPTkRTX1BFUl9EQVlcbiAgICAgICAgKSxcbiAgICAgICAgbWF0cmljZXMgPSBvcHRpb25zLl9nZXRWaWV3TW9kZWxGdW5jKHZpZXdNb2RlbCksXG4gICAgICAgIHdpZHRoUGVyY2VudCA9IDEwMCAvIHJhbmdlLmxlbmd0aDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB3aWR0aFBlcmNlbnQsXG4gICAgICAgIGhlaWdodDogb3B0aW9ucy5jb250YWluZXJIZWlnaHQsXG4gICAgICAgIGV2ZW50QmxvY2tIZWlnaHQ6IG9wdGlvbnMuZXZlbnRIZWlnaHQgKyBvcHRpb25zLmV2ZW50R3V0dGVyLFxuICAgICAgICBldmVudEJsb2NrR3V0dGVyOiBvcHRpb25zLmV2ZW50R3V0dGVyLFxuICAgICAgICBldmVudEdyaWQ6IHV0aWwubWFwKHJhbmdlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB3aWR0aFBlcmNlbnQ7XG4gICAgICAgIH0pLFxuICAgICAgICBtYXRyaWNlczogbWF0cmljZXNcbiAgICB9O1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2aWV3TW9kZWwgLSB2aWV3TW9kZWwgZnJvbSBwYXJlbnQgdmlld3MuXG4gKi9cbk1vbnRoV2Vlay5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24odmlld01vZGVsKSB7XG4gICAgdmFyIGJhc2VWaWV3TW9kZWwgPSB0aGlzLl9nZXRCYXNlVmlld01vZGVsKHZpZXdNb2RlbCksXG4gICAgICAgIG1heEV2ZW50SW5EYXkgPSAwO1xuXG4gICAgbWF4RXZlbnRJbkRheSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHV0aWwubWFwKGJhc2VWaWV3TW9kZWwubWF0cmljZXMsIGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgdXRpbC5tYXAobWF0cml4LCBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiByb3cubGVuZ3RoO1xuICAgICAgICB9KSk7XG4gICAgfSkpO1xuXG4gICAgdGhpcy5yZXNpemUobWF4RXZlbnRJbkRheSk7XG5cbiAgICB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSB0bXBsKGJhc2VWaWV3TW9kZWwpO1xufTtcblxuLyoqXG4gKiBSZXNpemUgTW9udGhXZWVrIGNvbnRhaW5lciBhbmQgc2VuZCBpbmZvcm1hdGlvbiB0byBwYXJlbnQgdmlld3MuXG4gKiBAb3ZlcnJpZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhFdmVudEluRGF5IC0gaG93IGxhcmdlc3QgZXZlbnQgYmxvY2sgaW4gb25lIGRheT9cbiAqL1xuTW9udGhXZWVrLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbihtYXhFdmVudEluRGF5KSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIG5ld0hlaWdodCA9IChtYXhFdmVudEluRGF5ICogKG9wdGlvbnMuZXZlbnRIZWlnaHQgKyBvcHRpb25zLmV2ZW50R3V0dGVyKSkgKyBvcHRpb25zLmNvbnRhaW5lckJvdHRvbUd1dHRlcjtcblxuICAgIG5ld0hlaWdodCA9IE1hdGgubWF4KG5ld0hlaWdodCwgb3B0aW9ucy5taW5IZWlnaHQpO1xuICAgIFxuICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IG5ld0hlaWdodCArICdweCc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vbnRoV2VlaztcblxuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcImNvbXBpbGVyXCI6WzcsXCI+PSA0LjAuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctZGlzcGxheS10YWJsZVxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctZGlzcGxheS10YWJsZS1yb3dcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1kaXNwbGF5LXRhYmxlLWNlbGxcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctc2Nyb2xsLXkgc2NoZWR1bGUtdmlldy1kYXluYW1lLWxheW91dFxcXCI+PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctZGlzcGxheS10YWJsZS1yb3dcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1kaXNwbGF5LXRhYmxlLWNlbGxcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctc2Nyb2xsLXkgc2NoZWR1bGUtdmlldy1hbGxkYXktbGF5b3V0XFxcIj48L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1kaXNwbGF5LXRhYmxlLXJvd1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LWRpc3BsYXktdGFibGUtY2VsbCBzY2hlZHVsZS12aWV3LXRpbWVncmlkLWxheW91dFxcXCI+PC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgSGVscGVycyBmb3IgaGFuZGxlYmFyIHRlbXBsYXRlcy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG5cbmZ1bmN0aW9uIGdldEVsU2l6ZSh2YWx1ZSwgcG9zdGZpeCwgcHJlZml4KSB7XG4gICAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuICAgIGlmICh1dGlsLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgJzonICsgdmFsdWUgKyBwb3N0Zml4O1xuICAgIH1cblxuICAgIHJldHVybiBwcmVmaXggKyAnOmF1dG8nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnc3RhbXAnOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuc3RhbXAob2JqKTtcbiAgICB9LFxuXG4gICAgJ2VxdWFsJzogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICB9LFxuXG4gICAgJ29yJzogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gYSB8fCBiO1xuICAgIH0sXG5cbiAgICAnZmknOiBmdW5jdGlvbihhLCBvcGVyLCBiLCBvcHRpb25zKSB7XG4gICAgICAgIHN3aXRjaCAob3Blcikge1xuICAgICAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICAgICAgICAgIHJldHVybiAoYSA9PSBiKSA/IG9wdGlvbnMuZm4odGhpcykgOiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgICAgICAgICBjYXNlICc9PT0nOlxuICAgICAgICAgICAgICAgIHJldHVybiAgKGEgPT09IGIpID8gb3B0aW9ucy5mbih0aGlzKSA6IG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2NvbW1vbi13aWR0aCc6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICAgIHJldHVybiBnZXRFbFNpemUod2lkdGgsICclJywgJ3dpZHRoJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVzZSBpbiB0aW1lLmhic1xuICAgICAqIEBwYXJhbSB7RXZlbnRWaWV3TW9kZWx9IGV2ZW50Vmlld01vZGVsIHZpZXdNb2RlbFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGVsZW1lbnQgc2l6ZSBjc3MgY2xhc3NcbiAgICAgKi9cbiAgICAndGltZS1ldmVudEJsb2NrJzogZnVuY3Rpb24oZXZlbnRWaWV3TW9kZWwpIHtcbiAgICAgICAgdmFyIHRvcCA9IGdldEVsU2l6ZShldmVudFZpZXdNb2RlbC50b3AsICdweCcsICd0b3AnKSxcbiAgICAgICAgICAgIGxlZnQgPSBnZXRFbFNpemUoZXZlbnRWaWV3TW9kZWwubGVmdCwgJyUnLCAnbGVmdCcpLFxuICAgICAgICAgICAgd2lkdGggPSBnZXRFbFNpemUoZXZlbnRWaWV3TW9kZWwud2lkdGgsICclJywgJ3dpZHRoJyksXG4gICAgICAgICAgICBoZWlnaHQgPSBnZXRFbFNpemUoZXZlbnRWaWV3TW9kZWwuaGVpZ2h0LCAncHgnLCAnaGVpZ2h0Jyk7XG5cbiAgICAgICAgcmV0dXJuIFt0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHRdLmpvaW4oJzsnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXNlIGluIGRheW5hbWUuaGJzXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY3NzIGNsYXNzXG4gICAgICovXG4gICAgJ2RheW5hbWUtaXNIb2xsaWRheSc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kYXkgPT09IDAgfHwgdGhpcy5kYXkgPT09IDYpIHtcbiAgICAgICAgICAgIHJldHVybiAnc2NoZWR1bGUtdmlldy1kYXluYW1lIHNjaGVkdWxlLWhvbGxpZGF5JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnc2NoZWR1bGUtdmlldy1kYXluYW1lJztcbiAgICB9LFxuXG4gICAgJ211bHRpcGx5JzogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gYSAqIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOyFgOugie2KuOuwleyKpCDtl6ztjbxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIOyFgOugie2KuOuwleyKpCBuYW1lIOyGjeyEseqwklxuICAgICAqIEBwYXJhbSB7e3ZhbHVlOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmd9fSBsaXN0IC0g7Ji17IWYIOumrOyKpO2KuFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RlZFZhbHVlIC0g6riw67O47ISg7YOd7LKY66asIOybkO2VmOuKlCDqsJJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBodG1sIHRhZ1xuICAgICAqL1xuICAgICdzZWxlY3Rib3gnOiBmdW5jdGlvbihuYW1lLCBsaXN0LCBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIHZhciBodG1sID0gJzxzZWxlY3QgbmFtZT1cIicgKyBuYW1lICsgJ1wiPic7XG5cbiAgICAgICAgdXRpbC5mb3JFYWNoKGxpc3QsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCInICsgZGF0YS52YWx1ZSArICdcIicgKyAoc2VsZWN0ZWRWYWx1ZSA9PT0gZGF0YS52YWx1ZSA/ICcgc2VsZWN0ZWQnIDogJycpICsgJz4nICsgZGF0YS5sYWJlbCArICc8L29wdGlvbj4nO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaHRtbCArICc8L3NlbGVjdD4nO1xuICAgIH0sXG5cbiAgICAncmFkaW9DYWxlbmRhckNvbG9yJzogZnVuY3Rpb24obmFtZSwgbGlzdCwgY2hlY2tlZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB1dGlsLm1hcChsaXN0LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxsYWJlbD4nICsgXG4gICAgICAgICAgICAgICAgJzxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwiJyArIG5hbWUgKyAnXCIgdmFsdWU9XCInICsgZGF0YS52YWx1ZSArICdcIicgKyBcbiAgICAgICAgICAgICAgICAoZGF0YS52YWx1ZSA9PT0gY2hlY2tlZFZhbHVlID8gJyBjaGVja2VkJyA6ICcnKSArICcgLz4nICsgXG4gICAgICAgICAgICAgICAgJzxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjojJyArIGRhdGEudmFsdWUgKyAnXCI+Jm5ic3A7PC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICc8L2xhYmVsPic7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgIH1cbn07XG5cbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZSh7XCIxXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgYWxpYXMxPWNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uO1xuXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctbW9udGh3ZWVrLWdyaWQtbGluZVxcXCIgc3R5bGU9XFxcIndpZHRoOlwiXG4gICAgKyBhbGlhczEoY29udGFpbmVyLmxhbWJkYShkZXB0aDAsIGRlcHRoMCkpXG4gICAgKyBcIiU7bGVmdDpcIlxuICAgICsgYWxpYXMxKChoZWxwZXJzLm11bHRpcGx5IHx8IChkZXB0aDAgJiYgZGVwdGgwLm11bHRpcGx5KSB8fCBoZWxwZXJzLmhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSxkZXB0aDAsKGRhdGEgJiYgZGF0YS5pbmRleCkse1wibmFtZVwiOlwibXVsdGlwbHlcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpXG4gICAgKyBcIiU7XFxcIj4mbmJzcDs8L2Rpdj5cXG5cIjtcbn0sXCIzXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxO1xuXG4gIHJldHVybiAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sZGVwdGgwLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oNCwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIik7XG59LFwiNFwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMTtcblxuICByZXR1cm4gXCIgXFxuXCJcbiAgICArICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSxkZXB0aDAse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSg1LCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKTtcbn0sXCI1XCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxO1xuXG4gIHJldHVybiBcIiBcXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzW1wiaWZcIl0uY2FsbChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LGRlcHRoMCx7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSg2LCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKTtcbn0sXCI2XCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxLCBhbGlhczE9ZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSwgYWxpYXMyPWhlbHBlcnMuaGVscGVyTWlzc2luZywgYWxpYXMzPWNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uLCBhbGlhczQ9Y29udGFpbmVyLmxhbWJkYTtcblxuICByZXR1cm4gXCIgXFxuPGRpdiBkYXRhLWlkPVxcXCJcIlxuICAgICsgYWxpYXMzKChoZWxwZXJzLnN0YW1wIHx8IChkZXB0aDAgJiYgZGVwdGgwLnN0YW1wKSB8fCBhbGlhczIpLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tb2RlbCA6IGRlcHRoMCkse1wibmFtZVwiOlwic3RhbXBcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpXG4gICAgKyBcIlxcXCIgXFxuICAgIGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LWFsbGRheS1ldmVudC1ibG9jayBcIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzW1wiaWZcIl0uY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnJlbmRlclN0YXJ0cyA6IGRlcHRoMCkse1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oNywgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArICgoc3RhY2sxID0gaGVscGVyc1tcImlmXCJdLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5yZW5kZXJFbmRzIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSg5LCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCJcXFwiXFxuICAgIHN0eWxlPVxcXCJ0b3A6XCJcbiAgICArIGFsaWFzMygoaGVscGVycy5tdWx0aXBseSB8fCAoZGVwdGgwICYmIGRlcHRoMC5tdWx0aXBseSkgfHwgYWxpYXMyKS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudG9wIDogZGVwdGgwKSwoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS5ldmVudEJsb2NrSGVpZ2h0KSx7XCJuYW1lXCI6XCJtdWx0aXBseVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSlcbiAgICArIFwicHg7bGVmdDpcIlxuICAgICsgYWxpYXMzKChoZWxwZXJzLm11bHRpcGx5IHx8IChkZXB0aDAgJiYgZGVwdGgwLm11bHRpcGx5KSB8fCBhbGlhczIpLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5sZWZ0IDogZGVwdGgwKSwoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS53aWR0aCkse1wibmFtZVwiOlwibXVsdGlwbHlcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpXG4gICAgKyBcIiU7d2lkdGg6XCJcbiAgICArIGFsaWFzMygoaGVscGVycy5tdWx0aXBseSB8fCAoZGVwdGgwICYmIGRlcHRoMC5tdWx0aXBseSkgfHwgYWxpYXMyKS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAud2lkdGggOiBkZXB0aDApLCgoc3RhY2sxID0gKGRhdGEgJiYgZGF0YS5yb290KSkgJiYgc3RhY2sxLndpZHRoKSx7XCJuYW1lXCI6XCJtdWx0aXBseVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSlcbiAgICArIFwiJTtoZWlnaHQ6XCJcbiAgICArIGFsaWFzMyhhbGlhczQoKChzdGFjazEgPSAoZGF0YSAmJiBkYXRhLnJvb3QpKSAmJiBzdGFjazEuZXZlbnRCbG9ja0hlaWdodCksIGRlcHRoMCkpXG4gICAgKyBcInB4O21hcmdpbi10b3A6XCJcbiAgICArIGFsaWFzMyhhbGlhczQoKChzdGFjazEgPSAoZGF0YSAmJiBkYXRhLnJvb3QpKSAmJiBzdGFjazEuZXZlbnRCbG9ja0d1dHRlciksIGRlcHRoMCkpXG4gICAgKyBcInB4XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1hbGxkYXktZXZlbnRcXFwiIHN0eWxlPVxcXCJoZWlnaHQ6XCJcbiAgICArIGFsaWFzMyhhbGlhczQoKChzdGFjazEgPSAoZGF0YSAmJiBkYXRhLnJvb3QpKSAmJiBzdGFjazEuZXZlbnRIZWlnaHQpLCBkZXB0aDApKVxuICAgICsgXCJweFxcXCI+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1hbGxkYXktZXZlbnQtdGl0bGVcXFwiPlwiXG4gICAgKyBhbGlhczMoYWxpYXM0KCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1vZGVsIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS50aXRsZSA6IHN0YWNrMSksIGRlcHRoMCkpXG4gICAgKyBcIjwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LWFsbGRheS1yZXNpemUtaGFuZGxlIGhhbmRsZS15XFxcIj4mbmJzcDs8L3NwYW4+XFxuICAgIDwvZGl2PiBcXG48L2Rpdj5cXG5cIjtcbn0sXCI3XCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICByZXR1cm4gXCIgc2NoZWR1bGUtdmlldy1hbGxkYXktZXhjZWVkLWxlZnRcIjtcbn0sXCI5XCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICByZXR1cm4gXCIgc2NoZWR1bGUtdmlldy1hbGxkYXktZXhjZWVkLXJpZ2h0XCI7XG59LFwiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMSwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge307XG5cbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1tb250aHdlZWstZ3JpZFxcXCI+XFxuXCJcbiAgICArICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5ldmVudEdyaWQgOiBkZXB0aDApLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMSwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1tb250aHdlZWstZXZlbnRzXFxcIj5cXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1hdHJpY2VzIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDMsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIjwvZGl2PlxcblwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVnaXN0ZXIgZGV2ZWxvcGVkIGN1c3RvbSBoYW5kbGViYXJzIGhlbHBlci5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgaGVscGVyID0gcmVxdWlyZSgnLi9oZWxwZXInKTtcbnZhciBIYW5kbGViYXJzID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xuXG51dGlsLmZvckVhY2goaGVscGVyLCBmdW5jdGlvbihoZWxwZXIsIG5hbWUpIHtcbiAgICBIYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKG5hbWUsIGhlbHBlcik7XG59LCB0aGlzKTtcblxuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcImNvbXBpbGVyXCI6WzcsXCI+PSA0LjAuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBoZWxwZXI7XG5cbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1hbGxkYXktbGVmdFxcXCI+XFxuICAgIDxzcGFuPlwiXG4gICAgKyBjb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnRpdGxlIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50aXRsZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJzLmhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBcImZ1bmN0aW9uXCIgPyBoZWxwZXIuY2FsbChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LHtcIm5hbWVcIjpcInRpdGxlXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIjwvc3Bhbj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LWFsbGRheS1yaWdodFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctYWxsZGF5LW1vbnRod2Vlay1jb250YWluZXJcXFwiPjwvZGl2PlxcbjwvZGl2PlxcblwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoe1wiMVwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sIGFsaWFzMj1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGFsaWFzMz1cImZ1bmN0aW9uXCIsIGFsaWFzND1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbjtcblxuICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnNbXCJkYXluYW1lLWlzSG9sbGlkYXlcIl0gfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwW1wiZGF5bmFtZS1pc0hvbGxpZGF5XCJdIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJkYXluYW1lLWlzSG9sbGlkYXlcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiXFxcIiBzdHlsZT1cXFwiXCJcbiAgICArIGFsaWFzNCgoaGVscGVyc1tcImNvbW1vbi13aWR0aFwiXSB8fCAoZGVwdGgwICYmIGRlcHRoMFtcImNvbW1vbi13aWR0aFwiXSkgfHwgYWxpYXMyKS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAud2lkdGggOiBkZXB0aDApLHtcIm5hbWVcIjpcImNvbW1vbi13aWR0aFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSlcbiAgICArIFwiXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1kYXluYW1lLWxhYmVsXFxcIj5cIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuZGF5TmFtZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZGF5TmFtZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiZGF5TmFtZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCI8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1kYXluYW1lLWRhdGVcXFwiPlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5kYXRlIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5kYXRlIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJkYXRlXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIjwvZGl2PlxcbjwvZGl2PlxcblwiO1xufSxcImNvbXBpbGVyXCI6WzcsXCI+PSA0LjAuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazE7XG5cbiAgcmV0dXJuICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSxkZXB0aDAse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgxLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKTtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pO1xuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcIjFcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazE7XG5cbiAgcmV0dXJuICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSxkZXB0aDAse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgyLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKTtcbn0sXCIyXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxO1xuXG4gIHJldHVybiAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sZGVwdGgwLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMywgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIik7XG59LFwiM1wiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMTtcblxuICByZXR1cm4gKChzdGFjazEgPSBoZWxwZXJzW1wiaWZcIl0uY2FsbChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LGRlcHRoMCx7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSg0LCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCJcXG5cIjtcbn0sXCI0XCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxLCBhbGlhczE9ZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSwgYWxpYXMyPWhlbHBlcnMuaGVscGVyTWlzc2luZywgYWxpYXMzPWNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uO1xuXG4gIHJldHVybiBcIiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctdGltZS1kYXRlLWV2ZW50LWJsb2NrXFxcIiBkYXRhLWlkPVxcXCJcIlxuICAgICsgYWxpYXMzKChoZWxwZXJzLnN0YW1wIHx8IChkZXB0aDAgJiYgZGVwdGgwLnN0YW1wKSB8fCBhbGlhczIpLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tb2RlbCA6IGRlcHRoMCkse1wibmFtZVwiOlwic3RhbXBcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpXG4gICAgKyBcIlxcXCIgc3R5bGU9XFxcIlwiXG4gICAgKyBhbGlhczMoKGhlbHBlcnNbXCJ0aW1lLWV2ZW50QmxvY2tcIl0gfHwgKGRlcHRoMCAmJiBkZXB0aDBbXCJ0aW1lLWV2ZW50QmxvY2tcIl0pIHx8IGFsaWFzMikuY2FsbChhbGlhczEsZGVwdGgwLHtcIm5hbWVcIjpcInRpbWUtZXZlbnRCbG9ja1wiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSlcbiAgICArIFwiXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy10aW1lLWV2ZW50XFxcIj5cIlxuICAgICsgYWxpYXMzKGNvbnRhaW5lci5sYW1iZGEoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubW9kZWwgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLnRpdGxlIDogc3RhY2sxKSwgZGVwdGgwKSlcbiAgICArIFwiPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctdGltZS1yZXNpemUtaGFuZGxlIGhhbmRsZS14XFxcIj4mbmJzcDs8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cIjtcbn0sXCJjb21waWxlclwiOls3LFwiPj0gNC4wLjBcIl0sXCJtYWluXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxO1xuXG4gIHJldHVybiAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1hdHJpY2VzIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDEsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoe1wiMVwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sIGFsaWFzMj1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGFsaWFzMz1cImZ1bmN0aW9uXCIsIGFsaWFzND1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbjtcblxuICByZXR1cm4gXCI8bGkgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctdGltZWdyaWQtaG91ci1cIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuaG91ciB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaG91ciA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiaG91clwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJcXFwiPjxzcGFuPlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5ob3VyIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5ob3VyIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJob3VyXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIjwvc3Bhbj48L2xpPlwiO1xufSxcIjNcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctdGltZWdyaWQtZ3JpZFxcXCI+PC9kaXY+XCI7XG59LFwiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMSwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge307XG5cbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy10aW1lZ3JpZFxcXCI+XFxuICAgIDx1bCBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy10aW1lZ3JpZC1sZWZ0XFxcIj5cXG4gICAgICAgIFwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaG91cnMgOiBkZXB0aDApLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMSwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiXFxuICAgIDwvdWw+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctdGltZWdyaWQtcmlnaHRcXFwiPlxcbiAgICAgICAgXCJcbiAgICArICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5ob3VycyA6IGRlcHRoMCkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgzLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCJcXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctdGltZWdyaWQtZXZlbnRzXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctdGltZWdyaWQtZXZlbnRzLWNvbnRhaW5lclxcXCI+PC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LXRpbWVncmlkLWhvdXJtYXJrZXJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctdGltZWdyaWQtaG91cm1hcmtlci13cmFwXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LXRpbWVncmlkLWhvdXJtYXJrZXItbGluZVxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy10aW1lZ3JpZC1ob3VybWFya2VyLXRpbWVcXFwiPjAwOjAwPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy10aW1lZ3JpZC10b2RheW1hcmtlclxcXCI+dG9kYXk8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoZSBiYXNlIGNsYXNzIG9mIHZpZXdzLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2NvbGxlY3Rpb24nKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIG9mIHZpZXdzLlxuICpcbiAqIEFsbCB2aWV3cyBjcmVhdGUgb3duIGNvbnRhaW5lciBlbGVtZW50IGluc2lkZSBzdXBwbGllZCBjb250YWluZXIgZWxlbWVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvcHRpb25zfSBvcHRpb25zIFRoZSBvYmplY3QgZm9yIGRlc2NyaWJlIHZpZXcncyBzcGVjcy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBEZWZhdWx0IGNvbnRhaW5lciBlbGVtZW50IGZvciB2aWV3LiB5b3UgY2FuIHVzZSB0aGlzIGVsZW1lbnQgZm9yIHRoaXMuY29udGFpbmVyIHN5bnRheC5cbiAqL1xuZnVuY3Rpb24gVmlldyhvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICB2YXIgaWQgPSB1dGlsLnN0YW1wKHRoaXMpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChjb250YWluZXIpKSB7XG4gICAgICAgIGNvbnRhaW5lciA9IGRvbXV0aWwuYXBwZW5kSFRNTEVsZW1lbnQoJ2RpdicpO1xuICAgIH1cblxuICAgIGRvbXV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnc2NoZWR1bGUtdmlldy0nICsgaWQpO1xuXG4gICAgLyoqXG4gICAgICogdW5pcXVlIGlkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gaWQ7XG5cbiAgICAvKipcbiAgICAgKiBiYXNlIGVsZW1lbnQgb2Ygdmlldy5cbiAgICAgKiBAdHlwZSB7SFRNTERJVkVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICAvKmVzbGludC1kaXNhYmxlKi9cbiAgICAvKipcbiAgICAgKiBjaGlsZCB2aWV3cy5cbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNoaWxkcyA9IG5ldyBDb2xsZWN0aW9uKGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuc3RhbXAodmlldyk7XG4gICAgfSk7XG4gICAgLyplc2xpbnQtZW5hYmxlKi9cblxuICAgIC8qKlxuICAgICAqIHBhcmVudCB2aWV3IGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtWaWV3fVxuICAgICAqL1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBBZGQgY2hpbGQgdmlld3MuXG4gKiBAcGFyYW0ge1ZpZXd9IHZpZXcgVGhlIHZpZXcgaW5zdGFuY2UgdG8gYWRkLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZuXSBGdW5jdGlvbiBmb3IgaW52b2tlIGJlZm9yZSBhZGQuIHBhcmVudCB2aWV3IGNsYXNzIGlzIHN1cHBsaWVkIGZpcnN0IGFyZ3VtZW50cy5cbiAqL1xuVmlldy5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbih2aWV3LCBmbikge1xuICAgIGlmIChmbikge1xuICAgICAgICBmbi5jYWxsKHZpZXcsIHRoaXMpO1xuICAgIH1cbiAgICAvLyBhZGQgcGFyZW50IHZpZXdcbiAgICB2aWV3LnBhcmVudCA9IHRoaXM7XG5cbiAgICB0aGlzLmNoaWxkcy5hZGQodmlldyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhZGRlZCBjaGlsZCB2aWV3LlxuICogQHBhcmFtIHsobnVtYmVyfFZpZXcpfSBpZCBWaWV3IGlkIG9yIGluc3RhbmNlIGl0c2VsZiB0byByZW1vdmUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZm5dIEZ1bmN0aW9uIGZvciBpbnZva2UgYmVmb3JlIHJlbW92ZS4gcGFyZW50IHZpZXcgY2xhc3MgaXMgc3VwcGxpZWQgZmlyc3QgYXJndW1lbnRzLlxuICovXG5WaWV3LnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uKGlkLCBmbikge1xuICAgIHZhciB2aWV3ID0gdXRpbC5pc051bWJlcihpZCkgPyB0aGlzLmNoaWxkcy5pdGVtc1tpZF0gOiBpZDtcblxuICAgIGlkID0gdXRpbC5zdGFtcCh2aWV3KTtcblxuICAgIGlmIChmbikge1xuICAgICAgICBmbi5jYWxsKHZpZXcsIHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGRzLnJlbW92ZShpZCk7XG59O1xuXG4vKipcbiAqIFJlbmRlciB2aWV3IHJlY3Vyc2l2ZWx5LlxuICovXG5WaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNoaWxkcy5lYWNoKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICBjaGlsZFZpZXcucmVuZGVyKCk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEludm9rZSBmdW5jdGlvbiByZWN1cnNpdmVseS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gZnVuY3Rpb24gdG8gaW52b2tlIGNoaWxkIHZpZXcgcmVjdXJzaXZlbHlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBUaGlzPWZhbHNlXSAtIHNldCB0cnVlIHRoZW4gc2tpcCBpbnZva2Ugd2l0aCB0aGlzKHJvb3QpIHZpZXcuXG4gKi9cblZpZXcucHJvdG90eXBlLnJlY3Vyc2l2ZSA9IGZ1bmN0aW9uKGZuLCBza2lwVGhpcykge1xuICAgIGlmICghdXRpbC5pc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFza2lwVGhpcykge1xuICAgICAgICBmbih0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLmNoaWxkcy5lYWNoKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICBjaGlsZFZpZXcucmVjdXJzaXZlKGZuKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmVzaXplIHZpZXcgcmVjdXJzaXZlbHkgdG8gcGFyZW50LlxuICovXG5WaWV3LnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKHBhcmVudC5fb25SZXNpemUpKSB7XG4gICAgICAgICAgICBwYXJlbnQuX29uUmVzaXplLmFwcGx5KHBhcmVudCwgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbn07XG5cbi8qKlxuICogSW52b2tpbmcgbWV0aG9kIGJlZm9yZSBkZXN0cm95aW5nLlxuICovXG5WaWV3LnByb3RvdHlwZS5fYmVmb3JlRGVzdHJveSA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogQ2xlYXIgcHJvcGVydGllc1xuICovXG5WaWV3LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JlZm9yZURlc3Ryb3koKTtcbiAgICB0aGlzLmNoaWxkcy5jbGVhcigpO1xuICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuXG4gICAgdGhpcy5pZCA9IHRoaXMucGFyZW50ID0gdGhpcy5jaGlsZHMgPSB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG59O1xuXG4vKmVzbGludC1kaXNhYmxlKi9cbi8qKlxuICogRGVzdHJveSBjaGlsZCB2aWV3IHJlY3Vyc2l2ZWx5LlxuICovXG5WaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oaXNDaGlsZFZpZXcpIHtcbiAgICB0aGlzLmNoaWxkcy5lYWNoKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICBjaGlsZFZpZXcuZGVzdHJveSh0cnVlKTtcbiAgICAgICAgY2hpbGRWaWV3Ll9kZXN0cm95KCk7XG4gICAgfSk7XG5cbiAgICBpZiAoaXNDaGlsZFZpZXcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2Rlc3Ryb3koKTtcbn07XG4vKmVzbGludC1lbmFibGUqL1xuXG4vKipcbiAqIENhbGN1bGF0ZSB2aWV3J3MgY29udGFpbmVyIGVsZW1lbnQgYm91bmQuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgYm91bmQgb2YgY29udGFpbmVyIGVsZW1lbnQuXG4gKi9cblZpZXcucHJvdG90eXBlLmdldFZpZXdCb3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgcG9zaXRpb24gPSBkb211dGlsLmdldFBvc2l0aW9uKGNvbnRhaW5lciksXG4gICAgICAgIHNpemUgPSBkb211dGlsLmdldFNpemUoY29udGFpbmVyKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBvc2l0aW9uWzBdLFxuICAgICAgICB5OiBwb3NpdGlvblsxXSxcbiAgICAgICAgd2lkdGg6IHNpemVbMF0sXG4gICAgICAgIGhlaWdodDogc2l6ZVsxXVxuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXc7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBWaWV3IG9mIGFsbGRheSBldmVudCBjb250YWluZXIgaW5zaWRlIG9mIFdlZWsgdmlldy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXcnKTtcbnZhciBNb250aFdlZWsgPSByZXF1aXJlKCcuLi9tb250aHdlZWsnKTtcbnZhciBtYWluVG1wbCA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlL3dlZWsvYWxsZGF5LmhicycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge1ZpZXd9XG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBUaGUgb2JqZWN0IGZvciB2aWV3IGN1c3RvbWl6YXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yZW5kZXJTdGFydERhdGUgLSBzdGFydCBkYXRlIG9mIGFsbGRheSB2aWV3J3MgcmVuZGVyIGRhdGUuIFlZWVktTU0tRERcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJlbmRlckVuZERhdGUgLSBlbmQgZGF0ZSBvZiBhbGxkYXkgdmlldydzIHJlbmRlciBkYXRlLiBZWVlZLU1NLUREXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaGVpZ2h0PTYwXSAtIG1pbmltdW0gaGVpZ2h0IG9mIGV2ZW50IGNvbnRhaW5lciBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmV2ZW50QmxvY2tIZWlnaHQ9MThdIC0gaGVpZ2h0IG9mIGVhY2ggZXZlbnQgYmxvY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZXZlbnRCbG9ja0d1dHRlcj0yXSAtIGd1dHRlciBoZWlnaHQgb2YgZWFjaCBldmVudCBibG9jay5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLl9nZXRWaWV3TW9kZWxGdW5jXSAtIGZ1bmN0aW9uIGZvciBleHRyYWN0IHBhcnRpYWwgdmlldyBtb2RlbCBkYXRhIGZyb20gd2hvbGUgdmlldyBtb2RlbHMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgQ29udGFpbmVyIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIEFsbGRheShvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICBjb250YWluZXIgPSBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAnc2NoZWR1bGUtdmlldy1hbGxkYXktY29udGFpbmVyJ1xuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiByZW5kZXJpbmcgb3B0aW9ucy5cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgdGl0bGU6ICfsooXsnbzsnbzsoJUnLFxuICAgICAgICByZW5kZXJTdGFydERhdGU6ICcnLFxuICAgICAgICByZW5kZXJFbmREYXRlOiAnJyxcbiAgICAgICAgY29udGFpbmVySGVpZ2h0OiA0MCxcbiAgICAgICAgY29udGFpbmVyQm90dG9tR3V0dGVyOiA4LFxuICAgICAgICBldmVudEhlaWdodDogMTgsXG4gICAgICAgIGV2ZW50R3V0dGVyOiAyLFxuICAgICAgICBfZ2V0Vmlld01vZGVsRnVuYzogZnVuY3Rpb24odmlld01vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlld01vZGVsLmV2ZW50c0luRGF0ZVJhbmdlLmFsbGRheTtcbiAgICAgICAgfVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgVmlldy5jYWxsKHRoaXMsIG51bGwsIGNvbnRhaW5lcik7XG59XG5cbnV0aWwuaW5oZXJpdChBbGxkYXksIFZpZXcpO1xuXG4vKipcbiAqIGNyZWF0ZSBtb250aCB3ZWVrIHZpZXcgbW9kZWwgZm9yIHJlbmRlciBhbGxkYXkgZXZlbnRzIGluIHRvcCBvZiB3ZWVrIHZpZXdzLlxuICogQG92ZXJyaWRlXG4gKiBAcGFyYW0ge29iamVjdH0gdmlld01vZGVsIC0gdmlld01vZGVsIGZyb20gcGFyZW50IHZpZXdzLlxuICovXG5BbGxkYXkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgbW9udGhXZWVrSW5zdDtcblxuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBtYWluVG1wbCh0aGlzLm9wdGlvbnMpO1xuXG4gICAgdGhpcy5jaGlsZHMuY2xlYXIoKTtcblxuICAgIG1vbnRoV2Vla0luc3QgPSBuZXcgTW9udGhXZWVrKFxuICAgICAgICB0aGlzLm9wdGlvbnMsIFxuICAgICAgICBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LWFsbGRheS1tb250aHdlZWstY29udGFpbmVyJywgY29udGFpbmVyKVxuICAgICk7XG5cbiAgICB0aGlzLmFkZENoaWxkKG1vbnRoV2Vla0luc3QpO1xuXG4gICAgdGhpcy5jaGlsZHMuZWFjaChmdW5jdGlvbihjaGlsZFZpZXcpIHtcbiAgICAgICAgY2hpbGRWaWV3LnJlbmRlcih2aWV3TW9kZWwpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbGxkYXk7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBWaWV3IGZvciByZW5kZXJpbmcgZGF5bmFtZXNcbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciBWaWV3ID0gcmVxdWlyZSgnLi4vdmlldycpO1xudmFyIGRheW5hbWVUbXBsID0gcmVxdWlyZSgnLi4vdGVtcGxhdGUvd2Vlay9kYXluYW1lcy5oYnMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbiB7b2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgZGF5bmFtZSB2aWV3XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgQ29udGFpbmVyIGVsZW1lbnQgdG8gdXNlLlxuICogQGV4dGVuZHMge1ZpZXd9XG4gKi9cbmZ1bmN0aW9uIERheU5hbWUob3B0aW9ucywgY29udGFpbmVyKSB7XG4gICAgY29udGFpbmVyID0gZG9tdXRpbC5hcHBlbmRIVE1MRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgJ3NjaGVkdWxlLXZpZXctZGF5bmFtZS1jb250YWluZXInXG4gICAgKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgZGF5bmFtZXM6IFsn7J28JywgJ+yblCcsICftmZQnLCAn7IiYJywgJ+uqqScsICfquIgnLCAn7YagJ11cbiAgICB9LCBvcHRpb25zKTtcblxuICAgIFZpZXcuY2FsbCh0aGlzLCBudWxsLCBjb250YWluZXIpO1xufVxuXG51dGlsLmluaGVyaXQoRGF5TmFtZSwgVmlldyk7XG5cbi8qKlxuICogR2V0IGRlZmF1bHQgdmlld21vZGVscy5cbiAqIEBwYXJhbSB7RGF0ZX0gc3RhcnQgVGhlIGRhdGUgb2Ygc3RhcnQgcmVuZGVyXG4gKiBAcGFyYW0ge0RhdGV9IGVuZCBUaGUgZW5kIG9mIGVuZCByZW5kZXJcbiAqIEByZXR1cm5zIHthcnJheX0gdmlld21vZGVsLlxuICovXG5EYXlOYW1lLnByb3RvdHlwZS5fZ2V0QmFzZVZpZXdNb2RlbCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgZGF5bmFtZXMgPSB0aGlzLm9wdGlvbnMuZGF5bmFtZXMsXG4gICAgICAgIHZpZXdNb2RlbDtcblxuICAgIHZpZXdNb2RlbCA9IHV0aWwubWFwKGRhdGV0aW1lLnJhbmdlKFxuICAgICAgICBkYXRldGltZS5zdGFydChzdGFydCksXG4gICAgICAgIGRhdGV0aW1lLnN0YXJ0KGVuZCksXG4gICAgICAgIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZXG4gICAgKSwgZnVuY3Rpb24oZCwgaSwgYXJyKSB7XG4gICAgICAgIHZhciBkYXkgPSBkLmdldERheSgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXk6IGRheSxcbiAgICAgICAgICAgIGRheU5hbWU6IGRheW5hbWVzW2RheV0sXG4gICAgICAgICAgICBkYXRlOiBkLmdldERhdGUoKSxcbiAgICAgICAgICAgIHdpZHRoOiAxMDAgLyBhcnIubGVuZ3RoXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdmlld01vZGVsO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2aWV3TW9kZWwgVmlldyBtb2RlbCBmcm9tIHBhcmVudCAoV2Vla1ZpZXcpXG4gKi9cbkRheU5hbWUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgIHZhciBfdmlld01vZGVsID0gdGhpcy5fZ2V0QmFzZVZpZXdNb2RlbChcbiAgICAgICAgdmlld01vZGVsLnJlbmRlclN0YXJ0RGF0ZSxcbiAgICAgICAgdmlld01vZGVsLnJlbmRlckVuZERhdGVcbiAgICApO1xuXG4gICAgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gZGF5bmFtZVRtcGwoX3ZpZXdNb2RlbCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERheU5hbWU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBWaWV3IG9mIHRpbWUuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXcnKTtcbnZhciB0aW1lVG1wbCA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlL3dlZWsvdGltZS5oYnMnKTtcbnZhciBmb3JFYWNoQXJyID0gdXRpbC5mb3JFYWNoQXJyYXk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7Vmlld31cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBEYXRlIGVsZW1lbnQgd2lkdGggKHBlcmNlbnQpXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBPcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy55bWQgWVlZTU1ERCBzdHJpbmcgZm9yIHRoaXMgdmlld1xuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmlzVG9kYXkgd2hlbiBzZXQgdHJ1ZSB0aGVuIGFzc2lnbiB0b2RheSBkZXNpZ24gY2xhc3MgdG8gY29udGFpbmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuaG91clN0YXJ0IENhbiBsaW1pdCBvZiByZW5kZXIgaG91ciBzdGFydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmhvdXJFbmQgQ2FuIGxpbWl0IG9mIHJlbmRlciBob3VyIGVuZC5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBFbGVtZW50IHRvIHVzZSBjb250YWluZXIgZm9yIHRoaXMgdmlldy5cbiAqL1xuZnVuY3Rpb24gVGltZSh3aWR0aCwgb3B0aW9ucywgY29udGFpbmVyKSB7XG4gICAgVmlldy5jYWxsKHRoaXMsIG51bGwsIGNvbnRhaW5lcik7XG5cbiAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSB3aWR0aCArICclJztcblxuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgeW1kOiAnJyxcbiAgICAgICAgaXNUb2RheTogZmFsc2UsXG4gICAgICAgIGhvdXJTdGFydDogMCxcbiAgICAgICAgaG91ckVuZDogMjRcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaXNUb2RheSkge1xuICAgICAgICBkb211dGlsLmFkZENsYXNzKHRoaXMuY29udGFpbmVyLCAnc2NoZWR1bGUtdmlldy10aW1lLWRhdGUtdG9kYXknKTtcbiAgICB9XG59XG5cbnV0aWwuaW5oZXJpdChUaW1lLCBWaWV3KTtcblxuLyoqXG4gKiBDb252ZXJ0IFlZWVlNTUREIGZvcm1hdHRlZCBzdHJpbmcgZGF0ZSB0byBEYXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBmb3JtYXR0ZWQgc3RyaW5nLlxuICogQHJldHVybnMge0RhdGV9IHN0YXJ0IG9mIGRhdGUuXG4gKi9cblRpbWUucHJvdG90eXBlLl9wYXJzZURhdGVHcm91cCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciB5ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigwLCA0KSwgMTApLFxuICAgICAgICBtID0gcGFyc2VJbnQoc3RyLnN1YnN0cig0LCAyKSwgMTApLFxuICAgICAgICBkID0gcGFyc2VJbnQoc3RyLnN1YnN0cig2LCAyKSwgMTApO1xuXG4gICAgcmV0dXJuIG5ldyBEYXRlKHksIG0gLSAxLCBkKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFdmVudFZpZXdNb2RlbH0gdmlld01vZGVsIC0gdmlldyBtb2RlbCBpbnN0YW5jZSB0byBjYWxjdWxhdGUgYm91bmQuXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIGNhbGN1bGF0aW5nIGV2ZW50IGVsZW1lbnQncyBib3VuZC5cbiAqIEBwYXJhbSB7RGF0ZX0gb3B0aW9ucy50b2RheVN0YXJ0IC0gZGF0ZSBvYmplY3QgcmVwcmVzZW50IGV2ZW50IGRhdGUncyBzdGFydCAoMDA6MDA6MDApXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5iYXNlTVMgLSB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byByZW5kZXIgZXZlbnQgYmxvY2tzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuYmFzZUhlaWdodCAtIHBpeGVsIHZhbHVlIHJlbGF0ZWQgd2l0aCBiYXNlTVMgb3B0aW9ucy5cbiAqIEBwYXJhbSB7bnVtYmVyW119IG9wdGlvbnMuYmFzZUxlZnQgLSBsZWZ0IHBvc2l0aW9uIHBlcmNlbnRzIGZvciBlYWNoIGNvbHVtbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5iYXNlV2lkdGggLSB0aGUgdW5pdCBvZiBldmVudCBibG9ja3Mgd2lkdGggcGVyY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNvbHVtbkluZGV4IC0gdGhlIG51bWJlciBpbmRleCBvZiBldmVudCBibG9ja3MuXG4gKiBpdCByZXByZXNlbnQgcmVuZGVyaW5nIGluZGV4IGZyb20gbGVmdCBzaWRlcyBpbiB2aWV3LlxuICogQHJldHVybnMge29iamVjdH0gYm91bmQgb2JqZWN0IGZvciBzdXBwbGllZCB2aWV3IG1vZGVsLlxuICovXG5UaW1lLnByb3RvdHlwZS5nZXRFdmVudFZpZXdCb3VuZCA9IGZ1bmN0aW9uKHZpZXdNb2RlbCwgb3B0aW9ucykge1xuICAgIHZhciBiYXNlTVMgPSBvcHRpb25zLmJhc2VNUyxcbiAgICAgICAgYmFzZUhlaWdodCA9IG9wdGlvbnMuYmFzZUhlaWdodCxcbiAgICAgICAgb2Zmc2V0U3RhcnQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHRvcDtcblxuICAgIG9mZnNldFN0YXJ0ID0gdmlld01vZGVsLnZhbHVlT2YoKS5zdGFydHMgLSBvcHRpb25zLnRvZGF5U3RhcnQ7XG5cbiAgICAvLyBjb250YWluZXJIZWlnaHQgOiBtaWxsaXNlY29uZHMgaW4gZGF5ID0geCA6IGV2ZW50J3MgbWlsbGlzZWNvbmRzXG4gICAgdG9wID0gKGJhc2VIZWlnaHQgKiBvZmZzZXRTdGFydCkgLyBiYXNlTVM7XG4gICAgaGVpZ2h0ID0gKGJhc2VIZWlnaHQgKiB2aWV3TW9kZWwuZHVyYXRpb24oKSkgLyBiYXNlTVM7XG4gICAgd2lkdGggPSBvcHRpb25zLmJhc2VXaWR0aCAqICh2aWV3TW9kZWwuZXh0cmFTcGFjZSArIDEpO1xuXG4gICAgLy8gc2V0IHdpZHRoIGF1dG8gd2hlbiBoYXMgbm8gY29sbGlzaW9ucy5cbiAgICBpZiAoIXZpZXdNb2RlbC5oYXNDb2xsaWRlKSB7XG4gICAgICAgIHdpZHRoID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgbGVmdDogb3B0aW9ucy5iYXNlTGVmdFtvcHRpb25zLmNvbHVtbkluZGV4XSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG59O1xuXG4vKipcbiAqIFNldCB2aWV3bW9kZWxzIGZvciByZW5kZXJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30geW1kIFRoZSBkYXRlIG9mIGV2ZW50cy4gWVlZWU1NREQgZm9ybWF0LlxuICogQHBhcmFtIHthcnJheX0gbWF0cmljZXMgVGhlIG1hdHJpY2VzIGZvciBldmVudCBwbGFjaW5nLlxuICovXG5UaW1lLnByb3RvdHlwZS5fZ2V0QmFzZVZpZXdNb2RlbCA9IGZ1bmN0aW9uKHltZCwgbWF0cmljZXMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgaG91clN0YXJ0ID0gb3B0aW9ucy5ob3VyU3RhcnQsXG4gICAgICAgIGhvdXJFbmQgPSBvcHRpb25zLmhvdXJFbmQsXG4gICAgICAgIGNvbnRhaW5lckhlaWdodCxcbiAgICAgICAgdG9kYXlTdGFydCxcbiAgICAgICAgYmFzZU1TO1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGVhY2ggZXZlbnQgZWxlbWVudCBib3VuZHMgcmVsYXRpdmUgd2l0aCByZW5kZXJlZCBob3VyIG1pbGxpc2Vjb25kcyBhbmRcbiAgICAgKiB3cmFwIGVhY2ggZXZlbnQgbW9kZWwgdG8gdmlld21vZGVscy5cbiAgICAgKi9cbiAgICBjb250YWluZXJIZWlnaHQgPSB0aGlzLmdldFZpZXdCb3VuZCgpLmhlaWdodDtcbiAgICB0b2RheVN0YXJ0ID0gdGhpcy5fcGFyc2VEYXRlR3JvdXAoeW1kKTtcbiAgICB0b2RheVN0YXJ0LnNldEhvdXJzKGhvdXJTdGFydCk7XG4gICAgYmFzZU1TID0gZGF0ZXRpbWUubWlsbGlzZWNvbmRzRnJvbSgnaG91cicsIChob3VyRW5kIC0gaG91clN0YXJ0KSk7XG5cbiAgICBmb3JFYWNoQXJyKG1hdHJpY2VzLCBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICAgICAgdmFyIG1heFJvd0xlbmd0aCxcbiAgICAgICAgICAgIHdpZHRoUGVyY2VudCxcbiAgICAgICAgICAgIGxlZnRQZXJjZW50cyxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgbWF4Um93TGVuZ3RoID0gTWF0aC5tYXguYXBwbHkobnVsbCwgdXRpbC5tYXAobWF0cml4LCBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiByb3cubGVuZ3RoO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgd2lkdGhQZXJjZW50ID0gMTAwIC8gbWF4Um93TGVuZ3RoO1xuXG4gICAgICAgIGxlZnRQZXJjZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWF4Um93TGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGxlZnRQZXJjZW50c1tpXSA9IHdpZHRoUGVyY2VudCAqIGk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JFYWNoQXJyKG1hdHJpeCwgZnVuY3Rpb24ocm93KSB7XG4gICAgICAgICAgICBmb3JFYWNoQXJyKHJvdywgZnVuY3Rpb24odmlld01vZGVsLCBjb2wpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmlld0JvdW5kO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3TW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZpZXdCb3VuZCA9IHRoaXMuZ2V0RXZlbnRWaWV3Qm91bmQodmlld01vZGVsLCB7XG4gICAgICAgICAgICAgICAgICAgIHRvZGF5U3RhcnQ6IHRvZGF5U3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VNUzogYmFzZU1TLFxuICAgICAgICAgICAgICAgICAgICBiYXNlTGVmdDogbGVmdFBlcmNlbnRzLFxuICAgICAgICAgICAgICAgICAgICBiYXNlV2lkdGg6IHdpZHRoUGVyY2VudCxcbiAgICAgICAgICAgICAgICAgICAgYmFzZUhlaWdodDogY29udGFpbmVySGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleDogY29sXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB1dGlsLmV4dGVuZCh2aWV3TW9kZWwsIHZpZXdCb3VuZCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtEYXRlfSAtIERhdGUgb2YgdGhpcyB2aWV3LlxuICovXG5UaW1lLnByb3RvdHlwZS5nZXREYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlRGF0ZUdyb3VwKHRoaXMub3B0aW9ucy55bWQpO1xufTtcblxuXG4vKipcbiAqIEBvdmVycmlkZVxuICogQHBhcmFtIHtzdHJpbmd9IHltZCBUaGUgZGF0ZSBvZiBldmVudHMuIFlZWVlNTUREIGZvcm1hdFxuICogQHBhcmFtIHthcnJheX0gbWF0cmljZXMgTWF0cmljZXMgZm9yIHBsYWNpbmcgZXZlbnRzXG4gKi9cblRpbWUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHltZCwgbWF0cmljZXMpIHtcbiAgICB0aGlzLl9nZXRCYXNlVmlld01vZGVsKHltZCwgbWF0cmljZXMpO1xuICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9IHRpbWVUbXBsKHtcbiAgICAgICAgbWF0cmljZXM6IG1hdHJpY2VzXG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBWaWV3IGZvciByZW5kZXJlZCBldmVudHMgYnkgdGltZXMuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgcmVxQW5pbUZyYW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL3JlcUFuaW1GcmFtZScpO1xudmFyIFZpZXcgPSByZXF1aXJlKCcuLi92aWV3Jyk7XG52YXIgVGltZSA9IHJlcXVpcmUoJy4vdGltZScpO1xudmFyIEF1dG9TY3JvbGwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vYXV0b1Njcm9sbCcpO1xudmFyIG1haW5UbXBsID0gcmVxdWlyZSgnLi4vdGVtcGxhdGUvd2Vlay90aW1lR3JpZC5oYnMnKTtcblxudmFyIFBJWEVMX1JFTkRFUl9FUlJPUiA9IDAuNTtcbnZhciBIT1VSTUFSS0VSX1JFRlJFU0hfSU5URVJWQUwgPSAxMDAwICogMTA7XG52YXIgSU5JVElBTF9BVVRPU0NST0xMX0RFTEFZID0gdXRpbC5icm93c2VyLm1zaWUgPyAxMDAgOiA1MDtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtWaWV3fVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgVGhlIG9iamVjdCBmb3IgdmlldyBjdXN0b21pemF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhvdXJTdGFydD0wXSBZb3UgY2FuIGNoYW5nZSB2aWV3J3Mgc3RhcnQgaG91cnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaG91ckVuZD0wXSBZb3UgY2FuIGNoYW5nZSB2aWV3J3MgZW5kIGhvdXJzLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIENvbnRhaW5lciBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBUaW1lR3JpZChvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICBjb250YWluZXIgPSBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAnc2NoZWR1bGUtdmlldy10aW1lZ3JpZC1jb250YWluZXInXG4gICAgKTtcblxuICAgIFZpZXcuY2FsbCh0aGlzLCBudWxsLCBjb250YWluZXIpO1xuXG4gICAgaWYgKCF1dGlsLmJyb3dzZXIuc2FmYXJpKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXV0b1Njcm9sbH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2F1dG9TY3JvbGwgPSBuZXcgQXV0b1Njcm9sbChjb250YWluZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRpbWUgdmlldyBvcHRpb25zLlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICBob3VyU3RhcnQ6IDAsXG4gICAgICAgIGhvdXJFbmQ6IDI0XG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcnZhbCBpZCBmb3IgaG91cm1hcmtlciBhbmltYXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmludGVydmFsSUQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fc2Nyb2xsZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuYXR0YWNoRXZlbnQoKTtcbn1cblxudXRpbC5pbmhlcml0KFRpbWVHcmlkLCBWaWV3KTtcblxuLyoqKioqKioqKipcbiAqIFByb3RvdHlwZSBwcm9wc1xuICoqKioqKioqKiovXG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuVGltZUdyaWQucHJvdG90eXBlLnZpZXdOYW1lID0gJ3RpbWVncmlkJztcblxuLyoqXG4gKiBEZXN0cm95IHZpZXcuXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVGltZUdyaWQucHJvdG90eXBlLl9iZWZvcmVEZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElEKTtcblxuICAgIGlmICh0aGlzLl9hdXRvU2Nyb2xsKSB7XG4gICAgICAgIHRoaXMuX2F1dG9TY3JvbGwuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2F1dG9TY3JvbGwgPSB0aGlzLmhvdXJtYXJrZXIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgYmFzZSB2aWV3TW9kZWwuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBWaWV3TW9kZWxcbiAqL1xuVGltZUdyaWQucHJvdG90eXBlLl9nZXRCYXNlVmlld01vZGVsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGVuZCA9IG9wdGlvbnMuaG91ckVuZCxcbiAgICAgICAgaSA9IG9wdGlvbnMuaG91clN0YXJ0LFxuICAgICAgICBob3VycyA9IFtdO1xuXG4gICAgZm9yICg7IGkgPCBlbmQ7IGkgKz0gMSkge1xuICAgICAgICBob3Vycy5wdXNoKHtob3VyOiBpfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtob3VyczogaG91cnN9O1xufTtcblxuLyoqXG4gKiBSZWNvbmNpbGF0aW9uIGNoaWxkIHZpZXdzIGFuZCByZW5kZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gdmlld01vZGVscyBWaWV3bW9kZWxcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggcGVyY2VudCBvZiBlYWNoIHRpbWUgdmlldy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBDb250YWluZXIgZWxlbWVudCBmb3IgZWFjaCB0aW1lIHZpZXcuXG4gKi9cblRpbWVHcmlkLnByb3RvdHlwZS5fcmVuZGVyQ2hpbGRzID0gZnVuY3Rpb24odmlld01vZGVscywgd2lkdGgsIGNvbnRhaW5lcikge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBjaGlsZE9wdGlvbixcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIGlzVG9kYXksXG4gICAgICAgIHRvZGF5ID0gZGF0ZXRpbWUuZm9ybWF0KG5ldyBEYXRlKCksICdZWVlZTU1ERCcpO1xuXG4gICAgLy8gY2xlYXIgY29udGVudHNcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgdGhpcy5jaGlsZHMuY2xlYXIoKTtcbiAgICB0aGlzLnRvZGF5bWFya2VyTGVmdCA9IG51bGw7XG5cbiAgICAvLyByZWNvbmNpbGF0aW9uIG9mIGNoaWxkIHZpZXdzXG4gICAgdXRpbC5mb3JFYWNoKHZpZXdNb2RlbHMsIGZ1bmN0aW9uKGV2ZW50cywgeW1kKSB7XG4gICAgICAgIGlzVG9kYXkgPSB5bWQgPT09IHRvZGF5O1xuXG4gICAgICAgIGlmIChpc1RvZGF5KSB7XG4gICAgICAgICAgICB0aGlzLnRvZGF5bWFya2VyTGVmdCA9IHdpZHRoICogdGhpcy5jaGlsZHMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGRPcHRpb24gPSB7XG4gICAgICAgICAgICB5bWQ6IHltZCxcbiAgICAgICAgICAgIGlzVG9kYXk6IGlzVG9kYXksXG4gICAgICAgICAgICBob3VyU3RhcnQ6IG9wdGlvbnMuaG91clN0YXJ0LFxuICAgICAgICAgICAgaG91ckVuZDogb3B0aW9ucy5ob3VyRW5kXG4gICAgICAgIH07XG5cbiAgICAgICAgY2hpbGQgPSBuZXcgVGltZShcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgY2hpbGRPcHRpb24sXG4gICAgICAgICAgICBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KCdkaXYnLCBjb250YWluZXIsICdzY2hlZHVsZS12aWV3LXRpbWUtZGF0ZScpXG4gICAgICAgICk7XG4gICAgICAgIGNoaWxkLnJlbmRlcih5bWQsIGV2ZW50cyk7XG5cbiAgICAgICAgdGhpcy5hZGRDaGlsZChjaGlsZCk7XG4gICAgfSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICogQHBhcmFtIHtvYmplY3R9IHZpZXdNb2RlbCBWaWV3TW9kZWwgbGlzdCBmcm9tIFdlZWsgdmlldy5cbiAqL1xuVGltZUdyaWQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgIHZhciB0aW1lVmlld01vZGVsID0gdmlld01vZGVsLmV2ZW50c0luRGF0ZVJhbmdlLnRpbWUsXG4gICAgICAgIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLFxuICAgICAgICBiYXNlVmlld01vZGVsID0gdGhpcy5fZ2V0QmFzZVZpZXdNb2RlbCgpLFxuICAgICAgICBldmVudExlbiA9IHV0aWwua2V5cyh0aW1lVmlld01vZGVsKS5sZW5ndGg7XG5cbiAgICBpZiAoIWV2ZW50TGVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gbWFpblRtcGwoYmFzZVZpZXdNb2RlbCk7XG5cbiAgICAvKioqKioqKioqKlxuICAgICAqIFJlbmRlciBjaGlsZHNcbiAgICAgKioqKioqKioqKi9cbiAgICB0aGlzLl9yZW5kZXJDaGlsZHMoXG4gICAgICAgIHRpbWVWaWV3TW9kZWwsXG4gICAgICAgIDEwMCAvIGV2ZW50TGVuLFxuICAgICAgICBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LXRpbWVncmlkLWV2ZW50cy1jb250YWluZXInLCBjb250YWluZXIpXG4gICAgKTtcblxuICAgIHRoaXMuX2hvdXJMYWJlbHMgPSBkb211dGlsLmZpbmQoJ3VsJywgY29udGFpbmVyKTtcblxuICAgIC8qKioqKioqKioqXG4gICAgICogUmVuZGVyIGhvdXJtYXJrZXJcbiAgICAgKioqKioqKioqKi9cbiAgICB0aGlzLmhvdXJtYXJrZXIgPSBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LXRpbWVncmlkLWhvdXJtYXJrZXInLCBjb250YWluZXIpO1xuICAgIHRoaXMucmVmcmVzaEhvdXJtYXJrZXIoKTtcblxuICAgIGlmICghdGhpcy5fc2Nyb2xsZWQpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNjcm9sbFRvTm93KCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZWZyZXNoIGhvdXJtYXJrZXIgZWxlbWVudC5cbiAqL1xuVGltZUdyaWQucHJvdG90eXBlLnJlZnJlc2hIb3VybWFya2VyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhvdXJMYWJlbHMgPSB0aGlzLl9ob3VyTGFiZWxzLFxuICAgICAgICBob3VybWFya2VyID0gdGhpcy5ob3VybWFya2VyLFxuXG4gICAgICAgIHZpZXdNb2RlbCA9IHRoaXMuX2dldEhvdXJtYXJrZXJWaWV3TW9kZWwoKSxcbiAgICAgICAgdG9kYXltYXJrZXJMZWZ0ID0gdGhpcy50b2RheW1hcmtlckxlZnQsXG4gICAgICAgIHRvZGF5bWFya2VyLFxuICAgICAgICB0ZXh0LFxuICAgICAgICBsYWJlbFRvVmlzaWJsZSxcbiAgICAgICAgbGFiZWxUb0ludmlzaWJsZTtcblxuICAgIGlmICghaG91cm1hcmtlciB8fCAhdmlld01vZGVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2RheW1hcmtlciA9IGRvbXV0aWwuZmluZCgnLnNjaGVkdWxlLXZpZXctdGltZWdyaWQtdG9kYXltYXJrZXInLCBob3VybWFya2VyKTtcbiAgICB0ZXh0ID0gZG9tdXRpbC5maW5kKCcuc2NoZWR1bGUtdmlldy10aW1lZ3JpZC1ob3VybWFya2VyLXRpbWUnLCBob3VybWFya2VyKTtcbiAgICBsYWJlbFRvVmlzaWJsZSA9IGRvbXV0aWwuZmluZCgnLnNjaGVkdWxlLWludmlzaWJsZScsIGhvdXJMYWJlbHMpO1xuICAgIGxhYmVsVG9JbnZpc2libGUgPSBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LXRpbWVncmlkLWhvdXItJyArIHZpZXdNb2RlbC5ob3VyLCBob3VyTGFiZWxzKTtcblxuICAgIHJlcUFuaW1GcmFtZS5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobGFiZWxUb1Zpc2libGUgIT09IGxhYmVsVG9JbnZpc2libGUpIHtcbiAgICAgICAgICAgIGlmIChsYWJlbFRvVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGRvbXV0aWwucmVtb3ZlQ2xhc3MobGFiZWxUb1Zpc2libGUsICdzY2hlZHVsZS1pbnZpc2libGUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxhYmVsVG9JbnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBkb211dGlsLmFkZENsYXNzKGxhYmVsVG9JbnZpc2libGUsICdzY2hlZHVsZS1pbnZpc2libGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGhvdXJtYXJrZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIGhvdXJtYXJrZXIuc3R5bGUudG9wID0gKHZpZXdNb2RlbC50b3AgLSBQSVhFTF9SRU5ERVJfRVJST1IpICsgJ3B4JztcblxuICAgICAgICBpZiAoIXV0aWwuaXNOdWxsKHRvZGF5bWFya2VyTGVmdCkpIHtcbiAgICAgICAgICAgIHRvZGF5bWFya2VyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgdG9kYXltYXJrZXIuc3R5bGUubGVmdCA9IHRvZGF5bWFya2VyTGVmdCArICclJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvZGF5bWFya2VyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0LmlubmVySFRNTCA9IHZpZXdNb2RlbC50ZXh0O1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gZ3JpZCBzaXplLlxuICogQHJldHVybnMge251bWJlcltdfSBUaGUgc2l6ZSBvZiBncmlkIGVsZW1lbnQuXG4gKi9cblRpbWVHcmlkLnByb3RvdHlwZS5fZ2V0R3JpZFNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdGhpcy5jb250YWluZXIuY2hpbGROb2Rlc1swXTtcblxuICAgIGlmICghY2hpbGROb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9tdXRpbC5nZXRTaXplKGNoaWxkTm9kZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RGF0ZX0gW3RpbWVdIC0gZGF0ZSBvYmplY3QgdG8gY29udmVydCBwaXhlbCBpbiBncmlkcy5cbiAqIHVzZSAqKkRhdGUubm93KCkqKiB3aGVuIG5vdCBzdXBwbGllZC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBwaXhlbCB2YWx1ZSByZXByZXNlbnQgY3VycmVudCB0aW1lIGluIGdyaWRzLlxuICovXG5UaW1lR3JpZC5wcm90b3R5cGUuX2dldFRvcEJ5VGltZSA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICB2YXIgbm93ID0gdXRpbC5pc0RhdGUodGltZSkgPyBuZXcgRGF0ZSh0aW1lLmdldFRpbWUoKSkgOiBuZXcgRGF0ZSgpLFxuICAgICAgICBzdGFydCA9IGRhdGV0aW1lLnN0YXJ0KG5vdyksXG4gICAgICAgIGhvdXJTdGFydCA9IHRoaXMub3B0aW9ucy5ob3VyU3RhcnQsXG4gICAgICAgIGdyaWRTaXplID0gdGhpcy5fZ2V0R3JpZFNpemUoKSxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICB0b3A7XG5cbiAgICBpZiAoIWdyaWRTaXplKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIG9mZnNldCA9ICtub3cgLSArc3RhcnQ7XG4gICAgaWYgKGhvdXJTdGFydCkge1xuICAgICAgICBvZmZzZXQgLT0gZGF0ZXRpbWUubWlsbGlzZWNvbmRzRnJvbSgnaG91cicsIGhvdXJTdGFydCk7XG4gICAgfVxuXG4gICAgdG9wID0gKG9mZnNldCAqIGdyaWRTaXplWzFdKSAvIChkYXRldGltZS5taWxsaXNlY29uZHNGcm9tKCdob3VyJywgdGhpcy5fZ2V0QmFzZVZpZXdNb2RlbCgpLmhvdXJzLmxlbmd0aCkpO1xuXG4gICAgcmV0dXJuIHRvcDtcbn07XG5cbi8qKlxuICogR2V0IEhvdXJtYXJrZXIgdmlld21vZGVsLlxuICogQHJldHVybnMge29iamVjdH0gVmlld01vZGVsIG9mIGhvdXJtYXJrZXIuXG4gKi9cblRpbWVHcmlkLnByb3RvdHlwZS5fZ2V0SG91cm1hcmtlclZpZXdNb2RlbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiB0aGlzLl9nZXRUb3BCeVRpbWUoKSxcbiAgICAgICAgaG91cjogbm93LmdldEhvdXJzKCksXG4gICAgICAgIHRleHQ6IGRhdGV0aW1lLmZvcm1hdChub3csICdISDptbScpXG4gICAgfTtcbn07XG5cbi8qKlxuICogQXR0YWNoIGV2ZW50c1xuICovXG5UaW1lR3JpZC5wcm90b3R5cGUuYXR0YWNoRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSUQpO1xuICAgIHRoaXMuaW50ZXJ2YWxJRCA9IHdpbmRvdy5zZXRJbnRlcnZhbCh1dGlsLmJpbmQodGhpcy5vblRpY2ssIHRoaXMpLCBIT1VSTUFSS0VSX1JFRlJFU0hfSU5URVJWQUwpO1xufTtcblxuLyoqXG4gKiBTY3JvbGwgdGltZSBncmlkIHRvIGN1cnJlbnQgaG91cm1hcmtlci5cbiAqL1xuVGltZUdyaWQucHJvdG90eXBlLnNjcm9sbFRvTm93ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1cnJlbnRIb3VyVG9wID0gdGhpcy5fZ2V0VG9wQnlUaW1lKCksXG4gICAgICAgIHZpZXdCb3VuZCA9IHRoaXMuZ2V0Vmlld0JvdW5kKCksXG4gICAgICAgIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuXG4gICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgPSAoMCwgY3VycmVudEhvdXJUb3AgLSAodmlld0JvdW5kLmhlaWdodCAvIDIpKTtcbiAgICB9LCBJTklUSUFMX0FVVE9TQ1JPTExfREVMQVkpO1xufTtcblxuLyoqKioqKioqKipcbiAqIEV2ZW50IGhhbmRsZXJzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBJbnRlcnZhbCB0aWNrIGhhbmRsZXJcbiAqL1xuVGltZUdyaWQucHJvdG90eXBlLm9uVGljayA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVmcmVzaEhvdXJtYXJrZXIoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZUdyaWQ7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBWaWV3IG9mIGRheXMgVUkuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXcnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QmFzZS5XZWVrfSBjb250cm9sbGVyIFRoZSBjb250cm9sbGVyIG1peGluIHBhcnQuXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBWaWV3IG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZW5kZXJTdGFydERhdGVdIFN0YXJ0IGRhdGUgb2YgcmVuZGVyLiBpZiBub3Qgc3VwcGxpZWQgdGhlbiB1c2UgLTNkIGZyb20gdG9kYXkuIFlZWVktTU0tREQgZm9ybWF0LlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlbmRlckVuZERhdGVdIEVuZCBkYXRlIG9mIHJlbmRlci4gaWYgbm90IHN1cHBsaWVkIHRoZW4gdXNlICszZCBmcm9tIHRvZGF5LiBZWVlZLU1NLUREIGZvcm1hdC5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBUaGUgZWxlbWVudCB0byB1c2UgY29udGFpbmVyIGZvciB0aGlzIHZpZXcuXG4gKiBAZXh0ZW5kcyB7Vmlld31cbiAqL1xuZnVuY3Rpb24gV2Vlayhjb250cm9sbGVyLCBvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICB2YXIgcmFuZ2U7XG5cbiAgICBjb250YWluZXIgPSBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAnc2NoZWR1bGUtdmlldy13ZWVrLWNvbnRhaW5lcidcbiAgICApO1xuXG4gICAgVmlldy5jYWxsKHRoaXMsIG51bGwsIGNvbnRhaW5lcik7XG5cbiAgICByYW5nZSA9IHRoaXMuX2dldFJlbmRlckRhdGVSYW5nZShuZXcgRGF0ZSgpKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtvYmplY3R9IE9wdGlvbnMgZm9yIHZpZXcuXG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICByZW5kZXJTdGFydERhdGU6IGRhdGV0aW1lLmZvcm1hdChyYW5nZS5zdGFydCwgJ1lZWVktTU0tREQnKSxcbiAgICAgICAgcmVuZGVyRW5kRGF0ZTogZGF0ZXRpbWUuZm9ybWF0KHJhbmdlLmVuZCwgJ1lZWVktTU0tREQnKVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogV2VlayBjb250cm9sbGVyIG1peGluLlxuICAgICAqIEB0eXBlIHtCYXNlLldlZWt9XG4gICAgICovXG4gICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbn1cblxudXRpbC5pbmhlcml0KFdlZWssIFZpZXcpO1xuXG4vKioqKioqKioqKlxuICogT3ZlcnJpZGUgcHJvcHNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIFJlbmRlciBlYWNoIGNoaWxkIHZpZXcgd2l0aCBldmVudHMgaW4gcmFuZ2VzLlxuICovXG5XZWVrLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgcmVuZGVyU3RhcnREYXRlID0gZGF0ZXRpbWUucGFyc2Uob3B0aW9ucy5yZW5kZXJTdGFydERhdGUpLFxuICAgICAgICByZW5kZXJFbmREYXRlID0gZGF0ZXRpbWUucGFyc2Uob3B0aW9ucy5yZW5kZXJFbmREYXRlKSxcbiAgICAgICAgZXZlbnRzSW5EYXRlUmFuZ2UgPSB0aGlzLmNvbnRyb2xsZXIuZmluZEJ5RGF0ZVJhbmdlKFxuICAgICAgICAgICAgZGF0ZXRpbWUuc3RhcnQocmVuZGVyU3RhcnREYXRlKSxcbiAgICAgICAgICAgIGRhdGV0aW1lLmVuZChyZW5kZXJFbmREYXRlKVxuICAgICAgICApLFxuICAgICAgICB2aWV3TW9kZWwgPSB7XG4gICAgICAgICAgICBldmVudHNJbkRhdGVSYW5nZTogZXZlbnRzSW5EYXRlUmFuZ2UsXG4gICAgICAgICAgICByZW5kZXJTdGFydERhdGU6IHJlbmRlclN0YXJ0RGF0ZSxcbiAgICAgICAgICAgIHJlbmRlckVuZERhdGU6IHJlbmRlckVuZERhdGVcbiAgICAgICAgfTtcblxuICAgIHRoaXMuY2hpbGRzLmVhY2goZnVuY3Rpb24oY2hpbGRWaWV3KSB7XG4gICAgICAgIGNoaWxkVmlldy5yZW5kZXIodmlld01vZGVsKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogTGlzdGVuIGNoaWxkIHZpZXcncyByZXNpemUgZXZlbnQgYW5kIGhhbmRsZSBpdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgLSB0aGUgc3RyaW5nIHRvIHVzZSBncm91cCByZXF1ZXN0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbSAtIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gZm9yIHJlc2l6aW5nIHNlc3Npb24uXG4gKi9cbi8vIFdlZWsucHJvdG90eXBlLl9vblJlc2l6ZSA9IGZ1bmN0aW9uKHNvdXJjZSwgcGFyYW0pIHtcbi8vICAgICB2YXIgb3duQ2hpbGRzID0gdGhpcy5jaGlsZHMsXG4vLyAgICAgICAgIHRpbWVncmlkLFxuLy8gICAgICAgICBoZWlnaHQ7XG4vL1xuLy8gICAgIGlmIChzb3VyY2UgPT09ICdtb250aHdlZWs6cmVzaXplJykge1xuLy8gICAgICAgICB0aW1lZ3JpZCA9IG93bkNoaWxkcy5maW5kKGZ1bmN0aW9uKHZpZXcpIHtcbi8vICAgICAgICAgICAgIHJldHVybiB2aWV3LnZpZXdOYW1lID09PSAndGltZWdyaWQnO1xuLy8gICAgICAgICB9KS5zaW5nbGUoKTtcbi8vXG4vLyAgICAgICAgIGhlaWdodCA9IHRoaXMudGltZUdyaWRPcmlnaW5IZWlnaHQ7XG4vL1xuLy8gICAgICAgICBpZiAoIXRoaXMudGltZUdyaWRPcmlnaW5IZWlnaHQpIHtcbi8vICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMudGltZUdyaWRPcmlnaW5IZWlnaHQgPSBkb211dGlsLmdldFNpemUodGltZWdyaWQuY29udGFpbmVyKVsxXTtcbi8vICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgdGltZWdyaWQuY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IChoZWlnaHQgLSBwYXJhbSkgKyAncHgnO1xuLy8gICAgICAgICByZXR1cm47XG4vLyAgICAgfVxuLy8gfTtcblxuLyoqKioqKioqKipcbiAqIFByb3RvdHlwZSBwcm9wc1xuICoqKioqKioqKiovXG5cbldlZWsucHJvdG90eXBlLnZpZXdOYW1lID0gJ3dlZWsnO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBkZWZhdWx0IHJlbmRlciBkYXRlIHJhbmdlIGZyb20gc3VwcGxpZWQgZGF0ZS5cbiAqIEBwYXJhbSB7RGF0ZX0gYmFzZURhdGUgYmFzZSBkYXRlLlxuICogQHJldHVybnMge29iamVjdH0gZGF0ZSByYW5nZS5cbiAqL1xuV2Vlay5wcm90b3R5cGUuX2dldFJlbmRlckRhdGVSYW5nZSA9IGZ1bmN0aW9uKGJhc2VEYXRlKSB7XG4gICAgdmFyIGJhc2UgPSBkYXRldGltZS5zdGFydChiYXNlRGF0ZSksXG4gICAgICAgIHN0YXJ0ID0gbmV3IERhdGUoK2Jhc2UpLFxuICAgICAgICBlbmQgPSBuZXcgRGF0ZSgrYmFzZSk7XG5cbiAgICBzdGFydC5zZXREYXRlKHN0YXJ0LmdldERhdGUoKSAtIDMpO1xuICAgIGVuZC5zZXREYXRlKGVuZC5nZXREYXRlKCkgKyAzKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgZW5kOiBlbmRcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWVrO1xuXG4iXX0=
