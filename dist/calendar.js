(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
/**
 * Dooray Calendar
 * @version 0.1.12
 */
/* eslint vars-on-top:0, strict:0 */

/**********
 * Common
 **********/
require('tui-code-snippet');
require('./src/js/view/template/registerHelpers');
var config = require('./src/js/config');
var dirty = require('./src/js/common/dirty');
var datetime = require('./src/js/common/datetime');
var array = require('./src/js/common/array');
var domevent = require('./src/js/common/domevent');
var domutil = require('./src/js/common/domutil');
var Colleciton = require('./src/js/common/collection');
var model = require('./src/js/common/model');
var common = require('./src/js/common/common');
var reqAnimFrame = require('./src/js/common/reqAnimFrame');
var AJAX = require('./src/js/common/ajax');
var FillRemainHeight = require('./src/js/common/fillRemainHeight');

/**********
 * Models
 **********/
var Point = require('./src/js/common/point');
var CalEvent = require('./src/js/model/calEvent');
var CalEventViewModel = require('./src/js/model/viewModel/calEvent');

/**********
 * Views
 **********/
var View = require('./src/js/view/view');
View.prototype.cssPrefix = config.cssPrefix;

var MonthWeek = require('./src/js/view/monthweek');
var Week = require('./src/js/view/week/week');
var DayName = require('./src/js/view/week/dayname');
var TimeGrid = require('./src/js/view/week/timeGrid');
var Time = require('./src/js/view/week/time');

/**********
 * Handlers
 **********/
var Drag = require('./src/js/handler/drag');
var TimeCore = require('./src/js/handler/time/core');
var TimeClick = require('./src/js/handler/time/click');
var TimeCreation = require('./src/js/handler/time/creation');
var TimeCreationGuide = require('./src/js/handler/time/creationGuide');
var TimeMove = require('./src/js/handler/time/move');
var TimeMoveGuide = require('./src/js/handler/time/moveGuide');
var TimeResize = require('./src/js/handler/time/resize');
var TimeResizeGuide = require('./src/js/handler/time/resizeGuide');

var AlldayCore = require('./src/js/handler/allday/core');
var AlldayClick = require('./src/js/handler/allday/click');
var AlldayCreation = require('./src/js/handler/allday/creation');
var AlldayCreationGuide = require('./src/js/handler/allday/creationGuide');
var AlldayMove = require('./src/js/handler/allday/move');
var AlldayMoveGuide = require('./src/js/handler/allday/moveGuide');
var AlldayResize = require('./src/js/handler/allday/resize');
var AlldayResizeGuide = require('./src/js/handler/allday/resizeGuide');

/**********
 * Factory
 **********/
var controllerFactory = require('./src/js/factory/controller');

/**********
 * SERVICE MODULE
 **********/
var MiniCalendar = require('./src/js/dooray/view/minicalendar');
var DoorayEvent = require('./src/js/dooray/model/calEvent');
var DoorayController = require('./src/js/dooray/controller/base');
var TaskView = require('./src/js/dooray/view/taskview');
var MilestoneClick = require('./src/js/dooray/handler/milestoneClick');
var TaskClick = require('./src/js/dooray/handler/taskClick');

/**********
 * Calendar Factory
 **********/

var Calendar = require('./src/js/factory/calendar');
var ServiceCalendar = require('./src/js/dooray/factory/calendar');

/** @namespace ne.dooray.calendar */
global.tui.util.defineNamespace('ne.dooray.calendar', {
    // common
    config: config,
    dirty: dirty,
    datetime: datetime,
    array: array,
    domevent: domevent,
    domutil: domutil,
    Collection: Colleciton,
    model: model,
    common: common,
    reqAnimFrame: reqAnimFrame,
    AJAX: AJAX,
    Point: Point, 
    FillRemainHeight: FillRemainHeight,

    // model
    CalEvent: CalEvent,
    CalEventViewModel: CalEventViewModel,

    // view
    View: View,
    Week: Week,
    DayName: DayName,
    TimeGrid: TimeGrid,
    Time: Time,
    MonthWeek: MonthWeek,

    // handler, guide
    Drag: Drag,

    TimeCore: TimeCore,
    TimeClick: TimeClick,
    TimeCreation: TimeCreation,
    TimeCreationGuide: TimeCreationGuide,
    TimeMove: TimeMove,
    TimeMoveGuide: TimeMoveGuide,
    TimeResize: TimeResize,
    TimeResizeGuide: TimeResizeGuide,

    AlldayCore: AlldayCore,
    AlldayClick: AlldayClick,
    AlldayCreation: AlldayCreation,
    AlldayCreationGuide: AlldayCreationGuide,
    AlldayMove: AlldayMove,
    AlldayMoveGuide: AlldayMoveGuide,
    AlldayResize: AlldayResize,
    AlldayResizeGuide: AlldayResizeGuide,

    // only for test
    ControllerFactory: controllerFactory,

    // service modules
    DoorayEvent: DoorayEvent,
    DoorayController: DoorayController,
    MiniCalendar: MiniCalendar,
    TaskView: TaskView,
    MilestoneClick: MilestoneClick,
    TaskClick: TaskClick,

    // factory class
    OriginCalendar: Calendar,
    FullCalendar: ServiceCalendar
});


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./src/js/common/ajax":23,"./src/js/common/array":24,"./src/js/common/collection":26,"./src/js/common/common":27,"./src/js/common/datetime":28,"./src/js/common/dirty":29,"./src/js/common/domevent":30,"./src/js/common/domutil":31,"./src/js/common/fillRemainHeight":32,"./src/js/common/model":33,"./src/js/common/point":34,"./src/js/common/reqAnimFrame":35,"./src/js/config":36,"./src/js/dooray/controller/base":39,"./src/js/dooray/factory/calendar":40,"./src/js/dooray/handler/milestoneClick":42,"./src/js/dooray/handler/taskClick":43,"./src/js/dooray/model/calEvent":44,"./src/js/dooray/view/minicalendar":48,"./src/js/dooray/view/taskview":50,"./src/js/factory/calendar":52,"./src/js/factory/controller":53,"./src/js/handler/allday/click":55,"./src/js/handler/allday/core":56,"./src/js/handler/allday/creation":57,"./src/js/handler/allday/creationGuide":58,"./src/js/handler/allday/move":59,"./src/js/handler/allday/moveGuide":60,"./src/js/handler/allday/resize":61,"./src/js/handler/allday/resizeGuide":62,"./src/js/handler/drag":63,"./src/js/handler/time/click":64,"./src/js/handler/time/core":65,"./src/js/handler/time/creation":66,"./src/js/handler/time/creationGuide":67,"./src/js/handler/time/move":68,"./src/js/handler/time/moveGuide":69,"./src/js/handler/time/resize":70,"./src/js/handler/time/resizeGuide":71,"./src/js/model/calEvent":72,"./src/js/model/viewModel/calEvent":73,"./src/js/view/monthweek":75,"./src/js/view/template/registerHelpers":79,"./src/js/view/view":84,"./src/js/view/week/dayname":86,"./src/js/view/week/time":87,"./src/js/view/week/timeGrid":88,"./src/js/view/week/week":89,"tui-code-snippet":2}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _handlebarsBase = require('./handlebars/base');

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)

var base = _interopRequireWildcard(_handlebarsBase);

var _handlebarsSafeString = require('./handlebars/safe-string');

var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

var _handlebarsException = require('./handlebars/exception');

var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

var _handlebarsUtils = require('./handlebars/utils');

var Utils = _interopRequireWildcard(_handlebarsUtils);

var _handlebarsRuntime = require('./handlebars/runtime');

var runtime = _interopRequireWildcard(_handlebarsRuntime);

var _handlebarsNoConflict = require('./handlebars/no-conflict');

// For compatibility and usage outside of module systems, make the Handlebars object a namespace

var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

function create() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = _handlebarsSafeString2['default'];
  hb.Exception = _handlebarsException2['default'];
  hb.Utils = Utils;
  hb.escapeExpression = Utils.escapeExpression;

  hb.VM = runtime;
  hb.template = function (spec) {
    return runtime.template(spec, hb);
  };

  return hb;
}

var inst = create();
inst.create = create;

_handlebarsNoConflict2['default'](inst);

inst['default'] = inst;

exports['default'] = inst;
module.exports = exports['default'];


},{"./handlebars/base":4,"./handlebars/exception":7,"./handlebars/no-conflict":17,"./handlebars/runtime":18,"./handlebars/safe-string":19,"./handlebars/utils":20}],4:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.HandlebarsEnvironment = HandlebarsEnvironment;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _helpers = require('./helpers');

var _decorators = require('./decorators');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var VERSION = '4.0.4';
exports.VERSION = VERSION;
var COMPILER_REVISION = 7;

exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '== 1.x.x',
  5: '== 2.0.0-alpha.x',
  6: '>= 2.0.0-beta.1',
  7: '>= 4.0.0'
};

exports.REVISION_CHANGES = REVISION_CHANGES;
var objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials, decorators) {
  this.helpers = helpers || {};
  this.partials = partials || {};
  this.decorators = decorators || {};

  _helpers.registerDefaultHelpers(this);
  _decorators.registerDefaultDecorators(this);
}

HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: _logger2['default'],
  log: _logger2['default'].log,

  registerHelper: function registerHelper(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple helpers');
      }
      _utils.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn;
    }
  },
  unregisterHelper: function unregisterHelper(name) {
    delete this.helpers[name];
  },

  registerPartial: function registerPartial(name, partial) {
    if (_utils.toString.call(name) === objectType) {
      _utils.extend(this.partials, name);
    } else {
      if (typeof partial === 'undefined') {
        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
      }
      this.partials[name] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name) {
    delete this.partials[name];
  },

  registerDecorator: function registerDecorator(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple decorators');
      }
      _utils.extend(this.decorators, name);
    } else {
      this.decorators[name] = fn;
    }
  },
  unregisterDecorator: function unregisterDecorator(name) {
    delete this.decorators[name];
  }
};

var log = _logger2['default'].log;

exports.log = log;
exports.createFrame = _utils.createFrame;
exports.logger = _logger2['default'];


},{"./decorators":5,"./exception":7,"./helpers":8,"./logger":16,"./utils":20}],5:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultDecorators = registerDefaultDecorators;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _decoratorsInline = require('./decorators/inline');

var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

function registerDefaultDecorators(instance) {
  _decoratorsInline2['default'](instance);
}


},{"./decorators/inline":6}],6:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerDecorator('inline', function (fn, props, container, options) {
    var ret = fn;
    if (!props.partials) {
      props.partials = {};
      ret = function (context, options) {
        // Create a new partials stack frame prior to exec.
        var original = container.partials;
        container.partials = _utils.extend({}, original, props.partials);
        var ret = fn(context, options);
        container.partials = original;
        return ret;
      };
    }

    props.partials[options.args[0]] = options.fn;

    return ret;
  });
};

module.exports = exports['default'];


},{"../utils":20}],7:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var loc = node && node.loc,
      line = undefined,
      column = undefined;
  if (loc) {
    line = loc.start.line;
    column = loc.start.column;

    message += ' - ' + line + ':' + column;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  /* istanbul ignore else */
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, Exception);
  }

  if (loc) {
    this.lineNumber = line;
    this.column = column;
  }
}

Exception.prototype = new Error();

exports['default'] = Exception;
module.exports = exports['default'];


},{}],8:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultHelpers = registerDefaultHelpers;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _helpersBlockHelperMissing = require('./helpers/block-helper-missing');

var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

var _helpersEach = require('./helpers/each');

var _helpersEach2 = _interopRequireDefault(_helpersEach);

var _helpersHelperMissing = require('./helpers/helper-missing');

var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

var _helpersIf = require('./helpers/if');

var _helpersIf2 = _interopRequireDefault(_helpersIf);

var _helpersLog = require('./helpers/log');

var _helpersLog2 = _interopRequireDefault(_helpersLog);

var _helpersLookup = require('./helpers/lookup');

var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

var _helpersWith = require('./helpers/with');

var _helpersWith2 = _interopRequireDefault(_helpersWith);

function registerDefaultHelpers(instance) {
  _helpersBlockHelperMissing2['default'](instance);
  _helpersEach2['default'](instance);
  _helpersHelperMissing2['default'](instance);
  _helpersIf2['default'](instance);
  _helpersLog2['default'](instance);
  _helpersLookup2['default'](instance);
  _helpersWith2['default'](instance);
}


},{"./helpers/block-helper-missing":9,"./helpers/each":10,"./helpers/helper-missing":11,"./helpers/if":12,"./helpers/log":13,"./helpers/lookup":14,"./helpers/with":15}],9:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('blockHelperMissing', function (context, options) {
    var inverse = options.inverse,
        fn = options.fn;

    if (context === true) {
      return fn(this);
    } else if (context === false || context == null) {
      return inverse(this);
    } else if (_utils.isArray(context)) {
      if (context.length > 0) {
        if (options.ids) {
          options.ids = [options.name];
        }

        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      if (options.data && options.ids) {
        var data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
        options = { data: data };
      }

      return fn(context, options);
    }
  });
};

module.exports = exports['default'];


},{"../utils":20}],10:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('../utils');

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('each', function (context, options) {
    if (!options) {
      throw new _exception2['default']('Must pass iterator to #each');
    }

    var fn = options.fn,
        inverse = options.inverse,
        i = 0,
        ret = '',
        data = undefined,
        contextPath = undefined;

    if (options.data && options.ids) {
      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
    }

    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    if (options.data) {
      data = _utils.createFrame(options.data);
    }

    function execIteration(field, index, last) {
      if (data) {
        data.key = field;
        data.index = index;
        data.first = index === 0;
        data.last = !!last;

        if (contextPath) {
          data.contextPath = contextPath + field;
        }
      }

      ret = ret + fn(context[field], {
        data: data,
        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
      });
    }

    if (context && typeof context === 'object') {
      if (_utils.isArray(context)) {
        for (var j = context.length; i < j; i++) {
          if (i in context) {
            execIteration(i, i, i === context.length - 1);
          }
        }
      } else {
        var priorKey = undefined;

        for (var key in context) {
          if (context.hasOwnProperty(key)) {
            // We're running the iterations one step out of sync so we can detect
            // the last iteration without have to scan the object twice and create
            // an itermediate keys array.
            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1);
            }
            priorKey = key;
            i++;
          }
        }
        if (priorKey !== undefined) {
          execIteration(priorKey, i - 1, true);
        }
      }
    }

    if (i === 0) {
      ret = inverse(this);
    }

    return ret;
  });
};

module.exports = exports['default'];


},{"../exception":7,"../utils":20}],11:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('helperMissing', function () /* [args, ]options */{
    if (arguments.length === 1) {
      // A missing field in a {{foo}} construct.
      return undefined;
    } else {
      // Someone is actually trying to call something, blow up.
      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    }
  });
};

module.exports = exports['default'];


},{"../exception":7}],12:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('if', function (conditional, options) {
    if (_utils.isFunction(conditional)) {
      conditional = conditional.call(this);
    }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function (conditional, options) {
    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
  });
};

module.exports = exports['default'];


},{"../utils":20}],13:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('log', function () /* message, options */{
    var args = [undefined],
        options = arguments[arguments.length - 1];
    for (var i = 0; i < arguments.length - 1; i++) {
      args.push(arguments[i]);
    }

    var level = 1;
    if (options.hash.level != null) {
      level = options.hash.level;
    } else if (options.data && options.data.level != null) {
      level = options.data.level;
    }
    args[0] = level;

    instance.log.apply(instance, args);
  });
};

module.exports = exports['default'];


},{}],14:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('lookup', function (obj, field) {
    return obj && obj[field];
  });
};

module.exports = exports['default'];


},{}],15:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('with', function (context, options) {
    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    var fn = options.fn;

    if (!_utils.isEmpty(context)) {
      var data = options.data;
      if (options.data && options.ids) {
        data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
      }

      return fn(context, {
        data: data,
        blockParams: _utils.blockParams([context], [data && data.contextPath])
      });
    } else {
      return options.inverse(this);
    }
  });
};

module.exports = exports['default'];


},{"../utils":20}],16:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('./utils');

var logger = {
  methodMap: ['debug', 'info', 'warn', 'error'],
  level: 'info',

  // Maps a given level value to the `methodMap` indexes above.
  lookupLevel: function lookupLevel(level) {
    if (typeof level === 'string') {
      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
      if (levelMap >= 0) {
        level = levelMap;
      } else {
        level = parseInt(level, 10);
      }
    }

    return level;
  },

  // Can be overridden in the host environment
  log: function log(level) {
    level = logger.lookupLevel(level);

    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
      var method = logger.methodMap[level];
      if (!console[method]) {
        // eslint-disable-line no-console
        method = 'log';
      }

      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        message[_key - 1] = arguments[_key];
      }

      console[method].apply(console, message); // eslint-disable-line no-console
    }
  }
};

exports['default'] = logger;
module.exports = exports['default'];


},{"./utils":20}],17:[function(require,module,exports){
(function (global){
/* global window */
'use strict';

exports.__esModule = true;

exports['default'] = function (Handlebars) {
  /* istanbul ignore next */
  var root = typeof global !== 'undefined' ? global : window,
      $Handlebars = root.Handlebars;
  /* istanbul ignore next */
  Handlebars.noConflict = function () {
    if (root.Handlebars === Handlebars) {
      root.Handlebars = $Handlebars;
    }
  };
};

module.exports = exports['default'];


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],18:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.checkRevision = checkRevision;
exports.template = template;
exports.wrapProgram = wrapProgram;
exports.resolvePartial = resolvePartial;
exports.invokePartial = invokePartial;
exports.noop = noop;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _utils = require('./utils');

var Utils = _interopRequireWildcard(_utils);

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _base = require('./base');

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = _base.COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
    }
  }
}

function template(templateSpec, env) {
  /* istanbul ignore next */
  if (!env) {
    throw new _exception2['default']('No environment passed to template');
  }
  if (!templateSpec || !templateSpec.main) {
    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
  }

  templateSpec.main.decorator = templateSpec.main_d;

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  env.VM.checkRevision(templateSpec.compiler);

  function invokePartialWrapper(partial, context, options) {
    if (options.hash) {
      context = Utils.extend({}, context, options.hash);
      if (options.ids) {
        options.ids[0] = true;
      }
    }

    partial = env.VM.resolvePartial.call(this, partial, context, options);
    var result = env.VM.invokePartial.call(this, partial, context, options);

    if (result == null && env.compile) {
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, options);
    }
    if (result != null) {
      if (options.indent) {
        var lines = result.split('\n');
        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }

          lines[i] = options.indent + lines[i];
        }
        result = lines.join('\n');
      }
      return result;
    } else {
      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    }
  }

  // Just add water
  var container = {
    strict: function strict(obj, name) {
      if (!(name in obj)) {
        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
      }
      return obj[name];
    },
    lookup: function lookup(depths, name) {
      var len = depths.length;
      for (var i = 0; i < len; i++) {
        if (depths[i] && depths[i][name] != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === 'function' ? current.call(context) : current;
    },

    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,

    fn: function fn(i) {
      var ret = templateSpec[i];
      ret.decorator = templateSpec[i + '_d'];
      return ret;
    },

    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams, depths) {
      var programWrapper = this.programs[i],
          fn = this.fn(i);
      if (data || depths || blockParams || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      }
      return programWrapper;
    },

    data: function data(value, depth) {
      while (value && depth--) {
        value = value._parent;
      }
      return value;
    },
    merge: function merge(param, common) {
      var obj = param || common;

      if (param && common && param !== common) {
        obj = Utils.extend({}, common, param);
      }

      return obj;
    },

    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };

  function ret(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var data = options.data;

    ret._setup(options);
    if (!options.partial && templateSpec.useData) {
      data = initData(context, data);
    }
    var depths = undefined,
        blockParams = templateSpec.useBlockParams ? [] : undefined;
    if (templateSpec.useDepths) {
      if (options.depths) {
        depths = context !== options.depths[0] ? [context].concat(options.depths) : options.depths;
      } else {
        depths = [context];
      }
    }

    function main(context /*, options*/) {
      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    }
    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    return main(context, options);
  }
  ret.isTop = true;

  ret._setup = function (options) {
    if (!options.partial) {
      container.helpers = container.merge(options.helpers, env.helpers);

      if (templateSpec.usePartial) {
        container.partials = container.merge(options.partials, env.partials);
      }
      if (templateSpec.usePartial || templateSpec.useDecorators) {
        container.decorators = container.merge(options.decorators, env.decorators);
      }
    } else {
      container.helpers = options.helpers;
      container.partials = options.partials;
      container.decorators = options.decorators;
    }
  };

  ret._child = function (i, data, blockParams, depths) {
    if (templateSpec.useBlockParams && !blockParams) {
      throw new _exception2['default']('must pass block params');
    }
    if (templateSpec.useDepths && !depths) {
      throw new _exception2['default']('must pass parent depths');
    }

    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
  };
  return ret;
}

function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
  function prog(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var currentDepths = depths;
    if (depths && context !== depths[0]) {
      currentDepths = [context].concat(depths);
    }

    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
  }

  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}

function resolvePartial(partial, context, options) {
  if (!partial) {
    if (options.name === '@partial-block') {
      partial = options.data['partial-block'];
    } else {
      partial = options.partials[options.name];
    }
  } else if (!partial.call && !options.name) {
    // This is a dynamic partial that returned a string
    options.name = partial;
    partial = options.partials[partial];
  }
  return partial;
}

function invokePartial(partial, context, options) {
  options.partial = true;
  if (options.ids) {
    options.data.contextPath = options.ids[0] || options.data.contextPath;
  }

  var partialBlock = undefined;
  if (options.fn && options.fn !== noop) {
    options.data = _base.createFrame(options.data);
    partialBlock = options.data['partial-block'] = options.fn;

    if (partialBlock.partials) {
      options.partials = Utils.extend({}, options.partials, partialBlock.partials);
    }
  }

  if (partial === undefined && partialBlock) {
    partial = partialBlock;
  }

  if (partial === undefined) {
    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
  } else if (partial instanceof Function) {
    return partial(context, options);
  }
}

function noop() {
  return '';
}

function initData(context, data) {
  if (!data || !('root' in data)) {
    data = data ? _base.createFrame(data) : {};
    data.root = context;
  }
  return data;
}

function executeDecorators(fn, prog, container, depths, data, blockParams) {
  if (fn.decorator) {
    var props = {};
    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
    Utils.extend(prog, props);
  }
  return prog;
}


},{"./base":4,"./exception":7,"./utils":20}],19:[function(require,module,exports){
// Build out our basic SafeString type
'use strict';

exports.__esModule = true;
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
  return '' + this.string;
};

exports['default'] = SafeString;
module.exports = exports['default'];


},{}],20:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.extend = extend;
exports.indexOf = indexOf;
exports.escapeExpression = escapeExpression;
exports.isEmpty = isEmpty;
exports.createFrame = createFrame;
exports.blockParams = blockParams;
exports.appendContextPath = appendContextPath;
var escape = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;',
  '=': '&#x3D;'
};

var badChars = /[&<>"'`=]/g,
    possible = /[&<>"'`=]/;

function escapeChar(chr) {
  return escape[chr];
}

function extend(obj /* , ...source */) {
  for (var i = 1; i < arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }

  return obj;
}

var toString = Object.prototype.toString;

// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
/* eslint-disable func-style */
exports.toString = toString;
var isFunction = function isFunction(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
/* istanbul ignore next */
if (isFunction(/x/)) {
  exports.isFunction = isFunction = function (value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
exports.isFunction = isFunction;

/* eslint-enable func-style */

/* istanbul ignore next */
var isArray = Array.isArray || function (value) {
  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
};

// Older IE versions do not directly support indexOf so we must implement our own, sadly.
exports.isArray = isArray;

function indexOf(array, value) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
}

function escapeExpression(string) {
  if (typeof string !== 'string') {
    // don't escape SafeStrings, since they're already safe
    if (string && string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return '';
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = '' + string;
  }

  if (!possible.test(string)) {
    return string;
  }
  return string.replace(badChars, escapeChar);
}

function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

function createFrame(object) {
  var frame = extend({}, object);
  frame._parent = object;
  return frame;
}

function blockParams(params, ids) {
  params.path = ids;
  return params;
}

function appendContextPath(contextPath, id) {
  return (contextPath ? contextPath + '.' : '') + id;
}


},{}],21:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime')['default'];

},{"./dist/cjs/handlebars.runtime":3}],22:[function(require,module,exports){
module.exports = require("handlebars/runtime")["default"];

},{"handlebars/runtime":21}],23:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Module for full management of requesting AJAX from server.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;

/**
 * @constructor
 */
function AJAX() {}

AJAX.ERROR = {
    NOT_SUPPORT: '사용하시는 브라우저가 서비스 이용에 필요한 필수 기능을 지원하지 않습니다. 최신 버전의 브라우저를 사용해 주세요.'
};

/**********
 * ajax
 **********/

/**
 * 비동기 요청을 위한 객체를 만들어 반환한다
 * @return {(XMLHttpRequest|ActiveXObject)} 비동기 통신 지원 객체
 */
AJAX.prototype._createXHR = function() {
    if (util.isExisty(util.pick(window, 'XMLHttpRequest'))) {
        return new XMLHttpRequest();
    } else if (util.isExisty(util.pick(window, 'ActiveXObject'))) {
        return new ActiveXObject('Microsoft.XMLHTTP'); // jshint ignore:line
    }

    window.alert(AJAX.ERROR.NOT_SUPPORT);
};

/**
 * 타입에 따라 데이터를 추가 가공한다
 *
 * TODO: 현재는 JSON데이터만 처리중이고 필요에 따라 늘어나야 한다
 * @param {string} dataType 데이터 타입
 * @param {*} data 가공할 데이터
 * @return {*} 가공된 데이터
 */
AJAX.prototype._processRawData = function(dataType, data) {
    var result = data;
    if (dataType === 'json') {
        try {
            result = JSON.parse(data);
        } catch (e) {
            result = data;
        }
    }

    return result;
};

/**
 * XHR의 응답 데이터를 처리한다
 * @param {object} options - ajax옵션 객체
 * @param {(XMLHttpRequest|ActiveXObject)} xhr - 비동기 요청 객체
 */
AJAX.prototype._onReadyStateChange = function(options, xhr) {
    var status,
        response,
        responseHeader;

    if (xhr.readyState !== 4) {
        return;
    }

    status = xhr.status;

    if ((status >= 200 && status < 300) || status === 304) {
        response = this._processRawData(options.dataType, xhr.responseText);
        responseHeader = util.pick(response, 'header');

        if (!responseHeader) {
            options.error();
        } else if (responseHeader.isSuccessful) {
            options.success(response);
        } else {
            options.fail(response);
        }
    } else if (status !== 0) {
        options.error();
    }

    options.complete();
};


/**
 * ajax 요청을 수행한다.
 * 
 * 요청 타입에 따른 추가 데이터 처리는 따로 하지 않으므로 사전에 미리 준비해야 한다
 * 예를 들어, get요청은 QueryString으로 url을 설정해야 하고, post등의 data를 사용하
 * 는 요청은 미리 stringfy된 값을 data옵션으로 전달해야 한다.
 *
 * @param {string} url ajax요청 할 url
 * @param {Object} options 옵션
 * @param {string} [options.method='POST'] 요청 시 사용할 http methods
 * @param {boolean} [options.async=true] 비동기 요청 사용 여부
 * @param {string} [options.type='application/json; charset=utf-8'] type 헤더 값
 * @param {string} [options.contentType='application/json'] Content-Type 헤더 값
 * @param {string} [options.dataType='json'] 서버에서 응답받기 바라는 결과의 타입
 * @param {function} [optoins.success] - isSuccessful true에 대한 콜백
 * @param {function} [options.fail] - isSuccessful false 에 대한 콜백
 * @param {function} [options.error] 요청에 대한 에러 발생 시 수행할 콜백
 * @param {function} [options.complete] 요청이 끝났을 때 (성공, 실패 여부와 무관) 수행하는 콜백
 * @param {bollean} [options.cache=true] - false 일 경우 timestamp 파라미터를 url에 붙여 캐시를 무시
 */
AJAX.prototype.ajax = function(url, options) {
    var xhr,
        data,
        separator,
        defaultOptions = {
            method: 'GET',
            async: true,
            type: 'application/json; charset=utf-8',
            contentType: 'application/json',
            dataType: 'json',
            success: function() {},
            fail: function() {},
            error: function() {},
            complete: function() {},
            cache: true
        };

    options = util.extend(defaultOptions, options);
    data = util.pick(options, 'data');
    if (!options.cache) {
        separator = ~url.indexOf('?') ? '&' : '?';
        url = url + separator + '_=' + +(new Date());
    }

    xhr = this._createXHR();
    xhr.open(options.method, url, options.async);
    xhr.setRequestHeader('type', options.type);
    xhr.setRequestHeader('content-type', options.contentType);
    xhr.onreadystatechange = util.bind(this._onReadyStateChange, this, options, xhr);
    xhr.send(data ? data : null);
};

module.exports = AJAX;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],24:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Utility module for array sort, binary search.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var datetime = require('../common/datetime');

/**
 * A module for sorting array.
 * @module array
 */

/**********
 * Search
 **********/

/**
 * search item index using binary search algorithm.
 *
 * the array must be sorted.
 * @param {array} arr array to search.
 * @param {(string|number|boolean)} search value to search.
 * @param {function} [fn] iteratee for retrieve each element's value to search.
 * @param {function} [compare] compare function for specific sort status. default is string ascending.
 * @returns {number} The number of item index searched. return negative number when no exist that item.
 * It can use insert index after Math.abs()
 * @example
 *
 * var arr = [1, 3, 7, 11, 15, 23];
 *
 * function sortNumber(a, b) {
 *     return a - b;
 * }
 *
 * bsearch(arr, 15, null, sortNumber);    // 4
 * bsearch(arr, 21, null, sortNumber);    // -5
 *
 * arr.splice(Math.abs(bsearch(arr, 21, null, sortNumber)), 0, 21);
 * // [1, 2, 7, 11, 15, 21, 23]
 */
function bsearch(arr, search, fn, compare) {
    var minIndex = 0,
        maxIndex = arr.length - 1,
        currentIndex,
        value,
        comp;

    compare = compare || stringASC;

    while (minIndex <= maxIndex) {
        currentIndex = (minIndex + maxIndex) / 2 | 0;    // Math.floor
        value = fn ? fn(arr[currentIndex]) : arr[currentIndex];
        comp = compare(value, search);

        if (comp < 0) {
            minIndex = currentIndex + 1;
        } else if (comp > 0) {
            maxIndex = currentIndex - 1;
        } else {
            return currentIndex;
        }
    }

    return ~maxIndex;
}

/**********
 * Compare Functions
 **********/

/**
 * compare function for array sort.
 *
 * sort array by ascending.
 * @param {boolean} a The boolean to compare
 * @param {boolean} b The boolean to compare.
 * @returns {number} Result of comparison.
 */
function booleanASC(a, b) {
    if (a !== b) {
        return a ? -1 : 1;
    }
    return 0;
}

/**
 * compare function for array sort.
 *
 * sort array by descending.
 * @param {boolean} a The boolean to compare
 * @param {boolean} b The boolean to compare.
 * @returns {number} Result of comparison.
 */
function booleanDESC(a, b) {
    if (a !== b) {
        return a ? 1 : -1;
    }
    return 0;
}

/**
 * compare function for array sort.
 *
 * sort array by number ascending.
 * @param {number} _a The number to compare.
 * @param {number} _b The number to compare.
 * @returns {number} Result of comparison.
 */
function numberASC(_a, _b) {
    var a = +_a,
        b = +_b;

    return a - b;
}

/**
 * compare function for array sort.
 *
 * sort array by number descending.
 * @param {number} _a The number to compare.
 * @param {number} _b The number to compare.
 * @returns {number} Result of comparison.
 */
function numberDESC(_a, _b) {
    var a = +_a,
        b = +_b;

    return b - a;
}

/**
 * compare function for array sort.
 *
 * sort array by string ascending
 * @param {string} _a The string to compare.
 * @param {string} _b The string to compare.
 * @returns {number} Result of comparison.
 */
function stringASC(_a, _b) {
    var a = _a + '',
        b = _b + '';

    if (a > b) {
        return 1;
    } else if (a < b) {
        return -1;
    }

    return 0;
}

/**
 * compare function for array sort.
 *
 * sort array by string descending
 * @param {string} _a The string to compare.
 * @param {string} _b The string to compare.
 * @returns {number} Result of comparison.
 */
function stringDESC(_a, _b) {
    var a = _a + '',
        b = _b + '';

    if (a > b) {
        return -1;
    } else if (a < b) {
        return 1;
    }

    return 0;
}

/**
 * compare function for array sort.
 *
 * sort array by string ascending with ignore case.
 * @param {string} _a The string to compare.
 * @param {string} _b The string to compare.
 * @returns {number} Result of comparison.
 */
function stringASCIgnoreCase(_a, _b) {
    var a = (_a + '').toLowerCase(),
        b = (_b + '').toLowerCase();

    if (a > b) {
        return 1;
    } else if (a < b) {
        return -1;
    }

    return 0;
}

/**
 * compare function for array sort.
 *
 * sort array by string descending with ignore case.
 * @param {string} _a The string to compare.
 * @param {string} _b The string to compare.
 * @returns {number} Result of comparison.
 */
function stringDESCIgnoreCase(_a, _b) {
    var a = (_a + '').toLowerCase(),
        b = (_b + '').toLowerCase();

    if (a > b) {
        return -1;
    } else if (a < b) {
        return 1;
    }

    return 0;
}

/**
 * Compare event models for sort.
 *
 * 1. all day event first.
 * 2. early starts.
 * 3. longest duration.
 * 4. early created.
 * @param {CalEvent|CalEventViewModel} a The object event instance.
 * @param {CalEvent|CalEventViewModel} b The object event instance.
 * @returns {number} Result of comparison.
 */
function eventASC(a, b) {
    var durationA,
        durationB,
        allDayCompare,
        startsCompare;

    a = a.valueOf();
    b = b.valueOf();

    allDayCompare = booleanASC(a.isAllDay, b.isAllDay);

    if (allDayCompare) {
        return allDayCompare;
    }

    startsCompare = datetime.compare(a.getStarts(), b.getStarts());

    if (startsCompare) {
        return startsCompare;
    }

    durationA = a.duration().getTime();
    durationB = b.duration().getTime();

    if (durationA < durationB) {
        return 1;
    } else if (durationA > durationB) {
        return -1;
    }

    return util.stamp(a) - util.stamp(b);
}


module.exports = {
    bsearch: bsearch,
    compare: {
        event: {
            asc: eventASC
        },
        bool: {
            asc: booleanASC,
            desc: booleanDESC
        },
        num: {
            asc: numberASC,
            desc: numberDESC
        },
        str: {
            asc: stringASC,
            desc: stringDESC,
            ascIgnoreCase: stringASCIgnoreCase,
            descIgnoreCase: stringDESCIgnoreCase
        }
    }
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/datetime":28}],25:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Add autoscroll feature to elements that prevented text selection.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var domevent = require('../common/domevent');
var domutil = require('../common/domutil');
var Point = require('../common/point');

var SCROLL_INTERVAL = 30;
var SCROLL_MAX = 15;
var SCROLL_CLICK_INCREASED = 2;    // IE에서 스크롤 바 클릭 시 실제 UI pixel 보다 넓게 잡히는 현상 offset.

/**
 * Add autoscroll feature to elements that prevented text selection.
 * @constructor
 * @param {HTMLElement} container - HTMLElement to add autoscroll features.
 */
function AutoScroll(container) {
    /**
     * @type {HTMLElement}
     */
    this.container = container;

    /**
     * @type {AutoScroll.DIRECTION}
     */
    this._direction = AutoScroll.DIRECTION.INSIDE;

    /**
     * @type {number}
     */
    this._offset = 0;

    /**
     * interval to scrolling
     * @type {number}
     */
    this._intervalID = 0;

    domevent.on(container, {
        'mousedown': this._onMouseDown
    }, this);
}

/**
 * @enum
 */
AutoScroll.DIRECTION = {
    INSIDE: 0,
    TOP: 1,
    RIGHT: 2,
    BOTTOM: 3,
    LEFT: 4
};

/**
 * Instance destroy method.
 */
AutoScroll.prototype.destroy = function() {
    domevent.off(this.container, {
        'mousedown': this._onMouseDown,
        'mousemove': this._onMouseMove,
        'mouseup': this._onMouseUp
    }, this);

    window.clearInterval(this._intervalID);
    this._intervalID = this._direction = this.container = null;
};

/**
 * Normalize ClientRect and calculate each position of edges.
 * @param {ClientRect} clientRect - ClientRect object of element.
 * @returns {object} edges.
 */
AutoScroll.prototype._getEdgePositions = function(clientRect) {
    return {
        top: clientRect.top,
        right: clientRect.left + clientRect.width,
        bottom: clientRect.bottom,
        left: clientRect.left
    };
};

/**
 * Get element real size ("real size" -> size without scrollbar)
 * @param {HTMLElement} el - element want to know real size ("real size" -> size without scrollbar)
 * @returns {number[]} real size [width, height]
 */
AutoScroll.prototype.getRealSize = function(el) {
    var computed = domutil.getComputedStyle(el),
        border,
        padding;

    border = parseFloat(computed.getPropertyValue('border-top-width')) +
        parseFloat(computed.getPropertyValue('border-bottom-width'));
    padding = parseFloat(computed.getPropertyValue('padding-top')) +
        parseFloat(computed.getPropertyValue('padding-bottom'));

    return [el.clientWidth + border + padding, el.clientHeight + border + padding];
};

/**
 * Check supplied element has scrollbar.
 * @param {HTMLElement} el - element want to know has scrollbar.
 * @returns {boolean[]} has scrollbar? [horizontal, vertical]
 */
AutoScroll.prototype.hasScrollbar = function(el) {
    var realSize = this.getRealSize(el);

    return [
        el.offsetWidth > Math.ceil(realSize[0]),
        el.offsetHeight > Math.ceil(realSize[1])
    ];
};

/**
 * @param {HTMLElement} el - element want to know.
 * @param {MouseEvent} mouseEvent - mouse event object.
 * @returns {boolean} mouse pointer is on the scrollbar?
 */
AutoScroll.prototype.isOnScrollbar = function(el, mouseEvent) {
    var realSize = this.getRealSize(el),
        pos = domevent.getMousePosition(mouseEvent, el),
        mouseInScrollbar = false;

    mouseInScrollbar = (realSize[0] - SCROLL_CLICK_INCREASED < pos[0] ||
                        realSize[1] - SCROLL_CLICK_INCREASED < pos[1]);

    return mouseInScrollbar;
};

/**
 * MouseDown event handler
 * @param {MouseEvent} mouseDownEvent - mouse down event
 */
AutoScroll.prototype._onMouseDown = function(mouseDownEvent) {
    // only primary button can start drag.
    if (domevent.getMouseButton(mouseDownEvent) !== 0) {
        return;
    }

    // deactivate autoscroll feature when mouse is on the scrollbar. (IE)
    if (util.browser.msie && this.isOnScrollbar(this.container, mouseDownEvent)) {
        return;
    }

    window.clearInterval(this._intervalID);
    this._intervalID = window.setInterval(util.bind(this._onTick, this), SCROLL_INTERVAL);

    domevent.on(global, {
        'mousemove': this._onMouseMove,
        'mouseup': this._onMouseUp
    }, this);
};

/**
 * MouseMove event handler
 * @param {MouseEvent} mouseEvent - mouse move event object.
 */
AutoScroll.prototype._onMouseMove = function(mouseEvent) {
    var edge = this._getEdgePositions(this.container.getBoundingClientRect()),
        pos = Point.n(domevent.getMousePosition(mouseEvent));

    if (pos.y >= edge.top && pos.y <= edge.bottom &&
        pos.x >= edge.left && pos.x <= edge.right) {
        this._direction = AutoScroll.DIRECTION.INSIDE;
        return;
    }

    if (pos.y < edge.top) {
        this._direction = AutoScroll.DIRECTION.TOP;
        this._offset = edge.top - pos.y;
        return;
    }

    if (pos.y > edge.bottom) {
        this._direction = AutoScroll.DIRECTION.BOTTOM;
        this._offset = pos.y - edge.bottom;
        return;
    }

    if (pos.x < edge.left) {
        this._direction = AutoScroll.DIRECTION.LEFT;
        this._offset = edge.left - pos.x;
        return;
    }

    this._direction = AutoScroll.DIRECTION.RIGHT;
    this._offset = pos.x - edge.right;
    return;
};

/**
 * MouseUp event handler.
 */
AutoScroll.prototype._onMouseUp = function() {
    window.clearInterval(this._intervalID);
    this._intervalID = 0;
    this._direction = AutoScroll.DIRECTION.INSIDE;
    this._offset = 0;

    domevent.off(global, {
        'mousemove': this._onMouseMove,
        'mouseup': this._onMouseUp
    }, this);
};

/**
 * Interval tick event handler
 */
AutoScroll.prototype._onTick = function() {
    var direction = this._direction,
        container,
        factor;

    if (!direction) {
        return;
    }

    container = this.container;
    factor = Math.min(this._offset, SCROLL_MAX);

    switch (direction) {
        case AutoScroll.DIRECTION.TOP:
            container.scrollTop -= factor;
            break;
        case AutoScroll.DIRECTION.RIGHT:
            container.scrollLeft += factor;
            break;
        case AutoScroll.DIRECTION.BOTTOM:
            container.scrollTop += factor;
            break;
        default:
            container.scrollLeft -= factor;
            break;
    }
};

module.exports = AutoScroll;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/domevent":30,"../common/domutil":31,"../common/point":34}],26:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Common collections.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util,
    forEachProp = util.forEachOwnProperties,
    forEachArr = util.forEachArray,
    isFunc = util.isFunction,
    isObj = util.isObject;

var aps = Array.prototype.slice;

/**
 * Common collection.
 *
 * It need function for get model's unique id.
 *
 * if the function is not supplied then it use default function {@link Collection#getItemID}
 * @constructor
 * @param {function} [getItemIDFn] function for get model's id.
 */
function Collection(getItemIDFn) {
    /**
     * @type {object.<string, *>}
     */
    this.items = {};

    /**
     * @type {number}
     */
    this.length = 0;

    if (isFunc(getItemIDFn)) {
        /**
         * @type {function}
         */
        this.getItemID = getItemIDFn;
    }
}

/**********
 * static props
 **********/

/**
 * Combind supplied function filters and condition.
 * @param {...function} filters - function filters
 * @returns {function} combined filter
 */
Collection.and = function(filters) {
    var cnt;

    filters = aps.call(arguments);
    cnt = filters.length;

    return function(item) {
        var i = 0;

        for (; i < cnt; i += 1) {
            if (!filters[i].call(null, item)) {
                return false;
            }
        }
        
        return true;
    };
};

/**
 * Combine multiple function filters with OR clause.
 * @param {...function} filters - function filters
 * @returns {function} combined filter
 */
Collection.or = function(filters) {
    var cnt;

    filters = aps.call(arguments);
    cnt = filters.length;

    return function(item) {
        var i = 1,
            result = filters[0].call(null, item);

        for (; i < cnt; i += 1) {
            result = (result || filters[i].call(null, item));
        }

        return result;
    };
};

/**
 * Merge several collections.
 *
 * You can\'t merge collections different _getEventID functions. Take case of use.
 * @param {...Collection} collections collection arguments to merge
 * @returns {Collection} merged collection.
 */
Collection.merge = function(collections) {    // eslint-disable-line
    var cols = aps.call(arguments),
        newItems = {},
        merged = new Collection(cols[0].getItemID),
        extend = util.extend;

    forEachArr(cols, function(col) {
        extend(newItems, col.items);
    });

    merged.items = newItems;
    merged.length = util.keys(merged.items).length;

    return merged;
};

/**********
 * prototype props
 **********/

/**
 * get model's unique id.
 * @param {object} item model instance.
 * @returns {number} model unique id.
 */
Collection.prototype.getItemID = function(item) {
    return item._id + '';
};

/**
 * add models.
 * @param {...*} item models to add this collection.
 */
Collection.prototype.add = function(item) {
    var id,
        ownItems;

    if (arguments.length > 1) {
        forEachArr(aps.call(arguments), function(o) {
            this.add(o);
        }, this);

        return;
    }

    id = this.getItemID(item);
    ownItems = this.items;

    if (!ownItems[id]) {
        this.length += 1;
    }
    ownItems[id] = item;
};

/**
 * remove models.
 * @param {...(object|string|number)} id model instance or unique id to delete.
 * @returns {array} deleted model list.
 */
Collection.prototype.remove = function(id) {
    var removed = [],
        ownItems,
        itemToRemove;

    if (!this.length) {
        return removed;
    }

    if (arguments.length > 1) {
        removed = util.map(aps.call(arguments), function(id) {
            return this.remove(id);
        }, this);

        return removed;
    }

    ownItems = this.items;

    if (isObj(id)) {
        id = this.getItemID(id);
    }

    if (!ownItems[id]) {
        return removed;
    }

    this.length -= 1;
    itemToRemove = ownItems[id];
    delete ownItems[id];

    return itemToRemove;
};

/**
 * remove all models in collection.
 */
Collection.prototype.clear = function() {
    this.items = {};
    this.length = 0;
};

/**
 * check collection has specific model.
 * @param {(object|string|number|function)} id model instance or id or filter function to check
 * @returns {boolean} is has model?
 */
Collection.prototype.has = function(id) {
    var isFilter,
        has;

    if (!this.length) {
        return false;
    }

    isFilter = isFunc(id);
    has = false;

    if (isFilter) {
        this.each(function(item) {
            if (id(item) === true) {
                has = true;
                return false;
            }
        });
    } else {
        id = isObj(id) ? this.getItemID(id) : id;
        has = util.isExisty(this.items[id]);
    }

    return has;
};

/**
 * invoke callback when model exist in collection.
 * @param {(string|number)} id model unique id.
 * @param {function} fn the callback.
 * @param {*} [context] callback context.
 */
Collection.prototype.doWhenHas = function(id, fn, context) {
    var item = this.items[id];

    if (!util.isExisty(item)) {
        return;
    }

    fn.call(context || this, item);
};

/**
 * Search model. and return new collection.
 * @param {function} filter filter function.
 * @returns {Collection} new collection with filtered models.
 * @example
 * collection.find(function(item) {
 *     return item.edited === true;
 * });
 *
 * function filter1(item) {
 *     return item.edited === false;
 * }
 *
 * function filter2(item) {
 *     return item.disabled === false;
 * }
 *
 * collection.find(Collection.and(filter1, filter2));
 *
 * collection.find(Collection.or(filter1, filter2));
 */
Collection.prototype.find = function(filter) {
    var result = new Collection();

    if (this.hasOwnProperty('getItemID')) {
        result.getItemID = this.getItemID;
    }

    this.each(function(item) {
        if (filter(item) === true) {
            result.add(item);
        }
    });

    return result;
};

/**
 * Group element by specific key values.
 *
 * if key parameter is function then invoke it and use returned value.
 * @param {(string|number|function|array)} key key property or getter function. if string[] supplied, create each collection before grouping.
 * @param {function} [groupFunc] - function that return each group's key
 * @returns {object.<string, Collection>} grouped object
 * @example
 * 
 * // pass `string`, `number`, `boolean` type value then group by property value.
 * collection.groupBy('gender');    // group by 'gender' property value.
 * collection.groupBy(50);          // group by '50' property value.
 * 
 * // pass `function` then group by return value. each invocation `function` is called with `(item)`.
 * collection.groupBy(function(item) {
 *     if (item.score > 60) {
 *         return 'pass';
 *     }
 *     return 'fail';
 * });
 *
 * // pass `array` with first arguments then create each collection before grouping.
 * collection.groupBy(['go', 'ruby', 'javascript']);
 * // result: { 'go': empty Collection, 'ruby': empty Collection, 'javascript': empty Collection }
 *
 * // can pass `function` with `array` then group each elements.
 * collection.groupBy(['go', 'ruby', 'javascript'], function(item) {
 *     if (item.isFast) {
 *         return 'go';
 *     }
 *
 *     return item.name;
 * });
 */
Collection.prototype.groupBy = function(key, groupFunc) {
    var result = {},
        collection,
        baseValue,
        isFunc = util.isFunction,
        keyIsFunc = isFunc(key),
        getItemIDFn = this.getItemID;

    if (util.isArray(key)) {
        util.forEachArray(key, function(k) {
            result[k + ''] = new Collection(getItemIDFn);
        });

        if (!groupFunc) {
            return result;
        }

        key = groupFunc;
        keyIsFunc = true;
    }

    this.each(function(item) {
        if (keyIsFunc) {
            baseValue = key(item);
        } else {
            baseValue = item[key];

            if (isFunc(baseValue)) {
                baseValue = baseValue.apply(item);
            }
        }

        collection = result[baseValue];

        if (!collection) {
            collection = result[baseValue] = new Collection(getItemIDFn);
        }

        collection.add(item);
    });

    return result;
};

/**
 * Return single item in collection.
 *
 * Returned item is inserted in this collection firstly.
 * @param {function} [filter] - function filter
 * @returns {object} item.
 */
Collection.prototype.single = function(filter) {
    var result,
        useFilter = util.isFunction(filter);

    this.each(function(item) {
        if (!useFilter) {
            result = item;
            return false;
        } else if (filter(item)) {
            result = item;
            return false;
        }
    }, this);

    return result;
};

/**
 * sort a basis of supplied compare function.
 * @param {function} compareFunction compareFunction
 * @returns {array} sorted array.
 */
Collection.prototype.sort = function(compareFunction) {
    var arr = [];

    this.each(function(item) {
        arr.push(item);
    });

    if (isFunc(compareFunction)) {
        arr = arr.sort(compareFunction);
    }

    return arr;
};

/**
 * iterate each model element.
 *
 * when iteratee return false then break the loop.
 * @param {function} iteratee iteratee(item, index, items)
 * @param {*} [context] context
 */
Collection.prototype.each = function(iteratee, context) {
    forEachProp(this.items, iteratee, context || this);
};

/**
 * return new array with collection items.
 * @returns {array} new array.
 */
Collection.prototype.toArray = function() {
    if (!this.length) {
        return [];
    }

    return util.map(this.items, function(item) {
        return item;
    });
};

module.exports = Collection;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],27:[function(require,module,exports){
(function (global){
/**
 * @fileoverview common/general utilities.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var Collection = require('../common/collection');
var aps = Array.prototype.slice;

function eventIDGetter(event) {
    return event.cid();
}

module.exports = {
    /**
     * @param {...*} initItems - items to add newly created collection.
     * @returns {Collection} new collection for event models.
     */
    createEventCollection: function(initItems) {    // eslint-disable-line
        var collection = new Collection(eventIDGetter);

        if (arguments.length) {
            collection.add.apply(collection, arguments);
        }

        return collection;
    },

    /**
     * Get ratio value.
     *
     * a : b = y : X;
     *
     * =
     *
     * X = (b * y) / a;
     * @param {number} a - a
     * @param {number} b - b
     * @param {number} y - y
     * @returns {number} ratio value
     */
    ratio: function(a, b, y) {
        // a : b = y : x;
        return (b * y) / a;
    },

    /**
     * Find nearest value from supplied params.
     * @param {number} value - value to find.
     * @param {array} nearest - nearest array.
     * @returns {number} nearest value
     */
    nearest: function(value, nearest) {
        var diff = util.map(nearest, function(v) {
                return Math.abs(value - v);
            }),
            nearestIndex = util.inArray(Math.min.apply(null, diff), diff);

        return nearest[nearestIndex];
    },

    /**
     * pick value from object then return utility object to treat it.
     * @param {object} obj - object to search supplied path property.
     * @param {...string} paths - rest parameter that string value to search property in object.
     * @returns {object} pick object.
     */
    pick2: function(obj, paths) {    // eslint-disable-line
        var result = util.pick.apply(null, arguments),
            pick;

        pick = {
            /**
             * @returns {*} picked value.
             */
            val: function() {
                return result;
            },

            /**
             * invoke supplied function in picked object.
             *
             * the callback context is set picked object.
             * @param {string|function} fn - function to invoke in picked object.
             * @returns {*} result of invoke.
             */
            then: function(fn) {
                var args;

                if (!result) {
                    return undefined;    //eslint-disable-line
                }

                args = aps.call(arguments, 1);

                if (util.isString(fn)) {
                    return (util.pick(result, fn) || function() {}).apply(result, args);
                }

                return fn.call(result, result);
            }
        };

        return pick;
    },

    /**
     * Mixin method.
     *
     * (extend methods except property name 'mixin')
     * @param {object} from - mixin object.
     * @param {object} to - object to mixin.
     */
    mixin: function(from, to) {
        util.extend(to.prototype, from);
    },

    /**
     * Limit supplied value base on `minArr`, `maxArr`
     * @param {number} value - value
     * @param {array} minArr - min
     * @param {array} maxArr - max
     * @return {number} limited value
     */
    limit: function(value, minArr, maxArr) {
        var v = Math.max.apply(null, [value].concat(minArr));
        v = Math.min.apply(null, [v].concat(maxArr));
        return v;
    },

    stripTags: function(str) {
        return str.replace(/<([^>]+)>/ig, '');
    }
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/collection":26}],28:[function(require,module,exports){
(function (global){
/**
 * @fileoverview datetime utility module
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util,
    opt = Object.prototype.toString;

var dateFormatRx = /^(\d{4}[-|\/]*\d{2}[-|\/]*\d{2})\s?(\d{2}:\d{2}:\d{2})?$/;

var datetime,
    tokenFunc;

var memo = {
    millisecondsTo: {},
    millisecondsFrom: {}
};

tokenFunc = {
    /**
     * @param {Date} date date object.
     * @returns {string} YYYYMMDD
     */
    'YYYYMMDD': function(date) {
        return [
            date.getFullYear(),
            datetime.leadingZero(date.getMonth() + 1, 2),
            datetime.leadingZero(date.getDate(), 2)
        ].join('');
    },
    /**
     * @param {Date} date date object
     * @returns {string} four digit year number
     */
    'YYYY': function(date) {
        return date.getFullYear() + '';
    },

    /**
     * @param {Date} date date object
     * @returns {string} two digit month number
     */
    'MM': function(date) {
        return datetime.leadingZero(date.getMonth() + 1, 2);
    },

    /**
     * @param {Date} date date object
     * @returns {string} two digit date number
     */
    'DD': function(date) {
        return datetime.leadingZero(date.getDate(), 2);
    },

    /**
     * @param {Date} date date object
     * @returns {string} HH:mm
     */
    'HH:mm': function(date) {
        var hour = date.getHours(),
            minutes = date.getMinutes();

        return datetime.leadingZero(hour, 2) + ':' +
            datetime.leadingZero(minutes, 2);
    },

    /**
     * format to local date
     * @param {Date} date date object
     * @returns {string} 1988-09-25T09:00:00+09:00
     */
    'LOCAL': function(date) {
        var timeZoneOffset = -date.getTimezoneOffset(),
            diff = timeZoneOffset >= 0 ? '+' : '-',
            pad = function(num) {
                return datetime.leadingZero(num, 2);
            };

        return date.getFullYear() 
            + '-' + pad(date.getMonth() + 1)
            + '-' + pad(date.getDate())
            + 'T' + pad(date.getHours())
            + ':' + pad(date.getMinutes()) 
            + ':' + pad(date.getSeconds()) 
            + diff + pad(timeZoneOffset / 60) 
            + ':' + pad(timeZoneOffset % 60);
    }
};

datetime = {
    /**
     * The number of milliseconds one day.
     * @type {number}
     */
    MILLISECONDS_PER_DAY: 86400000,

    /**
     * The number of milliseconds one hour.
     * @type {number}
     */
    MILLISECONDS_PER_HOUR: 3600000,

    /**
     * The number of milliseconds one minutes.
     * @type {number}
     */
    MILLISECONDS_PER_MINUTES: 60000,

    /**
     * convert milliseconds
     * @param {string} type - type of value.
     * @param {number} value - value to convert.
     * @param {function} iteratee - iteratee function to use reduce.
     * @returns {number} converted value.
     */
    _convMilliseconds: function(type, value, iteratee) {
        var conv = [60, 60, 1000],
            index = {
                hour: 0,
                minutes: 1,
                seconds: 2
            };

        if (!(type in index) || global.isNaN(value)) {
            return false;
        }

        return util.reduce([value].concat(conv.slice(index[type])), iteratee);
    },

    /**
     * Convert milliseconds value to other type
     * @param {type} type convert to type want to. support "hour", "minutes", "seconds" only.
     * @param {value} value - value to convert.
     * @returns {number} converted value.
     */
    millisecondsTo: function(type, value) {
        var cache = memo.millisecondsTo,
            key = type + value;

        if (cache[key]) {
            return cache[key];
        }

        cache[key] = datetime._convMilliseconds(type, value, function(memo, v) {
            return memo / v;
        });

        return cache[key];
    },

    /**
     * Convert value to milliseconds
     * @param {type} type - type of supplied value. support "hour", "minutes", "seconds" only.
     * @param {value} value - value to convert.
     * @returns {number} converted value.
     */
    millisecondsFrom: function(type, value) {
        var cache = memo.millisecondsFrom,
            key = type + value;

        if (cache[key]) {
            return cache[key];
        }

        cache[key] = datetime._convMilliseconds(type, value, function(memo, v) {
            return memo * v;
        });

        return cache[key];
    },

    /**
     * Make date array from supplied paramters.
     * @param {Date} start Start date.
     * @param {Date} end End date.
     * @param {number} step The number of milliseconds to use increment.
     * @returns {array} Date array.
     */
    range: function(start, end, step) {
        var cursor = new Date(start.getTime()),
            result = [];

        while (cursor <= end) {
            result.push(cursor);
            cursor = new Date(cursor.getTime() + step);
        }

        return result;
    },

    /**
     * Clone supplied date.
     * @param {Date} date date object to clone.
     * @returns {Date} Cloned date object
     */
    clone: function(date) {
        return new Date(date.getTime());
    },

    /**
     * Compare two dates.
     *
     * when first date is latest then seconds then return -1.
     *
     * return +1 reverse, and return 0 is same.
     * @param {Date} d1 Date object to compare.
     * @param {Date} d2 Date object to compare.
     * @returns {number} result of compare
     */
    compare: function(d1, d2) {
        var _d1 = d1.getTime(),
            _d2 = d2.getTime();

        if (_d1 < _d2) {
            return -1;
        } else if (_d1 > _d2) {
            return 1;
        }
        return 0;
    },

    /**
     * @param {Date} d1 - date one
     * @param {Date} d2 - date two
     * @returns {boolean} is two date are same year, month?
     */
    isSameMonth: function(d1, d2) {
        return (d1.getFullYear() === d2.getFullYear() &&
                d1.getMonth() === d2.getMonth());
    },

    /**
     * @param {Date} d1 - date one
     * @param {Date} d2 - date two
     * @returns {boolean} is two date are same year, month, date?
     */
    isSameDate: function(d1, d2) {
        var sameMonth = datetime.isSameMonth(d1, d2);
        return sameMonth && (d1.getDate() === d2.getDate());
    },

    /**
     * Check supplied parameter is valid date object.
     * @param {*} d Object to validate.
     * @returns {boolean} return true when parameter is valid date object.
     */
    isValid: function(d) {
        if (opt.call(d) === '[object Date]') {
            return !window.isNaN(d.getTime());
        }
        return false;
    },

    /**
     * convert non local date to UTC date.
     * @param {Date} d Date to convert UTC.
     * @returns {Date} The UTC Date.
     */
    toUTC: function(d) {
        var l = d.getTime(),
            offset = datetime.millisecondsFrom('minutes', new Date().getTimezoneOffset());

        return new Date(l + offset);
    },

    /**
     * pad left zero characters.
     * @param {number} number number value to pad zero.
     * @param {number} length pad length to want.
     * @returns {string} padded string.
     */
    leadingZero: function(number, length) {
        var zero = '',
            i = 0;

        if ((number + '').length > length) {
            return number + '';
        }

        for (; i < (length - 1); i += 1) {
            zero += '0';
        }

        return (zero + number).slice(length * -1);
    },

    /**
     * Convert date string to date object.
     *
     * Only listed below formats avaliable.
     *
     * - YYYYMMDD
     * - YYYY/MM/DD
     * - YYYY-MM-DD
     * - YYYY/MM/DD HH:mm:SS
     * - YYYY-MM-DD HH:mm:SS
     *
     * @param {string} str Formatted string.
     * @param {number} [fixMonth=-1] - number for fix month calculating.
     * @returns {(Date|boolean)} Converted Date object. when supplied str is not available then return false.
     */
    parse: function(str, fixMonth) {
        var separator,
            matches = str.match(dateFormatRx),
            ymd,
            hms;

        if (util.isUndefined(fixMonth)) {
            fixMonth = -1;
        }

        if (!matches) {
            return false;
        }

        if (str.length > 8) {
            // YYYY/MM/DD
            // YYYY-MM-DD
            // YYYY/MM/DD HH:mm:SS
            // YYYY-MM-DD HH:mm:SS
            separator = ~str.indexOf('/') ? '/' : '-';
            matches = matches.splice(1);

            ymd = matches[0].split(separator);
            hms = matches[1] ? matches[1].split(':') : [0, 0, 0];
        } else {
            // YYYYMMDD
            matches = matches[0];
            ymd = [matches.substr(0, 4), matches.substr(4, 2), matches.substr(6, 2)];
            hms = [0, 0, 0];
        }

        return new Date(+ymd[0], +ymd[1] + fixMonth, +ymd[2], +hms[0], +hms[1], +hms[2]);
    },

    /**
     * Return date object from Date.
     * @param {Date} date date
     * @returns {object} Date object.
     */
    raw: function(date) {
        return {
            y: date.getFullYear(),
            M: date.getMonth(),
            d: date.getDate(),
            h: date.getHours(),
            m: date.getMinutes(),
            s: date.getSeconds(),
            ms: date.getMilliseconds()
        };
    },

    /**
     * Return 00:00:00 supplied date.
     * @param {Date} date date.
     * @returns {Date} start date.
     */
    start: function(date) {
        var d = new Date(date.getTime());
        d.setHours(0, 0, 0, 0);

        return d;
    },

    /**
     * Return 23:59:59 supplied date.
     * @param {Date} date date.
     * @returns {Date} end date.
     */
    end: function(date) {
        var d = new Date(date.getTime());
        d.setHours(23, 59, 59, 0);

        return d;
    },

    /**
     * Return formatted string as basis of supplied string.
     *
     * Supported Token Lists.
     *
     * - YYYY => 1988
     * - MM => 01 ~ 12
     * - DD => 01 ~ 31
     * - YYYYMMDD => 19880925
     * @param {Date} date String want to formatted.
     * @param {string} format format str.
     * @returns {string}  Formatted date string.
     */
    format: function(date, format) {
        var result = format;
        util.forEachOwnProperties(tokenFunc, function(converter, token) {
            result = result.replace(token, converter(date));
        });

        return result;
    },

    /**
     * Return 2-dimensional array month calendar
     *
     * dates that different month with given date are negative values
     * @param {Date} month - date want to calculate month calendar
     * @param {number} [startDayOfWeek=0] - start day of week
     * @param {function} [iteratee] - iteratee for customizing calendar object
     * @returns {Array.<string[]>} calendar 2d array
     */
    arr2dCalendar: function(month, startDayOfWeek, iteratee) {
        var weekArr,
            starts, ends,
            startIndex, endIndex,
            afterDates,
            cursor, week,
            calendar = [];

        starts = new Date(new Date(+month).setDate(1));
        ends = new Date(new Date(+starts).setMonth(starts.getMonth() + 1));
        ends = new Date(new Date(+ends).setDate(ends.getDate() - 1));

        // create day number array by startDayOfWeek number
        // 4 -> [4, 5, 6, 0, 1, 2, 3]
        // 2 -> [2, 3, 4, 5, 6, 0, 1]
        weekArr = util.range(startDayOfWeek, 7).concat(util.range(7)).slice(0, 7);
        startIndex = util.inArray(starts.getDay(), weekArr);
        endIndex = util.inArray(ends.getDay(), weekArr);
        // free dates after last date of this month
        afterDates = 7 - (endIndex + 1);

        cursor = new Date(new Date(+starts).setDate(starts.getDate() - startIndex));
        // iteratee all dates to render
        util.forEachArray(util.range(startIndex + ends.getDate() + afterDates), function(i) {
            var date;

            if (!(i % 7)) {
                // group each date by week
                week = calendar[i / 7] = [];
            }

            date = new Date(+cursor);
            date = iteratee ? iteratee(date) : date;
            week.push(date);

            // add date
            cursor = new Date(cursor.setDate(cursor.getDate() + 1));
        });

        return calendar;
    }
};

module.exports = datetime;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],29:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Dirty flagging module for objects.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var common = global.tui.util,
    existy = common.isExisty,
    pick = common.pick,
    isFunc = common.isFunction;

/**
 * Mixin module for dirty flagging on specific objects.
 * @mixin
 * @example
 * var obj = { hello: 'good', test: '123' };
 * dirty.mixin(obj);
 *
 * obj.set('hello', 'world');
 * obj.isDirty();    // true
 * obj.isPropChanged('hello');    // true
 * obj.isPropChanged('test');    // false
 * obj.dirty(false);
 *
 * obj.isDirty();    // false
 * obj.isPropChanged('hello');    // false
 */
var dirty = {
    /**
     * Set property value with dirty flagging.
     * @param {string} propName Property name.
     * @param {*} value Proprty value.
     */
    set: function(propName, value) {
        var originValue = this[propName];

        if (originValue === value) {
            return;
        }

        this[propName] = value;

        if (!this._changed) {
            /**
             * Save changed properties.
             * @memberof dirty
             * @name _changed
             * @type {Object}
             */
            this._changed = {};
        }

        this._changed[propName] = true;

        /**
         * Dirty flag
         * @type {Boolean}
         * @name _dirty
         * @memberof dirty
         */
        this._dirty = true;
    },

    /**
     * Check dirty flag.
     * @returns {boolean} Property is changed.
     */
    isDirty: function() {
        return !!this._dirty;
    },

    /**
     * Set dirty flag manually.
     * @param {Boolean} [toDirty=true] This will set dirty flag directly.
     */
    dirty: function(toDirty) {
        toDirty = existy(toDirty) ? toDirty : true;

        /* istanbul ignore else */
        if (!toDirty) {
            this._changed = {};
        }

        this._dirty = toDirty;
    },

    /**
     * Delete property safety.
     * @param {String} propName The name of property.
     */
    deleteProp: function(propName) {
        delete this[propName];

        if (this._changed) {
            delete this._changed[propName];
        }
    },

    /**
     * Check the changes with specific property.
     * @param {String} propName The name of property you want.
     * @returns {boolean} Is property changed?
     */
    isPropChanged: function(propName) {
        if (!this._changed) {
            return false;
        }

        return this._changed[propName] === true;
    },

    /**
     * Mixin to specific objects.
     * @param {Object} target The object to mix this module.
     * @memberof module:util/dirty
     * @example
     * function Animal() {}
     * dirty.mixin(Animal.prototype);
     */
    mixin: function(target) {
        var methodFilterR = /(^_|mixin|wrap)/;

        common.forEachOwnProperties(dirty, function(o, k) {
            if (!methodFilterR.test(k)) {
                target[k] = dirty[k];
            }
        });
    },

    /**
     * Wrapper method for dirty flagging.
     *
     * This method invoke after invoked specific method that added by you.
     *
     * The method want to add are must exist before add.
     * @param {object} target Target object to method wrap.
     * @param {(string|object)} methodName
     *  Method name to wrap or methodName: flag objects.
     * @param {boolean} [flag=true]
     *  this will used to flagging by dirty flagger after invoke the methods added by you.
     * @memberof module:util/dirty
     * @example
     * function Animal(name) {
     *     this.name = name;
     * }
     * Animal.prototype.growl = jasmine.createSpy('growl');
     * Animal.prototype.test = function() {
     *     return this.name;
     * };
     *
     * dirty.mixin(Animal.prototype);
     * // single
     * dirty.wrap(Animal.prototype, 'growl', true);
     * // multiple
     * dirty.wrap(Animap.prototype, {
     *     growl: true,
     *     test: false
     * });
     *
     */
    wrap: function(target, methodName, flag) {
        var wrap = dirty.wrap,
            fn;

        if (common.isObject(methodName)) {
            common.forEachOwnProperties(methodName, function(flag, methodName) {
                wrap(target, methodName, flag);
            });
            return;
        }

        flag = existy(flag) ? flag : true;

        if (!target._wrapper) {
            /**
             * @param {function} fn Original method to wrap.
             * @param {boolean} flagToSet The boolean value to using dirty flagging.
             * @returns {*} The result value of original method.
             * @name _wrapper
             * @memberof dirty
             */
            target._wrapper = function(fn, flagToSet) {
                return function() {
                    var args = Array.prototype.slice.call(arguments);
                    var result = fn.apply(this, args);
                    this._dirty = flagToSet;
                    return result;
                };
            };
        }

        if (existy(pick(target, methodName)) &&
            isFunc(target[methodName]) &&
            !existy(pick(target, methodName, '_wrapped'))) {
            fn = target[methodName];
            target[methodName] = target._wrapper(fn, flag);
            target[methodName]._wrapped = true;
        }
    }
};

module.exports = dirty;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],30:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Utility module for handling DOM events.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util,
    browser = util.browser,
    eventKey = '_evt',
    DRAG = {
        START: ['touchstart', 'mousedown'],
        END: {
            mousedown: 'mouseup',
            touchstart: 'touchend',
            pointerdown: 'touchend',
            MSPointerDown: 'touchend'
        },
        MOVE: {
            mousedown: 'mousemove',
            touchstart: 'touchmove',
            pointerdown: 'touchmove',
            MSPointerDown: 'touchmove'
        }
    };

var domevent = {
    /**
     * Bind dom events.
     * @param {HTMLElement} obj HTMLElement to bind events.
     * @param {(string|object)} types Space splitted events names or eventName:handler object.
     * @param {*} fn handler function or context for handler method.
     * @param {*} [context] context object for handler method.
     */
    on: function(obj, types, fn, context) {
        if (util.isString(types)) {
            util.forEach(types.split(' '), function(type) {
                domevent._on(obj, type, fn, context);
            });

            return;
        }

        util.forEachOwnProperties(types, function(handler, type) {
            domevent._on(obj, type, handler, fn);
        });
    },

    /**
     * DOM event binding.
     * @param {HTMLElement} obj HTMLElement to bind events.
     * @param {String} type The name of events.
     * @param {*} fn handler function
     * @param {*} [context] context object for handler method.
     * @private
     */
    _on: function(obj, type, fn, context) {
        var id,
            handler,
            originHandler;

        id = type + util.stamp(fn) + (context ? '_' + util.stamp(context) : '');

        if (obj[eventKey] && obj[eventKey][id]) {
            return;
        }

        handler = function(e) {
            fn.call(context || obj, e || window.event);
        };

        originHandler = handler;

        if ('addEventListener' in obj) {
            if (type === 'mouseenter' || type === 'mouseleave') {
                handler = function(e) {
                    e = e || window.event;
                    if (!domevent._checkMouse(obj, e)) {
                        return;
                    }
                    originHandler(e);
                };
                obj.addEventListener((type === 'mouseenter') ?
                    'mouseover' : 'mouseout', handler, false);
            } else {
                if (type === 'mousewheel') {
                    obj.addEventListener('DOMMouseScroll', handler, false);
                }

                obj.addEventListener(type, handler, false);
            }
        } else if ('attachEvent' in obj) {
            obj.attachEvent('on' + type, handler);
        }

        obj[eventKey] = obj[eventKey] || {};
        obj[eventKey][id] = handler;
    },

    /**
     * Unbind DOM Event handler.
     * @param {HTMLElement} obj HTMLElement to unbind.
     * @param {(string|object)} types Space splitted events names or eventName:handler object.
     * @param {*} fn handler function or context for handler method.
     * @param {*} [context] context object for handler method.
     */
    off: function(obj, types, fn, context) {
        if (util.isString(types)) {
            util.forEach(types.split(' '), function(type) {
                domevent._off(obj, type, fn, context);
            });

            return;
        }

        util.forEachOwnProperties(types, function(handler, type) {
            domevent._off(obj, type, handler, fn);
        });
    },

    /**
     * Unbind DOM event handler.
     * @param {HTMLElement} obj HTMLElement to unbind.
     * @param {String} type The name of event to unbind.
     * @param {function()} fn Event handler that supplied when binding.
     * @param {*} context context object that supplied when binding.
     * @private
     */
    _off: function(obj, type, fn, context) {
        var id = type + util.stamp(fn) + (context ? '_' + util.stamp(context) : ''),
            handler = obj[eventKey] && obj[eventKey][id];

        if (!handler) {
            return;
        }

        if ('removeEventListener' in obj) {
            if (type === 'mouseenter' || type === 'mouseleave') {
                obj.removeEventListener((type === 'mouseenter') ?
                    'mouseover' : 'mouseout', handler, false);
            } else {
                if (type === 'mousewheel') {
                    obj.removeEventListener('DOMMouseScroll', handler, false);
                }

                obj.removeEventListener(type, handler, false);
            }
        } else if ('detachEvent' in obj) {
            try {
                obj.detachEvent('on' + type, handler);
            } catch (e) {}    //eslint-disable-line
        }

        delete obj[eventKey][id];

        if (util.keys(obj[eventKey]).length) {
            return;
        }

        // throw exception when deleting host object's property in below IE8
        if (util.browser.msie && util.browser.version < 9) {
            obj[eventKey] = null;
            return;
        }

        delete obj[eventKey];
    },

    /**
     * Bind DOM event. this event will unbind after invokes.
     * @param {HTMLElement} obj HTMLElement to bind events.
     * @param {(string|object)} types Space splitted events names or eventName:handler object.
     * @param {*} fn handler function or context for handler method.
     * @param {*} [context] context object for handler method.
     */
    once: function(obj, types, fn, context) {
        var that = this;

        if (util.isObject(types)) {
            util.forEachOwnProperties(types, function(handler, type) {
                domevent.once(obj, type, handler, fn);
            });
            return;
        }

        function onceHandler() {
            fn.apply(context || obj, arguments);
            that._off(obj, types, onceHandler, context);
        }

        domevent.on(obj, types, onceHandler, context);
    },

    /**
     * Cancel event bubbling.
     * @param {Event} e Event object.
     */
    stopPropagation: function(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
        } else {
            e.cancelBubble = true;
        }
    },

    /**
     * Cancel browser default actions.
     * @param {Event} e Event object.
     */
    preventDefault: function(e) {
        if (e.preventDefault) {
            e.preventDefault();
        } else {
            e.returnValue = false;
        }
    },

    /**
     * Syntatic sugar of stopPropagation and preventDefault
     * @param {Event} e Event object.
     */
    stop: function(e) {
        domevent.preventDefault(e);
        domevent.stopPropagation(e);
    },

    /**
     * Stop scroll events.
     * @param {HTMLElement} el HTML element to prevent scroll.
     */
    disableScrollPropagation: function(el) {
        domevent.on(el, 'mousewheel MozMousePixelScroll', domevent.stopPropagation);
    },

    /**
     * Stop all events related with click.
     * @param {HTMLElement} el HTML element to prevent all event related with click.
     */
    disableClickPropagation: function(el) {
        domevent.on(el, DRAG.START.join(' ') + ' click dblclick', domevent.stopPropagation);
    },

    /**
     * Get mouse position from mouse event.
     *
     * If supplied relatveElement parameter then return relative position based on element.
     * @param {Event} mouseEvent Mouse event object
     * @param {HTMLElement} relativeElement HTML element that calculate relative position.
     * @returns {number[]} mouse position.
     */
    getMousePosition: function(mouseEvent, relativeElement) {
        var rect;

        if (!relativeElement) {
            return [mouseEvent.clientX, mouseEvent.clientY];
        }

        rect = relativeElement.getBoundingClientRect();

        return [
            mouseEvent.clientX - rect.left - relativeElement.clientLeft,
            mouseEvent.clientY - rect.top - relativeElement.clientTop
        ];
    },

    /**
     * Normalize mouse wheel event that different each browsers.
     * @param {MouseEvent} e Mouse wheel event.
     * @returns {Number} delta
     */
    getWheelDelta: function(e) {
        var delta = 0;

        if (e.wheelDelta) {
            delta = e.wheelDelta / 120;
        }

        if (e.detail) {
            delta = -e.detail / 3;
        }

        return delta;
    },

    /**
     * prevent firing mouseleave event when mouse entered child elements.
     * @param {HTMLElement} el HTML element
     * @param {MouseEvent} e Mouse event
     * @returns {Boolean} leave?
     * @private
     */
    _checkMouse: function(el, e) {
        var related = e.relatedTarget;

        if (!related) {
            return true;
        }

        try {
            while (related && (related !== el)) {
                related = related.parentNode;
            }
        } catch (err) {
            return false;
        }

        return (related !== el);
    },

    /**
     * Trigger specific events to html element.
     * @param {HTMLElement} obj HTMLElement
     * @param {string} type Event type name
     * @param {object} [eventData] Event data
     */
    trigger: function(obj, type, eventData) {
        var rMouseEvent = /(mouse|click)/;
        if (util.isUndefined(eventData) && rMouseEvent.exec(type)) {
            eventData = domevent.mouseEvent(type);
        }

        if (obj.dispatchEvent) {
            obj.dispatchEvent(eventData);
        } else if (obj.fireEvent) {
            obj.fireEvent('on' + type, eventData);
        }
    },

    /**
     * Create virtual mouse event.
     *
     * Tested at
     *
     * - IE7 ~ IE11
     * - Chrome
     * - Firefox
     * - Safari
     * @param {string} type Event type
     * @param {object} [eventObj] Event data
     * @returns {MouseEvent} Virtual mouse event.
     */
    mouseEvent: function(type, eventObj) {
        var evt,
            e;

        e = util.extend({
            bubbles: true,
            cancelable: (type !== 'mousemove'),
            view: window,
            wheelDelta: 0,
            detail: 0,
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            button: 0,
            relatedTarget: undefined  // eslint-disable-line
        }, eventObj);

        // prevent throw error when inserting wheelDelta property to mouse event on below IE8
        if (browser.msie && browser.version < 9) {
            delete e.wheelDelta;
        }

        if (typeof document.createEvent === 'function') {
            evt = document.createEvent('MouseEvents');
            evt.initMouseEvent(type,
                e.bubbles, e.cancelable, e.view, e.detail,
                e.screenX, e.screenY, e.clientX, e.clientY,
                e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
                e.button, document.body.parentNode
            );
        } else if (document.createEventObject) {
            evt = document.createEventObject();

            util.forEach(e, function(value, propName) {
                evt[propName] = value;
            }, this);
            evt.button = {0: 1, 1: 4, 2: 2}[evt.button] || evt.button;
        }
        return evt;
    },

    /**
     * Normalize mouse event's button attributes.
     *
     * Can detect which button is clicked by this method.
     *
     * Meaning of return numbers
     *
     * - 0: primary mouse button
     * - 1: wheel button or center button
     * - 2: secondary mouse button
     * @param {MouseEvent} mouseEvent - The mouse event object want to know.
     * @returns {number} - The value of meaning which button is clicked?
     */
    getMouseButton: function(mouseEvent) {
        var button,
            primary = '0,1,3,5,7',
            secondary = '2,6',
            wheel = '4';

        /* istanbul ignore else */
        if (document.implementation.hasFeature('MouseEvents', '2.0')) {
            return mouseEvent.button;
        }

        button = mouseEvent.button + '';
        if (~primary.indexOf(button)) {
            return 0;
        } else if (~secondary.indexOf(button)) {
            return 2;
        } else if (~wheel.indexOf(button)) {
            return 1;
        }
    }
};

module.exports = domevent;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],31:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Utility modules for manipulate DOM elements.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var domevent = require('./domevent');
var Collection = require('./collection');

var util = global.tui.util,
    posKey = '_pos',
    domutil;

var CSS_AUTO_REGEX = /^auto$|^$|%/;

function trim(str) {
    return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
}

domutil = {
    /**
     * Create DOM element and return it.
     * @param {string} tagName Tag name to append.
     * @param {HTMLElement} [container] HTML element will be parent to created element.
     * if not supplied, will use **document.body**
     * @param {string} [className] Design class names to appling created element.
     * @returns {HTMLElement} HTML element created.
     */
    appendHTMLElement: function(tagName, container, className) {
        var el;

        className = className || '';

        el = document.createElement(tagName);
        el.className = className;

        if (container) {
            container.appendChild(el);
        } else {
            document.body.appendChild(el);
        }

        return el;
    },

    /**
     * Remove element from parent node.
     * @param {HTMLElement} el - element to remove.
     */
    remove: function(el) {
        if (el && el.parentNode) {
            el.parentNode.removeChild(el);
        }
    },

    /**
     * Get element by id
     * @param {string} id element id attribute
     * @returns {HTMLElement} element
     */
    get: function(id) {
        return document.getElementById(id);
    },

    /**
     * Check supplied element is matched selector.
     * @param {HTMLElement} el - element to check
     * @param {string} selector - selector string to check
     * @return {boolean} match?
     */
    _matcher: function(el, selector) {
        var cssClassSelector = /^\./,
            idSelector = /^#/;

        if (cssClassSelector.test(selector)) {
            return domutil.hasClass(el, selector.replace('.', ''));
        } else if (idSelector.test(selector)) {
            return el.id === selector.replace('#', '');
        }

        return el.nodeName.toLowerCase() === selector.toLowerCase();
    },

    /**
     * Find DOM element by specific selectors.
     * below three selector only supported.
     *
     * 1. css selector
     * 2. id selector
     * 3. nodeName selector
     * @param {string} selector selector
     * @param {(HTMLElement|string)} [root] You can assign root element to find. if not supplied, document.body will use.
     * @param {boolean|function} [multiple=false] - set true then return all elements that meet condition, if set function then use it filter function.
     * @returns {HTMLElement} HTML element finded.
     */
    find: function(selector, root, multiple) {
        var result = [],
            found = false,
            isFirst = util.isUndefined(multiple) || multiple === false,
            isFilter = util.isFunction(multiple);

        if (util.isString(root)) {
            root = domutil.get(root);
        }
        
        root = root || window.document.body;

        function recurse(el, selector) {
            var childNodes = el.childNodes,
                i = 0,
                len = childNodes.length,
                cursor;

            for (; i < len; i += 1) {
                cursor = childNodes[i];

                if (cursor.nodeName === '#text') {
                    continue;
                }

                if (domutil._matcher(cursor, selector)) {
                    if ((isFilter && multiple(cursor)) || !isFilter) {
                        result.push(cursor);
                    }

                    if (isFirst) {
                        found = true;
                        break;
                    }
                } else if (cursor.childNodes.length > 0) {
                    recurse(cursor, selector);
                    if (found) {
                        break;
                    }
                }
            }
        }

        recurse(root, selector);

        return isFirst ? (result[0] || null) : result;
    },

    /**
     * Find parent element recursively.
     * @param {HTMLElement} el - base element to start find.
     * @param {string} selector - selector string for find
     * @returns {HTMLElement} - element finded or undefined.
     */
    closest: function(el, selector) {
        var parent = el.parentNode;

        if (domutil._matcher(el, selector)) {
            return el;
        }

        while (parent && parent !== window.document.body) {
            if (domutil._matcher(parent, selector)) {
                return parent;
            }

            parent = parent.parentNode;
        }
    },

    /**
     * Return texts inside element.
     * @param {HTMLElement} el target element
     * @return {string} text inside node
     */
    text: function(el) {
        var ret = '',
            i = 0,
            nodeType = el.nodeType;

        if (nodeType) {
            if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                // nodes that available contain other nodes
                if (typeof el.textContent === 'string') {
                    return el.textContent;
                }

                for (el = el.firstChild; el; el = el.nextSibling) {
                    ret += domutil.text(el);
                }
            } else if (nodeType === 3 || nodeType === 4) {
                // TEXT, CDATA SECTION
                return el.nodeValue;
            }
        } else {
            for (; el[i]; i += 1) {
                ret += domutil.text(el[i]);
            }
        }
        return ret;
    },

    /**
     * Set data attribute to target element
     * @param {HTMLElement} el - element to set data attribute
     * @param {string} key - key
     * @param {string|number} data - data value
     */
    setData: function(el, key, data) {
        if ('dataset' in el) {
            el.dataset[key] = data;
            return;
        }

        el.setAttribute('data-' + key, data);
    },

    /**
     * Get data value from data-attribute
     * @param {HTMLElement} el - target element
     * @param {string} key - key
     * @returns {string} value
     */
    getData: function(el, key) {
        if ('dataset' in el) {
            return el.dataset[key];
        }

        return el.getAttribute('data-' + key);
    },

    /**
     * Check element has specific design class name.
     * @param {HTMLElement} el target element
     * @param {string} name css class
     * @returns {boolean} return true when element has that css class name
     */
    hasClass: function(el, name) {
        var className;

        if (!util.isUndefined(el.classList)) {
            return el.classList.contains(name);
        }

        className = domutil.getClass(el);

        return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
    },

    /**
     * Add design class to HTML element.
     * @param {HTMLElement} el target element
     * @param {string} name css class name
     */
    addClass: function(el, name) {
        var className;

        if (!util.isUndefined(el.classList)) {
            util.forEachArray(name.split(' '), function(value) {
                el.classList.add(value);
            });
        } else if (!domutil.hasClass(el, name)) {
            className = domutil.getClass(el);
            domutil.setClass(el, (className ? className + ' ' : '') + name);
        }
    },

    /**
     *
     * Overwrite design class to HTML element.
     * @param {HTMLElement} el target element
     * @param {string} name css class name
     */
    setClass: function(el, name) {
        if (util.isUndefined(el.className.baseVal)) {
            el.className = name;
        } else {
            el.className.baseVal = name;
        }
    },

    /**
     * Element에 cssClass속성을 제거하는 메서드
     * Remove specific design class from HTML element.
     * @param {HTMLElement} el target element
     * @param {string} name class name to remove
     */
    removeClass: function(el, name) {
        var removed = '';

        if (!util.isUndefined(el.classList)) {
            el.classList.remove(name);
        } else {
            removed = (' ' + domutil.getClass(el) + ' ').replace(' ' + name + ' ', ' ');
            domutil.setClass(el, trim(removed));
        }
    },

    /**
     * Get HTML element's design classes.
     * @param {HTMLElement} el target element
     * @returns {string} element css class name
     */
    getClass: function(el) {
        if (!el || !el.className) {
            return '';
        }

        return util.isUndefined(el.className.baseVal) ? el.className : el.className.baseVal;
    },

    /**
     * Get specific CSS style value from HTML element.
     * @param {HTMLElement} el target element
     * @param {string} style css attribute name
     * @returns {(string|null)} css style value
     */
    getStyle: function(el, style) {
        var value = el.style[style] || (el.currentStyle && el.currentStyle[style]),
            css;

        if ((!value || value === 'auto') && document.defaultView) {
            css = document.defaultView.getComputedStyle(el, null);
            value = css ? css[style] : null;
        }

        return value === 'auto' ? null : value;
    },

    /**
     * get element's computed style values.
     *
     * in lower IE8. use polyfill function that return object. it has only one function 'getPropertyValue'
     * @param {HTMLElement} el - element want to get style.
     * @returns {object} virtual CSSStyleDeclaration object.
     */
    getComputedStyle: function(el) {
        var defaultView = document.defaultView;

        if (!defaultView || !defaultView.getComputedStyle) {
            return {
                getPropertyValue: function(prop) {
                    var re = /(\-([a-z]){1})/g;
                    if (prop === 'float') {
                        prop = 'styleFloat';
                    }

                    if (re.test(prop)) {
                        prop = prop.replace(re, function () {
                            return arguments[2].toUpperCase();
                        });
                    }

                    return el.currentStyle[prop] ? el.currentStyle[prop] : null;
                }
            };
        }

        return document.defaultView.getComputedStyle(el);
    },

    /**
     * Set position CSS style.
     * @param {HTMLElement} el target element
     * @param {number} [x=0] left pixel value.
     * @param {number} [y=0] top pixel value.
     */
    setPosition: function(el, x, y) {
        x = util.isUndefined(x) ? 0 : x;
        y = util.isUndefined(y) ? 0 : y;

        el[posKey] = [x, y];

        el.style.left = x + 'px';
        el.style.top = y + 'px';
    },

    /**
     * Get position from HTML element.
     * @param {HTMLElement} el target element
     * @param {boolean} [clear=false] clear cache before calculating position.
     * @returns {number[]} point
     */
    getPosition: function(el, clear) {
        var left,
            top,
            bound;

        if (clear) {
            el[posKey] = null;
        }

        if (el[posKey]) {
            return el[posKey];
        }

        left = 0;
        top = 0;

        if ((CSS_AUTO_REGEX.test(el.style.left) || CSS_AUTO_REGEX.test(el.style.top)) &&
            'getBoundingClientRect' in el) {
            // 엘리먼트의 left또는 top이 'auto'일 때 수단
            bound = el.getBoundingClientRect();

            left = bound.left;
            top = bound.top;
        } else {
            left = parseFloat(el.style.left || 0);
            top = parseFloat(el.style.top || 0);
        }

        return [left, top];
    },

    /**
     * Return element's size
     * @param {HTMLElement} el target element
     * @return {number[]} width, height
     */
    getSize: function(el) {
        var bound,
            width = domutil.getStyle(el, 'width'),
            height = domutil.getStyle(el, 'height');

        if ((CSS_AUTO_REGEX.test(width) || CSS_AUTO_REGEX.test(height)) &&
            'getBoundingClientRect' in el) {
            bound = el.getBoundingClientRect();
            width = bound.width;
            height = bound.height;
        } else {
            width = parseFloat(width || 0);
            height = parseFloat(height || 0);
        }

        return [width, height];
    },

    /**
     * Check specific CSS style is available.
     * @param {array} props property name to testing
     * @return {(string|boolean)} return true when property is available
     * @example
     * var props = ['transform', '-webkit-transform'];
     * domutil.testProp(props);    // 'transform'
     */
    testProp: function(props) {
        var style = document.documentElement.style,
            i = 0,
            len = props.length;

        for (; i < len; i += 1) {
            if (props[i] in style) {
                return props[i];
            }
        }
        return false;
    },

    /**
     * Get form data
     * @param {HTMLFormElement} formElement - form element to extract data
     * @returns {object} form data
     */
    getFormData: function(formElement) {
        var groupedByName = new Collection(function() { return this.length; }),
            noDisabledFilter = function(el) { return !el.disabled; },
            output = {};
            
        groupedByName.add.apply(
            groupedByName, 
            domutil.find('input', formElement, noDisabledFilter)
                .concat(domutil.find('select', formElement, noDisabledFilter))
                .concat(domutil.find('textarea', formElement, noDisabledFilter))
        );

        groupedByName = groupedByName.groupBy(function(el) {
            return el && el.getAttribute('name') || '_other';
        });

        util.forEach(groupedByName, function(elements, name) {
            if (name === '_other') {
                return;
            }

            elements.each(function(el) {
                var nodeName = el.nodeName.toLowerCase(),
                    type = el.type,
                    result = [];

                if (type === 'radio') {
                    result = [elements.find(function(el) { return el.checked; }).toArray().pop()];
                } else if (type === 'checkbox') {
                    result = elements.find(function(el) { return el.checked; }).toArray();
                } else if (nodeName === 'select') {
                    elements.find(function(el) { return !!el.childNodes.length; })
                        .each(function(el) {
                            result = result.concat(domutil.find('option', el, function(opt) {
                                return opt.selected;
                            }));
                        });
                } else {
                    result = elements.find(function(el) { return el.value !== ''; }).toArray();
                }

                result = util.map(result, function(el) { return el.value; });

                if (!result.length) {
                    result = '';
                } else if (result.length === 1) {
                    result = result[0];
                }

                output[name] = result;
            });
        });

        return output;
    }
};

/*eslint-disable*/
var userSelectProperty = domutil.testProp([
    'userSelect', 
    'WebkitUserSelect', 
    'OUserSelect', 
    'MozUserSelect', 
    'msUserSelect'
]);
var supportSelectStart = 'onselectstart' in document;
var prevSelectStyle = '';
/*eslint-enable*/

/**
 * Disable browser's text selection behaviors.
 * @method
 */
domutil.disableTextSelection = (function() {
    if (supportSelectStart) {
        return function() {
            domevent.on(window, 'selectstart', domevent.preventDefault);
        };
    }

    return function() {
        var style = document.documentElement.style;
        prevSelectStyle = style[userSelectProperty];
        style[userSelectProperty] = 'none';
    };
})();

/**
 * Enable browser's text selection behaviors.
 * @method
 */
domutil.enableTextSelection = (function() {
    if (supportSelectStart) {
        return function() {
            domevent.off(window, 'selectstart', domevent.preventDefault);
        };
    }

    return function() {
        document.documentElement.style[userSelectProperty] = prevSelectStyle;
    };
})();

/**
 * Disable browser's image drag behaviors.
 */
domutil.disableImageDrag = function() {
    domevent.on(window, 'dragstart', domevent.preventDefault);
};

/**
 * Enable browser's image drag behaviors.
 */
domutil.enableImageDrag = function() {
    domevent.off(window, 'dragstart', domevent.preventDefault);
};

module.exports = domutil;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./collection":26,"./domevent":30}],32:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Module for specific element's height set to remain height of container element.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.tui.util;
var domutil = require('../common/domutil');

/**
 * @constructor
 * @param {HTMLElement[]} elements - element list to managing height
 * @param {HTMLElement} container - wrapping container element
 */
function FillRemainHeight(elements, container) {
    if (!(this instanceof FillRemainHeight)) {
        return new FillRemainHeight(elements, container);
    }

    /**
     * @type {number}
     */
    this._idx = 0;

    /**
     * @type {object}
     */
    this._listed = {};

    /**
     * @type {HTMLElement}
     */
    this._container = container;

    util.forEach(elements, function(element) {
        this.addElement(element);
    }, this);
}

/**
 * Destroy method
 */
FillRemainHeight.prototype.destroy = function() {
    this._idx = this._listed = this._container = null;
};

/**
 * @param {HTMLElement} element - element to set height px
 * @param {number} height - pixel height value
 * @private
 */
FillRemainHeight.prototype._setHeight = function(element, height) {
    element.style.height = height + 'px';
};

FillRemainHeight.prototype._getHeight = function(element) {
    return element.offsetHeight;
};

/**
 * Add managed element
 * @param {HTMLElement} element - element to managing height
 */
FillRemainHeight.prototype.addElement = function(element) {
    var id = this._idx;

    domutil.setData(element, 'elid', id);

    this._listed[id] = element;
    this._idx += 1;
};

/**
 * Remove managed element
 * @param {HTMLElement} element - element to remove
 */
FillRemainHeight.prototype.removeElement = function(element) {
    var id = domutil.getData(element, 'elid');

    domutil.setData(element, 'elid', '');

    delete this._listed[id];
};

/**
 * Get height of element that not listed in this module
 * @param {object} listed - this._listed property
 * @param {HTMLElement} element - element to calculate height
 * @returns {number} height
 */
FillRemainHeight.prototype._getOtherElementHeight = function(listed, element) {
    var id;

    if (element.nodeName === '#text') {
        return 0;
    }

    id = domutil.getData(element, 'elid');

    if (listed[id]) {
        return 0;
    }

    return this._getHeight(element);
};

/**
 * calculate rest height of container and set it to listed elements.
 */
FillRemainHeight.prototype.refresh = function() {
    var container = this._container,
        containerHeight = domutil.getSize(container)[1],
        childs = container.childNodes,
        i = 0, len = childs.length,
        listed = this._listed,
        usedHeight = 0,
        height;

    for (; i < len; i += 1) {
        usedHeight += this._getOtherElementHeight(listed, childs[i]);
    }

    height = (containerHeight - usedHeight) / util.keys(listed).length;
    util.forEach(listed, function(element) {
        this._setHeight(element, height);
    }, this);
};

module.exports = FillRemainHeight;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/domutil":31}],33:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Mixin module for models.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util,
    spaceRx = /^\s*|\s*$/g,
    model;

var datetime = require('../common/datetime');

/**
 * Mixin module for models.
 * @mixin
 */
model = {
    /**
     * string trim
     * @param {string} str string to trim
     * @returns {string} trimed string
     */
    trim: function(str) {
        return str.replace(spaceRx, '');
    },
    /**
     * The collections of validator functions.
     */
    validators: {
        /**
         * check all of supplied fields(property) is not undefined or empty string.
         * @param {object} instance model instance.
         * @param {string[]} fields property names to check.
         * @returns {boolean} return true when supplied fields are not undefined or empty string.
         */
        required: function(instance, fields) {
            var valid = true,
                isValid = function(obj) {
                    return !util.isUndefined(obj) && model.trim(obj) !== '';
                };

            util.forEach(fields, function(fieldName) {
                valid = isValid(instance[fieldName]);
                return valid;
            });

            return valid;
        },

        /**
         * check supplied fields are valid dates and valid date ranges.
         * @param {object} instance model instance.
         * @param {Date[]} fields array of date range (starts, ends)
         * @returns {boolean} is valid date range?
         */
        dateRange: function(instance, fields) {
            var starts,
                ends;

            if (!util.isExisty(instance) || fields.length !== 2) {
                return true;
            }

            starts = new Date(instance[fields[0]]);
            ends = new Date(instance[fields[1]]);

            if (!datetime.isValid(starts) || !datetime.isValid(ends)) {
                return false;
            }

            if (datetime.compare(starts, ends) === 1) {
                return false;
            }

            return true;
        }
    },

    /**
     * Check validate for model instance.
     *
     * The validate are works on a basis of constructor's "schema" property.
     *
     * You can customize validators add some method to model#validators.
     * @returns {Boolean} model is valid?
     */
    isValid: function() {
        var that = this,
            schema = this.constructor.schema,
            validators = model.validators,
            validator,
            valid = true;

        if (!schema) {
            return true;
        }

        util.forEach(schema, function(values, validatorName) {
            validator = validators[validatorName];

            if (validator) {
                valid = validator(that, values);
                return valid;
            }
        });

        return valid;
    },

    /**
     * Make data object form instance.
     *
     * It return object fill with all owned properties but exclude functions.
     * @returns {object} Data object
     */
    parameterize: function() {
        var param = {},
            isFunc = util.isFunction;

        util.forEach(this, function(value, propName) {
            if (!isFunc(value)) {
                param[propName] = value;
            }
        });

        return param;
    },

    /**
     * Mixin model module to supplied target.
     * @param {Object} target The object of want to mixed.
     * @example
     * function Man() {
     *     this.name = 'john';
     * }
     * model.mixin(Man.prototype);
     */
    mixin: function(target) {
        util.forEach(model, function(method, name) {
            if (name !== 'mixin') {
                target[name] = method;
            }
        });
    }
};

module.exports = model;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/datetime":28}],34:[function(require,module,exports){
(function (global){
/**
 * @fileoverview
 * Class for represent two dimensional x, y coordinates.
 *
 * It suppliy a group of functions for manipulate coordinates.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 * @example
 * var p = point(10, 10);
 * var r1 = p.add(Point(5, 5));
 * console.log(p.toString())    // "Point(10, 10)"
 * console.log(r1.toString())    // "Point(15, 15)"
 *
 * var p2 = new Point(10, 10);
 * p2._add(point(5, 5));
 * console.log(p2.toString())   // "Point(15, 15)"
 */
'use strict';

var util = global.tui.util;

/**
 * Class for represent two dimentional x, y coordinates.
 * @constructor
 * @param {number} x The number of X coordinates.
 * @param {number} y The number of Y coordinates.
 * @param {boolean} [useRound=false] set true when each coordinates are rounded before initialize.
 * @example
 * var t = new Point(13, 5);
 */
function Point(x, y, useRound) {
    /**
     * @type {number}
     */
    this.x = (useRound ? Math.round(x) : x);

    /**
     * @type {number}
     */
    this.y = (useRound ? Math.round(y) : y);
}

/**********
 * static props
 **********/

/**
 * Calculate point ratio.
 * @param {Point} point The instance of point.
 * @param {number} factor From factor
 * @param {number} toFactor To factor
 * @returns {Point} Point instance calculated.
 */
Point.getRatio = function(point, factor, toFactor) {
    if (factor === toFactor) {
        return point.clone();
    }

    return point.multiplyBy(toFactor)._divideBy(factor);
};

/**
 * Syntatic sugar of new Point()
 * @param {(Point|number|number[])} x X coordinate value.
 * @param {(number|boolean)} [y] Y coordinate value or boolean value for coordinates round.
 * @param {boolean} [useRound] Set true then round initial coordinate values.
 * @returns {Point} The instance of point.
 * @example
 * var p1 = point(10, 15);
 * var p2 = point([10, 15]);
 */
Point.n = function(x, y, useRound) {
    if (x instanceof Point) {
        return x;
    }

    if (util.isArray(x)) {
        return new Point(x[0], x[1], y);
    }

    return new Point(x, y, useRound);
};

/**********
 * prototype props
 **********/

/**
 * Clone points
 * @returns {Point} The point instance cloned.
 */
Point.prototype.clone = function() {
    return new Point(this.x, this.y);
};

/**
 * Add points.
 * @param {Point} point The point instance to add.
 * @return {Point} Point calculated.
 */
Point.prototype.add = function(point) {
    return this.clone()._add(Point.n(point));
};

/**
 * Add self points.
 * @param {Point} point The point instance to add.
 * @return {Point} Point calculated.
 */
Point.prototype._add = function(point) {
    this.x += point.x;
    this.y += point.y;
    return this;
};

/**
 * Subtract points.
 * @param {Point} point The point instance to subtract.
 * @return {Point} Point calculated.
 */
Point.prototype.subtract = function(point) {
    return this.clone()._subtract(Point.n(point));
};

/**
 * Subtract points. (manipulate self)
 * @param {Point} point The point instance to subtract.
 * @returns {Point} Point calculated.
 */
Point.prototype._subtract = function(point) {
    this.x -= point.x;
    this.y -= point.y;
    return this;
};

/**
 * Divide points.
 * @param {number} num The number to divide.
 * @returns {Point} Point calculated.
 */
Point.prototype.divideBy = function(num) {
    return this.clone()._divideBy(num);
};

/**
 * Divide points. (manipulate self)
 * @param {number} num The number to divide.
 * @returns {Point} Point calculated.
 */
Point.prototype._divideBy = function(num) {
    this.x /= num;
    this.y /= num;
    return this;
};

/**
 * Multiply coordinates.
 * @param {number} num Thyen number to multiply
 * @return {Point} Point calculated.
 */
Point.prototype.multiplyBy = function(num) {
    return this.clone()._multiplyBy(num);
};

/**
 * Multiply self coordinates.
 * @param {number} num The number to multiply.
 * @returns {Point} Point calculated.
 */
Point.prototype._multiplyBy = function(num) {
    this.x *= num;
    this.y *= num;
    return this;
};

/**
 * Round coordinates.
 * @returns {Point} Point calculated.
 */
Point.prototype.round = function() {
    return this.clone()._round();
};

/**
 * Round self coordinates.
 * @returns {Point} Point calculated.
 */
Point.prototype._round = function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
};

/**
 * Reverse values between positive and negative.
 * @returns {Point} Point calculated.
 */
Point.prototype.reverse = function() {
    return this.clone()._reverse();
};

/**
 * Reverse self values between positive and negative.
 * @returns {Point} Point calculated.
 */
Point.prototype._reverse = function() {
    this.x *= -1;
    this.y *= -1;
    return this;
};

/**
 * Floor coordinates.
 * @returns {Point} Point calculated.
 */
Point.prototype.floor = function() {
    return this.clone()._floor();
};

/**
 * Floor self coordinates.
 * @returns {Point} Point calculated.
 */
Point.prototype._floor = function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
};

/**
 * Ceil coordinates.
 * @returns {Point} Point calculated.
 */
Point.prototype.ceil = function() {
    return this.clone()._ceil();
};

/**
 * Ceil self coodinates.
 * @returns {Point} Point calculated.
 */
Point.prototype._ceil = function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
};

/**
 * Rotate point.
 * @param {number} deg The number of rotate degree.
 * @param {Point} [center=this] Center point instance to use rotate center. use own when not supplied.
 * @param {number} [cos] Cosine values for rotate. it useful when multi point rotate.
 * @param {number} [sin] Sine values for rotate. it useful when multi point rotate.
 * @returns {Point} The point instance rotated.
 */
Point.prototype.rotate = function(deg, center, cos, sin) {
    return this.clone()._rotate(deg, center, cos, sin);
};

/**
 * Rotate self.
 * @param {number} deg The number of rotate degree.
 * @param {Point} [center=this] Center point instance to use rotate center. use own when not supplied.
 * @param {number} [cos] Cosine values for rotate. it useful when multi point rotate.
 * @param {number} [sin] Sine values for rotate. it useful when multi point rotate.
 * @returns {Point} The point instance rotated.
 */
Point.prototype._rotate = function(deg, center, cos, sin) {
    var rad = deg * (Math.PI / 180),
        x,
        y;

    cos = cos || parseFloat(Math.cos(rad).toFixed(8));
    sin = sin || parseFloat(Math.sin(rad).toFixed(8));

    this._subtract(center);

    x = this.x;
    y = this.y;

    this.x = x * cos - y * sin;
    this.y = x * sin + y * cos;

    this._add(center);

    return this;
};

/**
 * Calculate distance between two points.
 * @param {Point} point Point instance.
 * @returns {number} The number of distance between two points.
 */
Point.prototype.distanceTo = function(point) {
    var x,
        y;

    point = Point.n(point);

    x = point.x - this.x;
    y = point.y - this.y;

    return Math.sqrt(x * x + y * y);
};

/**
 * Check point equals.
 * @param {Point} point Point instance to compare
 * @returns {boolean} equality
 */
Point.prototype.equals = function(point) {
    point = Point.n(point);
    return point.x === this.x && point.y === this.y;
};

/**
 * Return formatted string. 'Point(x, y)'
 * @returns {string} string
 */
Point.prototype.toString = function() {
    return 'Point(' + this.x + ', ' + this.y + ')';
};

/**
 * Return coodinates to array. [x, y]
 * @returns {number[]} coordinate array.
 */
Point.prototype.toArray = function() {
    return [this.x, this.y];
};

module.exports = Point;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],35:[function(require,module,exports){
(function (global){
/**
 * @fileoverview RequestAnimFrame
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var requestFn,
    cancelFn;

function getPrefixed(name) {
    return global['webkit' + name] || global['moz' + name] || global['ms' + name];
}

requestFn = global.requestAnimationFrame ||
    getPrefixed('RequestAnimationFrame') ||
    function(fn, context) {
        fn.call(context);
    };

cancelFn = global.cancelAnimationFrame ||
    getPrefixed('CancelAnimationFrame') ||
    getPrefixed('CancelRequestAnimationFrame') ||
    function() {};

/**
 * @module module:reqAnimFrame
 */

module.exports = {
    /**
     * Shim of requestAnimationFrame
     * @param {function} fn callback function
     * @param {*} context context for callback
     * @returns {number} Unique id
     */
    requestAnimFrame: function(fn, context) {
        return requestFn.call(global, util.bind(fn, context));
    },

    /**
     * Shim of cancelAnimationFrame
     * @param {number} id requestAnimationFrame id
     */
    cancelAnimFrame: function(id) {
        if (!id) {
            return;
        }

        cancelFn.call(global, id);
    }
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],36:[function(require,module,exports){
/* eslint-disable */
/**
 * @fileoverview Global configuration object module. This @echo syntax will change preprocess context. See gulpfile.js
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var config = {
    throwError: function(msg) {
        alert(msg);
    },

    cssPrefix: 'dcal-',

    classname: function(str) {
        return config.cssPrefix + (str + '');
    },

    minicalendar: {
        getDataRegExp: /dcal-minicalendar-(\d{4}-\d{2}-\d{2})/
    },

    allday: {
        getViewIDRegExp: /^dcal-allday-monthweek[\s]dcal-(\d+)/,
        checkCondRegExp: /^dcal-allday-event(-title)?$/
    },

    time: {
        getViewIDRegExp: /^dcal-time-date[\s]dcal-(\d+)/
    }
};

module.exports = config;


},{}],37:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Base calendar controller
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var CalEvent = require('../model/calEvent');
var CalEventViewModel = require('../model/viewModel/calEvent');
var datetime = require('../common/datetime');
var common = require('../common/common');

/**
 * @constructor
 * @param {object} options - options for base controller
 * @param {function} [options.groupFunc] - function for group each models {@see Collection#groupBy}
 * @mixes util.CustomEvents
 */
function Base(options) {
    options = options || {};

    /**
     * function for group each event models.
     * @type {function}
     * @param {CalEventViewModel} viewModel - view model instance
     * @return {string} group key
     */
    this.groupFunc = options.groupFunc || function(viewModel) {
        if (viewModel.model.isAllDay) {
            return 'allday';
        }
        return 'time';
    }

    /**
     * events collection.
     * @type {Collection}
     */
    this.events = common.createEventCollection();

    /**
     * Matrix for multidate events.
     * @type {object.<string, array>}
     */
    this.dateMatrix = {};
}

/**
 * Calculate contain dates in event.
 * @private
 * @param {CalEvent} event The instance of event.
 * @returns {array} contain dates.
 */
Base.prototype._getContainDatesInEvent = function(event) {
    var range = datetime.range(
        datetime.start(event.getStarts()),
        datetime.start(event.getEnds()),
        datetime.MILLISECONDS_PER_DAY
    );

    return range;
};

/**********
 * CRUD
 **********/

/**
 * Create an event instance from raw data.
 * @emits Base#createdEvent
 * @param {object} options Data object to create event.
 * @param {boolean} silent - set true then don't fire events.
 * @returns {CalEvent} The instance of CalEvent that created.
 */
Base.prototype.createEvent = function(options, silent) {
    var event = this.addEvent(CalEvent.create(options));

    if (!silent) {
        /**
         * @event Base#createdEvent
         * @type {CalEvent}
         */
        this.fire('createdEvent', event);
    }

    return event;
};

/**
 * @emits Base#beforeCreateEvent
 * @emits Base#createdEvent
 * @param {Calendar~CalEvent[]} dataList - dataObject list to create event.
 * @param {boolean} [silent=false] - set true then don't fire events.
 * @returns {CalEvent[]} The instance list of CalEvent that created.
 */
Base.prototype.createEvents = function(dataList, silent) {
    return util.map(dataList, function(data) {
        return this.createEvent(data, silent);
    }, this);
};

/**
 * Update an event.
 * @emits Base#updateEvent
 * @param {number} id The unique id of CalEvent instance.
 * @param {object} options updated object data.
 * @returns {CalEvent|boolean} updated event instance, when it fail then return false.
 */
Base.prototype.updateEvent = function(id, options) {
    var result = false;

    this.events.doWhenHas(id, function(model) {
        options = options || {};

        if (options.title) {
            model.set('title', options.title);
        }

        if (options.isAllDay) {
            model.set('isAllDay', options.isAllDay);
        }

        if (options.starts) {
            model.set('starts', new Date(options.starts));
        }

        if (options.ends) {
            model.set('ends', new Date(options.ends));
        }

        this._removeFromMatrix(model);
        this._addToMatrix(model);

        result = model;
    }, this);

    /**
     * @event Base#updateEvent
     */
    this.fire('updateEvent');

    return result;
};

/**
 * Delete event instance from controller.
 * @param {number} id - unique id of model instance.
 * @returns {CalEvent} deleted model instance.
 */
Base.prototype.deleteEvent = function(id) {
    var result = false;

    this.events.doWhenHas(id, function(event) {
        result = event;
        this._removeFromMatrix(event);
        this.events.remove(event);
    }, this);

    return result;
};

/**
 * Set date matrix to supplied event instance.
 * @param {CalEvent} event - instance of event.
 */
Base.prototype._addToMatrix = function(event) {
    var ownMatrix = this.dateMatrix,
        containDates = this._getContainDatesInEvent(event);

    util.forEach(containDates, function(date) {
        var ymd = datetime.format(date, 'YYYYMMDD'),
            matrix = ownMatrix[ymd] = ownMatrix[ymd] || [];

        matrix.push(util.stamp(event));
    });
};

/**
 * Remove event's id from matrix.
 * @param {CalEvent} event - instance of event
 */
Base.prototype._removeFromMatrix = function(event) {
    var modelID = util.stamp(event);

    util.forEach(this.dateMatrix, function(matrix) {
        var index = util.inArray(modelID, matrix);

        if (~index) {
            matrix.splice(index, 1);
        }
    }, this);
};

/**
 * Add an event instance.
 * @emits Base#addedEvent
 * @param {CalEvent} event The instance of CalEvent.
 * @param {boolean} silent - set true then don't fire events.
 * @returns {CalEvent} The instance of CalEvent that added.
 */
Base.prototype.addEvent = function(event, silent) {
    this.events.add(event);
    this._addToMatrix(event);

    if (!silent) {
        /**
         * @event Base#addedEvent
         * @type {object}
         */
        this.fire('addedEvent', event);
    }

    return event;
};

/**
 * split event model by ymd.
 * @param {Date} starts - start date
 * @param {Date} ends - end date
 * @param {Collection} eventCollection - collection of event model.
 * @returns {object.<string, Collection>} splitted event model collections.
 */
Base.prototype.splitEventByDateRange = function(starts, ends, eventCollection) {
    var range = datetime.range(
            datetime.start(starts),
            datetime.start(ends),
            datetime.MILLISECONDS_PER_DAY
        ),
        ownMatrix = this.dateMatrix,
        result = {};

    util.forEachArray(range, function(date) {
        var ymd = datetime.format(date, 'YYYYMMDD'),
            matrix = ownMatrix[ymd],
            collection;

        collection = result[ymd] = common.createEventCollection();

        if (matrix && matrix.length) {
            util.forEachArray(matrix, function(id) {
                eventCollection.doWhenHas(id, function(event) {
                    collection.add(event);
                });
            });
        }
    });

    return result;
};

/**
 * Return events in supplied date range.
 *
 * available only YMD.
 * @param {Date} starts start date.
 * @param {Date} ends end date.
 * @returns {object.<string, Collection>} event collection grouped by dates.
 */
Base.prototype.findByDateRange = function(starts, ends) {
    var range = datetime.range(
            datetime.start(starts),
            datetime.start(ends),
            datetime.MILLISECONDS_PER_DAY
        ),
        ownEvents = this.events.items,
        ownMatrix = this.dateMatrix,
        dformat = datetime.format,
        result = {},
        matrix,
        ymd,
        viewModels;

    util.forEachArray(range, function(date) {
        ymd = dformat(date, 'YYYYMMDD');
        matrix = ownMatrix[ymd];
        viewModels = result[ymd] = common.createEventCollection();

        if (matrix && matrix.length) {
            viewModels.add.apply(viewModels, util.map(matrix, function(id) {
                return CalEventViewModel.create(ownEvents[id]);
            }));
        }
    });

    return result;
};

// mixin
util.CustomEvents.mixin(Base);

module.exports = Base;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/common":27,"../common/datetime":28,"../model/calEvent":72,"../model/viewModel/calEvent":73}],38:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Controller mixin modules for day views.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var Collection = require('../../common/collection');
var datetime = require('../../common/datetime');
var common = require('../../common/common');
var array = require('../../common/array');
var CalEventViewModel = require('../../model/viewModel/calEvent');
var aps = Array.prototype.slice;

/**
 * @mixin Base.Week
 */
var Week = {
    /**********
     * COMMON
     **********/

    /**
     * Calculate collision group.
     * @this Base.Week
     * @param {array} viewModels List of viewmodels.
     * @returns {array} Collision Group.
     */
    getCollisionGroup: function(viewModels) {
        var collisionGroups = [],
            foundPrevCollisionEvent = false,
            previousEventList;

        if (!viewModels.length) {
            return collisionGroups;
        }

        collisionGroups[0] = [util.stamp(viewModels[0].valueOf())];
        util.forEachArray(viewModels.slice(1), function(event, index) {
            foundPrevCollisionEvent = false;
            previousEventList = aps.apply(viewModels, [0, index + 1]).reverse();

            util.forEachArray(previousEventList, function(previous) {
                if (event.collidesWith(previous)) {
                    // 이전 일정들과 겹치는 경우 겹치는 일정의 Collision Group을
                    // 찾아 이 일정을 추가한다
                    foundPrevCollisionEvent = true;

                    util.forEachArray(collisionGroups.slice(0).reverse(), function(group) {
                        if (~util.inArray(util.stamp(previous.valueOf()), group)) {
                            // 겹치는 이전 일정을 찾은 경우 그 일정이 속한
                            // Collision Group에 이 일정을 포함시킨다.
                            group.push(util.stamp(event.valueOf()));
                            return false;
                        }
                    });

                    return false;
                }
            });

            if (!foundPrevCollisionEvent) {
                // 이 일정은 이전일정과 겹치지 않는 일정이므로
                // 새 Collision Group을 구성한다.
                collisionGroups.push([util.stamp(event.valueOf())]);
            }
        });

        return collisionGroups;
    },

    /**
     * Get row length by column index in 2d matrix.
     * @this Base.Week
     * @param {array[]} arr2d Matrix
     * @param {number} col Column index.
     * @return {number} Last row number in column.
     */
    getLastRowInColumn: function(arr2d, col) {
        var row = arr2d.length;

        while (row > 0) {
            row -= 1;
            if (!util.isUndefined(arr2d[row][col])) {
                return row;
            }
        }

        return false;
    },

    /**
     * Calculate matrix for appointment block element placing.
     * @this Base.Week
     * @param {Collection} collection model collection.
     * @param {array[]} collisionGroups Collision groups for event set.
     * @returns {array} matrices
     */
    getMatrices: function(collection, collisionGroups) {
        var result = [],
            getLastRowInColumn = Week.getLastRowInColumn;

        util.forEachArray(collisionGroups, function(group) {
            var matrix = [[]];

            util.forEachArray(group, function(eventID) {
                var event = collection.items[eventID],
                    col = 0,
                    found = false,
                    nextRow,
                    lastRowInColumn;

                while (!found) {
                    lastRowInColumn = getLastRowInColumn(matrix, col);

                    if (lastRowInColumn === false) {
                        matrix[0].push(event);
                        found = true;
                    } else if (!event.collidesWith(matrix[lastRowInColumn][col])) {
                        nextRow = lastRowInColumn + 1;
                        if (util.isUndefined(matrix[nextRow])) {
                            matrix[nextRow] = [];
                        }
                        matrix[nextRow][col] = event;
                        found = true;
                    }

                    col += 1;
                }
            });

            result.push(matrix);
        });

        return result;
    },

    /**********
     * TIME GRID VIEW
     **********/

    /**
     * Make array with start and end times on events.
     * @this Base.Week
     * @param {array[]} matrix - matrix from controller.
     * @returns {array[]} starttime, endtime array (exclude first row's events)
     */
    generateTimeArrayInRow: function(matrix) {
        var row,
            col,
            event,
            map = [],
            cursor = [],
            maxColLen = Math.max.apply(null, util.map(matrix, function(col) {
                return col.length;
            }));

        for (col = 1; col < maxColLen; col += 1) {
            row = 0;
            event = util.pick(matrix, row, col);

            while (event) {
                cursor.push([event.getStarts().getTime(), event.getEnds().getTime()]);

                row += 1;
                event = util.pick(matrix, row, col);
            }

            map.push(cursor);
            cursor = [];
        }

        return map;
    },

    /**
     * Get collision information from list
     * @this Base.Week
     * @param {array.<number[]>} arr - list to detecting collision. [[start, end], [start, end]]
     * @param {number} start - event start time that want to detect collisions.
     * @param {number} end - event end time that want to detect collisions.
     * @returns {boolean} target has collide in supplied array?
     */
    hasCollide: function(arr, start, end) {
        var startStart,
            startEnd,
            endStart,
            endEnd,
            getFunc = function(index) {
                return function(block) {
                    return block[index];
                };
            },
            abs = Math.abs,
            compare = array.compare.num.asc,
            hasCollide;

        if (!arr.length) {
            return false;
        }

        startStart = abs(array.bsearch(arr, start, getFunc(0), compare));
        startEnd = abs(array.bsearch(arr, start, getFunc(1), compare));
        endStart = abs(array.bsearch(arr, end, getFunc(0), compare));
        endEnd = abs(array.bsearch(arr, end, getFunc(1), compare));
        hasCollide = !(startStart === startEnd && startEnd === endStart && endStart === endEnd);

        return hasCollide;
    },

    /**
     * Initialize values to viewmodels for detect real collision at rendering phase.
     * @this Base.Week
     * @param {array[]} matrices - Matrix data.
     */
    getCollides: function(matrices) {
        util.forEachArray(matrices, function(matrix) {
            var binaryMap,
                maxRowLength;

            binaryMap = Week.generateTimeArrayInRow(matrix);
            maxRowLength = Math.max.apply(null, util.map(matrix, function(row) {
                return row.length;
            }));

            util.forEachArray(matrix, function(row) {
                util.forEachArray(row, function(viewModel, col) {
                    var startTime,
                        endTime,
                        hasCollide,
                        i;

                    if (!viewModel) {
                        return;
                    }

                    startTime = viewModel.getStarts().getTime() + 1;
                    endTime = viewModel.getEnds().getTime() - 1;

                    for (i = (col + 1); i < maxRowLength; i += 1) {
                        hasCollide = Week.hasCollide(binaryMap[i - 1], startTime, endTime);

                        if (hasCollide) {
                            viewModel.hasCollide = true;
                            break;
                        }

                        viewModel.extraSpace += 1;
                    }
                });
            });
        });
    },

    /**
     * @this Base
     * @param {Date} starts - start date.
     * @param {Date} ends - end date.
     * @param {Collection} time - view model collection.
     * @returns {object} view model for time part.
     */
    getViewModelForTimeView: function(starts, ends, time) {
        var ymdSplitted = this.splitEventByDateRange(starts, ends, time),
            result = {};

        util.forEach(ymdSplitted, function(collection, ymd) {
            var viewModels = collection.sort(array.compare.event.asc),
                collisionGroups,
                matrices;

            collisionGroups = this.getCollisionGroup(viewModels);
            matrices = this.getMatrices(collection, collisionGroups);
            this.getCollides(matrices);

            result[ymd] = matrices;
        }, Week);

        return result;
    },

    /**********
     * ALLDAY VIEW
     **********/

    /**
     * create view model for allday view part.
     * @param {Date} starts start date.
     * @param {Date} ends end date.
     * @param {Collection} viewModels - allday event viewModel viewModels.
     * @returns {object} allday viewModel.
     */
    getViewModelForAlldayView: function(starts, ends, viewModels) {
        var list,
            ymdsToRender,
            collisionGroups,
            matrices;

        if (!viewModels || !viewModels.length) {
            return [];
        }

        ymdsToRender = util.map(
            datetime.range(starts, ends, datetime.MILLISECONDS_PER_DAY),
            function(date) {
                return datetime.format(date, 'YYYYMMDD');
            }
        );

        list = viewModels.sort(array.compare.event.asc);
        collisionGroups = Week.getCollisionGroup(list);
        matrices = Week.getMatrices(viewModels, collisionGroups);

        util.forEachArray(matrices, function(matrix) {
            util.forEachArray(matrix, function(column) {
                util.forEachArray(column, function(viewModel, index) {
                    var ymd, dateLength;

                    if (!viewModel) {
                        return;
                    }

                    ymd = datetime.format(viewModel.getStarts(), 'YYYYMMDD');
                    dateLength = datetime.range(
                        viewModel.getStarts(),
                        viewModel.getEnds(),
                        datetime.MILLISECONDS_PER_DAY
                    ).length;

                    viewModel.top = index;
                    viewModel.left = util.inArray(ymd, ymdsToRender);
                    viewModel.width = dateLength;
                });
            });
        });

        return matrices;
    },

    /**********
     * READ
     **********/

    /**
     * Populate events in date range.
     * @this Base
     * @param {Date} starts start date.
     * @param {Date} ends end date.
     * @param {object} [andFilter] - additional filter to AND clause
     * @returns {object} events grouped by dates.
     */
    findByDateRange: function(starts, ends, andFilter) {
        var that = this,
            events,
            viewModels,
            filter;

        filter = function(model) {
            var ownStarts = model.getStarts(),
                ownEnds = model.getEnds();

            return (ownStarts >= starts && ownEnds <= ends) ||
                (ownStarts < starts && ownEnds >= starts) ||
                (ownEnds > ends && ownStarts <= ends);
        };

        if (andFilter) {
            filter = Collection.and.apply(null, [filter].concat(andFilter));
        }

        // QUERY EVENTS
        events = this.events.find(filter);

        // CONVERT TO VIEWMODEL
        viewModels = common.createEventCollection.apply(
            null,
            util.map(events.items, function(event) {
                return CalEventViewModel.create(event);
            })
        ).groupBy(['allday', 'time'], this.groupFunc);

        // CUSTOMIZE VIEWMODEL FOR EACH VIEW
        util.forEach(viewModels, function(coll, key, obj) {
            if (key === 'allday') {
                coll.each(function(viewModel) {
                    var ownStarts = viewModel.getStarts(),
                        ownEnds = viewModel.getEnds();

                    if (ownStarts < starts) {
                        viewModel.renderStarts = new Date(starts.getTime());
                    }

                    if (ownEnds > ends) {
                        viewModel.renderEnds = new Date(ends.getTime());
                    }
                });

                obj.allday = util.bind(Week.getViewModelForAlldayView, that)(starts, ends, coll);
            } else if (key === 'time') {
                obj.time = util.bind(Week.getViewModelForTimeView, that)(starts, ends, coll);
            }
        });

        return viewModels;
    }
};

module.exports = Week;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/array":24,"../../common/collection":26,"../../common/common":27,"../../common/datetime":28,"../../model/viewModel/calEvent":73}],39:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Base controller for Dooray service project.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var Base = require('../../controller/base');
var DoorayEvent = require('../model/calEvent');

/**
 * @constructor
 * @param {object} options - options for base controller
 * @param {function} [options.groupFunc] - function for group each models {@see Collection#groupBy}
 * @extends {Base}
 */
function DoorayBase(options) {
    Base.call(this, options);
}

util.inherit(DoorayBase, Base);

/**********
 * CRUD override
 **********/

/**
 * Create an event instance from raw data.
 * @override
 * @emits Base#beforeCreateEvent
 * @emits Base#createdEvent
 * @param {ServiceCalendar~CalEvent} data - Data object to create event.
 * @param {boolean} silent - set true then don't fire events.
 * @returns {DoorayEvent} The instance of CalEvent that created.
 */
DoorayBase.prototype.createEvent = function(data, silent) {
    var inst,
        eventData = {
            data: data
        };

    /**
     * @event Base#beforeCreateEvent
     * @type {ServiceCalendar~Events[]}
     */
    if (!this.invoke('beforeCreateEvent', eventData)) {
        return;
    }

    inst = this.addEvent(DoorayEvent.create(data));

    if (!silent) {
        /**
         * @event Base#createdEvent
         * @type {DoorayEvent}
         */
        this.fire('createdEvent', inst);
    }

    return inst;
};

/**
 * Update an event.
 * @emits DoorayBase#updateEvent
 * @param {CalEvent} calEvent - event instance to update 
 * @param {object} options updated object data
 * @returns {CalEvent|boolean} updated event instance, when it fail then return false
 */
DoorayBase.prototype.updateEvent = function(calEvent, options) {
    if (options.title) {
        calEvent.set('title', options.title);
    }

    if (options.isAllDay) {
        calEvent.set('isAllDay', options.isAllDay);
    }

    if (options.starts) {
        calEvent.set('starts', new Date(options.starts));
    }

    if (options.ends) {
        calEvent.set('ends', new Date(options.ends));
    }

    if (options.color) {
        calEvent.set('color', options.color);
    }

    if (options.bgColor) {
        calEvent.set('bgColor', options.bgColor);
    }

    this._removeFromMatrix(calEvent);
    this._addToMatrix(calEvent);

    /**
     * @event DoorayBase#updateEvent
     */
    this.fire('updateEvent');

    return true;
};

/**
 * Delete event instance from controller
 * @param {CalEvent} calEvent - event instance to delete
 * @returns {CalEvent} deleted model instance
 */
DoorayBase.prototype.deleteEvent = function(calEvent) {
    this._removeFromMatrix(calEvent);
    this.events.remove(calEvent);

    return true;
};


module.exports = DoorayBase;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../controller/base":37,"../model/calEvent":44}],40:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Calendar for service.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../../config');
var datetime = require('../../common/datetime');
var Calendar = require('../../factory/calendar');
var DoorayBase = require('../controller/base');
var Week = require('../../controller/viewMixin/week');
var serviceWeekViewFactory = require('./weekView');

/**
 * @typedef {object} ServiceCalendar~DoorayEvent
 * @property {string} [id] - 일정의 uniqueID.
 * @property {string} [calendarID] - 각 일정을 캘린더별로 그룹지을 수 있는 값.
 * @property {string} title - 이벤트 제목
 * @property {string} category - 이벤트 타입
 * @property {string} dueDateClass - 업무 일정 분류 (category가 'task'일 때 유효)
 * @property {string} starts - 일정 시작 시간
 * @property {string} ends - 일정 종료 시간
 * @property {string} [color] - 일정 텍스트색
 * @property {string} [bgColor] - 일정 배경색
 */

/**
 * Calendar factor module for service (dooray)
 * @constructor
 * @extends {Calendar}
 * @param {object} options - options for calendar
 *  @param {string} [options.cssPrefix] - CSS classname prefix
 *  @param {function} [options.groupFunc] - function for group event models {@see Collection#groupBy}
 *  @param {function} [options.controller] - controller instance
 *  @param {string} [options.defaultView='week'] - default view of calendar
 *  @param {object} [options.calendarColor] - {@see ServiceCalendar~DoorayEvent} 의 calendarID별로 스타일을 미리 지정 가능
 *  @param {object} [options.week] - options for week view
 *   @param {number} [options.week.startDayOfWeek=0] - start day of week
 *   @param {string} options.week.renderStartDate - YYYY-MM-DD render start date
 *   @param {string} options.week.renderEndDate - YYYY-MM-DD render end date
 *  @param {ServiceCalendar~DoorayEvent[]} options.events - 기본 일정 목록
 *  @param {object} [options.month] - options for month view
 *  @param {string} options.month.renderMonth - YYYY-MM render month
 * @param {HTMLDivElement} container = container element for calendar
 */
function ServiceCalendar(options, container) {
    var controller;

    if (!(this instanceof ServiceCalendar)) {
        return new ServiceCalendar(options, container);
    }

    /**
     * 서비스에서 사용되는 모델 구분용 옵션 함수
     * @param {CalEventViewModel} viewModel - DoorayEvent를 래핑한 뷰 모델
     * @returns {string} 구분 키 값
     */
    options.groupFunc = function(viewModel) {
        return viewModel.model.category;
    };

    // 컨트롤러 만들기
    controller = options.controller = (function() {
        var controller = new DoorayBase(options),
            originFindByDateRange;

        // 주뷰 컨트롤러 믹스인
        controller.Week = {};
        util.forEach(Week, function(method, methodName) {
            controller.Week[methodName] = util.bind(method, controller);
        });

        // 일정 조회 API에 기존 캘린더에 없었던 milstone, task를 지원하도록
        // 하기 위해 메서드를 오버라이딩한다.
        originFindByDateRange = controller.Week.findByDateRange;

        // visible이 true인 일정만 필터링 하기 위한 필터 함수
        function filterModelIsVisible(model) {
            return !!model.visible;
        }

        controller.Week.findByDateRange = function(starts, ends) {
            var dateRange = util.map(datetime.range(
                    datetime.start(starts),
                    datetime.end(ends),
                    datetime.MILLISECONDS_PER_DAY
                ), function(d) { return datetime.format(d, 'YYYY-MM-DD'); }),
                viewModel = originFindByDateRange(starts, ends, [filterModelIsVisible]);

            util.forEach(viewModel, function(coll, key, obj) {
                var groupedByYMD;

                // 마일스톤, 업무 뷰 뷰모델 가공
                if (key === 'task' || key === 'milestone') {
                    groupedByYMD = coll.groupBy(dateRange, function(viewModel) {
                        return datetime.format(viewModel.model.ends, 'YYYY-MM-DD');
                    });

                    if (key === 'task') {
                        util.forEach(groupedByYMD, function(coll, ymd, obj) {
                            obj[ymd] = coll.groupBy(function(viewModel) {
                                return viewModel.model.dueDateClass;
                            });
                        });
                    }

                    obj[key] = groupedByYMD;
                }
            });

            return viewModel;
        };

        return controller;
    })();

    // FullCalendar 기본 모듈은 category, dueDateClass 플래그를 모름. 때문에
    // 이곳에서 이벤트 핸들러를 등록해서 일정 생성 전에 isAllDay플래그를 보고
    // category를 수동으로 지정해준다
    controller.on('beforeCreateEvent', function(e) {
        var data = e.data;

        if (!data.category) {
            data.category = data.isAllDay ? 'allday' : 'time';
        }
    });

    /**
     * @type {object}
     */
    this.calendarColor = options.calendarColor || {};

    Calendar.call(this, options, container);
}

util.inherit(ServiceCalendar, Calendar);

/**********
 * CRUD override
 **********/

/**
 * Create events instance and render calendar.
 * @param {ServiceCalendar~DoorayEvent[]} dataObjectList - array of {@see ServiceCalendar~DoorayEvent[]} object
 * @param {boolean} [silent=false] - no auto render after creation when set true
 */
ServiceCalendar.prototype.createEvents = function(dataObjectList, silent) {
    var calColor = this.calendarColor;

    util.forEach(dataObjectList, function(obj) {
        var color = calColor[obj.calendarID];

        if (color) {
            obj.color = color.color;
            obj.bgColor = color.bgColor;
        }
    });

    Calendar.prototype.createEvents.call(this, dataObjectList, silent);
};

/**
 * @override
 * @param {string} id - id of event instance from server API
 * @returns {DoorayEvent} founded event instance.
 */
ServiceCalendar.prototype.getEvent = function(id) {
    return this.controller.events.single(function(model) {
        return model.id === id;
    });
};

/**
 * @override
 * @param {string} id - ID of event instance to update data
 * @param {object} data - data object to update event
 */
ServiceCalendar.prototype.updateEvent = function(id, data) {
    var ctrl = this.controller,
        ownEvents = ctrl.events,
        calEvent = ownEvents.single(function(model) {
            return model.id === id;
        });

    if (calEvent) {
        ctrl.updateEvent(calEvent, data);
        this.render();
    }
};

/**
 * Delete DoorayEvent instance
 * @override
 * @fires ServiceCalendar#beforeDeleteEvent
 * @param {string} id - ID of event to delete
 */
ServiceCalendar.prototype.deleteEvent = function(id) {
    var ctrl = this.controller,
        ownEvents = ctrl.events,
        calEvent = ownEvents.single(function(model) {
            return model.id === id;
        });

    if (!calEvent) {
        return;
    }

    /**
     * @event ServiceCalendar#beforeDeleteEvent
     * @type {object}
     * @property {CalEvent} model - model instance to delete
     */
    this.fire('beforeDeleteEvent', {
        model: calEvent 
    });
    
    ctrl.deleteEvent(calEvent);
    this.render();
};

/**********
 * Custom Events
 **********/

/**
 * 각 뷰의 클릭 핸들러와 사용자 클릭 이벤트 핸들러를 잇기 위한 브릿지 개념의 이벤트 핸들러
 * @emits ServiceCalendar#clickEvent
 * @param {object} clickEventData - 'clickEvent' 핸들러의 이벤트 데이터
 */
ServiceCalendar.prototype._onClick = function(clickEventData) {
    /**
     * @events ServiceCalendar#clickEvent
     * @type {object}
     * @property {DoorayEvent} model - 클릭 이벤트 블록과 관련된 일정 모델 인스턴스
     * @property {MouseEvent} jsEvent - 마우스 이벤트
     */
    this.fire('clickEvent', clickEventData);
};

/**
 * @fires {ServiceCalendar#beforeCreateEvent}
 * @param {object} createEventData - select event data from allday, time
 */
ServiceCalendar.prototype._onBeforeCreate = function(createEventData) {
    /**
     * @events ServiceCalendar#beforeCreateEvent
     * @type {object}
     * @property {Date} starts - select start date
     * @property {Date] ends - select end date
     */
    this.fire('beforeCreateEvent', createEventData);
};

/**
 * @fires ServiceCalendar#beforeUpdateEvent
 * @param {object} updateEventData - update event data
 */
ServiceCalendar.prototype._onBeforeUpdate = function(updateEventData) {
    /**
     * @event ServiceCalendar#beforeUpdateEvent
     * @type {object}
     * @property {CalEvent} model - model instance to update
     * @property {Date} starts - select start date
     * @property {Date] ends - select end date
     */
    this.fire('beforeUpdateEvent', updateEventData);
};

/**
 * 캘린더 팩토리 클래스와 주뷰, 월뷰의 이벤트 연결을 토글한다
 * @param {boolean} isAttach - true면 이벤트 연결함.
 * @param {Week|Month} view - 주뷰 또는 월뷰
 * @param {ServiceCalendar} calendar - 캘린더 팩토리 클래스
 */
ServiceCalendar.prototype._toggleViewEvent = function(isAttach, view, calendar) {
    var handler = view.handler,
        calendar = this,
        method = isAttach ? 'on' : 'off';

    util.forEach(handler.click, function(handlerInstance) {
        handlerInstance[method]('clickEvent', calendar._onClick, calendar);
    });

    util.forEach(handler.creation, function(handlerInstance) {
        handlerInstance[method]('beforeCreateEvent', calendar._onBeforeCreate, calendar);
    });

    util.forEach(handler.move, function(handlerInstance) {
        handlerInstance[method]('beforeUpdateEvent', calendar._onBeforeUpdate, calendar);
    });

    util.forEach(handler.resize, function(handlerInstance) {
        handlerInstance[method]('beforeUpdateEvent', calendar._onBeforeUpdate, calendar);
    });
};

/**********
 * Methods
 **********/

/**
 * 같은 calendarID를 가진 모든 일정에 대해 글자색, 배경색을 재지정하고 뷰를 새로고침한다
 * @param {string} calendarID - calendarID value
 * @param {object} option - color data object
 *  @param {string} option.color - text color of event element
 *  @param {string} option.bgColor - bg color of event element
 *  @param {boolean} [option.render=true] - set false then does not auto render.
 */
ServiceCalendar.prototype.setCalendarColor = function(calendarID, option) {
    var calColor = this.calendarColor,
        ownEvents = this.controller.events,
        ownColor = calColor[calendarID];

    if (!util.isObject(option)) {
        config.throwError('Calendar#changeCalendarColor(): color 는 {color: \'\', bgColor: \'\'} 형태여야 합니다.');
    }

    ownColor = calColor[calendarID] = util.extend({
        color: '#000',
        bgColor: '#a1b56c',
        render: true
    }, option);

    ownEvents.each(function(model) {
        if (model.calendarID !== calendarID) {
            return;
        }

        model.color = ownColor.color;
        model.bgColor = ownColor.bgColor;
    });

    if (!!ownColor.render) {
        this.render();
    }
};

/**
 * Toggle events visibility by calendar ID
 * @param {string} calendarID - calendar id value
 * @param {boolean} toHide - set true to hide events
 * @param {boolean} render - set true then render after change visible property each models
 * @private
 */
ServiceCalendar.prototype._toggleEventsByCalendarID = function(calendarID, toHide, render) {
    var ownEvents = this.controller.events;

    calendarID = util.isArray(calendarID) ? calendarID : [calendarID];

    ownEvents.each(function(model) {
        if (~util.inArray(model.calendarID, calendarID)) {
            model.set('visible', !toHide);
        }
    });

    if (render) {
        this.render();
    }
};

/**
 * Show events visibility by calendar ID
 * @param {string|string[]} calendarID - calendar id value
 * @param {boolean} [render=true] - set false then doesn't render after change model's property.
 */
ServiceCalendar.prototype.showEventsByCalendarID = function(calendarID, render) {
    render = util.isExisty(render) ? render : true;
    this._toggleEventsByCalendarID(calendarID, false, render);
};

/**
 * Hide events visibility by calendar ID
 * @param {string|string[]} calendarID - calendar id value
 * @param {boolean} [render=true] - set false then doesn't render after change model's property.
 */
ServiceCalendar.prototype.hideEventsByCalendarID = function(calendarID, render) {
    render = util.isExisty(render) ? render : true;
    this._toggleEventsByCalendarID(calendarID, true, render);
};

/**
 * 주뷰, 월뷰 간 전환
 * @override
 * @param {string} viewName - 'week', 'month' 중 하나
 * @param {boolean} [force=false] - true 지정시 뷰 전환이 없어도 전환을 위한 동작을 수행한다
 * @param {boolean} [silent=false] - no auto render after creation when set true
 */
ServiceCalendar.prototype.toggleView = function(viewName, force, silent) {
    var layout = this.layout,
        controller = this.controller,
        dragHandler = this.dragHandler,
        options = this.options,
        created;

    if (!force && this.currentViewName === viewName) {
        return;
    }
    
    layout.childs.doWhenHas(viewName, function(view) {
        this._toggleViewEvent(false, view, this);
    }, this);
    layout.clear();

    if (viewName === 'week') {
        created = serviceWeekViewFactory(controller, layout.container, dragHandler, options);
        layout.addChild(created.view);
        this._refreshMethod = created.refresh;
    } else if (viewName === 'month') {
        //TODO: month view. 
    }

    layout.childs.doWhenHas(viewName, function(view) {
        this._toggleViewEvent(true, view, this);
    }, this);

    this.currentViewName = viewName;

    if (!silent) {
        this.render();
    }
};

module.exports = ServiceCalendar;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../config":36,"../../controller/viewMixin/week":38,"../../factory/calendar":52,"../controller/base":39,"./weekView":41}],41:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Factory module for WeekView (customized for service)
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../../config');
var domutil = require('../../common/domutil');
var fillRemainHeight = require('../../common/fillRemainHeight');

// Parent views
var Week = require('../../view/week/week');

// Sub views
var DayName = require('../../view/week/dayname');
var Milestone = require('../view/milestone');
var TaskView = require('../view/taskview');
var TimeGrid = require('../../view/week/timeGrid');
var Allday = require('../../view/week/allday');

// Handlers
var AlldayClick = require('../../handler/allday/click');
var AlldayCreation = require('../../handler/allday/creation');
var AlldayMove = require('../../handler/allday/move');
var AlldayResize = require('../../handler/allday/resize');
var TimeClick = require('../../handler/time/click');
var TimeCreation = require('../../handler/time/creation');
var TimeMove = require('../../handler/time/move');
var TimeResize = require('../../handler/time/resize');
var MilestoneClick = require('../handler/milestoneClick');
var TaskClick = require('../handler/taskClick');

// Base Templates
var weekViewTmpl = require('../../dooray/view/template/factory/weekView.hbs');

module.exports = function(baseController, layoutContainer, dragHandler, options) {
    var weekView,
        dayNameView,
        milestoneView,
        taskView,
        alldayView,
        timeGridContainer,
        timeGridView,
        milestoneClickHandler,
        taskClickHandler,
        alldayClickHandler,
        alldayCreationHandler,
        alldayMoveHandler,
        alldayResizeHandler,
        timeClickHandler,
        timeCreationHandler,
        timeMoveHandler,
        timeResizeHandler,
        frh;

    weekView = new Week(null, options.week, layoutContainer);
    weekView.container.innerHTML = weekViewTmpl();

    /**********
     * 일자표기 (상단 일월화수...)
     **********/
    dayNameView = new DayName(null, domutil.find('.' + config.classname('dayname-layout'), weekView.container));
    weekView.addChild(dayNameView);

    /**********
     * 마일스톤
     **********/
    milestoneView = new Milestone(options.week, domutil.find('.' + config.classname('milestone-layout')));
    weekView.addChild(milestoneView);
    milestoneClickHandler = new MilestoneClick(dragHandler, milestoneView, baseController);

    /**********
     * 업무
     **********/
    taskView = new TaskView(options.week, domutil.find('.' + config.classname('milestone-layout')));
    weekView.addChild(taskView);
    taskClickHandler = new TaskClick(dragHandler, taskView, baseController);

    /**********
     * 종일일정
     **********/
    alldayView = new Allday(options.week, domutil.find('.' + config.classname('allday-layout'), weekView.container));
    weekView.addChild(alldayView);
    alldayClickHandler = new AlldayClick(dragHandler, alldayView, baseController);
    alldayCreationHandler = new AlldayCreation(dragHandler, alldayView, baseController);
    alldayMoveHandler = new AlldayMove(dragHandler, alldayView, baseController);
    alldayResizeHandler = new AlldayResize(dragHandler, alldayView, baseController);

    /**********
     * 시간별 일정
     **********/
    timeGridContainer = domutil.find('.' + config.classname('timegrid-layout'), weekView.container);
    timeGridView = new TimeGrid(options.week, timeGridContainer);
    weekView.addChild(timeGridView);
    timeClickHandler = new TimeClick(dragHandler, timeGridView, baseController);
    timeCreationHandler = new TimeCreation(dragHandler, timeGridView, baseController);
    timeMoveHandler = new TimeMove(dragHandler, timeGridView, baseController);
    timeResizeHandler = new TimeResize(dragHandler, timeGridView, baseController);

    // 가변높이 모듈 초기화
    frh = fillRemainHeight([timeGridContainer], weekView.container);

    weekView.on('afterRender', function() {
        frh.refresh();
    });

    weekView.handler = {
        click: {
            milestone: milestoneClickHandler,
            task: taskClickHandler,
            allday: alldayClickHandler,
            time: timeClickHandler
        },
        creation: {
            allday: alldayCreationHandler,
            time: timeCreationHandler
        },
        move: {
            allday: alldayMoveHandler,
            time: timeMoveHandler
        },
        resize: {
            allday: alldayResizeHandler,
            time: timeResizeHandler
        }
    };


    // add controller
    weekView.controller = baseController.Week;

    // add destroy
    weekView._beforeDestroy = function() {
        util.forEach(weekView.handlers, function(type) {
            util.forEach(type, function(handler) {
                handler.off();
                handler.destroy();
            });
        });
    };

    return {
        view: weekView,
        refresh: function() {
            frh.refresh();
        }
    };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/domutil":31,"../../common/fillRemainHeight":32,"../../config":36,"../../dooray/view/template/factory/weekView.hbs":51,"../../handler/allday/click":55,"../../handler/allday/creation":57,"../../handler/allday/move":59,"../../handler/allday/resize":61,"../../handler/time/click":64,"../../handler/time/creation":66,"../../handler/time/move":68,"../../handler/time/resize":70,"../../view/week/allday":85,"../../view/week/dayname":86,"../../view/week/timeGrid":88,"../../view/week/week":89,"../handler/milestoneClick":42,"../handler/taskClick":43,"../view/milestone":46,"../view/taskview":50}],42:[function(require,module,exports){
(function (global){
/**
 * @fileoverview 마일스톤 항목 클릭 이벤트 핸들러 모듈
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../../config');
var domutil = require('../../common/domutil');

/**
 * 마일스톤 클릭 이벤트 핸들러 모듈
 * @constructor
 * @implelements {Handler}
 * @mixes util.CustomEvents
 * @param {Drag} dragHandler - dragHandler instance
 * @param {Milestone} milestoneView - milstone view instance
 * @param {Base} baseController - baseController instance
 */
function MilestoneClick(dragHandler, milestoneView, baseController) {
    /**
     * @type {Drag}
     */
    this.dragHandler = dragHandler;

    /**
     * @type {Milestone}
     */
    this.milestoneView = milestoneView;

    /**
     * @type {Base}
     */
    this.baseController = baseController;

    dragHandler.on({
        'click': this._onClick
    }, this);
}

/**
 * Destroy
 */
MilestoneClick.prototype.destroy = function() {
    this.dragHandler.off(this);
    this.dragHandler = this.milestoneView = this.baseController = null;
};

/**
 * @param {HTMLElement} target - check reponsibility to this handler module supplied element
 * @returns {boolean|string} return false when handler has no responsibility for supplied element. 
 * otherwise, return event model id that related with target element.
 */
MilestoneClick.prototype.checkExpectedCondition = function(target) {
    target = domutil.closest(target, '.' + config.classname('milestone-item'));
    
    if (!target) {
        return false;
    }

    return domutil.getData(target, 'id');
};

/**
 * @emits MilestoneClick#clickEvent
 * @param {object} clickEvent - click event object
 */
MilestoneClick.prototype._onClick = function(clickEvent) {
    var modelID = this.checkExpectedCondition(clickEvent.target);

    if (!modelID) {
        return;
    }

    this.baseController.events.doWhenHas(modelID, function(model) {
        /**
         * @events MilestoneClick#clickEvent
         * @type {object}
         * @property {CalEvent} model - model instance
         * @property {MouseEvent} jsEvent - MouseEvent object
         */
        this.fire('clickEvent', {
            model:  model,
            jsEvent: clickEvent.originEvent
        });
    }, this);
};

util.CustomEvents.mixin(MilestoneClick);

module.exports = MilestoneClick;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/domutil":31,"../../config":36}],43:[function(require,module,exports){
(function (global){
/**
 * @fileoverview 마일스톤 항목 클릭 이벤트 핸들러 모듈
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../../config');
var domutil = require('../../common/domutil');

/**
 * 마일스톤 클릭 이벤트 핸들러 모듈
 * @constructor
 * @implelements {Handler}
 * @mixes util.CustomEvents
 * @param {Drag} dragHandler - dragHandler instance
 * @param {Task} taskView - milstone view instance
 * @param {Base} baseController - baseController instance
 */
function TaskClick(dragHandler, taskView, baseController) {
    /**
     * @type {Drag}
     */
    this.dragHandler = dragHandler;

    /**
     * @type {Task}
     */
    this.taskView = taskView;

    /**
     * @type {Base}
     */
    this.baseController = baseController;

    dragHandler.on({
        'click': this._onClick
    }, this);
}

/**
 * Destroy
 */
TaskClick.prototype.destroy = function() {
    this.dragHandler.off(this);
    this.dragHandler = this.taskView = this.baseController = null;
};

/**
 * @param {HTMLElement} target - check reponsibility to this handler module supplied element
 * @returns {boolean|string} return false when handler has no responsibility for supplied element. 
 * otherwise, return event model id that related with target element.
 */
TaskClick.prototype.checkExpectedCondition = function(target) {
    target = domutil.closest(target, '.' + config.classname('task-item'));

    if (!target) {
        return false;
    }

    return domutil.getData(target, 'id');
};

/**
 * @emits TaskClick#clickEvent
 * @param {object} clickEvent - click event object
 */
TaskClick.prototype._onClick = function(clickEvent) {
    var modelID = this.checkExpectedCondition(clickEvent.target);

    if (!modelID) {
        return;
    }

    this.baseController.events.doWhenHas(modelID, function(model) {
        /**
         * @events TaskClick#clickEvent
         * @type {object}
         * @property {CalEvent} model - model instance
         * @property {MouseEvent} jsEvent - MouseEvent object
         */
        this.fire('clickEvent', {
            model:  model,
            jsEvent: clickEvent.originEvent
        });
    }, this);
};

util.CustomEvents.mixin(TaskClick);

module.exports = TaskClick;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/domutil":31,"../../config":36}],44:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Extend model class for Dooray Calendar project.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var CalEvent = require('../../model/calEvent');

/**
 * 일정 카테고리
 * @readonly
 * @enum {string}
 */
var EVENT_CATEGORY = {
    /** 마일스톤 */
    MILESTONE: 'milestone',

    /** 업무 */
    TASK: 'task',
    
    /** 종일일정 */
    ALLDAY: 'allday',

    /** 시간별 일정 */
    TIME: 'time'
};

/**
 * CalEvent class for dooray project
 * @constructor
 * @extends {CalEvent}
 */
function DoorayEvent() {
    CalEvent.call(this);

    /**
     * 캘린더 ID
     * @type {string}
     */
    this.calendarID = '';

    /**
     * 일정 카테고리 (마일스톤, 업무, 종일일정, 시간별일정)
     * @type {string}
     */
    this.category = '';

    /**
     * 업무 일정의 경우 구분 (출근전, 점심전, 퇴근전)
     * @type {string}
     */
    this.dueDateClass = '';

    /**
     * 일정 노출 여부
     * @type {boolean}
     */
    this.visible = true;

    /**
     * 렌더링과 관계 없는 별도 데이터 저장 공간.
     * @type {object}
     */
    this.raw = null;
}

util.inherit(DoorayEvent, CalEvent);

/**
 * @override
 */
DoorayEvent.create = function(data) {
    var inst = new DoorayEvent();
    inst.init(data);

    return inst;
};

/**
 * @override
 * @param {object} options options.
 */
DoorayEvent.prototype.init = function(options) {
    options = options || {};

    CalEvent.prototype.init.call(this, options);

    this.isAllDay = options.category === EVENT_CATEGORY.ALLDAY;
    this.calendarID = options.calendarID;
    this.category = options.category;
    this.dueDateClass = options.dueDateClass;
    this.visible = util.isExisty(options.visible) ? options.visible : true;

    if (options.category === EVENT_CATEGORY.MILESTONE ||
        options.category === EVENT_CATEGORY.TASK) {
        this.starts = new Date(+this.ends);
        this.starts.setMinutes(this.starts.getMinutes() - 30);
    }

    this.raw = options.raw || null;
};

module.exports = DoorayEvent;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../model/calEvent":72}],45:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression, alias5=container.lambda;

  return "<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "milestone-day\" \n     style=\"width:"
    + alias4(alias5(((stack1 = (data && data.root)) && stack1.width), depth0))
    + "%;left:"
    + alias4((helpers.multiply || (depth0 && depth0.multiply) || alias2).call(alias1,((stack1 = (data && data.root)) && stack1.width),(data && data.index),{"name":"multiply","hash":{},"data":data}))
    + "%;min-height:"
    + alias4(alias5(((stack1 = (data && data.root)) && stack1.minHeight), depth0))
    + "px;height:"
    + alias4(alias5(((stack1 = (data && data.root)) && stack1.height), depth0))
    + "px\">\n    <ul class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "milestone-list\">\n"
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.items : depth0),{"name":"each","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</ul>\n</div>\n";
},"2":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3=container.escapeExpression, alias4=container.lambda;

  return "<li data-id=\""
    + alias3((helpers.stamp || (depth0 && depth0.stamp) || alias2).call(alias1,(depth0 != null ? depth0.model : depth0),{"name":"stamp","hash":{},"data":data}))
    + "\" \n        data-title=\""
    + alias3(alias4(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.title : stack1), depth0))
    + "\" \n        class=\""
    + alias3(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === "function" ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "milestone-item\" \n        style=\"line-height:"
    + alias3(alias4(((stack1 = (data && data.root)) && stack1.lineHeight), depth0))
    + "px;color:"
    + alias3(alias4(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.color : stack1), depth0))
    + "\">"
    + ((stack1 = (helpers["milestone-tmpl"] || (depth0 && depth0["milestone-tmpl"]) || alias2).call(alias1,(depth0 != null ? depth0.model : depth0),{"name":"milestone-tmpl","hash":{},"data":data})) != null ? stack1 : "")
    + "</li>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "milestone-left\">\n    <span>마일스톤</span>\n</div>\n<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "milestone-right "
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "clear\">\n"
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.events : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],46:[function(require,module,exports){
(function (global){
/**
 * @fileoverview 마일스톤 뷰
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../../config');
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var View = require('../../view/view');
var tmpl = require('./milestone.hbs');

var PADDING = 4;    // 마일스톤 그리드 내 패딩 값 (top + height)

/**
 * @constructor
 * @extends {View}
 * @param {object} options - options
 * @param {string} options.renderStartDate - start date of allday view's render date. YYYY-MM-DD
 * @param {string} options.renderEndDate - end date of allday view's render date. YYYY-MM-DD
 * @param {number} [options.minHeight=40] - min-height of milestone view 
 * @param {number} [options.lineHeight=12] - line height of milestone view
 * @param {HTMLElement} container - container element
 */
function Milestone(options, container) {
    container = domutil.appendHTMLElement(
        'div',
        container,
        config.classname('milestone-container')
    );

    View.call(this, container);

    /**
     * @type {object}
     */
    this.options = util.extend({
        renderStartDate: '',
        renderEndDate: '',
        minHeight: 40,
        lineHeight: 12
    }, options);
}

util.inherit(Milestone, View);

/**
 * Get base viewmodel for task view
 * @param {object} [viewModel] - view model from parent view
 * @returns {object} view model for task view
 */
Milestone.prototype._getBaseViewModel = function(viewModel) {
    var options = this.options,
        events = {},
        range = datetime.range(
            datetime.start(datetime.parse(options.renderStartDate)),
            datetime.end(datetime.parse(options.renderEndDate)),
            datetime.MILLISECONDS_PER_DAY
        ),
        height;

    util.forEach(range, function(d) {
        events[datetime.format(d, 'YYYY-MM-DD')] = {};
    });

    util.extend(events, viewModel);

    height = Math.max.apply(null, util.map(events, function(coll) {
        return coll.length;
    })) * options.lineHeight;

    height = Math.max(options.minHeight, height);

    return {
        events: events,
        width: 100 / range.length,
        minHeight: options.minHeight,
        height: height + PADDING,
        lineHeight: options.lineHeight
    };
};

/**
 * 마일스톤 뷰 렌더링
 * @override
 */
Milestone.prototype.render = function(viewModel) {
    var container = this.container,
        baseViewModel = this._getBaseViewModel(util.pick(viewModel.eventsInDateRange, 'milestone'));

    container.style.minHeight = this.options.minHeight + 'px';
    container.innerHTML = tmpl(baseViewModel);

    util.forEach(domutil.find('li', container, true), function(el) {
        if (el.offsetWidth < el.scrollWidth) {
            el.setAttribute('title', domutil.getData(el, 'title'));
        }
    });
};

module.exports = Milestone;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../../config":36,"../../view/view":84,"./milestone.hbs":45}],47:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    return "<th>"
    + container.escapeExpression(container.lambda(depth0, depth0))
    + "</th>\n";
},"3":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<tr>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},depth0,{"name":"each","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</tr>\n";
},"4":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<td class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "minicalendar-"
    + alias4(((helper = (helper = helpers.ymd || (depth0 != null ? depth0.ymd : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"ymd","hash":{},"data":data}) : helper)))
    + " \n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.isNotThisMonth : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.selected : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.today : depth0),{"name":"if","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.hasSchedule : depth0),{"name":"if","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.weekend : depth0),{"name":"if","hash":{},"fn":container.program(13, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\">\n<button type=\"button\" tabindex=\"-1\" class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "minicalendar-date\">\n    <div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "minicalendar-label\"><span>"
    + alias4(((helper = (helper = helpers.d || (depth0 != null ? depth0.d : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"d","hash":{},"data":data}) : helper)))
    + "</span></div>\n</button>\n</td>\n";
},"5":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "minicalendar-other ";
},"7":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "minicalendar-focused ";
},"9":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "minicalendar-today ";
},"11":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "minicalendar-has-schedule ";
},"13":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "minicalendar-weekend ";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<table>\n<caption>\n    <button type=\"button\" class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "minicalendar-nav "
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "minicalendar-prev\"><span>&lt;</span></button>\n    <span class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "minicalendar-title\">"
    + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
    + "</span>\n    <button type=\"button\" class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "minicalendar-nav "
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "minicalendar-next\"><span>&gt;</span></button>\n</caption>\n<thead><tr>\n"
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.dayname : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</tr></thead>\n<tbody>\n"
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.calendar : depth0),{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</tbody>\n</table>\n";
},"useData":true});

},{"hbsfy/runtime":22}],48:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Minicalendar view.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../../config');
var View = require('../../view/view');
var domutil = require('../../common/domutil');
var domevent = require('../../common/domevent');
var datetime = require('../../common/datetime');
var tmpl = require('./minicalendar.hbs');

/**
 * @constructor
 * @extends {View}
 * @param {object} options - options for minicalendar view
 *  @param {number} [options.startDayOfWeek=0] - start day of week. default 0 (sunday)
 *  @param {string|Date} [options.renderMonth] - month to render
 *  @param {string[]} [options.highlightDate] - dates to highlight
 *  @param {string[]} [options.daynames] - array of each days name.
 * @param {HTMLDivElement} container - element to use container
 */
function MiniCalendar(options, container) {
    var today = datetime.start(new Date());

    if (!(this instanceof MiniCalendar)) {
        return new MiniCalendar(options, container);
    }

    View.call(this, container);
    domutil.addClass(container, config.classname('minicalendar'));
    domevent.on(this.container, 'click', this._onClick, this);

    /**
     * @type {object}
     */
    options = this.options = util.extend({
        startDayOfWeek: 0,
        renderMonth: new Date(+today),
        highlightDate: [],
        daynames: ['일', '월', '화', '수', '목', '금', '토']
    }, options);

    // parse renderMonth options if it is an string
    if (util.isString(options.renderMonth)) {
        options.renderMonth = datetime.start(datetime.parse(options.renderMonth));
    }

    /**
     * 일자 강조 데이터
     * @type {object}
     */
    this.hlData = {};
    if (options.highlightDate.length) {
        this.highlightDate(options.highlightDate);
    }

    this.render();
}

util.inherit(MiniCalendar, View);

/**
 * Next, Prev button event handler
 * @fires Minicalendar#change
 * @param {HTMLButtonElement} buttonElement - next, prev button from _onClick event handler
 */
MiniCalendar.prototype._nav = function(buttonElement) {
    var isNext = domutil.hasClass(buttonElement, config.classname('minicalendar-next')),
        options = this.options,
        offset = isNext ? 1 : -1,
        eventData = {
            before: this.getSelectedDate()
        };

    options.renderMonth.setMonth(options.renderMonth.getMonth() + offset);

    this.render();

    eventData.after = this.getSelectedDate();

    /**
     * @event MiniCalendar#change
     * @type {object}
     * @property {Date} before - the date of before changed
     * @property {Date} after - the date of after changed
     */
    this.fire('change', eventData);
};

/**
 * Date button event handler
 * @fires Minicalendar#change
 * @param {HTMLButtonElement} buttonElement - date button from _onClick event handler
 */
MiniCalendar.prototype._date = function(buttonElement) {
    var td = domutil.closest(buttonElement, 'td'),
        today = (new Date()),
        previous,
        selected,
        eventData = {
            before: this.getSelectedDate()
        };

    if (td) {
        previous = domutil.find('.' + config.classname('minicalendar-focused'), this.container);

        if (previous) {
            domutil.removeClass(previous, config.classname('minicalendar-focused'));
        }

        domutil.addClass(td, config.classname('minicalendar-focused'));

        selected = this.getSelectedDate();

        if (datetime.isSameDate(selected, today)) {
            domutil.addClass(td, config.classname('minicalendar-today'));
        }

        eventData.after = selected;

        /**
         * @event MiniCalendar#change
         * @type {object}
         * @property {Date} before - the date of before changed
         * @property {Date} after - the date of after changed
         */
        this.fire('change', eventData);
    }
};

/**
 * Click event handler
 * @param {MouseEvent} clickEvent - click mouse event object
 */
MiniCalendar.prototype._onClick = function(clickEvent) {
    var target = clickEvent.srcElement || clickEvent.target,
        button = domutil.closest(target, 'button');

    if (!button) {
        return;
    }

    if (domutil.hasClass(button, config.classname('minicalendar-date'))) {
        this._date(button);
        return;
    }

    if (domutil.hasClass(button, config.classname('minicalendar-nav'))) {
        this._nav(button);
        return;
    }
};

/**
 * Get selected data
 * @returns {Date} selected date
 */
MiniCalendar.prototype.getSelectedDate = function() {
    var selected = domutil.find('.' + config.classname('minicalendar-focused'), this.container),
        matches;

    if (!selected) {
        return null;
    }

    matches = selected.className.match(config.minicalendar.getDataRegExp);

    if (!matches || matches.length < 2) {
        return;
    }

    return datetime.parse(matches[1]);
};

/**
 * select specific date.
 * @param {Date|string} date - date to select
 */
MiniCalendar.prototype.selectDate = function(date) {
    var _date, td, button;

    if (util.isString(date)) {
        date = datetime.parse(date);
    }

    _date = datetime.format(date, 'YYYY-MM-DD');
    td = domutil.find('.' + config.classname('minicalendar-') + _date, this.container);
    button = domutil.find('button', td);

    if (!td || !button) {
        return;
    }

    this._date(button);
};

/**
 * Get minicalendar view model
 * @param {Date} renderDate - Date to render minicalendar
 * @param {number} startDayOfWeek - number of start of week (0:sun ...)
 * @returns {object} viewmodel
 */
MiniCalendar.prototype._getViewModel = function(renderDate, startDayOfWeek) {
    var daynames = this.options.daynames,
        hlData = this.hlData,
        today = datetime.start(new Date()),
        isCurrentMonth = datetime.isSameMonth(renderDate, today),
        viewModel = {
            title: datetime.format(renderDate, 'YYYY.MM'),
            startDayOfWeek: startDayOfWeek
        };

    viewModel.dayname = util.map(
        util.range(startDayOfWeek, 7).concat(util.range(7)).slice(0, 7),
        function(i) { return daynames[i]; } 
    );

    viewModel.calendar = datetime.arr2dCalendar(renderDate, startDayOfWeek, function(date) {
        var d = date.getDate(),
            ymd = datetime.format(date, 'YYYY-MM-DD'),
            day = date.getDay(),
            selected = false,
            isToday = datetime.isSameDate(date, today),
            dateIsInThisMonth = datetime.isSameMonth(date, renderDate);

        if (dateIsInThisMonth) {
            if (isCurrentMonth) {
                if (isToday) {
                    selected = true;
                    isToday = true;
                }
            } else if (d === 1) {
                selected = true;
            }
        }

        return {
            d: d,
            ymd: ymd,
            hasSchedule: hlData[ymd],
            isNotThisMonth: !dateIsInThisMonth,
            weekend: (day === 0 || day === 6),
            selected: selected,
            today: isToday
        };
    });

    return viewModel;
};

/**
 * Render view
 */
MiniCalendar.prototype.render = function() {
    var container = this.container,
        options = this.options,
        renderDate = options.renderMonth,
        startDayOfWeek = options.startDayOfWeek,
        viewModel;

    viewModel = this._getViewModel(renderDate, startDayOfWeek);

    container.innerHTML = tmpl(viewModel);
};

/**
 * Cache data for highlight specific dates in calendar.
 * @param {string[]} dateStrList - the array of dates to highlight. (YYYY-MM-DD)
 * @param {boolean} [silent=false] - set true for prevent auto rendering.
 */
MiniCalendar.prototype.highlightDate = function(dateStrList, silent) {
    var ownData = this.hlData;

    util.forEach(dateStrList, function(ymd) {
        ownData[ymd] = true;
    });

    if (!silent) {
        this.render();
    }
};

/**
 * Clear cached data for highlighting specific date for represent the date has schedule.
 * @param {boolean} [silent=false] - set true for prevent auto rendering.
 */
MiniCalendar.prototype.clearHighlightDate = function(silent) {
    delete this.hlData;
    this.hlData = {};

    if (!silent) {
        this.render();
    }
};

util.CustomEvents.mixin(MiniCalendar);

module.exports = MiniCalendar;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domevent":30,"../../common/domutil":31,"../../config":36,"../../view/view":84,"./minicalendar.hbs":47}],49:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression, alias5=container.lambda;

  return "<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "task-day\" style=\"width:"
    + alias4(alias5(((stack1 = (data && data.root)) && stack1.width), depth0))
    + "%;left:"
    + alias4((helpers.multiply || (depth0 && depth0.multiply) || alias2).call(alias1,((stack1 = (data && data.root)) && stack1.width),(data && data.index),{"name":"multiply","hash":{},"data":data}))
    + "%;min-height:"
    + alias4(alias5(((stack1 = (data && data.root)) && stack1.minHeight), depth0))
    + "px;height:"
    + alias4(alias5(((stack1 = (data && data.root)) && stack1.height), depth0))
    + "px;\">\n<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "task-day-wrap\">\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.morning : depth0),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.lunch : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.evening : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</div>\n</div>\n";
},"2":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "task-duedate-class\" style=\"line-height:"
    + alias4(container.lambda(((stack1 = (data && data.root)) && stack1.lineHeight), depth0))
    + "px\"><strong>출근 전</strong></div>\n    <ul class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "task-list\">\n"
    + ((stack1 = helpers.each.call(alias1,((stack1 = (depth0 != null ? depth0.morning : depth0)) != null ? stack1.items : stack1),{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</ul>\n";
},"3":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3=container.escapeExpression, alias4=container.lambda;

  return "<li data-id=\""
    + alias3((helpers.stamp || (depth0 && depth0.stamp) || alias2).call(alias1,(depth0 != null ? depth0.model : depth0),{"name":"stamp","hash":{},"data":data}))
    + "\" \n        data-title=\""
    + alias3(alias4(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.title : stack1), depth0))
    + "\" \n        class=\""
    + alias3(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === "function" ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "task-item\" \n        style=\"line-height:"
    + alias3(alias4(((stack1 = (data && data.root)) && stack1.lineHeight), depth0))
    + "px;color:"
    + alias3(alias4(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.color : stack1), depth0))
    + "\">"
    + ((stack1 = (helpers["task-tmpl"] || (depth0 && depth0["task-tmpl"]) || alias2).call(alias1,(depth0 != null ? depth0.model : depth0),{"name":"task-tmpl","hash":{},"data":data})) != null ? stack1 : "")
    + "</li>\n";
},"5":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression, alias5=container.lambda;

  return "<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "task-duedate-class\" style=\"line-height:"
    + alias4(alias5(((stack1 = (data && data.root)) && stack1.lineHeight), depth0))
    + "px\"><strong>점심 전</strong></div>\n    <div style=\"line-height:"
    + alias4(alias5(((stack1 = (data && data.root)) && stack1.lineHeight), depth0))
    + "px\">점심 전</div>\n    <ul class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "task-list\">\n"
    + ((stack1 = helpers.each.call(alias1,((stack1 = (depth0 != null ? depth0.lunch : depth0)) != null ? stack1.items : stack1),{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</ul>\n";
},"7":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "task-duedate-class\" style=\"line-height:"
    + alias4(container.lambda(((stack1 = (data && data.root)) && stack1.lineHeight), depth0))
    + "px\"><strong>퇴근 전</strong></div>\n    <ul class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "task-list\">\n"
    + ((stack1 = helpers.each.call(alias1,((stack1 = (depth0 != null ? depth0.evening : depth0)) != null ? stack1.items : stack1),{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</ul>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "task-left\">\n    <span>업무</span>\n</div>\n<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "task-right schedule-view clear\">\n"
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.events : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],50:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Task view for upper area of Week view.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../../config');
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var View = require('../../view/view');
var tmpl = require('./taskview.hbs');

var PADDING = 4;    // 그리드 내 패딩 값 (top + height)

/**
 * @constructor
 * @extends {View}
 * @param {object} options - options for TaskView
 * @param {string} options.renderStartDate - start date of allday view's render date. YYYY-MM-DD
 * @param {string} options.renderEndDate - end date of allday view's render date. YYYY-MM-DD
 * @param {number} [options.minHeight=40] - min-height of taskview
 * @param {number} [options.lineHeight=12] - line height of milestone view
 * @param {HTMLElement} container - container element
 */
function TaskView(options, container) {
    container = domutil.appendHTMLElement(
        'div',
        container,
        config.classname('task-container')
    );

    View.call(this, container);

    /**
     * @type {object}
     */
    this.options = util.extend({
        renderStartDate: '',
        renderEndDate: '',
        minHeight: 40,
        lineHeight: 12
    }, options);
}

util.inherit(TaskView, View);

/**
 * Get base viewmodel for task view
 * @param {object} [viewModel] - view model from parent view
 * @returns {object} view model for task view
 */
TaskView.prototype._getBaseViewModel = function(viewModel) {
    var options = this.options,
        events = {},
        range = datetime.range(
            datetime.start(datetime.parse(options.renderStartDate)),
            datetime.end(datetime.parse(options.renderEndDate)),
            datetime.MILLISECONDS_PER_DAY
        ),
        height = 0,
        mmax = Math.max;

    util.forEach(range, function(d) {
        events[datetime.format(d, 'YYYY-MM-DD')] = {};
    });

    util.extend(events, viewModel);

    // (출근전, 점심전, 퇴근전 항목 수 * 12px) + (각 항목의 아이템 수 * 12px)
    height = mmax.apply(null, util.map(events, function(g) {
        var subcount = util.keys(g).length;

        util.forEach(g, function(coll) {
            subcount += coll.length;
        });

        return subcount;
    })) * options.lineHeight;

    height = mmax(options.minHeight, height);

    return {
        events: events,
        width: 100 / range.length,
        height: height + PADDING,
        lineHeight: options.lineHeight
    };
};

/**
 * 업무 뷰 렌더링
 * @override
 */
TaskView.prototype.render = function(viewModel) {
    var container = this.container,
        baseViewModel = this._getBaseViewModel(util.pick(viewModel.eventsInDateRange, 'task'));

    container.style.minHeight = this.options.minHeight + 'px';
    container.innerHTML = tmpl(baseViewModel);

    util.forEach(domutil.find('li', container, true), function(el) {
        if (el.offsetWidth < el.scrollWidth) {
            el.setAttribute('title', domutil.getData(el, 'title'));
        }
    });
};

module.exports = TaskView;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../../config":36,"../../view/view":84,"./taskview.hbs":49}],51:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "scroll-y "
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "dayname-layout\"></div>\n<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "scroll-y "
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "milestone-layout\" style=\"min-height:80px;max-height:100px\"></div>\n<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "scroll-y "
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "allday-layout\" style=\"min-height:48x;max-height:68px\"></div>\n<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "timegrid-layout\"></div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],52:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Factory module for control all other factory.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../config');
var common = require('../common/common');
var datetime = require('../common/datetime');
var Layout = require('../view/layout');
var Drag = require('../handler/drag');
var controllerFactory = require('./controller');
var weekViewFactory = require('./weekView');
var Handlebars = require('hbsfy/runtime');

/**
 * @typedef {object} Calendar~CalEvent
 * @property {string} title - 이벤트 제목
 * @property {boolean} isAllDay - 종일일정여부
 * @property {string} starts - 일정 시작 시간
 * @property {string} ends - 일정 종료 시간
 * @property {string} [color] - 일정 텍스트색
 * @property {string} [bgColor] - 일정 배경색
 */

/**
 * Calendar class
 * @constructor
 * @mixes util.CustomEvents
 * @param {object} options - options for calendar
 *  @param {function} [options.groupFunc] - function for group event models {@see Collection#groupBy}
 *  @param {function} [options.controller] - controller instance
 *  @param {string} [options.defaultView='week'] - default view of calendar
 *  @param {object} [options.template] - template option
 *   @param {function} [options.template.allday] - allday template function
 *   @param {function} [options.template.time] - time template function
 *  @param {object} [options.week] - options for week view
 *   @param {number} [options.week.startDayOfWeek=0] - start day of week
 *   @param {string} options.week.renderStartDate - YYYY-MM-DD render start date
 *   @param {string} options.week.renderEndDate - YYYY-MM-DD render end date
 *  @param {object} [options.month] - options for month view
 *   @param {string} options.month.renderMonth - YYYY-MM render month
 *  @param {Calendar~CalEvent[]} [options.events] - array of CalEvent data for add calendar after initialize.
 * @param {HTMLDivElement} container = container element for calendar
 */
function Calendar(options, container) {
    if (!(this instanceof Calendar)) {
        return new Calendar(options, container);
    }

    /**
     * base date of view (today() will use this property)
     * @type {Date}
     */
    this.baseDate = datetime.start(new Date());

    /**
     * default option from service page
     * @type {object}
     */
    this.options = this.setOptions(options);

    /**
     * original options for reference when ui reset
     * @type {object}
     */
    this.originOptions = JSON.parse(JSON.stringify(this.options));

    /**
     * base controller
     * @type {Base}
     */
    this.controller = options.controller || controllerFactory(options);

    /**
     * layout view (layout manager)
     * @type {Layout}
     */
    this.layout = new Layout(container);

    /**
     * global drag handler
     * @type {Drag}
     */
    this.dragHandler = new Drag({
        distance: 5
    }, this.layout);


    /**
     * current rendered view name.
     * @type {string}
     */
    this.currentViewName = options.defaultView || 'week';

    /**********
     * SETTING
     **********/
    this.layout.controller = this.controller;

    function refresh() {
        this.refreshChildView();
    }

    this.controller.on({
        updateEvent: refresh,
        createdEvent: refresh
    }, this);

    if (options.events && options.events.length) {
        this.createEvent(options.events, true);
    }

    /**
     * @type {Date}
     */
    this._currentStartDate = null;

    /**
     * @type {Date}
     */
    this._currentEndDate = null;

    /**
     * @type {function}
     */
    this._refreshMethod = null;

    this.initializeView();
}

/**********
 * CRUD Methods
 **********/

/**
 * Create events instance and render calendar.
 * @param {Calendar~Event[]} dataObjectList - array of {@see Calendar~Event} object
 * @param {boolean} [silent=false] - no auto render after creation when set true
 */
Calendar.prototype.createEvents = function(dataObjectList, silent) {
    this.controller.createEvents(dataObjectList, silent);

    if (!silent) {
        this.render();
    }
};

/**
 * Get event instance by event id
 * @param {string} id - ID of event instance
 * @returns {CalEvent} event instance
 */
Calendar.prototype.getEvent = function(id) {
    return util.pick(this.controller.events.items, id);
};

/**
 * Update event instance
 * @param {string} id - ID of event instance to update data
 * @param {object} data - object data to update instance
 */
Calendar.prototype.updateEvent = function(id, data) {
    var found;

    this.controller.events.doWhenHas(id, function(model) {
        found = model;
        util.forEach(data, function(value, key) {
            model.set(key, value);
        });
    });

    this.render();
    found.dirty(false);
};

/**
 * Delete event instance
 * @param {string} id - ID of event instance to delete
 */
Calendar.prototype.deleteEvent = function(id) {
    this.controller.events.remove(id);
    this.render();
};

/**********
 * Private Methods
 **********/

/**
 * Set child view's options recursively
 * @param {View} view - parent view
 * @param {function} func - option manipulate function
 * @private
 */
Calendar.prototype._setOptionRecurseively = function(view, func) {
    view.recursive(function(childView) {
        var opt = childView.options;

        if (!opt) {
            return;
        }

        func(opt);
    });
};

/**
 * @param {string|Date} date - date to show in calendar
 * @param {number} [startDayOfWeek=0] - start day of week
 * @return {array} render range
 * @private
 */
Calendar.prototype._getWeekRenderRange = function(date, startDayOfWeek) {
    var day, start, end;

    date = util.isDate(date) ? date : new Date(date);
    startDayOfWeek = (startDayOfWeek || 0);
    day = date.getDay();

    function mil(d) {
        return datetime.MILLISECONDS_PER_DAY * d;
    }

    // calculate default render range first.
    start = new Date(+date - mil(day) + mil(startDayOfWeek));
    end = new Date(+start + mil(6));

    if (day < startDayOfWeek) {
        start = new Date(+start - mil(7));
        end = new Date(+end - mil(7));
    }

    return [start, end];
};

/**********
 * General Methods
 **********/

/**
 * Delete all data and clear view.
 */
Calendar.prototype.clear = function() {
    this.controller.dateMatrix = {};
    this.controller.events.clear();
    this.render();
};

/**
 * Render calendar.
 */
Calendar.prototype.render = function() {
    this.layout.render();
};

/**
 * Refresh calendar layout.
 */
Calendar.prototype.refresh = function() {
    if (this._refreshMethod) {
        this._refreshMethod();
    }
};

/**
 * Initialize current view.
 */
Calendar.prototype.initializeView = function() {
    var currentViewName = this.currentViewName,
        options;

    this.toggleView(currentViewName, true, true);

    if (this.currentViewName === 'week') {
        options = this.options.week;
        this.setDate(options.renderStartDate, options.renderEndDate);
    } else {
        //TODO: month view.
    }
};

/**
 * Set calendar's render date range and refresh view
 * @param {string|Date} start - start date of render
 * @param {string|Date} end - end date of render
 */
Calendar.prototype.setDate = function(start, end) {
    var ymd = 'YYYY-MM-DD';
    start = util.isDate(start) ? start : new Date(start);

    if (this.currentViewName === 'week') {
        if (!end) {
            config.throwError('Calendar#setDate() Need 2 parameter (start, end) in "week" view.');
            return;
        }
        end = util.isDate(end) ? end : new Date(end);

        this._currentStartDate = new Date(+start);
        this._currentEndDate = new Date(+end);

        start = datetime.format(start, ymd);
        end = datetime.format(end, ymd);

        this._setOptionRecurseively(this.getCurrentView(), function(viewOption) {
            viewOption.renderStartDate = start;
            viewOption.renderEndDate = end;
        });
    } else {
        //TODO: month view.
    }

    this.refreshChildView(this.currentViewName);
};

/**
 * Move current render range to range that include supplied date
 * @param {string|Date} date - date to show
 */
Calendar.prototype.showDate = function(date) {
    var options = this.options;

    date = util.isDate(date) ? date : new Date(date);

    if (this.currentViewName === 'week') {
        this.setDate.apply(this, this._getWeekRenderRange(date, options.startDayOfWeek));
    } else {
        //TODO: month view.
    }
};

/**
 * Move to today.
 */
Calendar.prototype.today = function() {
    this.showDate(new Date());
};

/**
 * Move the calendar amount of offset value
 * @param {number} offset - offset value.
 * @example
 * // move previous week when "week" view.
 * // move previous month when "month" view.
 * calendar.move(-1);
 */
Calendar.prototype.move = function(offset) {
    var start = this._currentStartDate,
        end = this._currentEndDate,
        diff;

    if (this.currentViewName === 'week') {
        diff = ((end - start) + datetime.MILLISECONDS_PER_DAY) * (offset || 0);

        start = new Date(+start + diff);
        end = new Date(+end + diff);

        this.setDate(start, end);
    } else {
        //TODO: month view.
    }
};

/**
 * Move the calendar forward an arvitrary amount of unit
 */
Calendar.prototype.next = function() {
    this.move(1);
};

/**
 * Move the calendar backward an arvitrary amount of unit
 */
Calendar.prototype.prev = function() {
    this.move(-1);
};

/**
 * Return current rendered view.
 * @returns {View} current view instance
 */
Calendar.prototype.getCurrentView = function() {
    return util.pick(this.layout.childs.items, this.currentViewName);
}

/**
 * Toggle current view
 * @param {string} viewName - the name of view.
 * @param {boolean} force - force render despite of current view and new view are equal
 */
Calendar.prototype.toggleView = function(viewName, force) {
    var layout = this.layout,
        controller = this.controller,
        dragHandler = this.dragHandler,
        options = this.options;

    if (!force && this.currentViewName === viewName) {
        return;
    }

    this.currentViewName = viewName;
    layout.clear();

    if (viewName === 'week') {
        layout.addChild(weekViewFactory(controller, layout.container, dragHandler, options));
    }
}

/**
 * Destroy calendar instance.
 */
Calendar.prototype.destroy = function() {
    this.dragHandler.destroy();
    this.controller.off();
    this.layout.clear();
    this.layout.destroy();

    this.options = this.baseDate = this.controller =
        this.layout = this.dragHandler = null;
}

/**
 * Refresh child views
 * @param {string} [viewName] - the name of view to render. if not supplied then refresh all.
 */
Calendar.prototype.refreshChildView = function(viewName) {
    if (!viewName) {
        this.render();
        return;
    }

    this.layout.childs.items[viewName].render();
};

/**
 * Create default option
 * @param {object} options - option from service page
 * @returns {object} default option. 
 */
Calendar.prototype.setOptions = function(options) {
    var today = this.baseDate,
        ymd = 'YYYY-MM-DD',
        renderRange,
        weekOpt = options.week,
        tmplOpt = options.template;

    options = util.extend({
        defaultView: 'week',    // 기본 주간 뷰 설정
        week: null,
        month: null 
    }, options);

    weekOpt = options.week = util.extend({
        startDayOfWeek: 0
    }, options.week);

    if (!weekOpt.renderStartDate || !weekOpt.renderEndDate) {
        renderRange = this._getWeekRenderRange(new Date(), weekOpt.startDayOfWeek);
        weekOpt.renderStartDate = datetime.format(renderRange[0], ymd);
        weekOpt.renderEndDate = datetime.format(renderRange[1], ymd);
    }

    if (!options.month) {
        options.month = {
            renderMonth: datetime.format(today, 'YYYY-MM')
        };
    }

    util.forEach(tmplOpt, function(func, name) {
        Handlebars.registerHelper(name + '-tmpl', func);
    });

    return options;
};

util.CustomEvents.mixin(Calendar);

module.exports = Calendar;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/common":27,"../common/datetime":28,"../config":36,"../handler/drag":63,"../view/layout":74,"./controller":53,"./weekView":54,"hbsfy/runtime":22}],53:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Controller factory module.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var Base = require('../controller/base');
var Week = require('../controller/viewMixin/week');

/**
 * @param {object} options - options for base controller
 * @param {function} [options.groupFunc] - function for group each models {@see Collection#groupBy}
 * @returns {Base} The controller instance.
 */
module.exports = function(options) {
    var controller = new Base(options);

    controller.Week = {};
    util.forEach(Week, function(method, methodName) {
        controller.Week[methodName] = util.bind(method, controller);
    });

    return controller;
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../controller/base":37,"../controller/viewMixin/week":38}],54:[function(require,module,exports){
/**
 * @fileoverview Factory module for WeekView
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var config = require('../config');
var domutil = require('../common/domutil');
// Parent views
var Week = require('../view/week/week');
// Sub views
var DayName = require('../view/week/dayname');
var TimeGrid = require('../view/week/timeGrid');
var Allday = require('../view/week/allday');
// Handlers
var AlldayClick = require('../handler/allday/click');
var AlldayCreation = require('../handler/allday/creation');
var AlldayMove = require('../handler/allday/move');
var AlldayResize = require('../handler/allday/resize');
var TimeClick = require('../handler/time/click');
var TimeCreation = require('../handler/time/creation');
var TimeMove = require('../handler/time/move');
var TimeResize = require('../handler/time/resize');
// Base Templates
var weekViewTmpl = require('../view/template/factory/weekView.hbs');

module.exports = function(baseController, layoutContainer, dragHandler, options) {
    var weekView,
        dayNameView,
        alldayView,
        timeGridView,
        alldayClickHandler,
        alldayCreationHandler,
        alldayMoveHandler,
        alldayResizeHandler,
        timeClickHandler,
        timeCreationHandler,
        timeMoveHandler,
        timeResizeHandler;

    weekView = new Week(null, options.week, layoutContainer);
    weekView.container.innerHTML = weekViewTmpl();

    /**********
     * 일자표기 (상단 일월화수...)
     **********/
    dayNameView = new DayName(null, domutil.find('.' + config.classname('dayname-layout'), weekView.container));
    weekView.addChild(dayNameView);

    /**********
     * 종일일정
     **********/
    alldayView = new Allday(options.week, domutil.find('.' + config.classname('allday-layout'), weekView.container));
    weekView.addChild(alldayView);
    alldayClickHandler = new AlldayClick(dragHandler, alldayView, baseController);
    alldayCreationHandler = new AlldayCreation(dragHandler, alldayView, baseController);
    alldayMoveHandler = new AlldayMove(dragHandler, alldayView, baseController);
    alldayResizeHandler = new AlldayResize(dragHandler, alldayView, baseController);

    /**********
     * 시간별 일정
     **********/
    timeGridView = new TimeGrid(options.week, domutil.find('.' + config.classname('timegrid-layout'), weekView.container));
    weekView.addChild(timeGridView);
    timeClickHandler = new TimeClick(dragHandler, timeGridView, baseController);
    timeCreationHandler = new TimeCreation(dragHandler, timeGridView, baseController);
    timeMoveHandler = new TimeMove(dragHandler, timeGridView, baseController);
    timeResizeHandler = new TimeResize(dragHandler, timeGridView, baseController);

    weekView.handlers = {
        click: {
            allday: alldayClickHandler,
            time: timeClickHandler
        },
        creation: {
            allday: alldayCreationHandler,
            time: timeCreationHandler
        },
        move: {
            allday: alldayMoveHandler,
            time: timeMoveHandler
        },
        resize: {
            allday: alldayResizeHandler,
            time: timeResizeHandler
        }
    };

    // add controller
    weekView.controller = baseController.Week;

    // add destroy
    weekView._beforeDestroy = function() {
        util.forEach(weekView.handlers, function(type) {
            util.forEach(type, function(handler) {
                handler.off();
                handler.destroy();
            });
        });
    };

    return weekView;
};

},{"../common/domutil":31,"../config":36,"../handler/allday/click":55,"../handler/allday/creation":57,"../handler/allday/move":59,"../handler/allday/resize":61,"../handler/time/click":64,"../handler/time/creation":66,"../handler/time/move":68,"../handler/time/resize":70,"../view/template/factory/weekView.hbs":76,"../view/week/allday":85,"../view/week/dayname":86,"../view/week/timeGrid":88,"../view/week/week":89}],55:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Click handle module for allday events
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../../config');
var domutil = require('../../common/domutil');
var AlldayMove = require('./move');

/**
 * @constructor
 * @implements {Handler}
 * @mixes CustomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {Allday} [alldayView] - MonthWeek view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function AlldayClick(dragHandler, alldayView, baseController) {
    /**
     * @type {Drag}
     */
    this.dragHandler = dragHandler;

    /**
     * @type {Allday}
     */
    this.alldayView = alldayView;

    /**
     * @type {Base}
     */
    this.baseController = baseController;

    dragHandler.on({
        'click': this._onClick
    }, this);
}

/**
 * Destroy handler module
 */
AlldayClick.prototype.destroy = function() {
    this.dragHandler.off(this);
    this.alldayView = this.baseController = this.dragHandler = null;
};

/**
 * Check target element is expected condition for activate this plugins.
 * @param {HTMLElement} target - The element to check
 * @returns {string} - model id
 */
AlldayClick.prototype.checkExpectCondition = AlldayMove.prototype.checkExpectedCondition;

/**
 * Click event handler
 * @param {object} clickEvent - click event data
 * @emits AlldayClick#clickEvent
 */
AlldayClick.prototype._onClick = function(clickEvent) {
    var target = clickEvent.target,
        timeView = this.checkExpectCondition(target),
        blockElement = domutil.closest(target, '.' + config.classname('allday-event-block')),
        eventCollection = this.baseController.events;

    if (!timeView || !blockElement) {
        return;
    }

    eventCollection.doWhenHas(domutil.getData(blockElement, 'id'), function(model) {
        /**
         * @events AlldayClick#clickEvent
         * @type {object}
         * @property {CalEvent} model - model instance
         * @property {MouseEvent} jsEvent - MouseEvent object
         */
        this.fire('clickEvent', {
            model:  model,
            jsEvent: clickEvent.originEvent
        });
    }, this);
};

util.CustomEvents.mixin(AlldayClick);

module.exports = AlldayClick;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/domutil":31,"../../config":36,"./move":59}],56:[function(require,module,exports){
/**
 * @fileoverview Base mixin object for handler/allday
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var domutil = require('../../common/domutil');
var domevent = require('../../common/domevent');
var datetime = require('../../common/datetime');
var common = require('../../common/common');

var mmax = Math.max,
    mmin = Math.min,
    CONTAINER_PADDING_LEFT = 60;

/**
 * @mixin Allday.Core
 */
var alldayCore = {
    /**
     * @param {Allday} alldayView - view instance of allday.
     * @param {MouseEvent} mouseEvent - mouse event object.
     * @returns {function} function that return event data by mouse events.
     */
    _retriveEventData: function(alldayView, mouseEvent) {
        var container = alldayView.container,
            renderStartDate,
            renderEndDate,
            datesInRange,
            containerWidth,
            mousePos,
            dragStartXIndex;

        renderStartDate = datetime.parse(alldayView.options.renderStartDate);
        renderEndDate = datetime.end(datetime.parse(alldayView.options.renderEndDate));
        datesInRange = datetime.range(renderStartDate, renderEndDate, datetime.MILLISECONDS_PER_DAY).length;
        containerWidth = domutil.getSize(container)[0] - CONTAINER_PADDING_LEFT;    // subtract container left padding.

        mousePos = domevent.getMousePosition(mouseEvent, container);
        dragStartXIndex = common.ratio(containerWidth, datesInRange, mousePos[0] - CONTAINER_PADDING_LEFT) | 0;

        /**
         * @param {MouseEvent} mouseEvent - mouse event in drag actions.
         * @returns {object} event data.
         */
        return function(mouseEvent) {
            var pos = domevent.getMousePosition(mouseEvent, container),
                mouseX = pos[0] - CONTAINER_PADDING_LEFT,
                xIndex = common.ratio(containerWidth, datesInRange, mouseX) | 0;

            // apply limitation of creation event X index.
            xIndex = mmax(xIndex, 0);
            xIndex = mmin(xIndex, datesInRange - 1);

            return {
                relatedView: alldayView,
                dragStartXIndex: dragStartXIndex,
                datesInRange: datesInRange,
                xIndex: xIndex
            };
        };
    }
};

module.exports = alldayCore;


},{"../../common/common":27,"../../common/datetime":28,"../../common/domevent":30,"../../common/domutil":31}],57:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Handler module for MonthWeek view's creation actions.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.tui.util;
var config = require('../../config');
var datetime = require('../../common/datetime');
var common = require('../../common/common');
var domutil = require('../../common/domutil');
var alldayCore = require('./core');
var AlldayCreationGuide = require('./creationGuide');

/**
 * @constructor
 * @implements {Handler}
 * @mixes AlldayCore
 * @mixes CutomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {Allday} [alldayView] - MonthWeek view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function AlldayCreation(dragHandler, alldayView, baseController) {    // eslint-disable-line
    /**
     * Drag handler instance.
     * @type {Drag}
     */
    this.dragHandler = null;

    /**
     * allday view instance.
     * @type {Allday}
     */
    this.alldayView = null;

    /**
     * Base controller instance.
     * @type {Base}
     */
    this.baseController = null;

    /**
     * @type {function}
     */
    this.getEventDataFunc = null;

    if (arguments.length) {
        this.connect.apply(this, arguments);
    }

    /**
     * @type {AlldayCreationGuide}
     */
    this.guide = new AlldayCreationGuide(this);
}

/**
 * Destroy method
 */
AlldayCreation.prototype.destroy = function() {
    this.guide.destroy();
    this.dragHandler.off(this);
    this.dragHandler = this.alldayView = this.baseController =
        this.getEventDataFunc = null;
};

/**
 * Check dragstart target is expected conditions for this handler.
 * @param {HTMLElement} target - dragstart event handler's target element.
 * @returns {boolean|MonthWeek} return MonthWeek view instance when satiate condition.
 */
AlldayCreation.prototype.checkExpectedCondition = function(target) {
    var cssClass = domutil.getClass(target),
        matches;

    if (cssClass !== config.classname('monthweek-events')) {
        return false;
    }

    target = target.parentNode;
    cssClass = domutil.getClass(target);
    matches = cssClass.match(config.allday.getViewIDRegExp);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.alldayView.childs.items, matches[1]);
};

/**
 * Connect handler, view, controller.
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {Allday} [alldayView] - MonthWeek view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
AlldayCreation.prototype.connect = function(dragHandler, alldayView, baseController) {
    this.dragHandler = dragHandler;
    this.alldayView = alldayView;
    this.baseController = baseController;

    dragHandler.on({
        dragStart: this._onDragStart
    }, this);
};

/**
 * Request event model creation to controller by custom events.
 * @fires {AlldayCreation#beforeCreateEvent}
 * @param {object} eventData - event data from AlldayCreation module.
 */
AlldayCreation.prototype._createEvent = function(eventData) {
    var viewOptions = eventData.relatedView.options,
        dateRange = datetime.range(
            datetime.start(datetime.parse(viewOptions.renderStartDate)),
            datetime.end(datetime.parse(viewOptions.renderEndDate)),
            datetime.MILLISECONDS_PER_DAY
        ),
        startXIndex = eventData.dragStartXIndex,
        xIndex = eventData.xIndex,
        starts, ends;

    // when inverse start, end then change it.
    if (xIndex < startXIndex) {
        startXIndex = xIndex + startXIndex;
        xIndex = startXIndex - xIndex;
        startXIndex = startXIndex - xIndex;
    }

    starts = new Date(dateRange[startXIndex].getTime());
    ends = datetime.end(dateRange[xIndex]);

    /**
     * @event {AlldayCreation#beforeCreateEvent}
     * @type {object}
     * @property {boolean} isAllDay - whether event is fired in allday view area?
     * @property {Date} starts - select start date
     * @property {Date] ends - select end date
     */
    this.fire('beforeCreateEvent', {
        isAllDay: true,
        starts: starts,
        ends: ends
    });
};

/**
 * DragStart event handler method.
 * @emits AlldayCreation#allday_creation_dragstart
 * @param {object} dragStartEventData - Drag#dragStart event handler event data.
 */
AlldayCreation.prototype._onDragStart = function(dragStartEventData) {
    var target = dragStartEventData.target,
        result = this.checkExpectedCondition(target),
        getEventDataFunc,
        eventData;

    if (!result) {
        return;
    }

    this.dragHandler.on({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    getEventDataFunc = this.getEventDataFunc = this._retriveEventData(this.alldayView, dragStartEventData.originEvent);
    eventData = getEventDataFunc(dragStartEventData.originEvent);

    /**
     * @event AlldayCreation#allday_creation_dragstart
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire('allday_creation_dragstart', eventData);
};

/**
 * Drag event handler method.
 * @emits AlldayCreation#allday_creation_drag
 * @param {object} dragEventData - Drag#drag event handler eventdata.
 */
AlldayCreation.prototype._onDrag = function(dragEventData) {
    var getEventDataFunc = this.getEventDataFunc,
        eventData;

    if (!getEventDataFunc) {
        return;
    }

    eventData = getEventDataFunc(dragEventData.originEvent);

    /**
     * @event AlldayCreation#allday_creation_drag
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire('allday_creation_drag', eventData);
};

/**
 * DragEnd event hander method.
 * @emits AlldayCreation#allday_creation_dragend
 * @param {object} dragEndEventData - Drag#DragEnd event handler data.
 * @param {string} [overrideEventName] - override emitted event name when supplied.
 */
AlldayCreation.prototype._onDragEnd = function(dragEndEventData, overrideEventName) {
    var getEventDataFunc = this.getEventDataFunc,
        eventData;

    if (!getEventDataFunc) {
        return;
    }

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    eventData = getEventDataFunc(dragEndEventData.originEvent);

    this._createEvent(eventData);

    /**
     * @event AlldayCreation#allday_creation_dragend
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire(overrideEventName || 'allday_creation_dragend', eventData);

    this.getEventDataFunc = null;
};

/**
 * Click event handler method.
 * @emits AlldayCreation#allday_creation_click
 * @param {object} clickEventData - Drag#Click event handler data.
 */
AlldayCreation.prototype._onClick = function(clickEventData) {
    /**
     * @event AlldayCreation#allday_creation_click
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this._onDragEnd(clickEventData, 'allday_creation_click');
};

common.mixin(alldayCore, AlldayCreation);
util.CustomEvents.mixin(AlldayCreation);

module.exports = AlldayCreation;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/datetime":28,"../../common/domutil":31,"../../config":36,"./core":56,"./creationGuide":58}],58:[function(require,module,exports){
/**
 * @fileoverview Guide element for Allday.Creation
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var config = require('../../config');
var domutil = require('../../common/domutil');
var reqAnimFrame = require('../../common/reqAnimFrame');

var CREATE_NEW_LABEL = '새 일정';

/**
 * Class for Allday.Creation dragging effect.
 * @constructor
 * @param {AlldayCreation} alldayCreation - instance of AlldayCreation.
 */
function AlldayCreationGuide(alldayCreation) {
    /**
     * @type {AlldayCreation}
     */
    this.alldayCreation = alldayCreation;

    /**
     * @type {HTMLDIVElement}
     */
    this.eventContainer = null;

    /**
     * @type {HTMLDIVElement}
     */
    this.guideElement = document.createElement('div');

    this.initializeGuideElement();

    alldayCreation.on({
        'allday_creation_dragstart': this._onDragStart,
        'allday_creation_drag': this._onDrag,
        'allday_creation_click': this.clearGuideElement
    }, this);
}

/**
 * Destroy method
 */
AlldayCreationGuide.prototype.destroy = function() {
    this.clearGuideElement();
    this.alldayCreation.off(this);
    this.alldayCreation = this.eventContainer =
        this.guideElement = null;
};

/**
 * initialize guide element's default style.
 */
AlldayCreationGuide.prototype.initializeGuideElement = function() {
    var guideElement = this.guideElement,
        spanElement;

    domutil.addClass(guideElement, config.classname('allday-guide-creation-block'));
    domutil.appendHTMLElement('div', guideElement, config.classname('allday-guide-creation'));

    spanElement = domutil.appendHTMLElement('span', guideElement);
    spanElement.innerHTML = CREATE_NEW_LABEL;
};

/**
 * Refresh guide element.
 * @param {object} eventData - event data from Allday.Creation handler.
 */
AlldayCreationGuide.prototype._refreshGuideElement = function(eventData) {
    var guideElement = this.guideElement,
        baseWidthPercent = (100 / eventData.datesInRange),
        dragStartXIndex = eventData.dragStartXIndex,
        xIndex = eventData.xIndex,
        length = xIndex - dragStartXIndex,
        leftPercent,
        widthPercent;

    // when revert dragging.
    if (length < 0) {
        dragStartXIndex = xIndex;
        length = Math.abs(length);
    }

    leftPercent = baseWidthPercent * dragStartXIndex;
    widthPercent = baseWidthPercent * (length + 1);

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.display = 'block';
        guideElement.style.left = leftPercent + '%';
        guideElement.style.width = widthPercent + '%';
    });
};

/**
 * Clear guide element.
 */
AlldayCreationGuide.prototype.clearGuideElement = function() {
    var guideElement = this.guideElement;

    domutil.remove(guideElement);

    guideElement.style.display = 'none';
    guideElement.style.left = '';
    guideElement.style.width = '';
};

/**
 * DragStart event handler.
 * @param {object} dragStartEventData - event data object of Allday.Creation.
 */
AlldayCreationGuide.prototype._onDragStart = function(dragStartEventData) {
    var alldayCreation = this.alldayCreation,
        alldayView = alldayCreation.alldayView,
        alldayContainerElement = alldayView.container,
        eventContainer = domutil.find('.' + config.classname('monthweek-events'), alldayContainerElement);

    eventContainer.appendChild(this.guideElement);
    this._refreshGuideElement(dragStartEventData);
};

/**
 * Drag event handler.
 * @param {object} dragEventData - event data object of Allday.Creation.
 */
AlldayCreationGuide.prototype._onDrag = function(dragEventData) {
    this._refreshGuideElement(dragEventData);
};

module.exports = AlldayCreationGuide;


},{"../../common/domutil":31,"../../common/reqAnimFrame":35,"../../config":36}],59:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Move handler for Allday view.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.tui.util;
var config = require('../../config');
var common = require('../../common/common');
var domutil = require('../../common/domutil');
var AlldayCore = require('./core');
var AlldayMoveGuide = require('./moveGuide');

/**
 * @constructor
 * @implements {Handler}
 * @mixes AlldayCore
 * @mixes CustomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {Allday} [alldayView] - MonthWeek view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function AlldayMove(dragHandler, alldayView, baseController) {
    /**
     * Drag handler instance.
     * @type {Drag}
     */
    this.dragHandler = dragHandler;

    /**
     * allday view instance.
     * @type {Allday}
     */
    this.alldayView = alldayView;

    /**
     * Base controller instance.
     * @type {Base}
     */
    this.baseController = baseController;

    /**
     * Temporary variable for dragstart event data.
     * @type {object}
     */
    this._dragStart = null;

    dragHandler.on({
        dragStart: this._onDragStart
    }, this);

    /**
     * @type {AlldayMoveGuide}
     */
    this.guide = new AlldayMoveGuide(this);
}

AlldayMove.prototype.destroy = function() {
    this.guide.destroy();
    this.dragHandler.off(this);
    this.dragHandler = this.alldayView = this.baseController =
        this.guide = this._dragStart = null;
};

/**
 * Check dragstart target is expected conditions for this handler.
 * @param {HTMLElement} target - dragstart event handler's target element.
 * @returns {boolean|MonthWeek} return MonthWeek view instance when satiate condition.
 */
AlldayMove.prototype.checkExpectedCondition = function(target) {
    var cssClass = domutil.getClass(target),
        parentView,
        matches;

    if (~cssClass.indexOf(config.classname('allday-resize-handle'))) {
        return false;
    }

    parentView = domutil.closest(target, '.' + config.classname('allday-monthweek'));

    if (!parentView) {
        return false;
    }

    cssClass = domutil.getClass(parentView);
    matches = cssClass.match(config.allday.getViewIDRegExp);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.alldayView.childs.items, matches[1]);
};

/**
 * DragStart event handler method.
 * @emits AlldayMove#allday_move_dragstart
 * @param {object} dragStartEventData - Drag#dragStart event handler event data.
 */
AlldayMove.prototype._onDragStart = function(dragStartEventData) {
    var target = dragStartEventData.target,
        result = this.checkExpectedCondition(target),
        controller = this.baseController,
        eventBlockElement,
        modelID,
        targetModel,
        getEventDataFunc,
        eventData;

    if (!result) {
        return;
    }

    eventBlockElement = domutil.closest(target, '.' + config.classname('allday-event-block'));
    if (!eventBlockElement) {
        return;
    }

    modelID = domutil.getData(eventBlockElement, 'id');
    targetModel = controller.events.items[modelID];

    if (!targetModel) {
        return;
    }

    getEventDataFunc = this.getEventDataFunc = this._retriveEventData(this.alldayView, dragStartEventData.originEvent);
    eventData = this._dragStart = getEventDataFunc(dragStartEventData.originEvent);

    util.extend(eventData, {
        eventBlockElement: eventBlockElement,
        model: targetModel
    });

    this.dragHandler.on({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    /**
     * @event AlldayMove#allday_move_dragstart
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     * @property {CalEvent} model - data object of model isntance.
     * @property {HTMLDivElement} eventBlockElement - target event block element.
     */
    this.fire('allday_move_dragstart', eventData);
};


/**
 * Drag event handler method.
 * @emits AlldayMove#allday_move_drag
 * @param {object} dragEventData - Drag#drag event handler eventdata.
 */
AlldayMove.prototype._onDrag = function(dragEventData) {
    var getEventDataFunc = this.getEventDataFunc;

    if (!getEventDataFunc) {
        return;
    }

    /**
     * @event AlldayMove#allday_move_drag
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire('allday_move_drag', getEventDataFunc(dragEventData.originEvent));
};

/**
 * Request update event model to base controller.
 * @fires AlldayMove#beforeUpdateEvent
 * @param {object} eventData - event data from AlldayMove handler module.
 */
AlldayMove.prototype._updateEvent = function(eventData) {
    var model = eventData.targetModel,
        dateOffset = eventData.xIndex - eventData.dragStartXIndex,
        newStarts = new Date(model.starts.getTime()),
        newEnds = new Date(model.ends.getTime());

    newStarts = new Date(newStarts.setDate(newStarts.getDate() + dateOffset));
    newEnds = new Date(newEnds.setDate(newEnds.getDate() + dateOffset));

    /**
     * @event AlldayMove#beforeUpdateEvent
     * @type {object}
     * @property {CalEvent} model - model instance to update
     * @property {date} starts - start time to update
     * @property {date} ends - end time to update
     */
    this.fire('beforeUpdateEvent', {
        model: model,
        starts: newStarts,
        ends: newEnds
    });
};

/**
 * DragEnd event hander method.
 * @emits AlldayMove#allday_move_dragend
 * @param {object} dragEndEventData - Drag#DragEnd event handler data.
 * @param {string} [overrideEventName] - override emitted event name when supplied.
 * @param {?boolean} skipUpdate - true then skip update event model.
 */
AlldayMove.prototype._onDragEnd = function(dragEndEventData, overrideEventName, skipUpdate) {
    var getEventDataFunc = this.getEventDataFunc,
        dragStart = this._dragStart,
        eventData;

    if (!getEventDataFunc || !dragStart) {
        return;
    }

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    eventData = getEventDataFunc(dragEndEventData.originEvent);
    util.extend(eventData, {
        targetModel: dragStart.model
    });
    
    if (!skipUpdate) {
        this._updateEvent(eventData);
    }

    /**
     * @event AlldayMove#allday_move_dragend
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire(overrideEventName || 'allday_move_dragend', eventData);

    this.getEventDataFunc = this._dragStart = null;
};

/**
 * Click event handler method.
 * @emits AlldayMove#allday_move_click
 * @param {object} clickEventData - Drag#Click event handler data.
 */
AlldayMove.prototype._onClick = function(clickEventData) {
    /**
     * @event AlldayMove#allday_move_click
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this._onDragEnd(clickEventData, 'allday_move_click', true);
};

common.mixin(AlldayCore, AlldayMove);
util.CustomEvents.mixin(AlldayMove);

module.exports = AlldayMove;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/domutil":31,"../../config":36,"./core":56,"./moveGuide":60}],60:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Effect module for Allday.Move
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.tui.util;
var config = require('../../config');
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var reqAnimFrame = require('../../common/reqAnimFrame');

/**
 * Class for Allday.Move dragging effect.
 * @constructor
 * @param {AlldayMove} alldayMove - instance of AlldayMove.
 */
function AlldayMoveGuide(alldayMove) {
    /**
     * @type {AlldayMove}
     */
    this.alldayMove = alldayMove;

    /**
     * 실제로 이벤트 엘리먼트를 담는 엘리먼트
     * @type {HTMLDIVElement}
     */
    this.eventContainer = null;

    /**
     * @type {number}
     */
    this._dragStartXIndex = null;

    /**
     * @type {HTMLDIVElement}
     */
    this.guideElement = null;

    alldayMove.on({
        'allday_move_dragstart': this._onDragStart,
        'allday_move_drag': this._onDrag,
        'allday_move_dragend': this._clearGuideElement,
        'allday_move_click': this._clearGuideElement
    }, this);
}

/**
 * Destroy method
 */
AlldayMoveGuide.prototype.destroy = function() {
    this._clearGuideElement();
    this.alldayMove.off(this);
    this.alldayMove = this.eventContainer = this._dragStartXIndex =
        this.guideElement = null;
};

/**
 * Clear guide element.
 */
AlldayMoveGuide.prototype._clearGuideElement = function() {
    domutil.remove(this.guideElement);

    if (!util.browser.msie) {
        domutil.removeClass(global.document.body, config.classname('dragging'));
    }

    this._dragStartXIndex = this.getEventDataFunc = this.guideElement = null;
};

/**
 * Refresh guide element.
 * @param {number} leftPercent - left percent of guide element.
 * @param {number} widthPercent - width percent of guide element.
 * @param {boolean} isExceededLeft - event starts is faster then render start date?
 * @param {boolean} isExceededRight - event ends is later then render end date?
 */
AlldayMoveGuide.prototype.refreshGuideElement = function(leftPercent, widthPercent, isExceededLeft, isExceededRight) {
    var guideElement = this.guideElement;

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.left = leftPercent + '%';
        guideElement.style.width = widthPercent + '%';

        if (isExceededLeft) {
            domutil.addClass(guideElement, config.classname('allday-exceed-left'));
        } else {
            domutil.removeClass(guideElement, config.classname('allday-exceed-left'));
        }

        if (isExceededRight) {
            domutil.addClass(guideElement, config.classname('allday-exceed-right'));
        } else {
            domutil.removeClass(guideElement, config.classname('allday-exceed-right'));
        }
    });
};

/**
 * Get event block information from event data.
 *
 * For example, there is single event has 10 length. but render range in view is 5 then
 * rendered block must be cut out to render properly. in this case, this method return
 * how many block are cut before rendering.
 * 
 * 이벤트 데이터에서 이벤트 블록 엘리먼트 렌더링에 대한 필요 정보를 추출한다.
 *
 * ex) 렌더링 된 블록의 길이는 5지만 실제 이 이벤트는 10의 길이를 가지고 있을 때
 * 좌 우로 몇 만큼 잘려있는지에 관한 정보를 반환함.
 * @param {object} dragStartEventData - event data from Allday.Move handler.
 * @returns {function} function that return event block information.
 */
AlldayMoveGuide.prototype._getEventBlockDataFunc = function(dragStartEventData) {
    var model = dragStartEventData.model,
        datesInRange = dragStartEventData.datesInRange,
        baseWidthPercent = (100 / datesInRange),
        originEventStarts = datetime.start(model.starts),
        originEventEnds = datetime.end(model.ends),
        viewOptions = this.alldayMove.alldayView.options,
        renderStartDate = datetime.start(datetime.parse(viewOptions.renderStartDate)),
        renderEndDate = datetime.end(datetime.parse(viewOptions.renderEndDate)),
        fromLeft = (new Date(originEventStarts.getTime() - renderStartDate.getTime())) / datetime.MILLISECONDS_PER_DAY | 0,
        fromRight = (new Date(originEventEnds.getTime() - renderEndDate.getTime())) / datetime.MILLISECONDS_PER_DAY | 0;

    return function(indexOffset) {
        return {
            baseWidthPercent: baseWidthPercent,
            fromLeft: fromLeft + indexOffset,
            fromRight: fromRight + indexOffset
        };
    };
};

/**
 * DragStart event handler.
 * @param {object} dragStartEventData - event data.
 */
AlldayMoveGuide.prototype._onDragStart = function(dragStartEventData) {
    var alldayViewContainer = this.alldayMove.alldayView.container,
        guideElement = this.guideElement = dragStartEventData.eventBlockElement.cloneNode(true),
        eventContainer;

    if (!util.browser.msie) {
        domutil.addClass(global.document.body, config.classname('dragging'));
    }

    eventContainer = domutil.find('.' + config.classname('monthweek-events'), alldayViewContainer);
    domutil.addClass(guideElement, config.classname('allday-guide-move'));
    eventContainer.appendChild(guideElement);

    this._dragStartXIndex = dragStartEventData.xIndex;
    this.getEventDataFunc = this._getEventBlockDataFunc(dragStartEventData);
};

/**
 * Drag event handler.
 * @param {object} dragEventData - event data.
 */
AlldayMoveGuide.prototype._onDrag = function(dragEventData) {
    var getEventDataFunc = this.getEventDataFunc,
        dragStartXIndex = this._dragStartXIndex,
        datesInRange = dragEventData.datesInRange,
        eventData,
        isExceededLeft,
        isExceededRight,
        originLength,
        newLeft,
        newWidth;

    if (!getEventDataFunc) {
        return;
    }

    eventData = getEventDataFunc(dragEventData.xIndex - dragStartXIndex);
    isExceededLeft = eventData.fromLeft < 0;
    isExceededRight = eventData.fromRight > 0;

    newLeft = Math.max(0, eventData.fromLeft);
    originLength = (eventData.fromLeft * -1) + (datesInRange + eventData.fromRight);
    newWidth = isExceededLeft ? (originLength + eventData.fromLeft) : originLength;
    newWidth = isExceededRight ? (newWidth - eventData.fromRight) : newWidth;

    newLeft *= eventData.baseWidthPercent;
    newWidth *= eventData.baseWidthPercent;

    this.refreshGuideElement(newLeft, newWidth, isExceededLeft, isExceededRight);
};

module.exports = AlldayMoveGuide;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../../common/reqAnimFrame":35,"../../config":36}],61:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Resize handler module for Allday view.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.tui.util;
var config = require('../../config');
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var common = require('../../common/common');
var AlldayCore = require('./core');
var AlldayResizeGuide = require('./resizeGuide');

/**
 * @constructor
 * @implements {Handler}
 * @mixes AlldayCore
 * @mixes CustomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {Allday} [alldayView] - MonthWeek view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function AlldayResize(dragHandler, alldayView, baseController) {
    /**
     * Drag handler instance.
     * @type {Drag}
     */
    this.dragHandler = dragHandler;

    /**
     * allday view instance.
     * @type {Allday}
     */
    this.alldayView = alldayView;

    /**
     * Base controller instance.
     * @type {Base}
     */
    this.baseController = baseController;

    /**
     * Temporary variable for dragStart event data.
     * @type {object}
     */
    this._dragStart = null;

    dragHandler.on({
        dragStart: this._onDragStart
    }, this);

    /**
     * @type {AlldayResizeGuide}
     */
    this.guide = new AlldayResizeGuide(this);
}

/**
 * Destroy method
 */
AlldayResize.prototype.destroy = function() {
    this.guide.destroy();
    this.dragHandler.off(this);
    this.dragHandler = this.alldayView = this.baseController =
        this.guide = this._dragStart = null;
};

/**
 * Check dragstart target is expected conditions for this handler.
 * @param {HTMLElement} target - dragstart event handler's target element.
 * @returns {boolean|MonthWeek} return MonthWeek view instance when satiate condition.
 */
AlldayResize.prototype.checkExpectedCondition = function(target) {
    var cssClass = domutil.getClass(target),
        matches;

    if (!~cssClass.indexOf(config.classname('allday-resize-handle'))) {
        return false;
    }

    target = domutil.closest(target, '.' + config.classname('allday-monthweek'));

    if (!target) {
        return false;
    }

    cssClass = domutil.getClass(target);
    matches = cssClass.match(config.allday.getViewIDRegExp);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.alldayView.childs.items, matches[1]);
};

/**
 * DragStart event handler.
 * @emits AlldayResize#allday_resize_dragstart
 * @param {object} dragStartEventData - event data.
 */
AlldayResize.prototype._onDragStart = function(dragStartEventData) {
    var target = dragStartEventData.target,
        result = this.checkExpectedCondition(target),
        controller = this.baseController,
        eventBlockElement,
        modelID,
        targetModel,
        getEventDataFunc,
        eventData;

    if (!result) {
        return;
    }

    eventBlockElement = domutil.closest(target, '.' + config.classname('allday-event-block'));
    modelID = domutil.getData(eventBlockElement, 'id');
    targetModel = controller.events.items[modelID];

    if (!targetModel) {
        return;
    }

    getEventDataFunc = this.getEventDataFunc = this._retriveEventData(this.alldayView, dragStartEventData.originEvent);
    eventData = this._dragStart = getEventDataFunc(dragStartEventData.originEvent);

    util.extend(eventData, {
        eventBlockElement: eventBlockElement,
        model: targetModel
    });

    this.dragHandler.on({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    /**
     * @event AlldayResize#allday_resize_dragstart
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     * @property {CalEvent} model - data object of model isntance.
     * @property {HTMLDivElement} eventBlockElement - target event block element.
     */
    this.fire('allday_resize_dragstart', eventData);
};

/**
 * Drag event handler method.
 * @emits AlldayResize#allday_resize_drag
 * @param {object} dragEventData - Drag#drag event handler eventdata.
 */
AlldayResize.prototype._onDrag = function(dragEventData) {
    var getEventDataFunc = this.getEventDataFunc;

    if (!getEventDataFunc) {
        return;
    }

    /**
     * @event AlldayResize#allday_resize_drag
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire('allday_resize_drag', getEventDataFunc(dragEventData.originEvent));
};

/**
 * Request update event instance to base controller.
 * @fires AlldayResize#beforeUpdateEvent
 * @param {object} eventData - event data from AlldayResize handler.
 */
AlldayResize.prototype._updateEvent = function(eventData) {
    var model = eventData.targetModel,
        dateOffset = eventData.xIndex - eventData.dragStartXIndex,
        newEnds = new Date(model.ends.getTime());

    newEnds = new Date(newEnds.setDate(newEnds.getDate() + dateOffset));
    newEnds = new Date(Math.max(datetime.end(model.starts).getTime(), newEnds.getTime()));

    /**
     * @event AlldayResize#beforeUpdateEvent
     * @type {object}
     * @property {CalEvent} model - model instance to update
     * @property {date} starts - start time to update
     * @property {date} ends - end time to update
     */
    this.fire('beforeUpdateEvent', {
        model: model,
        starts: model.getStarts(),
        ends: newEnds
    });
};

/**
 * DragEnd event hander method.
 * @emits AlldayResize#allday_resize_dragend
 * @param {object} dragEndEventData - Drag#DragEnd event handler data.
 * @param {string} [overrideEventName] - override emitted event name when supplied.
 * @param {?boolean} skipUpdate - true then skip update event model.
 */
AlldayResize.prototype._onDragEnd = function(dragEndEventData, overrideEventName, skipUpdate) {
    var getEventDataFunc = this.getEventDataFunc,
        dragStart = this._dragStart,
        eventData;

    if (!getEventDataFunc || !dragStart) {
        return;
    }

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    eventData = getEventDataFunc(dragEndEventData.originEvent);
    util.extend(eventData, {
        targetModel: dragStart.model
    });

    if (!skipUpdate) {
        this._updateEvent(eventData);
    }

    /**
     * @event AlldayResize#allday_resize_dragend
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire(overrideEventName || 'allday_resize_dragend', eventData);

    this.getEventDataFunc = this._dragStart = null;
};

/**
 * Click event handler method.
 * @emits AlldayResize#allday_resize_click
 * @param {object} clickEventData - Drag#Click event handler data.
 */
AlldayResize.prototype._onClick = function(clickEventData) {
    /**
     * @event AlldayResize#allday_resize_click
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this._onDragEnd(clickEventData, 'allday_resize_click', true);
};

common.mixin(AlldayCore, AlldayResize);
util.CustomEvents.mixin(AlldayResize);

module.exports = AlldayResize;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/datetime":28,"../../common/domutil":31,"../../config":36,"./core":56,"./resizeGuide":62}],62:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Resize Guide module.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.tui.util;
var config = require('../../config');
var domutil = require('../../common/domutil');
var datetime = require('../../common/datetime');
var reqAnimFrame = require('../../common/reqAnimFrame');


/**
 * @constructor
 * @param {AlldayResize} alldayResize - instance of AlldayResize
 */
function AlldayResizeGuide(alldayResize) {
    /**
     * @type {AlldayResize}
     */
    this.alldayResize = alldayResize;

    /**
     * 실제로 이벤트 엘리먼트를 담는 엘리먼트
     * @type {HTMLDIVElement}
     */
    this.eventContainer = null;

    /**
     * @type {function}
     */
    this.getEventDataFunc = null;

    /**
     * @type {HTMLDIVElement}
     */
    this.guideElement = null;

    alldayResize.on({
        'allday_resize_dragstart': this._onDragStart,
        'allday_resize_drag': this._onDrag,
        'allday_resize_dragend': this._clearGuideElement,
        'allday_resize_click': this._clearGuideElement
    }, this);
}

/**
 * Destroy method
 */
AlldayResizeGuide.prototype.destroy = function() {
    this._clearGuideElement();
    this.alldayResize.off(this);
    this.alldayResize = this.eventContainer = this.getEventDataFunc =
        this.guideElement = null;
};

/**
 * Clear guide element.
 */
AlldayResizeGuide.prototype._clearGuideElement = function() {
    domutil.remove(this.guideElement);

    if (!util.browser.msie) {
        domutil.removeClass(global.document.body, config.classname('resizing-x'));
    }

    this.getEventDataFunc = null;
};

/**
 * Refresh guide element
 * @param {number} newWidth - new width percentage value to resize guide element.
 */
AlldayResizeGuide.prototype.refreshGuideElement = function(newWidth) {
    var guideElement = this.guideElement;

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.width = newWidth + '%';
    });
};

/**
 * Return function that calculate guide element's new width percentage value.
 * @param {object} dragStartEventData - dragstart event data.
 * @returns {function} return function that calculate guide element new width percentage.
 */
AlldayResizeGuide.prototype.getGuideElementWidthFunc = function(dragStartEventData) {
    var model = dragStartEventData.model,
        viewOptions = this.alldayResize.alldayView.options,
        startDate = datetime.start(new Date(Math.max(model.starts.getTime(), datetime.parse(viewOptions.renderStartDate).getTime()))),
        endDate = datetime.end(new Date(Math.min(model.ends.getTime(), datetime.parse(viewOptions.renderEndDate).getTime()))),
        originLength = datetime.range(startDate, endDate, datetime.MILLISECONDS_PER_DAY).length,
        baseWidthPercent = 100 / dragStartEventData.datesInRange,
        dragStartIndex = dragStartEventData.xIndex;

    return function(xIndex) {
        var offset = xIndex - dragStartIndex,
            newLength = originLength + offset;

        newLength = Math.max(1, newLength);

        return newLength * baseWidthPercent;
    }
};

/**
 * DragStart event handler.
 * @param {object} dragStartEventData - event data.
 */
AlldayResizeGuide.prototype._onDragStart = function(dragStartEventData) {
    var alldayViewContainer = this.alldayResize.alldayView.container,
        guideElement = this.guideElement = dragStartEventData.eventBlockElement.cloneNode(true),
        eventContainer;

    if (!util.browser.msie) {
        domutil.addClass(global.document.body, config.classname('resizing-x'));
    }

    eventContainer = domutil.find('.' + config.classname('monthweek-events'), alldayViewContainer);
    domutil.addClass(guideElement, config.classname('allday-guide-move'));
    eventContainer.appendChild(guideElement);

    this.getEventDataFunc = this.getGuideElementWidthFunc(dragStartEventData);
};

/**
 * Drag event handler.
 * @param {object} dragEventData - event data.
 */
AlldayResizeGuide.prototype._onDrag = function(dragEventData) {
    var func = this.getEventDataFunc;

    if (!func) {
        return;
    }

    this.refreshGuideElement(func(dragEventData.xIndex));
};

module.exports = AlldayResizeGuide;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../../common/reqAnimFrame":35,"../../config":36}],63:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Drag handler for calendar.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var domutil = require('../common/domutil');
var domevent = require('../common/domevent');

/**
 * @constructor
 * @mixes CustomEvents
 * @param {object} options - options for drag handler
 * @param {number} [options.distance=10] - distance in pixels after mouse must move before dragging should start
 * @param {LayoutView} layoutView Layout view instance.
 */
function Drag(options, layoutView) {
    var container = layoutView.container;

    domevent.on(container, 'mousedown', this._onMouseDown, this);

    this.options = util.extend({
        distance: 10
    }, options);

    /**
     * @type {HTMLElement}
     */
    this.container = container;

    /**
     * @type {boolean}
     */
    this._isMoved = false;

    /**
     * dragging distance in pixel between mousedown and firing dragStart events
     * @type {number}
     */
    this._distance = 0;

    /**
     * @type {boolean}
     */
    this._dragStartFired = false;

    /**
     * @type {object}
     */
    this._dragStartEventData = null;
}

/**
 * Destroy method.
 */
Drag.prototype.destroy = function() {
    domevent.off(this.container, 'mousedown', this._onMouseDown, this);
    this._isMoved = null;
    this.container = null;
};

/**
 * Toggle events for mouse dragging.
 * @param {boolean} toBind - bind events related with dragging when supplied "true"
 */
Drag.prototype._toggleDragEvent = function(toBind) {
    var container = this.container,
        domMethod,
        method;

    if (toBind) {
        domMethod = 'on';
        method = 'disable';
    } else {
        domMethod = 'off';
        method = 'enable';
    }

    domutil[method + 'TextSelection'](container);
    domutil[method + 'ImageDrag'](container);
    domevent[domMethod](global, {
        mousemove: this._onMouseMove,
        mouseup: this._onMouseUp
    }, this);
};

/**
 * Normalize mouse event object.
 * @param {MouseEvent} mouseEvent - mouse event object.
 * @returns {object} normalized mouse event data.
 */
Drag.prototype._getEventData = function(mouseEvent) {
    return {
        target: mouseEvent.target || mouseEvent.srcElement,
        originEvent: mouseEvent
    };
};

/**
 * MouseDown DOM event handler.
 * @param {MouseEvent} mouseDownEvent MouseDown event object.
 */
Drag.prototype._onMouseDown = function(mouseDownEvent) {
    // only primary button can start drag.
    if (domevent.getMouseButton(mouseDownEvent) !== 0) {
        return;
    }

    this._distance = 0;
    this._dragStartFired = false;
    this._dragStartEventData = this._getEventData(mouseDownEvent);

    this._toggleDragEvent(true);
};

/**
 * MouseMove DOM event handler.
 * @emits Drag#drag
 * @emits Drag#dragStart
 * @param {MouseEvent} mouseMoveEvent MouseMove event object.
 */
Drag.prototype._onMouseMove = function(mouseMoveEvent) {
    var distance = this.options.distance;
    // prevent automatic scrolling.
    domevent.preventDefault(mouseMoveEvent);

    this._isMoved = true;

    if (this._distance < distance) {
        this._distance += 1;
        return;
    }

    if (!this._dragStartFired) {
        this._dragStartFired = true;

        /**
         * Drag starts events. cancelable.
         * @event Drag#dragStart
         * @type {object}
         * @property {HTMLElement} target - target element in this event.
         * @property {MouseEvent} originEvent - original mouse event object.
         */
        if (!this.invoke('dragStart', this._dragStartEventData)) {
            this._toggleDragEvent(false);
            return;
        }
    }

    /**
     * CalEvents while dragging.
     * @event Drag#drag
     * @type {object}
     * @property {HTMLElement} target - target element in this event.
     * @property {MouseEvent} originEvent - original mouse event object.
     */
    this.fire('drag', this._getEventData(mouseMoveEvent));
};

/**
 * MouseUp DOM event handler.
 * @param {MouseEvent} mouseUpEvent MouseUp event object.
 * @emits Drag#dragEnd
 * @emits Drag#click
 */
Drag.prototype._onMouseUp = function(mouseUpEvent) {
    this._toggleDragEvent(false);

    // emit "click" event when not emitted drag event between mousedown and mouseup.
    if (this._isMoved) {
        this._isMoved = false;

        /**
         * Drag end events.
         * @event Drag#dragEnd
         * @type {MouseEvent}
         * @property {HTMLElement} target - target element in this event.
         * @property {MouseEvent} originEvent - original mouse event object.
         */
        this.fire('dragEnd', this._getEventData(mouseUpEvent));
        return;
    }

    /**
     * Click events.
     * @event Drag#click
     * @type {MouseEvent}
     * @property {HTMLElement} target - target element in this event.
     * @property {MouseEvent} originEvent - original mouse event object.
     */
    this.fire('click', this._getEventData(mouseUpEvent));
};

util.CustomEvents.mixin(Drag);

module.exports = Drag;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/domevent":30,"../common/domutil":31}],64:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Allday event click event hander module
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../../config');
var domutil = require('../../common/domutil');

/**
 * @constructor
 * @implements {Handler}
 * @mixes util.CustomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function TimeClick(dragHandler, timeGridView, baseController) {
    /**
     * @type {Drag}
     */
    this.dragHandler = dragHandler;

    /**
     * @type {TimeGrid}
     */
    this.timeGridView = timeGridView;

    /**
     * @type {Base}
     */
    this.baseController = baseController;

    dragHandler.on({
        'click': this._onClick
    }, this);
}

/**
 * Destroy method
 */
TimeClick.prototype.destroy = function() {
    this.dragHandler.off(this);
    this.timeGridView = this.baseController = this.dragHandler = null;
};

/**
 * Check target element is expected condition for activate this plugins.
 * @param {HTMLElement} target - The element to check
 * @returns {string} - model id
 */
TimeClick.prototype.checkExpectCondition = function(target) {
    var container,
        matches;

    container = domutil.closest(target, '.' + config.classname('time-date'));

    if (!container) {
        return false;
    }

    matches = domutil.getClass(container).match(config.time.getViewIDRegExp);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.timeGridView.childs.items, +matches[1]);
};

/**
 * Click event hander
 * @param {object} clickEvent - click event from {@link Drag}
 * @emits TimeClick#clickEvent
 */
TimeClick.prototype._onClick = function(clickEvent) {
    var target = clickEvent.target,
        timeView = this.checkExpectCondition(target),
        blockElement = domutil.closest(target, '.' + config.classname('time-date-event-block')),
        eventCollection = this.baseController.events;

    if (!timeView || !blockElement) {
        return;
    }

    eventCollection.doWhenHas(domutil.getData(blockElement, 'id'), function(model) {
        /**
         * @events TimeClick#clickEvent
         * @type {object}
         * @property {CalEvent} model - model instance
         * @property {MouseEvent} jsEvent - MouseEvent object
         */
        this.fire('clickEvent', {
            model:  model,
            jsEvent: clickEvent.originEvent
        });
    }, this);
};

util.CustomEvents.mixin(TimeClick);

module.exports = TimeClick;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/domutil":31,"../../config":36}],65:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Core methods for dragging actions
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var common = require('../../common/common');
var datetime = require('../../common/datetime');
var domevent = require('../../common/domevent');
var Point = require('../../common/point');

/**
 * @mixin Time.Core
 */
var timeCore = {
    /**
     * Get Y index ratio(hour) in time grids by supplied parameters.
     * @param {number} baseMil - base milliseconds number for supplied height.
     * @param {number} height - container element height.
     * @param {number} y - Y coordinate to calculate hour ratio.
     * @returns {number} hour index ratio value.
     */
    _calcGridYIndex: function(baseMil, height, y) {
        // get ratio from right expression > point.y : x = session.height : baseMil
        // and convert milliseconds value to hours.
        var result = datetime.millisecondsTo('hour', (y * baseMil) / height),
            floored = result | 0,
            nearest = common.nearest(result - floored, [0, 1]);

        return floored + (nearest ? 0.5 : 0);
    },

    /**
     * Get function to makes event data from Time and mouseEvent
     * @param {Time} timeView - Instance of time view.
     * @returns {function} - Function that return event data from mouse event.
     */
    _retriveEventData: function(timeView) {
        var container = timeView.container,
            options = timeView.options,
            viewHeight = timeView.getViewBound().height,
            viewTime = +timeView.getDate(),
            hourLength = options.hourEnd - options.hourStart,
            baseMil = datetime.millisecondsFrom('hour', hourLength);

        /**
         * @param {MouseEvent} mouseEvent - mouse event object to get common event data.
         * @param {object} [extend] - object to extend event data before return.
         * @returns {object} - common event data for time.*
         */
        return util.bind(function(mouseEvent, extend) {
            var mouseY = Point.n(domevent.getMousePosition(mouseEvent, container)).y,
                gridY = common.ratio(viewHeight, hourLength, mouseY),
                timeY = viewTime + datetime.millisecondsFrom('hour', gridY),
                nearestGridY = this._calcGridYIndex(baseMil, viewHeight, mouseY),
                nearestGridTimeY = viewTime + datetime.millisecondsFrom('hour', nearestGridY + options.hourStart);

            return util.extend({
                target: mouseEvent.target || mouseEvent.srcElement,
                relatedView: timeView,
                originEvent: mouseEvent,
                mouseY: mouseY,
                gridY: gridY,
                timeY: timeY,
                nearestGridY: nearestGridY,
                nearestGridTimeY: nearestGridTimeY
            }, extend);
        }, this);
    },

    /**
     * Mixin method.
     * @param {(TimeCreation|TimeMove)} obj - Constructor functions
     */
    mixin: function(obj) {
        var proto = obj.prototype;
        util.forEach(timeCore, function(method, methodName) {
            if (methodName === 'mixin') {
                return;
            }

            proto[methodName] = method;
        });
    }
};

module.exports = timeCore;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/datetime":28,"../../common/domevent":30,"../../common/point":34}],66:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Handling creation events from drag handler and time grid view
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../../config');
var array = require('../../common/array');
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var TimeCreationGuide = require('./creationGuide');
var timeCore = require('./core');

/**
 * @constructor
 * @implements {Handler}
 * @mixes timeCore
 * @mixes CustomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function TimeCreation(dragHandler, timeGridView, baseController) {
    /**
     * Drag handler instance.
     * @type {Drag}
     */
    this.dragHandler = null;

    /**
     * TimeGrid view instance.
     * @type {TimeGrid}
     */
    this.timeGridView = null;

    /**
     * Base controller instance.
     * @type {Base}
     */
    this.baseController = null;

    /**
     * @type {TimeCreationGuide}
     */
    this.guide = new TimeCreationGuide(this);

    /**
     * Temporary function for single drag session's calc.
     * @type {function}
     */
    this._getEventDataFunc = null;

    /**
     * Temporary function for drag start data cache.
     * @type {object}
     */
    this._dragStart = null;

    if (arguments.length) {
        this.connect.apply(this, arguments);
    }
}

/**
 * Destroy method
 */
TimeCreation.prototype.destroy = function() {
    this.guide.destroy();
    this.dragHandler.off(this);
    this.dragHandler = this.timeGridView = this.baseController =
        this._getEventDataFunc = this._dragStart = this.guide = null;
};

/**
 * Connect handler, view, controllers for event creations.
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
TimeCreation.prototype.connect = function(dragHandler, timeGridView, baseController) {
    this.dragHandler = dragHandler;
    this.timeGridView = timeGridView;
    this.baseController = baseController;

    dragHandler.on({
        dragStart: this._onDragStart
    }, this);
};

/**
 * Check target element is expected condition for activate this plugins.
 * @param {HTMLElement} target - The element to check
 * @returns {(boolean|Time)} - return Time view instance when satiate condition.
 */
TimeCreation.prototype.checkExpectedCondition = function(target) {
    var cssClass = domutil.getClass(target),
        matches;

    if (cssClass === config.classname('time-date-event-block')) {
        target = target.parentNode;
        cssClass = domutil.getClass(target);
    }

    matches = cssClass.match(config.time.getViewIDRegExp);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.timeGridView.childs.items, matches[1]);
};

/**
 * Drag#dragStart event handler.
 * @emits TimeCreation#time_creation_dragstart
 * @param {object} dragStartEventData - Drag#dragStart event data.
 * @param {string} [overrideEventName] - override emitted event name when supplied.
 * @param {function} [revise] - supply function for revise event data before emit.
 */
TimeCreation.prototype._onDragStart = function(dragStartEventData, overrideEventName, revise) {
    var target = dragStartEventData.target,
        result = this.checkExpectedCondition(target),
        getEventDataFunc,
        eventData;

    if (!result) {
        return;
    }

    getEventDataFunc = this._getEventDataFunc = this._retriveEventData(result);
    eventData = this._dragStart = getEventDataFunc(dragStartEventData.originEvent);

    if (revise) {
        revise(eventData);
    }

    this.dragHandler.on({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    /**
     * @event TimeCreation#time_creation_dragstart
     * @type {object}
     * @property {Time} relatedView - time view instance related with mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     */
    this.fire(overrideEventName || 'time_creation_dragstart', eventData);
};

/**
 * Drag#drag event handler
 * @emits TimeCreation#time_creation_drag
 * @param {object} dragEventData - event data from Drag#drag.
 * @param {string} [overrideEventName] - override emitted event name when supplied.
 * @param {function} [revise] - supply function for revise event data before emit.
 */
TimeCreation.prototype._onDrag = function(dragEventData, overrideEventName, revise) {
    var getEventDataFunc = this._getEventDataFunc,
        eventData;

    if (!getEventDataFunc) {
        return;
    }

    eventData = getEventDataFunc(dragEventData.originEvent);

    if (revise) {
        revise(eventData);
    }

    /**
     * @event TimeCreation#time_creation_drag
     * @type {object}
     * @property {Time} relatedView - time view instance related with mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     */
    this.fire(overrideEventName || 'time_creation_drag', eventData);
};

/**
 * @fires TimeCreation#beforeCreateEvent
 * @param {object} eventData - event data object from TimeCreation#time_creation_dragend
 * or TimeCreation#time_creation_click
 */
TimeCreation.prototype._createEvent = function(eventData) {
    var relatedView = eventData.relatedView,
        createRange = eventData.createRange,
        nearestGridTimeY = eventData.nearestGridTimeY,
        baseDate,
        dateStart,
        dateEnd,
        starts,
        ends;

    if (!createRange) {
        createRange = [
            nearestGridTimeY,
            nearestGridTimeY + datetime.millisecondsFrom('minutes', 30)
        ];
    }

    baseDate = new Date(relatedView.getDate());
    dateStart = datetime.start(baseDate);
    dateEnd = datetime.end(baseDate);
    starts = Math.max(dateStart.getTime(), createRange[0]);
    ends = Math.min(dateEnd.getTime(), createRange[1]);

    /**
     * @event TimeCreation#beforeCreateEvent
     * @type {object}
     * @property {boolean} isAllDay - whether event is fired in allday view area?
     * @property {Date} starts - select start time
     * @property {Date] ends - select end time
     */
    this.fire('beforeCreateEvent', {
        isAllDay: false,
        starts: new Date(starts),
        ends: new Date(ends)
    });
};

/**
 * Drag#dragEnd event handler
 * @emits TimeCreation#time_creation_dragend
 * @param {object} dragEndEventData - event data from Drag#dragend
 */
TimeCreation.prototype._onDragEnd = function(dragEndEventData) {
    var dragStart = this._dragStart;

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    function reviseFunc(eventData) {
        var range = [
            dragStart.nearestGridTimeY,
            eventData.nearestGridTimeY
        ].sort(array.compare.num.asc);
        range[1] += datetime.millisecondsFrom('hour', 0.5);

        eventData.createRange = range;

        this._createEvent(eventData);
    }

    /**
     * @event TimeCreation#time_creation_dragend
     * @type {object}
     * @property {Time} relatedView - time view instance related with mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {number[]} createRange - milliseconds range between drag start and end to create.
     */
    this._onDrag(dragEndEventData, 'time_creation_dragend', util.bind(reviseFunc, this));

    this._dragStart = this._getEventDataFunc = null;
};

/**
 * Drag#click event handler
 * @emits TimeCreation#time_creation_click
 * @param {object} clickEventData - event data from Drag#click.
 */
TimeCreation.prototype._onClick = function(clickEventData) {
    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    function reviseFunc(eventData) {
        this._createEvent(eventData);
    }

    /**
     * @event TimeCreation#time_creation_click
     * @type {object}
     * @property {Time} relatedView - time view instance related with mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     */
    this._onDrag(clickEventData, 'time_creation_click', util.bind(reviseFunc, this));

    this._dragStart = this._getEventDataFunc = null;
};

timeCore.mixin(TimeCreation);
util.CustomEvents.mixin(TimeCreation);

module.exports = TimeCreation;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/array":24,"../../common/datetime":28,"../../common/domutil":31,"../../config":36,"./core":65,"./creationGuide":67}],67:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Module for Time.Creation effect while dragging.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var common = require('../../common/common');
var datetime = require('../../common/datetime');
var config = require('../../config');
var domutil = require('../../common/domutil');
var reqAnimFrame = require('../../common/reqAnimFrame');
var ratio = require('../../common/common').ratio;
var MIN30 = (datetime.MILLISECONDS_PER_MINUTES * 30)

/**
 * Class for Time.Creation dragging effect.
 * @constructor
 * @param {TimeCreation} timeCreation - instance of TimeCreation.
 */
function TimeCreationGuide(timeCreation) {
    /**
     * Guide element for creation effect.
     * @type {HTMLElement}
     */
    this.guideElement = global.document.createElement('div');

    /**
     * @type {HTMLDivElement}
     */
    this.guideTimeElement = domutil.appendHTMLElement(
        'span', 
        this.guideElement, 
        config.classname('time-guide-creation-label')
    );

    domutil.addClass(this.guideElement, config.classname('time-guide-creation'));

    /**
     * @type {TimeCreation}
     */
    this.timeCreation = timeCreation;

    /**
     * @type {array}
     */
    this._styleUnit = null;

    /**
     * @type {array}
     */
    this._styleStart = null;

    /**
     * @type {function}
     */
    this._styleFunc = null;

    timeCreation.on({
        'time_creation_dragstart': this._onDragStart,
        'time_creation_drag': this._onDrag,
        'time_creation_click': this.clearGuideElement
    }, this);
}

/**
 * Destroy method.
 */
TimeCreationGuide.prototype.destroy = function() {
    this.clearGuideElement();
    this.timeCreation.off(this);
    this.timeCreation = this._styleUnit = this._styleStart =
        this._styleFunc = this.guideElement = this.guideTimeElement = null;
};

/**
 * Clear guide element.
 */
TimeCreationGuide.prototype.clearGuideElement = function() {
    var guideElement = this.guideElement,
        timeElement = this.guideTimeElement;

    domutil.remove(guideElement);

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.display = 'none';
        guideElement.style.top = '';
        guideElement.style.height = '';
        timeElement.innerHTML = '';
    });
};

/**
 * Refresh guide element
 * @param {number} top - The number of guide element's style top
 * @param {number} height - The number of guide element's style height
 * @param {Date} start - start time of event to create
 * @param {Date} end - end time of event to create
 * @param {boolean} bottomLabel - is label need to render bottom of guide element?
 */
TimeCreationGuide.prototype._refreshGuideElement = function(top, height, start, end, bottomLabel) {
    var guideElement = this.guideElement,
        timeElement = this.guideTimeElement;

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.top = top + 'px';
        guideElement.style.height = height + 'px';
        guideElement.style.display = 'block';

        timeElement.innerHTML = datetime.format(new Date(start), 'HH:mm') + 
            ' ~ ' + datetime.format(new Date(end), 'HH:mm');

        if (!!bottomLabel) {
            domutil.removeClass(timeElement, config.classname('time-guide-bottom'));
        } else {
            domutil.addClass(timeElement, config.classname('time-guide-bottom'));
        }
    });
};

/**
 * Get unit data of calculating new style of guide element by user interaction
 * @param {Time} relatedView - time view instance related with event
 * @returns {array} unit data.
 */
TimeCreationGuide.prototype._getUnitData = function(relatedView) {
    var viewOpt = relatedView.options,
        viewHeight = relatedView.getViewBound().height,
        hourLength = viewOpt.hourEnd - viewOpt.hourStart,
        todayStart = datetime.parse(viewOpt.ymd),
        todayEnd = datetime.end(todayStart);

    todayStart.setHours(0, 0, 0, 0);
    todayStart.setHours(viewOpt.hourStart);

    // [0] height of view
    // [1] hour length of view
    // [2] start time of view
    // [3] end time of view
    // [4] height of view for one hour
    return [viewHeight, hourLength, +todayStart, +todayEnd, viewHeight / hourLength];
};

/**
 * Applying limitation to supplied data and return it.
 * @param {number} top - top pixel of guide element
 * @param {number} height - height pixel of guide element
 * @param {number} start - relative time value of dragstart point
 * @param {number} end - relative time value of dragend point
 * @returns {array} limited style data
 */
TimeCreationGuide.prototype._limitStyleData = function(top, height, start, end) {
    var unitData = this._styleUnit;

    top = common.limit(top, [0], [unitData[0]]);
    height = common.limit(top + height, [0], [unitData[0]]) - top;
    start = common.limit(start, [unitData[2]], [unitData[3]]);
    end = common.limit(end, [unitData[2]], [unitData[3]]);

    return [top, height, start, end];
};

/**
 * Get function to calculate guide element UI data from supplied units
 * @param {number} viewHeight - total height of view's container element
 * @param {number} hourLength - hour length that rendered in time view
 * @param {number} todayStart - time for view's start date
 * @returns {function} UI data calculator function
 */
TimeCreationGuide.prototype._getStyleDataFunc = function(viewHeight, hourLength, todayStart) {
    var todayEnd = +datetime.end(new Date(+todayStart));

    function getStyleData(eventData) {
        var gridY = eventData.nearestGridY,
            gridTimeY = eventData.nearestGridTimeY,
            top, time;

        top = common.limit(ratio(hourLength, viewHeight, gridY), [0], [viewHeight]);
        time = common.limit(gridTimeY, [todayStart], [todayEnd]);

        return [top, time];
    }
        
    return getStyleData;
};

/**
 * DragStart event handler
 * @param {object} dragStartEventData - dragStart event data.
 */
TimeCreationGuide.prototype._onDragStart = function(dragStartEventData) {
    var relatedView = dragStartEventData.relatedView,
        unitData, styleFunc, styleData, result;

    unitData = this._styleUnit = this._getUnitData(relatedView);
    styleFunc = this._styleFunc = this._getStyleDataFunc.apply(this, unitData);
    styleData = this._styleStart = styleFunc(dragStartEventData);

    result = this._limitStyleData(
        styleData[0],
        (unitData[4] / 2),
        styleData[1],
        (styleData[1] + MIN30)
    );

    this._refreshGuideElement.apply(this, result);

    relatedView.container.appendChild(this.guideElement);
};

/**
 * Drag event handler
 * @param {object} dragEventData - drag event data.
 */
TimeCreationGuide.prototype._onDrag = function(dragEventData) {
    var styleFunc = this._styleFunc,
        unitData = this._styleUnit,
        startStyle = this._styleStart,
        heightOfHalfHour,
        endStyle,
        result;

    if (!styleFunc || !unitData || !startStyle) {
        return;
    }

    heightOfHalfHour = (unitData[4] / 2);
    endStyle = styleFunc(dragEventData);

    if (endStyle[0] > startStyle[0]) {
        result = this._limitStyleData(
            startStyle[0],
            (endStyle[0] - startStyle[0]) + heightOfHalfHour,
            startStyle[1],
            (endStyle[1] + MIN30)
        );

        this._refreshGuideElement.apply(this, result);
    } else {
        result = this._limitStyleData(
            endStyle[0],
            (startStyle[0] - endStyle[0]) + heightOfHalfHour,
            endStyle[1],
            (startStyle[1] + MIN30)
        );

        this._refreshGuideElement.apply(this, result.concat([true]));
    }
};

module.exports = TimeCreationGuide;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/datetime":28,"../../common/domutil":31,"../../common/reqAnimFrame":35,"../../config":36}],68:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Handling move events from drag handler and time grid view
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../../config');
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var timeCore = require('./core');
var TimeMoveGuide = require('./moveGuide');

/**
 * @constructor
 * @implements {Handler}
 * @mixes timeCore
 * @mixes util.CustomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function TimeMove(dragHandler, timeGridView, baseController) {
    /**
     * @type {Drag}
     */
    this.dragHandler = null;

    /**
     * @type {TimeGrid}
     */
    this.timeGridView = null;

    /**
     * @type {Base}
     */
    this.baseController = null;

    /**
     * @type {function}
     */
    this._getEventDataFunc = null;

    /**
     * @type {object}
     */
    this._dragStart = null;

    /**
     * @type {TimeMoveGuide}
     */
    this._guide = new TimeMoveGuide(this);

    if (arguments.length) {
        this.connect.apply(this, arguments);
    }
}

/**
 * Destroy method.
 */
TimeMove.prototype.destroy = function() {
    this._guide.destroy();
    this.dragHandler.off(this);
    this.dragHandler = this.timeGridView = this.baseController =
        this._getEventDataFunc = this._dragStart = this._guide = null;
};

/**
 * Connect handler, view, controllers for event creations.
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
TimeMove.prototype.connect = function(dragHandler, timeGridView, baseController) {
    this.dragHandler = dragHandler;
    this.timeGridView = timeGridView;
    this.baseController = baseController;

    dragHandler.on({
        dragStart: this._onDragStart
    }, this);
};

/**
 * Check target element is expected condition for activate this plugins.
 * @param {HTMLElement} target - The element to check
 * @returns {boolean|object} - return object when satiate condition.
 */
TimeMove.prototype.checkExpectCondition = function(target) {
    if (domutil.getClass(target) !== config.classname('time-event')) {
        return false;
    }

    return this._getTimeView(target);
};

/**
 * Get Time view container from supplied element.
 * @param {HTMLElement} target - element to find time view container.
 * @returns {object|boolean} - return time view instance when finded.
 */
TimeMove.prototype._getTimeView = function(target) {
    var container = domutil.closest(target, '.' + config.classname('time-date')),
        matches;

    if (!container) {
        return false;
    }

    matches = domutil.getClass(container).match(config.time.getViewIDRegExp);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.timeGridView.childs.items, +matches[1]);
};

/**
 * @emits TimeMove#time_move_dragstart
 * @param {object} dragStartEventData - Drag#dragStart event data.
 */
TimeMove.prototype._onDragStart = function(dragStartEventData) {
    var target = dragStartEventData.target,
        timeView = this.checkExpectCondition(target),
        blockElement = domutil.closest(target, '.' + config.classname('time-date-event-block')),
        getEventDataFunc,
        eventData;

    if (!timeView || !blockElement) {
        return;
    }

    getEventDataFunc = this._getEventDataFunc = this._retriveEventData(timeView);
    eventData = this._dragStart = getEventDataFunc(
        dragStartEventData.originEvent, {
            targetModelID: domutil.getData(blockElement, 'id')
        }
    );

    this.dragHandler.on({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    /**
     * @event TimeMove#time_move_dragstart
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {string} targetModelID - The model unique id emitted move event.
     */
    this.fire('time_move_dragstart', eventData);
};

/**
 * @emits TimeMove#time_move_drag
 * @param {MouseEvent} dragEventData - mousemove event object
 * @param {string} [overrideEventName] - name of emitting event to override.
 * @param {function} [revise] - supply function for revise event data before emit.
 */
TimeMove.prototype._onDrag = function(dragEventData, overrideEventName, revise) {
    var getEventDataFunc = this._getEventDataFunc,
        timeView = this._getTimeView(dragEventData.target),
        dragStart = this._dragStart,
        eventData;

    if (!timeView || !getEventDataFunc || !dragStart) {
        return;
    }

    eventData = getEventDataFunc(dragEventData.originEvent, {
        currentView: timeView,
        targetModelID: dragStart.targetModelID
    });

    if (revise) {
        revise(eventData);
    }

    /**
     * @event TimeMove#time_move_drag
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with drag start position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {Time} currentView - time view instance related with current mouse position.
     * @property {string} targetModelID - The model unique id emitted move event.
     */
    this.fire(overrideEventName || 'time_move_drag', eventData);
};

/**
 * Update model instance by dragend event results.
 * @fires TimeMove#beforeUpdateEvent
 * @param {object} eventData - event data from TimeMove#time_move_dragend
 */
TimeMove.prototype._updateEvent = function(eventData) {
    var ctrl = this.baseController,
        modelID = eventData.targetModelID,
        range = eventData.nearestRange,
        timeDiff = range[1] - range[0],
        dateDiff = 0,
        model = ctrl.events.items[modelID],
        relatedView = eventData.relatedView,
        currentView = eventData.currentView,
        eventDuration,
        dateStart,
        dateEnd,
        newStarts,
        newEnds,
        baseDate;

    if (!model || !currentView) {
        return;
    }

    timeDiff -= datetime.millisecondsFrom('minutes', 30);
    baseDate = new Date(relatedView.getDate());
    dateStart = datetime.start(baseDate);
    dateEnd = datetime.end(baseDate);
    newStarts = new Date(model.getStarts().getTime() + timeDiff);
    newEnds = new Date(model.getEnds().getTime() + timeDiff);
    eventDuration = model.duration();

    if (currentView) {
        dateDiff = currentView.getDate() - relatedView.getDate();
    }

    if (newStarts < dateStart) {
        newStarts = new Date(dateStart.getTime());
        newEnds = new Date(newStarts.getTime() + eventDuration.getTime());
    } else if (newEnds > dateEnd) {
        newEnds = new Date(dateEnd.getTime());
        newStarts = new Date(newEnds.getTime() - eventDuration.getTime());
    }

    newStarts = new Date(newStarts.getTime() + dateDiff);
    newEnds = new Date(newEnds.getTime() + dateDiff);

    /**
     * @event TimeMove#beforeUpdateEvent
     * @type {object}
     * @property {CalEvent} model - model instance to update
     * @property {date} starts - start time to update
     * @property {date} ends - end time to update
     */
    this.fire('beforeUpdateEvent', {
        model: model,
        starts: newStarts,
        ends: newEnds
    });
};

/**
 * @emits TimeMove#time_move_dragend
 * @param {MouseEvent} dragEndEventData - mouseup mouse event object.
 */
TimeMove.prototype._onDragEnd = function(dragEndEventData) {
    var getEventDataFunc = this._getEventDataFunc,
        currentView = this._getTimeView(dragEndEventData.target),
        dragStart = this._dragStart,
        eventData;

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    if (!getEventDataFunc || !dragStart) {
        return;
    }

    eventData = getEventDataFunc(dragEndEventData.originEvent, {
        currentView: currentView,
        targetModelID: dragStart.targetModelID
    });

    eventData.range = [
        dragStart.timeY,
        eventData.timeY + datetime.millisecondsFrom('hour', 0.5)
    ];

    eventData.nearestRange = [
        dragStart.nearestGridTimeY,
        eventData.nearestGridTimeY + datetime.millisecondsFrom('hour', 0.5)
    ];

    this._updateEvent(eventData);

    /**
     * @event TimeMove#time_move_dragend
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with drag start position.
     * @property {Time} currentView - time view instance related with current mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {string} targetModelID - The model unique id emitted move event.
     * @property {number[]} range - milliseconds range between drag start and end.
     * @property {number[]} nearestRange - milliseconds range related with nearestGridY between start and end.
     */
    this.fire('time_move_dragend', eventData);
};

/**
 * @emits TimeMove#time_move_click
 * @param {MouseEvent} clickEventData - click mouse event object.
 */
TimeMove.prototype._onClick = function(clickEventData) {
    var getEventDataFunc = this._getEventDataFunc,
        dragStart = this._dragStart,
        eventData;

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    if (!getEventDataFunc || !dragStart) {
        return;
    }

    eventData = getEventDataFunc(clickEventData.originEvent, {
        targetModelID: dragStart.targetModelID
    });

    /**
     * @event TimeMove#time_move_click
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with drag start position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {string} targetModelID - The model unique id emitted move event.
     */
    this.fire('time_move_click', eventData);
};

timeCore.mixin(TimeMove);
util.CustomEvents.mixin(TimeMove);

module.exports = TimeMove;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../../config":36,"./core":65,"./moveGuide":69}],69:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Module for Time.Move effect while dragging.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../../config');
var domutil = require('../../common/domutil');
var reqAnimFrame = require('../../common/reqAnimFrame');
var ratio = require('../../common/common').ratio;

/**
 * Class for Time.Move effect.
 * @constructor
 * @param {TimeMove} timeMove - The instance of TimeMove.
 */
function TimeMoveGuide(timeMove) {
    /**
     * @type {HTMLElement}
     */
    this.guideElement = null;

    /**
     * @type {TimeMove}
     */
    this.timeMove = timeMove;

    /**
     * @type {HTMLElement}
     */
    this._container = null;

    /**
     * @type {function}
     */
    this._getTopFunc = null;

    /**
     * @type {number}
     */
    this._startGridY = 0;

    /**
     * @type {number}
     */
    this._startTopPixel = 0;

    timeMove.on({
        'time_move_dragstart': this._onDragStart,
        'time_move_drag': this._onDrag,
        'time_move_dragend': this._clearGuideElement,
        'time_move_click': this._clearGuideElement
    }, this);
}

/**
 * Destroy method
 */
TimeMoveGuide.prototype.destroy = function() {
    this._clearGuideElement();
    this.timeMove.off(this);
    this.guideElement = this.timeMove = this._container =
        this._getTopFunc = this._startGridY = this._startTopPixel = null;
};

/**
 * Clear guide element.
 */
TimeMoveGuide.prototype._clearGuideElement = function() {
    var guideElement = this.guideElement;

    if (!util.browser.msie) {
        domutil.removeClass(global.document.body, config.classname('dragging'));
    }

    domutil.remove(guideElement);

    this.guideElement = this._getTopFunc =
        this._startGridY = this._startTopPixel = null;
};

/**
 * Refresh guide element
 * @param {string} top - guide element's style top.
 */
TimeMoveGuide.prototype._refreshGuideElement = function(top) {
    var guideElement = this.guideElement;

    if (!guideElement) {
        return;
    }

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.top = top + 'px';
        guideElement.style.display = 'block';
    });
};

/**
 * TimeMove#time_move_dragstart event handler
 * @param {object} dragStartEventData - dragstart event data
 */
TimeMoveGuide.prototype._onDragStart = function(dragStartEventData) {
    var guideElement = domutil.closest(
        dragStartEventData.target,
        '.' + config.classname('time-date-event-block')
    );

    if (!guideElement) {
        return;
    }

    guideElement = guideElement.cloneNode(true);
    domutil.addClass(guideElement, config.classname('time-guide-move'));

    this._startTopPixel = parseFloat(guideElement.style.top);
    this._startGridY = dragStartEventData.nearestGridY;
    this.guideElement = guideElement;
    this._container = dragStartEventData.relatedView.container;
    this._container.appendChild(guideElement);
};

/**
 * TimeMove#time_move_drag event handler
 * @param {object} dragEventData - drag event data
 */
TimeMoveGuide.prototype._onDrag = function(dragEventData) {
    var timeView = dragEventData.currentView,
        viewOptions = timeView.options,
        viewHeight = timeView.getViewBound().height,
        guideHeight = parseFloat(this.guideElement.style.height),
        hourLength = viewOptions.hourEnd - viewOptions.hourStart,
        gridYOffset = dragEventData.nearestGridY - this._startGridY,
        gridYOffsetPixel = ratio(hourLength, viewHeight, gridYOffset),
        bottomLimit,
        top;

    if (!util.browser.msie) {
        domutil.addClass(global.document.body, config.classname('dragging'));
    }

    if (this._container !== timeView.container) {
        this._container = timeView.container;
        this._container.appendChild(this.guideElement);
    }

    top = this._startTopPixel + gridYOffsetPixel;
    bottomLimit = viewHeight - guideHeight;

    top = Math.max(top, 0);
    top = Math.min(top, bottomLimit);

    this._refreshGuideElement(top);
};

module.exports = TimeMoveGuide;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/domutil":31,"../../common/reqAnimFrame":35,"../../config":36}],70:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Handling resize events from drag handler and time grid view
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.tui.util;
var config = require('../../config');
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var timeCore = require('./core');
var TimeResizeGuide = require('./resizeGuide');

/**
 * @constructor
 * @implements {Handler}
 * @mixes timeCore
 * @mixes util.CustomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function TimeResize(dragHandler, timeGridView, baseController) {
    /**
     * @type {Drag}
     */
    this.dragHandler = null;

    /**
     * @type {TimeGrid}
     */
    this.timeGridView = null;

    /**
     * @type {Base}
     */
    this.baseController = null;

    /**
     * @type {function}
     */
    this._getEventDataFunc = null;

    /**
     * @type {object}
     */
    this._dragStart = null;

    /**
     * @type {TimeResizeGuide}
     */
    this._guide = new TimeResizeGuide(this);

    if (arguments.length) {
        this.connect.apply(this, arguments);
    }
}

/**
 * Destroy method
 */
TimeResize.prototype.destroy = function() {
    this._guide.destroy();
    this.dragHandler.off(this);
    this.dragHandler = this.timeGridView = this.baseController =
        this._getEventDataFunc = this._dragStart = this._guide = null;
};

/**
 * Connect handler, view, controllers for event creations.
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
TimeResize.prototype.connect = function(dragHandler, timeGridView, baseController) {
    this.dragHandler = dragHandler;
    this.timeGridView = timeGridView;
    this.baseController = baseController;

    dragHandler.on({
        dragStart: this._onDragStart
    }, this);
};

/**
 * @param {HTMLElement} target - element to check condition.
 * @returns {object|boolean} - return time view instance or false
 */
TimeResize.prototype.checkExpectCondition = function(target) {
    var container,
        matches;

    if (!domutil.hasClass(target, config.classname('time-resize-handle'))) {
        return false;
    }

    container = domutil.closest(target, '.' + config.classname('time-date'));

    if (!container) {
        return false;
    }

    matches = domutil.getClass(container).match(config.time.getViewIDRegExp);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.timeGridView.childs.items, +matches[1]);
};

/**
 * @emits TimeResize#time_resize_dragstart
 * @param {object} dragStartEventData - event data of Drag#dragstart
 */
TimeResize.prototype._onDragStart = function(dragStartEventData) {
    var target = dragStartEventData.target,
        timeView = this.checkExpectCondition(target),
        blockElement = domutil.closest(target, '.' + config.classname('time-date-event-block')),
        getEventDataFunc,
        eventData;

    if (!timeView || !blockElement) {
        return;
    }

    getEventDataFunc = this._getEventDataFunc = this._retriveEventData(timeView);
    eventData = this._dragStart = getEventDataFunc(
        dragStartEventData.originEvent, {
            targetModelID: domutil.getData(blockElement, 'id')
        }
    );

    this.dragHandler.on({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    /**
     * @event TimeResize#time_resize_dragstart
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {string} targetModelID - The model unique id emitted move event.
     */
    this.fire('time_resize_dragstart', eventData);
};

/**
 * Drag#drag event handler
 * @emits TimeResize#time_resize_drag
 * @param {object} dragEventData - event data of Drag#drag custom event.
 * @param {string} [overrideEventName] - override emitted event name when supplied.
 * @param {function} [revise] - supply function for revise event data before emit.
 */
TimeResize.prototype._onDrag = function(dragEventData, overrideEventName, revise) {
    var getEventDataFunc = this._getEventDataFunc,
        startEventData = this._dragStart,
        eventData;

    if (!getEventDataFunc || !startEventData) {
        return;
    }

    eventData = getEventDataFunc(dragEventData.originEvent, {
        targetModelID: startEventData.targetModelID
    });

    if (revise) {
        revise(eventData);
    }

    /**
     * @event TimeResize#time_resize_drag
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with drag start position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {string} targetModelID - The model unique id emitted move event.
     */
    this.fire(overrideEventName || 'time_resize_drag', eventData);
};

/**
 * Update model instance by dragend event results.
 * @fires TimeResize#beforeUpdateEvent
 * @param {object} eventData - event data from TimeResize#time_resize_dragend
 */
TimeResize.prototype._updateEvent = function(eventData) {
    var ctrl = this.baseController,
        modelID = eventData.targetModelID,
        range = eventData.nearestRange,
        timeDiff = range[1] - range[0],
        model = ctrl.events.items[modelID],
        relatedView = eventData.relatedView,
        dateEnd,
        newEnds,
        baseDate;

    if (!model) {
        return;
    }

    timeDiff -= datetime.millisecondsFrom('minutes', 30);

    baseDate = new Date(relatedView.getDate());
    dateEnd = datetime.end(baseDate);
    newEnds = new Date(model.getEnds().getTime() + timeDiff);

    if (newEnds > dateEnd) {
        newEnds = new Date(dateEnd.getTime());
    }

    if (newEnds.getTime() - model.getStarts().getTime() < datetime.millisecondsFrom('minutes', 30)) {
        newEnds = new Date(model.getStarts().getTime() + datetime.millisecondsFrom('minutes', 30));
    }

    /**
     * @event TimeResize#beforeUpdateEvent
     * @type {object}
     * @property {CalEvent} model - model instance to update
     * @property {date} starts - start time to update
     * @property {date} ends - end time to update
     */
    this.fire('beforeUpdateEvent', {
        model: model,
        starts: model.getStarts(),
        ends: newEnds
    });
};

/**
 * Drag#dragEnd event handler
 * @emits TimeResize#time_resize_dragend
 * @param {MouseEvent} dragEndEventData - Mouse event of Drag#dragEnd custom event.
 */
TimeResize.prototype._onDragEnd = function(dragEndEventData) {
    var getEventDataFunc = this._getEventDataFunc,
        dragStart = this._dragStart,
        eventData;

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    if (!getEventDataFunc || !dragStart) {
        return;
    }

    eventData = getEventDataFunc(dragEndEventData.originEvent, {
        targetModelID: dragStart.targetModelID
    });

    eventData.range = [
        dragStart.timeY,
        eventData.timeY + datetime.millisecondsFrom('hour', 0.5)
    ];

    eventData.nearestRange = [
        dragStart.nearestGridTimeY,
        eventData.nearestGridTimeY + datetime.millisecondsFrom('hour', 0.5)
    ];

    this._updateEvent(eventData);

    /**
     * @event TimeResize#time_resize_dragend
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with drag start position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {string} targetModelID - The model unique id emitted move event.
     * @property {number[]} range - milliseconds range between drag start and end.
     * @property {number[]} nearestRange - milliseconds range related with nearestGridY between start and end.
     */
    this.fire('time_resize_dragend', eventData);

    this._getEventDataFunc = this._dragStart = null;
};

/**
 * @emits TimeResize#time_resize_click
 */
TimeResize.prototype._onClick = function() {
    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    /**
     * @event TimeResize#time_resize_click
     */
    this.fire('time_resize_click');
};

timeCore.mixin(TimeResize);
util.CustomEvents.mixin(TimeResize);

module.exports = TimeResize;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../../config":36,"./core":65,"./resizeGuide":71}],71:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Module for Time.Resize effect while dragging.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.tui.util;
var config = require('../../config');
var domutil = require('../../common/domutil');
var reqAnimFrame = require('../../common/reqAnimFrame');
var ratio = require('../../common/common').ratio;

/**
 * Class for Time.Resize effect.
 * @constructor
 * @param {TimeResize} timeResize - the instance of TimeResize handler.
 */
function TimeResizeGuide(timeResize) {
    /**
     * @type {HTMLElement}
     */
    this.guideElement = null;

    /**
     * @type {TimeResize}
     */
    this.timeResize = timeResize;

    /**
     * @type {function}
     */
    this._getTopFunc = null;

    /**
     * @type {HTMLElement}
     */
    this._originEventElement = null;

    /**
     * @type {number}
     */
    this._startTopPixel = 0;

    /**
     * @type {number}
     */
    this._startHeightPixel = 0;

    /**
     * @type {number}
     */
    this._startGridY = 0;

    timeResize.on({
        'time_resize_dragstart': this._onDragStart,
        'time_resize_drag': this._onDrag,
        'time_resize_dragend': this._clearGuideElement,
        'time_resize_click': this._clearGuideElement
    }, this);
}

/**
 * Destroy method
 */
TimeResizeGuide.prototype.destroy = function() {
    this._clearGuideElement();
    this.timeResize.off(this);
    this.guideElement = this.timeResize = this._getTopFunc =
        this._originEventElement = this._startHeightPixel =
        this._startGridY = this._startTopPixel = null;
};

/**
 * Clear guide element.
 */
TimeResizeGuide.prototype._clearGuideElement = function() {
    var guideElement = this.guideElement,
        originElement = this._originEventElement;

    if (!util.browser.msie) {
        domutil.removeClass(global.document.body, config.classname('resizing'));
    }

    if (originElement) {
        originElement.style.display = 'block';
    }

    domutil.remove(guideElement);

    this.guideElement = this._getTopFunc = this._originEventElement =
        this._startHeightPixel = this._startGridY = this._startTopPixel = null;
};

/**
 * Refresh guide element
 * @param {string} height - guide element's style height.
 */
TimeResizeGuide.prototype._refreshGuideElement = function(height) {
    var guideElement = this.guideElement;

    if (!guideElement) {
        return;
    }

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.height = height + 'px';
        guideElement.style.display = 'block';
    });
};


/**
 * TimeMove#time_move_dragstart event handler
 * @param {object} dragStartEventData - dragstart event data
 */
TimeResizeGuide.prototype._onDragStart = function(dragStartEventData) {
    var originElement = domutil.closest(
            dragStartEventData.target,
            '.' + config.classname('time-date-event-block')
        ),
        guideElement;

    if (!util.browser.msie) {
        domutil.addClass(global.document.body, config.classname('resizing'));
    }

    if (!originElement) {
        return;
    }

    this._startGridY = dragStartEventData.nearestGridY;
    this._startHeightPixel = parseFloat(originElement.style.height);
    this._startTopPixel = parseFloat(originElement.style.top);

    this._originEventElement = originElement;
    guideElement = this.guideElement = originElement.cloneNode(true);
    domutil.addClass(guideElement, config.classname('time-guide-resize'));

    originElement.style.display = 'none';
    dragStartEventData.relatedView.container.appendChild(guideElement);
};

/**
 * @param {object} dragEventData - event data from Drag#drag.
 */
TimeResizeGuide.prototype._onDrag = function(dragEventData) {
    var timeView = dragEventData.relatedView,
        viewOptions = timeView.options,
        viewHeight = timeView.getViewBound().height,
        hourLength = viewOptions.hourEnd - viewOptions.hourStart,
        guideElement = this.guideElement,
        guideTop = parseFloat(guideElement.style.top),
        gridYOffset = dragEventData.nearestGridY - this._startGridY,
        // hourLength : viewHeight = gridYOffset : X;
        gridYOffsetPixel = ratio(hourLength, viewHeight, gridYOffset),
        minHeight,
        maxHeight,
        height;

    height = (this._startHeightPixel + gridYOffsetPixel);
    // at least large than 30min from event start time.
    minHeight = guideTop + ratio(hourLength, viewHeight, 0.5);
    minHeight -= this._startTopPixel;
    // smaller than 24h
    maxHeight = viewHeight - guideTop;

    height = Math.max(height, minHeight);
    height = Math.min(height, maxHeight);

    this._refreshGuideElement(height);
};

module.exports = TimeResizeGuide;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/domutil":31,"../../common/reqAnimFrame":35,"../../config":36}],72:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Model of event.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var datetime = require('../common/datetime');
var dirty = require('../common/dirty');
var model = require('../common/model');

/**
 * The model of calendar events.
 * @constructor
 * @mixes dirty
 * @mixes model
 */
function CalEvent() {
    /**
     * `Optional` unique id for various use.
     * @type {string}
     */
    this.id = '';

    /**
     * title for event.
     * @type {string}
     */
    this.title = '';

    /**
     * is event is all day event?
     * @type {boolean}
     */
    this.isAllDay = false;

    /**
     * event starts
     * @type {Date}
     */
    this.starts = null;

    /**
     * event ends
     * @type {Date}
     */
    this.ends = null;

    /**
     * event text color
     * @type {string}
     */
    this.color = '#000';

    /**
     * event background color
     * @type {string}
     */
    this.bgColor = '#a1b56c';

    // initialize model id
    util.stamp(this);
}

/**********
 * static props
 **********/

CalEvent.schema = {
    required: ['title'],
    dateRange: ['starts', 'ends']
};

/**
 * create event model from json(object) data.
 * @param {object} data object for model.
 * @returns {CalEvent} CalEvent model instance.
 */
CalEvent.create = function(data) {
    var inst = new CalEvent();
    inst.init(data);

    return inst;
};

/**********
 * prototype props
 **********/

/**
 * Initialize event instance.
 * @param {object} options options.
 */
CalEvent.prototype.init = function(options) {
    options = options || {};

    this.id = options.id || '';
    this.title = options.title || '';
    this.isAllDay = util.isExisty(options.isAllDay) ? options.isAllDay : false;

    if (options.starts) {
        this.starts = new Date(options.starts);
    } else {
        this.starts = new Date();
    }

    if (options.ends) {
        this.ends = new Date(options.ends);
    } else {
        this.ends = new Date(this.starts.getTime());
        this.ends.setMinutes(this.ends.getMinutes() + 30);
    }

    this.color = options.color || this.color;
    this.bgColor = options.bgColor || this.bgColor;
};

/**
 * @returns {Date} render start date.
 */
CalEvent.prototype.getStarts = function() {
    return this.starts;
};

/**
 * @returns {Date} render end date.
 */
CalEvent.prototype.getEnds = function() {
    return this.ends;
};

/**
 * @returns {number} instance unique id.
 */
CalEvent.prototype.cid = function() {
    return util.stamp(this);
};

/**
 * Check two event are equals (means title, isAllDay, starts, ends are same)
 * @param {CalEvent} event CalEvent model instance to compare.
 * @returns {boolean} Return false when not same.
 */
CalEvent.prototype.equals = function(event) {
    if (this.id !== event.id) {
        return false;
    }

    if (this.title !== event.title) {
        return false;
    }

    if (this.isAllDay !== event.isAllDay) {
        return false;
    }

    if (datetime.compare(this.getStarts(), event.getStarts()) !== 0) {
        return false;
    }

    if (datetime.compare(this.getEnds(), event.getEnds()) !== 0) {
        return false;
    }

    if (this.color !== event.color) {
        return false;
    }

    if (this.bgColor !== event.bgColor) {
        return false;
    }

    return true;
};

/**
 * return duration between starts and ends.
 * @returns {Date} duration (UTC)
 */
CalEvent.prototype.duration = function() {
    var starts = this.getStarts(),
        ends = this.getEnds(),
        duration;

    if (this.isAllDay) {
        duration = new Date(datetime.end(ends) - datetime.start(starts));
    } else {
        duration = new Date(ends - starts);
    }

    return duration;
};

/**
 * Returns true if the given CalEvent coincides with the same time as the
 * calling CalEvent.
 * @param {CalEvent} event The other event to compare with this CalEvent.
 * @returns {boolean} If the other event occurs within the same time as the first object.
 */
CalEvent.prototype.collidesWith = function(event) {
    var ownStarts = this.getStarts(),
        ownEnds = this.getEnds(),
        starts = event.getStarts(),
        ends = event.getEnds();

    if ((starts > ownStarts && starts < ownEnds) ||
        (ends > ownStarts && ends < ownEnds) ||
        (starts <= ownStarts && ends >= ownEnds)) {
        return true;
    }
    return false;
};

model.mixin(CalEvent.prototype);
dirty.mixin(CalEvent.prototype);

module.exports = CalEvent;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/datetime":28,"../common/dirty":29,"../common/model":33}],73:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Model for views
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;

/**
 * CalEvent ViewModel
 * @constructor
 * @param {CalEvent} event CalEvent instance.
 */
function CalEventViewModel(event) {
    /**
     * The model of event.
     * @type {CalEvent}
     */
    this.model = event;

    /**
     * @type {number}
     */
    this.top = 0;

    /**
     * @type {number}
     */
    this.left = 0;

    /**
     * @type {number}
     */
    this.width = 0;

    /**
     * @type {number}
     */
    this.height = 0;

    /**
     * Represent event has collide with other events when rendering.
     * @type {boolean}
     */
    this.hasCollide = false;

    /**
     * Extra space at rigth side of this event.
     * @type {number}
     */
    this.extraSpace = 0;

    /**
     * represent this event block is not visible after rendered.
     *
     * in month view, some viewmodel in date need to hide when already rendered before dates.
     *
     * set true then it just shows empty space.
     * @type {boolean}
     */
    this.hidden = false;

    /**
     * represent render start date used at rendering.
     *
     * if set null then use model's 'starts' property.
     * @type {Date}
     */
    this.renderStarts = null;

    /**
     * represent render end date used at rendering.
     *
     * if set null then use model's 'ends' property.
     * @type {Date}
     */
    this.renderEnds = null;
}

/**********
 * static props
 **********/

/**
 * CalEventViewModel factory method.
 * @param {CalEvent} event CalEvent instance.
 * @returns {CalEventViewModel} CalEventViewModel instance.
 */
CalEventViewModel.create = function(event) {
    return new CalEventViewModel(event);
};


/**********
 * prototype props
 **********/

/**
 * return renderStarts property to render properly when specific event that exceed rendering date range.
 *
 * if renderStarts is not set. return model's starts property.
 * @override
 * @returns {Date} render start date.
 */
CalEventViewModel.prototype.getStarts = function() {
    if (this.renderStarts) {
        return this.renderStarts;
    }

    return this.model.starts;
};

/**
 * return renderStarts property to render properly when specific event that exceed rendering date range.
 *
 * if renderEnds is not set. return model's ends property.
 * @override
 * @returns {Date} render end date.
 */
CalEventViewModel.prototype.getEnds = function() {
    if (this.renderEnds) {
        return this.renderEnds;
    }

    return this.model.ends;
};

/**
 * @returns {number} unique number for model.
 */
CalEventViewModel.prototype.cid = function() {
    return util.stamp(this.model);
};

/**
 * Shadowing valueOf method for event sorting.
 * @returns {CalEvent} The model of event.
 */
CalEventViewModel.prototype.valueOf = function() {
    return this.model;
};

/**
 * Link duration method
 * @returns {number} CalEvent#duration result.
 */
CalEventViewModel.prototype.duration = function() {
    return this.model.duration();
};

/**
 * Link collidesWith method
 * @param {CalEvent|CalEventViewModel} viewModel - Model or viewmodel instance of CalEvents.
 * @returns {boolean} CalEvent#collidesWith result.
 */
CalEventViewModel.prototype.collidesWith = function(viewModel) {
    return this.model.collidesWith(viewModel.valueOf());
};

module.exports = CalEventViewModel;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],74:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Layout view. wrap all view containers at outside.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../config');
var domutil = require('../common/domutil');
var Collection = require('../common/collection');
var View = require('./view');

/**
 * Layout view for toggle each child view. It will controlled via navigation UI.
 * @constructor
 * @extends {View}
 * @param {HTMLElement} container Container element to use layout view.
 */
function Layout(container) {
    container = domutil.appendHTMLElement('div', container, config.classname('layout'));

    /**
     * @type {HTMLElement}
     */
    this.container = container;

    /*eslint-disable*/
    /**
     * @type {Collection} Child view collection.
     */
    this.childs = new Collection(function(childView) {
        return childView.viewName;
    });
    /*eslint-enable*/
}

util.inherit(Layout, View);

/**
 * Clear child views.
 */
Layout.prototype.clear = function() {
    this.childs.each(function(childView) {
        childView.destroy();
    });

    this.childs.clear();
    this.container.innerHTML = '';
};

/**
 * Remove child view.
 * @override
 * @param {(string|View)} viewName - name of view or instance.
 */
Layout.prototype.removeChild = function(viewName) {
    this.childs.remove(viewName);
};

/**
 * Toggle child views.
 * @param {string} viewName - Name of view.
 */
Layout.prototype.toggleChildView = function(viewName) {
    var container,
        prefix = ['add', 'remove'],
        flag;

    this.childs.each(function(childView) {
        container = childView.container;
        flag = +(childView.viewName === viewName);
        domutil[prefix[flag] + 'Class'](container, config.classname('hidden'));
    });
};

module.exports = Layout;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/collection":26,"../common/domutil":31,"../config":36,"./view":84}],75:[function(require,module,exports){
(function (global){
/**
 * @fileoverview View of week event container inside of Week view.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../config');
var domutil = require('../common/domutil');
var datetime = require('../common/datetime');
var View = require('./view');
var tmpl = require('./template/monthweek.hbs');

/**
 * @constructor
 * @extends {View}
 * @param {object} options - view options.
 * @param {number} [options.containerHeight=40] - minimum height of event container element.
 * @param {number} [options.containerButtonGutter=8] - free space at bottom to make create easy.
 * @param {number} [options.eventHeight=18] - height of each event block.
 * @param {number} [options.eventGutter=2] - gutter height of each event block.
 * @param {function} [options._getViewModelFunc] - function for extract partial view model data from whole view models.
 * @param {HTMLDIVElement} container - DOM element to use container for this view.
 */
function MonthWeek(options, container) {
    container = domutil.appendHTMLElement(
        'div',
        container,
        config.classname('allday-monthweek')
    );

    /**
     * @type {object}
     */
    options = this.options = util.extend({
        containerHeight: 40,
        containerBottomGutter: 8,
        eventHeight: 18,
        eventGutter: 2
    }, options);

    options.minHeight = options.containerHeight + options.containerBottomGutter;

    View.call(this, container);
}

util.inherit(MonthWeek, View);

/**
 * @param {object} viewModel - viewModel from parent views.
 * @returns {object} viewModel to rendering.
 */
MonthWeek.prototype._getBaseViewModel = function(viewModel) {
    var options = this.options,
        range = datetime.range(
            viewModel.renderStartDate,
            viewModel.renderEndDate,
            datetime.MILLISECONDS_PER_DAY
        ),
        matrices = options._getViewModelFunc(viewModel),
        widthPercent = 100 / range.length;

    return {
        width: widthPercent,
        height: options.containerHeight,
        eventBlockHeight: options.eventHeight + options.eventGutter,
        eventBlockGutter: options.eventGutter,
        eventHeight: options.eventHeight,
        eventGrid: util.map(range, function() {
            return widthPercent;
        }),
        matrices: matrices
    };
};

/**
 * @override
 * @param {object} viewModel - viewModel from parent views.
 */
MonthWeek.prototype.render = function(viewModel) {
    var baseViewModel = this._getBaseViewModel(viewModel),
        maxEventInDay = 0;

    maxEventInDay = Math.max.apply(null, util.map(baseViewModel.matrices, function(matrix) {
        return Math.max.apply(null, util.map(matrix, function(row) {
            return row.length;
        }));
    }));

    this.resize(maxEventInDay);

    this.container.innerHTML = tmpl(baseViewModel);
};

/**
 * Resize MonthWeek container and send information to parent views.
 * @override
 * @param {number} maxEventInDay - how largest event block in one day?
 */
MonthWeek.prototype.resize = function(maxEventInDay) {
    var options = this.options,
        newHeight = (maxEventInDay * (options.eventHeight + options.eventGutter)) + options.containerBottomGutter;

    newHeight = Math.max(newHeight, options.minHeight);
    
    this.container.style.height = newHeight + 'px';
};

module.exports = MonthWeek;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/datetime":28,"../common/domutil":31,"../config":36,"./template/monthweek.hbs":78,"./view":84}],76:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "scroll-y "
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "dayname-layout\"></div>\n<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "scroll-y "
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "allday-layout\"></div>\n<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "timegrid-layout\"></div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],77:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Helpers for handlebar templates.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var common = require('../../common/common');
var config = require('../../config');

function getElSize(value, postfix, prefix) {
    prefix = prefix || '';
    if (util.isNumber(value)) {
        return prefix + ':' + value + postfix;
    }

    return prefix + ':auto';
}

module.exports = {
    'stamp': function(obj) {
        return util.stamp(obj);
    },

    'equal': function(a, b) {
        return a === b;
    },

    'or': function(a, b) {
        return a || b;
    },

    'fi': function(a, oper, b, options) {
        switch (oper) {
            case '==':
                return (a == b) ? options.fn(this) : options.inverse(this);
            case '===':
                return  (a === b) ? options.fn(this) : options.inverse(this);
            default:
                break;
        }
    },

    'common-width': function(width) {
        return getElSize(width, '%', 'width');
    },

    /**
     * Use in time.hbs
     * @param {CalEventViewModel} eventViewModel viewModel
     * @returns {string} element size css class
     */
    'time-eventBlock': function(eventViewModel) {
        var top = getElSize(eventViewModel.top, 'px', 'top'),
            left = getElSize(eventViewModel.left, '%', 'left'),
            width = getElSize(eventViewModel.width, '%', 'width'),
            height = getElSize(eventViewModel.height, 'px', 'height');

        return [top, left, width, height].join(';');
    },

    /**
     * Use in dayname.hbs
     * @returns {string} css class
     */
    'dayname-isHolliday': function() {
        if (this.day === 0 || this.day === 6) {
            return config.classname('dayname') + ' ' + config.classname('holliday');
        }

        return config.classname('dayname');
    },

    'multiply': function(a, b) {
        return a * b;
    },

    'CSS_PREFIX': function() {
        return config.cssPrefix;
    },


    /**********
     * Default event template
     **********/

    'milestone-tmpl': function(model) {
        return '<span class="' + config.classname('dot') + '" style="background-color:' + model.bgColor + '"></span> ' + common.stripTags(model.title);
    },

    'task-tmpl': function(model) {
        return '<span class="' + config.classname('dot') + '" style="background-color:' + model.bgColor + '"></span> ' + common.stripTags(model.title);
    },

    'allday-tmpl': function(model) {
        return common.stripTags(model.title);
    },

    'time-tmpl': function(model) {
        return common.stripTags(model.title);
    }
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../config":36}],78:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3=container.escapeExpression;

  return "<div class=\""
    + alias3(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === "function" ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "monthweek-grid-line\" style=\"width:"
    + alias3(container.lambda(depth0, depth0))
    + "%;left:"
    + alias3((helpers.multiply || (depth0 && depth0.multiply) || alias2).call(alias1,depth0,(data && data.index),{"name":"multiply","hash":{},"data":data}))
    + "%;\">&nbsp;</div>\n";
},"3":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},depth0,{"name":"each","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"4":function(container,depth0,helpers,partials,data) {
    var stack1;

  return " \n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},depth0,{"name":"each","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"5":function(container,depth0,helpers,partials,data) {
    var stack1;

  return " \n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},depth0,{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"6":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3=container.escapeExpression, alias4="function", alias5=container.lambda;

  return " \n<div data-id=\""
    + alias3((helpers.stamp || (depth0 && depth0.stamp) || alias2).call(alias1,(depth0 != null ? depth0.model : depth0),{"name":"stamp","hash":{},"data":data}))
    + "\" \n    class=\""
    + alias3(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "allday-event-block "
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.renderStarts : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.renderEnds : depth0),{"name":"if","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\"\n    style=\"top:"
    + alias3((helpers.multiply || (depth0 && depth0.multiply) || alias2).call(alias1,(depth0 != null ? depth0.top : depth0),((stack1 = (data && data.root)) && stack1.eventBlockHeight),{"name":"multiply","hash":{},"data":data}))
    + "px;left:"
    + alias3((helpers.multiply || (depth0 && depth0.multiply) || alias2).call(alias1,(depth0 != null ? depth0.left : depth0),((stack1 = (data && data.root)) && stack1.width),{"name":"multiply","hash":{},"data":data}))
    + "%;width:"
    + alias3((helpers.multiply || (depth0 && depth0.multiply) || alias2).call(alias1,(depth0 != null ? depth0.width : depth0),((stack1 = (data && data.root)) && stack1.width),{"name":"multiply","hash":{},"data":data}))
    + "%;height:"
    + alias3(alias5(((stack1 = (data && data.root)) && stack1.eventBlockHeight), depth0))
    + "px;margin-top:"
    + alias3(alias5(((stack1 = (data && data.root)) && stack1.eventBlockGutter), depth0))
    + "px\">\n    <div class=\""
    + alias3(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "allday-event\" style=\"height:"
    + alias3(alias5(((stack1 = (data && data.root)) && stack1.eventHeight), depth0))
    + "px;color:"
    + alias3(alias5(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.color : stack1), depth0))
    + ";background-color:"
    + alias3(alias5(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.bgColor : stack1), depth0))
    + "\">\n        <span class=\""
    + alias3(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "allday-event-title\">"
    + ((stack1 = (helpers["allday-tmpl"] || (depth0 && depth0["allday-tmpl"]) || alias2).call(alias1,(depth0 != null ? depth0.model : depth0),{"name":"allday-tmpl","hash":{},"data":data})) != null ? stack1 : "")
    + "</span>\n        <span class=\""
    + alias3(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "allday-resize-handle handle-y\">&nbsp;</span>\n    </div> \n</div>\n";
},"7":function(container,depth0,helpers,partials,data) {
    var helper;

  return " "
    + container.escapeExpression(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "allday-exceed-left";
},"9":function(container,depth0,helpers,partials,data) {
    var helper;

  return " "
    + container.escapeExpression(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "allday-exceed-right";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "monthweek-grid\">\n"
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.eventGrid : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</div>\n<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "monthweek-events\">\n"
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.matrices : depth0),{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],79:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Register developed custom handlebars helper.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var helper = require('./helper');
var Handlebars = require('hbsfy/runtime');

util.forEach(helper, function(helper, name) {
    Handlebars.registerHelper(name, helper);
}, this);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./helper":77,"hbsfy/runtime":22}],80:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "allday-left\">\n    <span>"
    + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
    + "</span>\n</div>\n<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "allday-right\">\n    <div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "allday-monthweek-container\"></div>\n</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],81:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<div class=\""
    + alias4(((helper = (helper = helpers["dayname-isHolliday"] || (depth0 != null ? depth0["dayname-isHolliday"] : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"dayname-isHolliday","hash":{},"data":data}) : helper)))
    + "\" style=\""
    + alias4((helpers["common-width"] || (depth0 && depth0["common-width"]) || alias2).call(alias1,(depth0 != null ? depth0.width : depth0),{"name":"common-width","hash":{},"data":data}))
    + "\">\n    <div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "dayname-label\">"
    + alias4(((helper = (helper = helpers.dayName || (depth0 != null ? depth0.dayName : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"dayName","hash":{},"data":data}) : helper)))
    + "</div>\n    <div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "dayname-date\">"
    + alias4(((helper = (helper = helpers.date || (depth0 != null ? depth0.date : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"date","hash":{},"data":data}) : helper)))
    + "</div>\n</div>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},depth0,{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"useData":true});

},{"hbsfy/runtime":22}],82:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},depth0,{"name":"each","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"2":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},depth0,{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"3":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},depth0,{"name":"if","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"4":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression, alias5=container.lambda;

  return "<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "time-date-event-block\" data-id=\""
    + alias4((helpers.stamp || (depth0 && depth0.stamp) || alias2).call(alias1,(depth0 != null ? depth0.model : depth0),{"name":"stamp","hash":{},"data":data}))
    + "\" style=\""
    + alias4((helpers["time-eventBlock"] || (depth0 && depth0["time-eventBlock"]) || alias2).call(alias1,depth0,{"name":"time-eventBlock","hash":{},"data":data}))
    + "\">\n            <div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "time-event\" style=\"color:"
    + alias4(alias5(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.color : stack1), depth0))
    + ";background-color:"
    + alias4(alias5(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.bgColor : stack1), depth0))
    + "\">"
    + ((stack1 = (helpers["time-tmpl"] || (depth0 && depth0["time-tmpl"]) || alias2).call(alias1,(depth0 != null ? depth0.model : depth0),{"name":"time-tmpl","hash":{},"data":data})) != null ? stack1 : "")
    + "</div>\n            <div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "time-resize-handle handle-x\">&nbsp;</div>\n        </div>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.matrices : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"useData":true});

},{"hbsfy/runtime":22}],83:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<li class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "timegrid-hour-"
    + alias4(((helper = (helper = helpers.hour || (depth0 != null ? depth0.hour : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"hour","hash":{},"data":data}) : helper)))
    + "\"><span>"
    + alias4(((helper = (helper = helpers.hour || (depth0 != null ? depth0.hour : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"hour","hash":{},"data":data}) : helper)))
    + "</span></li>";
},"3":function(container,depth0,helpers,partials,data) {
    var helper;

  return "<div class=\""
    + container.escapeExpression(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "timegrid-grid\"></div>";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "timegrid\">\n    <ul class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "timegrid-left\">\n        "
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.hours : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n    </ul>\n    <div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "timegrid-right\">\n        "
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.hours : depth0),{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n    </div>\n    <div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "timegrid-events\">\n        <div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "timegrid-events-container\"></div>\n    </div>\n    <div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "timegrid-hourmarker\" style=\"display:none;\">\n        <div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "timegrid-hourmarker-wrap\">\n            <div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "timegrid-hourmarker-line\"></div>\n            <div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "timegrid-hourmarker-time\">00:00</div>\n            <div class=\""
    + alias4(((helper = (helper = helpers.CSS_PREFIX || (depth0 != null ? depth0.CSS_PREFIX : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"CSS_PREFIX","hash":{},"data":data}) : helper)))
    + "timegrid-todaymarker\">today</div>\n        </div>\n    </div>\n</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],84:[function(require,module,exports){
(function (global){
/**
 * @fileoverview The base class of views.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var domutil = require('../common/domutil');
var Collection = require('../common/collection');

/**
 * Base class of views.
 *
 * All views create own container element inside supplied container element.
 * @constructor
 * @param {HTMLElement} container Default container element for view. you can use this element for this.container syntax.
 */
function View(container) {
    var id = util.stamp(this);

    if (util.isUndefined(container)) {
        container = domutil.appendHTMLElement('div');
    }

    domutil.addClass(container, this.cssprefix(id));

    /**
     * unique id
     * @type {number}
     */
    this.id = id;

    /**
     * base element of view.
     * @type {HTMLDIVElement}
     */
    this.container = container;

    /*eslint-disable*/
    /**
     * child views.
     * @type {Collection}
     */
    this.childs = new Collection(function(view) {
        return util.stamp(view);
    });
    /*eslint-enable*/

    /**
     * parent view instance.
     * @type {View}
     */
    this.parent = null;
}

/**
 * CSS classname prefix
 * @type {string}
 */
View.prototype.cssPrefix = 'tui-view-';

/**
 * Add child views.
 * @param {View} view The view instance to add.
 * @param {function} [fn] Function for invoke before add. parent view class is supplied first arguments.
 */
View.prototype.addChild = function(view, fn) {
    if (fn) {
        fn.call(view, this);
    }
    // add parent view
    view.parent = this;

    this.childs.add(view);
};

/**
 * Remove added child view.
 * @param {(number|View)} id View id or instance itself to remove.
 * @param {function} [fn] Function for invoke before remove. parent view class is supplied first arguments.
 */
View.prototype.removeChild = function(id, fn) {
    var view = util.isNumber(id) ? this.childs.items[id] : id;

    id = util.stamp(view);

    if (fn) {
        fn.call(view, this);
    }

    this.childs.remove(id);
};

/**
 * Render view recursively.
 */
View.prototype.render = function() {
    this.childs.each(function(childView) {
        childView.render();
    });
};

/**
 * Invoke function recursively.
 * @param {function} fn - function to invoke child view recursively
 * @param {boolean} [skipThis=false] - set true then skip invoke with this(root) view.
 */
View.prototype.recursive = function(fn, skipThis) {
    if (!util.isFunction(fn)) {
        return;
    }

    if (!skipThis) {
        fn(this);
    }

    this.childs.each(function(childView) {
        childView.recursive(fn);
    });
};

/**
 * Resize view recursively to parent.
 */
View.prototype.resize = function() {
    var args = Array.prototype.slice.call(arguments),
        parent = this.parent;

    while (parent) {
        if (util.isFunction(parent._onResize)) {
            parent._onResize.apply(parent, args);
        }

        parent = parent.parent;
    }
};

/**
 * Invoking method before destroying.
 */
View.prototype._beforeDestroy = function() {};

/**
 * Clear properties
 */
View.prototype._destroy = function() {
    this._beforeDestroy();
    this.childs.clear();
    this.container.innerHTML = '';

    this.id = this.parent = this.childs = this.container = null;
};

/*eslint-disable*/
/**
 * Destroy child view recursively.
 */
View.prototype.destroy = function(isChildView) {
    this.childs.each(function(childView) {
        childView.destroy(true);
        childView._destroy();
    });

    if (isChildView) {
        return;
    }

    this._destroy();
};
/*eslint-enable*/

/**
 * Calculate view's container element bound.
 * @returns {object} The bound of container element.
 */
View.prototype.getViewBound = function() {
    var container = this.container,
        position = domutil.getPosition(container),
        size = domutil.getSize(container);

    return {
        x: position[0],
        y: position[1],
        width: size[0],
        height: size[1]
    };
};


/**
 * Return view default CSS prefix
 * @param {string} [className] - if supplied then return prefix added class name
 * @returns {string} CSS prefix value
 */
View.prototype.cssprefix = function(className) {
    return this.cssPrefix + (className || '');
};

module.exports = View;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/collection":26,"../common/domutil":31}],85:[function(require,module,exports){
(function (global){
/**
 * @fileoverview View of allday event container inside of Week view.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../../config');
var domutil = require('../../common/domutil');
var View = require('../view');
var MonthWeek = require('../monthweek');
var mainTmpl = require('../template/week/allday.hbs');

/**
 * @constructor
 * @extends {View}
 * @param {object} options The object for view customization.
 * @param {string} options.renderStartDate - start date of allday view's render date. YYYY-MM-DD
 * @param {string} options.renderEndDate - end date of allday view's render date. YYYY-MM-DD
 * @param {number} [options.height=60] - minimum height of event container element.
 * @param {number} [options.eventBlockHeight=18] - height of each event block.
 * @param {number} [options.eventBlockGutter=2] - gutter height of each event block.
 * @param {function} [options._getViewModelFunc] - function for extract partial view model data from whole view models.
 * @param {HTMLElement} container Container element.
 */
function Allday(options, container) {
    container = domutil.appendHTMLElement(
        'div',
        container,
        config.classname('allday-container')
    );

    /**
     * rendering options.
     * @type {object}
     */
    this.options = util.extend({
        title: '종일일정',
        renderStartDate: '',
        renderEndDate: '',
        containerHeight: 40,
        containerBottomGutter: 8,
        eventHeight: 18,
        eventGutter: 2,
        _getViewModelFunc: function(viewModel) {
            return viewModel.eventsInDateRange.allday;
        }
    }, options);

    View.call(this, container);
}

util.inherit(Allday, View);

/**
 * create month week view model for render allday events in top of week views.
 * @override
 * @param {object} viewModel - viewModel from parent views.
 */
Allday.prototype.render = function(viewModel) {
    var container = this.container,
        monthWeekInst;

    container.innerHTML = mainTmpl(this.options);

    this.childs.clear();

    monthWeekInst = new MonthWeek(
        this.options, 
        domutil.find('.' + config.classname('allday-monthweek-container'), container)
    );

    this.addChild(monthWeekInst);

    this.childs.each(function(childView) {
        childView.render(viewModel);
    });
};

module.exports = Allday;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/domutil":31,"../../config":36,"../monthweek":75,"../template/week/allday.hbs":80,"../view":84}],86:[function(require,module,exports){
(function (global){
/**
 * @fileoverview View for rendering daynames
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../../config');
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var View = require('../view');
var daynameTmpl = require('../template/week/daynames.hbs');

/**
 * @constructor
 * @param {object} options - options for dayname view
 * @param {HTMLElement} container Container element to use.
 * @extends {View}
 */
function DayName(options, container) {
    container = domutil.appendHTMLElement(
        'div',
        container,
        config.classname('dayname-container')
    );

    this.options = util.extend({
        daynames: ['일', '월', '화', '수', '목', '금', '토']
    }, options);

    View.call(this, container);
}

util.inherit(DayName, View);

/**
 * Get default viewmodels.
 * @param {Date} start The date of start render
 * @param {Date} end The end of end render
 * @returns {array} viewmodel.
 */
DayName.prototype._getBaseViewModel = function(start, end) {
    var daynames = this.options.daynames,
        viewModel;

    viewModel = util.map(datetime.range(
        datetime.start(start),
        datetime.start(end),
        datetime.MILLISECONDS_PER_DAY
    ), function(d, i, arr) {
        var day = d.getDay();

        return {
            day: day,
            dayName: daynames[day],
            date: d.getDate(),
            width: 100 / arr.length
        };
    });

    return viewModel;
};

/**
 * @override
 * @param {object} viewModel View model from parent (WeekView)
 */
DayName.prototype.render = function(viewModel) {
    var _viewModel = this._getBaseViewModel(
        viewModel.renderStartDate,
        viewModel.renderEndDate
    );

    this.container.innerHTML = daynameTmpl(_viewModel);
};

module.exports = DayName;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../../config":36,"../template/week/daynames.hbs":81,"../view":84}],87:[function(require,module,exports){
(function (global){
/**
 * @fileoverview View of time.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../../config');
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var View = require('../view');
var timeTmpl = require('../template/week/time.hbs');
var forEachArr = util.forEachArray;

/**
 * @constructor
 * @extends {View}
 * @param {number} width Date element width (percent)
 * @param {object} options Options
 * @param {string} options.ymd YYYMMDD string for this view
 * @param {boolean} options.isToday when set true then assign today design class to container.
 * @param {number} options.hourStart Can limit of render hour start.
 * @param {number} options.hourEnd Can limit of render hour end.
 * @param {HTMLElement} container Element to use container for this view.
 */
function Time(width, options, container) {
    View.call(this, container);

    container.style.width = width + '%';

    this.options = util.extend({
        ymd: '',
        isToday: false,
        hourStart: 0,
        hourEnd: 24
    }, options);

    if (this.options.isToday) {
        domutil.addClass(this.container, config.classname('time-date-today'));
    }
}

util.inherit(Time, View);

/**
 * Convert YYYYMMDD formatted string date to Date.
 * @param {string} str formatted string.
 * @returns {Date} start of date.
 */
Time.prototype._parseDateGroup = function(str) {
    var y = parseInt(str.substr(0, 4), 10),
        m = parseInt(str.substr(4, 2), 10),
        d = parseInt(str.substr(6, 2), 10);

    return new Date(y, m - 1, d);
};

/**
 * @param {CalEventViewModel} viewModel - view model instance to calculate bound.
 * @param {object} options - options for calculating event element's bound.
 * @param {Date} options.todayStart - date object represent event date's start (00:00:00)
 * @param {number} options.baseMS - the number of milliseconds to render event blocks.
 * @param {number} options.baseHeight - pixel value related with baseMS options.
 * @param {number[]} options.baseLeft - left position percents for each columns.
 * @param {number} options.baseWidth - the unit of event blocks width percent.
 * @param {number} options.columnIndex - the number index of event blocks.
 * it represent rendering index from left sides in view.
 * @returns {object} bound object for supplied view model.
 */
Time.prototype.getEventViewBound = function(viewModel, options) {
    var baseMS = options.baseMS,
        baseHeight = options.baseHeight,
        offsetStart,
        width,
        height,
        top;

    offsetStart = viewModel.valueOf().starts - options.todayStart;

    // containerHeight : milliseconds in day = x : event's milliseconds
    top = (baseHeight * offsetStart) / baseMS;
    height = (baseHeight * viewModel.duration()) / baseMS;
    width = options.baseWidth * (viewModel.extraSpace + 1);

    // set width auto when has no collisions.
    if (!viewModel.hasCollide) {
        width = null;
    }

    return {
        top: top,
        left: options.baseLeft[options.columnIndex],
        width: width,
        height: height
    };
};

/**
 * Set viewmodels for rendering.
 * @param {string} ymd The date of events. YYYYMMDD format.
 * @param {array} matrices The matrices for event placing.
 */
Time.prototype._getBaseViewModel = function(ymd, matrices) {
    var options = this.options,
        hourStart = options.hourStart,
        hourEnd = options.hourEnd,
        containerHeight,
        todayStart,
        baseMS;

    /**
     * Calculate each event element bounds relative with rendered hour milliseconds and
     * wrap each event model to viewmodels.
     */
    containerHeight = this.getViewBound().height;
    todayStart = this._parseDateGroup(ymd);
    todayStart.setHours(hourStart);
    baseMS = datetime.millisecondsFrom('hour', (hourEnd - hourStart));

    forEachArr(matrices, function(matrix) {
        var maxRowLength,
            widthPercent,
            leftPercents,
            i;

        maxRowLength = Math.max.apply(null, util.map(matrix, function(row) {
            return row.length;
        }));

        widthPercent = 100 / maxRowLength;

        leftPercents = [];
        for (i = 0; i < maxRowLength; i += 1) {
            leftPercents[i] = widthPercent * i;
        }

        forEachArr(matrix, function(row) {
            forEachArr(row, function(viewModel, col) {
                var viewBound;

                if (!viewModel) {
                    return;
                }

                viewBound = this.getEventViewBound(viewModel, {
                    todayStart: todayStart,
                    baseMS: baseMS,
                    baseLeft: leftPercents,
                    baseWidth: widthPercent,
                    baseHeight: containerHeight,
                    columnIndex: col
                });

                util.extend(viewModel, viewBound);
            }, this);
        }, this);
    }, this);
};

/**
 * @returns {Date} - Date of this view.
 */
Time.prototype.getDate = function() {
    return this._parseDateGroup(this.options.ymd);
};


/**
 * @override
 * @param {string} ymd The date of events. YYYYMMDD format
 * @param {array} matrices Matrices for placing events
 */
Time.prototype.render = function(ymd, matrices) {
    this._getBaseViewModel(ymd, matrices);
    this.container.innerHTML = timeTmpl({
        matrices: matrices
    });
};

module.exports = Time;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../../config":36,"../template/week/time.hbs":82,"../view":84}],88:[function(require,module,exports){
(function (global){
/**
 * @fileoverview View for rendered events by times.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../../config');
var domutil = require('../../common/domutil');
var datetime = require('../../common/datetime');
var reqAnimFrame = require('../../common/reqAnimFrame');
var View = require('../view');
var Time = require('./time');
var AutoScroll = require('../../common/autoScroll');
var mainTmpl = require('../template/week/timeGrid.hbs');

var PIXEL_RENDER_ERROR = 0.5;
var HOURMARKER_REFRESH_INTERVAL = 1000 * 10;
var INITIAL_AUTOSCROLL_DELAY = util.browser.msie ? 100 : 50;

/**
 * @constructor
 * @extends {View}
 * @param {object} options The object for view customization.
 * @param {number} [options.hourStart=0] You can change view's start hours.
 * @param {number} [options.hourEnd=0] You can change view's end hours.
 * @param {HTMLElement} container Container element.
 */
function TimeGrid(options, container) {
    container = domutil.appendHTMLElement(
        'div',
        container,
        config.classname('timegrid-container')
    );

    View.call(this, container);

    if (!util.browser.safari) {
        /**
         * @type {AutoScroll}
         */
        this._autoScroll = new AutoScroll(container);
    }

    /**
     * Time view options.
     * @type {object}
     */
    this.options = util.extend({
        hourStart: 0,
        hourEnd: 24
    }, options);

    /**
     * Interval id for hourmarker animation.
     * @type {number}
     */
    this.intervalID = 0;

    /**
     * @type {boolean}
     */
    this._scrolled = false;

    this.attachEvent();
}

util.inherit(TimeGrid, View);

/**********
 * Prototype props
 **********/

/**
 * @type {string}
 */
TimeGrid.prototype.viewName = 'timegrid';

/**
 * Destroy view.
 * @override
 */
TimeGrid.prototype._beforeDestroy = function() {
    window.clearInterval(this.intervalID);

    if (this._autoScroll) {
        this._autoScroll.destroy();
    }

    this._autoScroll = this.hourmarker = null;
};

/**
 * Get base viewModel.
 * @returns {object} ViewModel
 */
TimeGrid.prototype._getBaseViewModel = function() {
    var options = this.options,
        end = options.hourEnd,
        i = options.hourStart,
        hours = [];

    for (; i < end; i += 1) {
        hours.push({hour: i});
    }

    return {hours: hours};
};

/**
 * Reconcilation child views and render.
 * @param {object} viewModels Viewmodel
 * @param {number} width The width percent of each time view.
 * @param {HTMLElement} container Container element for each time view.
 */
TimeGrid.prototype._renderChilds = function(viewModels, width, container) {
    var options = this.options,
        childOption,
        child,
        isToday,
        today = datetime.format(new Date(), 'YYYYMMDD');

    // clear contents
    container.innerHTML = '';
    this.childs.clear();
    this.todaymarkerLeft = null;

    // reconcilation of child views
    util.forEach(viewModels, function(events, ymd) {
        isToday = ymd === today;

        if (isToday) {
            this.todaymarkerLeft = width * this.childs.length;
        }

        childOption = {
            ymd: ymd,
            isToday: isToday,
            hourStart: options.hourStart,
            hourEnd: options.hourEnd
        };

        child = new Time(
            width,
            childOption,
            domutil.appendHTMLElement('div', container, config.classname('time-date'))
        );
        child.render(ymd, events);

        this.addChild(child);
    }, this);
};

/**
 * @override
 * @param {object} viewModel ViewModel list from Week view.
 */
TimeGrid.prototype.render = function(viewModel) {
    var timeViewModel = viewModel.eventsInDateRange.time,
        container = this.container,
        baseViewModel = this._getBaseViewModel(),
        eventLen = util.keys(timeViewModel).length;

    if (!eventLen) {
        return;
    }

    container.innerHTML = mainTmpl(baseViewModel);

    /**********
     * Render childs
     **********/
    this._renderChilds(
        timeViewModel,
        100 / eventLen,
        domutil.find('.' + config.classname('timegrid-events-container'), container)
    );

    this._hourLabels = domutil.find('ul', container);

    /**********
     * Render hourmarker
     **********/
    this.hourmarker = domutil.find('.' + config.classname('timegrid-hourmarker'), container);
    this.refreshHourmarker();

    if (!this._scrolled) {
        this._scrolled = true;
        this.scrollToNow();
    }
};

/**
 * Refresh hourmarker element.
 */
TimeGrid.prototype.refreshHourmarker = function() {
    var hourLabels = this._hourLabels,
        hourmarker = this.hourmarker,

        viewModel = this._getHourmarkerViewModel(),
        todaymarkerLeft = this.todaymarkerLeft,
        todaymarker,
        text,
        labelToVisible,
        labelToInvisible;

    if (!hourmarker || !viewModel) {
        return;
    }

    todaymarker = domutil.find('.' + config.classname('timegrid-todaymarker'), hourmarker);
    text = domutil.find('.' + config.classname('timegrid-hourmarker-time'), hourmarker);
    labelToVisible = domutil.find('.' + config.classname('invisible'), hourLabels);
    labelToInvisible = domutil.find('.' + config.classname('timegrid-hour-') + viewModel.hour, hourLabels);

    reqAnimFrame.requestAnimFrame(function() {
        if (labelToVisible !== labelToInvisible) {
            if (labelToVisible) {
                domutil.removeClass(labelToVisible, config.classname('invisible'));
            }

            if (labelToInvisible) {
                domutil.addClass(labelToInvisible, config.classname('invisible'));
            }
        }

        hourmarker.style.display = 'block';
        hourmarker.style.top = (viewModel.top - PIXEL_RENDER_ERROR) + 'px';

        if (!util.isNull(todaymarkerLeft)) {
            todaymarker.style.display = 'block';
            todaymarker.style.left = todaymarkerLeft + '%';
        } else {
            todaymarker.style.display = 'none';
        }

        text.innerHTML = viewModel.text;
    });
};

/**
 * Return grid size.
 * @returns {number[]} The size of grid element.
 */
TimeGrid.prototype._getGridSize = function() {
    var childNode = this.container.childNodes[0];

    if (!childNode) {
        return false;
    }

    return domutil.getSize(childNode);
};

/**
 * @param {Date} [time] - date object to convert pixel in grids.
 * use **Date.now()** when not supplied.
 * @returns {number} The pixel value represent current time in grids.
 */
TimeGrid.prototype._getTopByTime = function(time) {
    var now = util.isDate(time) ? new Date(time.getTime()) : new Date(),
        start = datetime.start(now),
        hourStart = this.options.hourStart,
        gridSize = this._getGridSize(),
        offset,
        top;

    if (!gridSize) {
        return 0;
    }

    offset = +now - +start;
    if (hourStart) {
        offset -= datetime.millisecondsFrom('hour', hourStart);
    }

    top = (offset * gridSize[1]) / (datetime.millisecondsFrom('hour', this._getBaseViewModel().hours.length));

    return top;
};

/**
 * Get Hourmarker viewmodel.
 * @returns {object} ViewModel of hourmarker.
 */
TimeGrid.prototype._getHourmarkerViewModel = function() {
    var now = new Date();

    return {
        top: this._getTopByTime(),
        hour: now.getHours(),
        text: datetime.format(now, 'HH:mm')
    };
};

/**
 * Attach events
 */
TimeGrid.prototype.attachEvent = function() {
    window.clearInterval(this.intervalID);
    this.intervalID = window.setInterval(util.bind(this.onTick, this), HOURMARKER_REFRESH_INTERVAL);
};

/**
 * Scroll time grid to current hourmarker.
 */
TimeGrid.prototype.scrollToNow = function() {
    var currentHourTop = this._getTopByTime(),
        viewBound = this.getViewBound(),
        container = this.container;

    window.setTimeout(function() {
        container.scrollTop = (currentHourTop - (viewBound.height / 2));
    }, INITIAL_AUTOSCROLL_DELAY);
};

/**********
 * CalEvent handlers
 **********/

/**
 * Interval tick handler
 */
TimeGrid.prototype.onTick = function() {
    this.refreshHourmarker();
};

module.exports = TimeGrid;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/autoScroll":25,"../../common/datetime":28,"../../common/domutil":31,"../../common/reqAnimFrame":35,"../../config":36,"../template/week/timeGrid.hbs":83,"../view":84,"./time":87}],89:[function(require,module,exports){
(function (global){
/**
 * @fileoverview View of days UI.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.tui.util;
var config = require('../../config');
var domutil = require('../../common/domutil');
var datetime = require('../../common/datetime');
var View = require('../view');

/**
 * @constructor
 * @param {Base.Week} controller The controller mixin part.
 * @param {object} options View options
 * @param {string} [options.renderStartDate] Start date of render. if not supplied then use -3d from today. YYYY-MM-DD format.
 * @param {string} [options.renderEndDate] End date of render. if not supplied then use +3d from today. YYYY-MM-DD format.
 * @param {string} [options.cssPrefix] - CSS classname prefix
 * @param {HTMLElement} container The element to use container for this view.
 * @extends {View}
 */
function Week(controller, options, container) {
    var range;

    container = domutil.appendHTMLElement('div', container);

    View.call(this, container);

    domutil.addClass(container, config.classname('week-container'));

    range = this._getRenderDateRange(new Date());

    /**
     * @type {object} Options for view.
     */
    this.options = util.extend({
        renderStartDate: datetime.format(range.start, 'YYYY-MM-DD'),
        renderEndDate: datetime.format(range.end, 'YYYY-MM-DD')
    }, options);

    /**
     * Week controller mixin.
     * @type {Base.Week}
     */
    this.controller = controller;
}

util.inherit(Week, View);

/**********
 * Override props
 **********/

/**
 * Render each child view with events in ranges.
 * @fires Week#afterRender
 * @override
 */
Week.prototype.render = function() {
    var options = this.options,
        renderStartDate = datetime.parse(options.renderStartDate),
        renderEndDate = datetime.parse(options.renderEndDate),
        eventsInDateRange = this.controller.findByDateRange(
            datetime.start(renderStartDate),
            datetime.end(renderEndDate)
        ),
        viewModel = {
            eventsInDateRange: eventsInDateRange,
            renderStartDate: renderStartDate,
            renderEndDate: renderEndDate
        };

    this.childs.each(function(childView) {
        childView.render(viewModel);
    });

    /**
     * @event Week#afterRender
     */
    this.fire('afterRender');
};

/**********
 * Prototype props
 **********/

Week.prototype.viewName = 'week';

/**
 * Calculate default render date range from supplied date.
 * @param {Date} baseDate base date.
 * @returns {object} date range.
 */
Week.prototype._getRenderDateRange = function(baseDate) {
    var base = datetime.start(baseDate),
        start = new Date(+base),
        end = new Date(+base);

    start.setDate(start.getDate() - 3);
    end.setDate(end.getDate() + 3);

    return {
        start: start,
        end: end
    };
};

util.CustomEvents.mixin(Week);

module.exports = Week;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../../config":36,"../view":84}]},{},[1])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L2xpYi9fZW1wdHkuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9saWIvaGFuZGxlYmFycy5ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9iYXNlLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9kZWNvcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9kZWNvcmF0b3JzL2xpYi9oYW5kbGViYXJzL2RlY29yYXRvcnMvaW5saW5lLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9leGNlcHRpb24uanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2hlbHBlcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy9ibG9jay1oZWxwZXItbWlzc2luZy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvaGVscGVycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2VhY2guanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2hlbHBlcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy9oZWxwZXItbWlzc2luZy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvaGVscGVycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2lmLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9oZWxwZXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvbG9nLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9oZWxwZXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvbG9va3VwLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9oZWxwZXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvd2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvbG9nZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL25vLWNvbmZsaWN0LmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9zYWZlLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL2hic2Z5L3J1bnRpbWUuanMiLCJzcmMvanMvY29tbW9uL2FqYXguanMiLCJzcmMvanMvY29tbW9uL2FycmF5LmpzIiwic3JjL2pzL2NvbW1vbi9hdXRvU2Nyb2xsLmpzIiwic3JjL2pzL2NvbW1vbi9jb2xsZWN0aW9uLmpzIiwic3JjL2pzL2NvbW1vbi9jb21tb24uanMiLCJzcmMvanMvY29tbW9uL2RhdGV0aW1lLmpzIiwic3JjL2pzL2NvbW1vbi9kaXJ0eS5qcyIsInNyYy9qcy9jb21tb24vZG9tZXZlbnQuanMiLCJzcmMvanMvY29tbW9uL2RvbXV0aWwuanMiLCJzcmMvanMvY29tbW9uL2ZpbGxSZW1haW5IZWlnaHQuanMiLCJzcmMvanMvY29tbW9uL21vZGVsLmpzIiwic3JjL2pzL2NvbW1vbi9wb2ludC5qcyIsInNyYy9qcy9jb21tb24vcmVxQW5pbUZyYW1lLmpzIiwic3JjL2pzL2NvbmZpZy5qcyIsInNyYy9qcy9jb250cm9sbGVyL2Jhc2UuanMiLCJzcmMvanMvY29udHJvbGxlci92aWV3TWl4aW4vd2Vlay5qcyIsInNyYy9qcy9kb29yYXkvY29udHJvbGxlci9iYXNlLmpzIiwic3JjL2pzL2Rvb3JheS9mYWN0b3J5L2NhbGVuZGFyLmpzIiwic3JjL2pzL2Rvb3JheS9mYWN0b3J5L3dlZWtWaWV3LmpzIiwic3JjL2pzL2Rvb3JheS9oYW5kbGVyL21pbGVzdG9uZUNsaWNrLmpzIiwic3JjL2pzL2Rvb3JheS9oYW5kbGVyL3Rhc2tDbGljay5qcyIsInNyYy9qcy9kb29yYXkvbW9kZWwvY2FsRXZlbnQuanMiLCJzcmMvanMvZG9vcmF5L3ZpZXcvbWlsZXN0b25lLmhicyIsInNyYy9qcy9kb29yYXkvdmlldy9taWxlc3RvbmUuanMiLCJzcmMvanMvZG9vcmF5L3ZpZXcvbWluaWNhbGVuZGFyLmhicyIsInNyYy9qcy9kb29yYXkvdmlldy9taW5pY2FsZW5kYXIuanMiLCJzcmMvanMvZG9vcmF5L3ZpZXcvdGFza3ZpZXcuaGJzIiwic3JjL2pzL2Rvb3JheS92aWV3L3Rhc2t2aWV3LmpzIiwic3JjL2pzL2Rvb3JheS92aWV3L3RlbXBsYXRlL2ZhY3Rvcnkvd2Vla1ZpZXcuaGJzIiwic3JjL2pzL2ZhY3RvcnkvY2FsZW5kYXIuanMiLCJzcmMvanMvZmFjdG9yeS9jb250cm9sbGVyLmpzIiwic3JjL2pzL2ZhY3Rvcnkvd2Vla1ZpZXcuanMiLCJzcmMvanMvaGFuZGxlci9hbGxkYXkvY2xpY2suanMiLCJzcmMvanMvaGFuZGxlci9hbGxkYXkvY29yZS5qcyIsInNyYy9qcy9oYW5kbGVyL2FsbGRheS9jcmVhdGlvbi5qcyIsInNyYy9qcy9oYW5kbGVyL2FsbGRheS9jcmVhdGlvbkd1aWRlLmpzIiwic3JjL2pzL2hhbmRsZXIvYWxsZGF5L21vdmUuanMiLCJzcmMvanMvaGFuZGxlci9hbGxkYXkvbW92ZUd1aWRlLmpzIiwic3JjL2pzL2hhbmRsZXIvYWxsZGF5L3Jlc2l6ZS5qcyIsInNyYy9qcy9oYW5kbGVyL2FsbGRheS9yZXNpemVHdWlkZS5qcyIsInNyYy9qcy9oYW5kbGVyL2RyYWcuanMiLCJzcmMvanMvaGFuZGxlci90aW1lL2NsaWNrLmpzIiwic3JjL2pzL2hhbmRsZXIvdGltZS9jb3JlLmpzIiwic3JjL2pzL2hhbmRsZXIvdGltZS9jcmVhdGlvbi5qcyIsInNyYy9qcy9oYW5kbGVyL3RpbWUvY3JlYXRpb25HdWlkZS5qcyIsInNyYy9qcy9oYW5kbGVyL3RpbWUvbW92ZS5qcyIsInNyYy9qcy9oYW5kbGVyL3RpbWUvbW92ZUd1aWRlLmpzIiwic3JjL2pzL2hhbmRsZXIvdGltZS9yZXNpemUuanMiLCJzcmMvanMvaGFuZGxlci90aW1lL3Jlc2l6ZUd1aWRlLmpzIiwic3JjL2pzL21vZGVsL2NhbEV2ZW50LmpzIiwic3JjL2pzL21vZGVsL3ZpZXdNb2RlbC9jYWxFdmVudC5qcyIsInNyYy9qcy92aWV3L2xheW91dC5qcyIsInNyYy9qcy92aWV3L21vbnRod2Vlay5qcyIsInNyYy9qcy92aWV3L3RlbXBsYXRlL2ZhY3Rvcnkvd2Vla1ZpZXcuaGJzIiwic3JjL2pzL3ZpZXcvdGVtcGxhdGUvaGVscGVyLmpzIiwic3JjL2pzL3ZpZXcvdGVtcGxhdGUvbW9udGh3ZWVrLmhicyIsInNyYy9qcy92aWV3L3RlbXBsYXRlL3JlZ2lzdGVySGVscGVycy5qcyIsInNyYy9qcy92aWV3L3RlbXBsYXRlL3dlZWsvYWxsZGF5LmhicyIsInNyYy9qcy92aWV3L3RlbXBsYXRlL3dlZWsvZGF5bmFtZXMuaGJzIiwic3JjL2pzL3ZpZXcvdGVtcGxhdGUvd2Vlay90aW1lLmhicyIsInNyYy9qcy92aWV3L3RlbXBsYXRlL3dlZWsvdGltZUdyaWQuaGJzIiwic3JjL2pzL3ZpZXcvdmlldy5qcyIsInNyYy9qcy92aWV3L3dlZWsvYWxsZGF5LmpzIiwic3JjL2pzL3ZpZXcvd2Vlay9kYXluYW1lLmpzIiwic3JjL2pzL3ZpZXcvd2Vlay90aW1lLmpzIiwic3JjL2pzL3ZpZXcvd2Vlay90aW1lR3JpZC5qcyIsInNyYy9qcy92aWV3L3dlZWsvd2Vlay5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pKQTs7Ozs7Ozs7Ozs7Ozs4QkNBc0IsbUJBQW1COzs7OztJQUE3QixJQUFJOztvQ0FJTywwQkFBMEI7Ozs7bUNBQzNCLHdCQUF3Qjs7OzsrQkFDdkIsb0JBQW9COztJQUEvQixLQUFLOztpQ0FDUSxzQkFBc0I7O0lBQW5DLE9BQU87O29DQUVJLDBCQUEwQjs7Ozs7O0FBR2pELFNBQVMsTUFBTSxHQUFHO0FBQ2hCLE1BQUksRUFBRSxHQUFHLElBQUksSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7O0FBRTFDLE9BQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3ZCLElBQUUsQ0FBQyxVQUFVLG9DQUFhLENBQUM7QUFDM0IsSUFBRSxDQUFDLFNBQVMsbUNBQVksQ0FBQztBQUN6QixJQUFFLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUNqQixJQUFFLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDLGdCQUFnQixDQUFDOztBQUU3QyxJQUFFLENBQUMsRUFBRSxHQUFHLE9BQU8sQ0FBQztBQUNoQixJQUFFLENBQUMsUUFBUSxHQUFHLFVBQVMsSUFBSSxFQUFFO0FBQzNCLFdBQU8sT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7R0FDbkMsQ0FBQzs7QUFFRixTQUFPLEVBQUUsQ0FBQztDQUNYOztBQUVELElBQUksSUFBSSxHQUFHLE1BQU0sRUFBRSxDQUFDO0FBQ3BCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDOztBQUVyQixrQ0FBVyxJQUFJLENBQUMsQ0FBQzs7QUFFakIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQzs7cUJBRVIsSUFBSTs7Ozs7Ozs7Ozs7OztxQkNwQ3lCLFNBQVM7O3lCQUMvQixhQUFhOzs7O3VCQUNFLFdBQVc7OzBCQUNSLGNBQWM7O3NCQUNuQyxVQUFVOzs7O0FBRXRCLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQzs7QUFDeEIsSUFBTSxpQkFBaUIsR0FBRyxDQUFDLENBQUM7OztBQUU1QixJQUFNLGdCQUFnQixHQUFHO0FBQzlCLEdBQUMsRUFBRSxhQUFhO0FBQ2hCLEdBQUMsRUFBRSxlQUFlO0FBQ2xCLEdBQUMsRUFBRSxlQUFlO0FBQ2xCLEdBQUMsRUFBRSxVQUFVO0FBQ2IsR0FBQyxFQUFFLGtCQUFrQjtBQUNyQixHQUFDLEVBQUUsaUJBQWlCO0FBQ3BCLEdBQUMsRUFBRSxVQUFVO0NBQ2QsQ0FBQzs7O0FBRUYsSUFBTSxVQUFVLEdBQUcsaUJBQWlCLENBQUM7O0FBRTlCLFNBQVMscUJBQXFCLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUU7QUFDbkUsTUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLElBQUksRUFBRSxDQUFDO0FBQzdCLE1BQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxJQUFJLEVBQUUsQ0FBQztBQUMvQixNQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsSUFBSSxFQUFFLENBQUM7O0FBRW5DLFdBeEJNLHNCQUFzQixDQXdCTCxJQUFJLENBQUMsQ0FBQztBQUM3QixjQXhCTSx5QkFBeUIsQ0F3QkwsSUFBSSxDQUFDLENBQUM7Q0FDakM7O0FBRUQscUJBQXFCLENBQUMsU0FBUyxHQUFHO0FBQ2hDLGFBQVcsRUFBRSxxQkFBcUI7O0FBRWxDLFFBQU0scUJBQVE7QUFDZCxLQUFHLEVBQUUsb0JBQU8sR0FBRzs7QUFFZixnQkFBYyxFQUFFLHdCQUFTLElBQUksRUFBRSxFQUFFLEVBQUU7QUFDakMsUUFBSSxPQXJDcUIsUUFBUSxDQXFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLFVBQVUsRUFBRTtBQUN0QyxVQUFJLEVBQUUsRUFBRTtBQUFFLGNBQU0sMkJBQWMseUNBQXlDLENBQUMsQ0FBQztPQUFFO0FBQzNFLGFBdkNlLE1BQU0sQ0F1Q2QsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztLQUM1QixNQUFNO0FBQ0wsVUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7S0FDekI7R0FDRjtBQUNELGtCQUFnQixFQUFFLDBCQUFTLElBQUksRUFBRTtBQUMvQixXQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7R0FDM0I7O0FBRUQsaUJBQWUsRUFBRSx5QkFBUyxJQUFJLEVBQUUsT0FBTyxFQUFFO0FBQ3ZDLFFBQUksT0FqRHFCLFFBQVEsQ0FpRHBCLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxVQUFVLEVBQUU7QUFDdEMsYUFsRGUsTUFBTSxDQWtEZCxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQzdCLE1BQU07QUFDTCxVQUFJLE9BQU8sT0FBTyxLQUFLLFdBQVcsRUFBRTtBQUNsQyxjQUFNLHlFQUEwRCxJQUFJLG9CQUFpQixDQUFDO09BQ3ZGO0FBQ0QsVUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxPQUFPLENBQUM7S0FDL0I7R0FDRjtBQUNELG1CQUFpQixFQUFFLDJCQUFTLElBQUksRUFBRTtBQUNoQyxXQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7R0FDNUI7O0FBRUQsbUJBQWlCLEVBQUUsMkJBQVMsSUFBSSxFQUFFLEVBQUUsRUFBRTtBQUNwQyxRQUFJLE9BL0RxQixRQUFRLENBK0RwQixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssVUFBVSxFQUFFO0FBQ3RDLFVBQUksRUFBRSxFQUFFO0FBQUUsY0FBTSwyQkFBYyw0Q0FBNEMsQ0FBQyxDQUFDO09BQUU7QUFDOUUsYUFqRWUsTUFBTSxDQWlFZCxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQy9CLE1BQU07QUFDTCxVQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztLQUM1QjtHQUNGO0FBQ0QscUJBQW1CLEVBQUUsNkJBQVMsSUFBSSxFQUFFO0FBQ2xDLFdBQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztHQUM5QjtDQUNGLENBQUM7O0FBRUssSUFBSSxHQUFHLEdBQUcsb0JBQU8sR0FBRyxDQUFDOzs7UUFFcEIsV0FBVyxVQTdFWCxXQUFXO1FBNkVFLE1BQU07Ozs7Ozs7Ozs7OztnQ0M3RUEscUJBQXFCOzs7O0FBRXpDLFNBQVMseUJBQXlCLENBQUMsUUFBUSxFQUFFO0FBQ2xELGdDQUFlLFFBQVEsQ0FBQyxDQUFDO0NBQzFCOzs7Ozs7OztxQkNKb0IsVUFBVTs7cUJBRWhCLFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUUsVUFBUyxFQUFFLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUU7QUFDM0UsUUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ2IsUUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUU7QUFDbkIsV0FBSyxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7QUFDcEIsU0FBRyxHQUFHLFVBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTs7QUFFL0IsWUFBSSxRQUFRLEdBQUcsU0FBUyxDQUFDLFFBQVEsQ0FBQztBQUNsQyxpQkFBUyxDQUFDLFFBQVEsR0FBRyxPQVZyQixNQUFNLENBVXNCLEVBQUUsRUFBRSxRQUFRLEVBQUUsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzFELFlBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDL0IsaUJBQVMsQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0FBQzlCLGVBQU8sR0FBRyxDQUFDO09BQ1osQ0FBQztLQUNIOztBQUVELFNBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxFQUFFLENBQUM7O0FBRTdDLFdBQU8sR0FBRyxDQUFDO0dBQ1osQ0FBQyxDQUFDO0NBQ0o7Ozs7Ozs7Ozs7QUNwQkQsSUFBTSxVQUFVLEdBQUcsQ0FBQyxhQUFhLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQzs7QUFFbkcsU0FBUyxTQUFTLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRTtBQUNoQyxNQUFJLEdBQUcsR0FBRyxJQUFJLElBQUksSUFBSSxDQUFDLEdBQUc7TUFDdEIsSUFBSSxZQUFBO01BQ0osTUFBTSxZQUFBLENBQUM7QUFDWCxNQUFJLEdBQUcsRUFBRTtBQUNQLFFBQUksR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQztBQUN0QixVQUFNLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7O0FBRTFCLFdBQU8sSUFBSSxLQUFLLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUM7R0FDeEM7O0FBRUQsTUFBSSxHQUFHLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQzs7O0FBRzFELE9BQUssSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxVQUFVLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxFQUFFO0FBQ2hELFFBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7R0FDOUM7OztBQUdELE1BQUksS0FBSyxDQUFDLGlCQUFpQixFQUFFO0FBQzNCLFNBQUssQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7R0FDMUM7O0FBRUQsTUFBSSxHQUFHLEVBQUU7QUFDUCxRQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztBQUN2QixRQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztHQUN0QjtDQUNGOztBQUVELFNBQVMsQ0FBQyxTQUFTLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQzs7cUJBRW5CLFNBQVM7Ozs7Ozs7Ozs7Ozs7eUNDbENlLGdDQUFnQzs7OzsyQkFDOUMsZ0JBQWdCOzs7O29DQUNQLDBCQUEwQjs7Ozt5QkFDckMsY0FBYzs7OzswQkFDYixlQUFlOzs7OzZCQUNaLGtCQUFrQjs7OzsyQkFDcEIsZ0JBQWdCOzs7O0FBRWxDLFNBQVMsc0JBQXNCLENBQUMsUUFBUSxFQUFFO0FBQy9DLHlDQUEyQixRQUFRLENBQUMsQ0FBQztBQUNyQywyQkFBYSxRQUFRLENBQUMsQ0FBQztBQUN2QixvQ0FBc0IsUUFBUSxDQUFDLENBQUM7QUFDaEMseUJBQVcsUUFBUSxDQUFDLENBQUM7QUFDckIsMEJBQVksUUFBUSxDQUFDLENBQUM7QUFDdEIsNkJBQWUsUUFBUSxDQUFDLENBQUM7QUFDekIsMkJBQWEsUUFBUSxDQUFDLENBQUM7Q0FDeEI7Ozs7Ozs7O3FCQ2hCcUQsVUFBVTs7cUJBRWpELFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxjQUFjLENBQUMsb0JBQW9CLEVBQUUsVUFBUyxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3ZFLFFBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPO1FBQ3pCLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDOztBQUVwQixRQUFJLE9BQU8sS0FBSyxJQUFJLEVBQUU7QUFDcEIsYUFBTyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDakIsTUFBTSxJQUFJLE9BQU8sS0FBSyxLQUFLLElBQUksT0FBTyxJQUFJLElBQUksRUFBRTtBQUMvQyxhQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUN0QixNQUFNLElBQUksT0FYeUIsT0FBTyxDQVd4QixPQUFPLENBQUMsRUFBRTtBQUMzQixVQUFJLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO0FBQ3RCLFlBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUNmLGlCQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzlCOztBQUVELGVBQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO09BQ2hELE1BQU07QUFDTCxlQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztPQUN0QjtLQUNGLE1BQU07QUFDTCxVQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUMvQixZQUFJLElBQUksR0FBRyxPQXZCUSxXQUFXLENBdUJQLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNyQyxZQUFJLENBQUMsV0FBVyxHQUFHLE9BeEJuQixpQkFBaUIsQ0F3Qm9CLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM3RSxlQUFPLEdBQUcsRUFBQyxJQUFJLEVBQUUsSUFBSSxFQUFDLENBQUM7T0FDeEI7O0FBRUQsYUFBTyxFQUFFLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0tBQzdCO0dBQ0YsQ0FBQyxDQUFDO0NBQ0o7Ozs7Ozs7Ozs7Ozs7cUJDL0I4RSxVQUFVOzt5QkFDbkUsY0FBYzs7OztxQkFFckIsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsVUFBUyxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3pELFFBQUksQ0FBQyxPQUFPLEVBQUU7QUFDWixZQUFNLDJCQUFjLDZCQUE2QixDQUFDLENBQUM7S0FDcEQ7O0FBRUQsUUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDLEVBQUU7UUFDZixPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU87UUFDekIsQ0FBQyxHQUFHLENBQUM7UUFDTCxHQUFHLEdBQUcsRUFBRTtRQUNSLElBQUksWUFBQTtRQUNKLFdBQVcsWUFBQSxDQUFDOztBQUVoQixRQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUMvQixpQkFBVyxHQUFHLE9BakJaLGlCQUFpQixDQWlCYSxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0tBQ2pGOztBQUVELFFBQUksT0FwQnNELFVBQVUsQ0FvQnJELE9BQU8sQ0FBQyxFQUFFO0FBQUUsYUFBTyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FBRTs7QUFFMUQsUUFBSSxPQUFPLENBQUMsSUFBSSxFQUFFO0FBQ2hCLFVBQUksR0FBRyxPQXZCMkIsV0FBVyxDQXVCMUIsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ2xDOztBQUVELGFBQVMsYUFBYSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFO0FBQ3pDLFVBQUksSUFBSSxFQUFFO0FBQ1IsWUFBSSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUM7QUFDakIsWUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDbkIsWUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLEtBQUssQ0FBQyxDQUFDO0FBQ3pCLFlBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQzs7QUFFbkIsWUFBSSxXQUFXLEVBQUU7QUFDZixjQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsR0FBRyxLQUFLLENBQUM7U0FDeEM7T0FDRjs7QUFFRCxTQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDN0IsWUFBSSxFQUFFLElBQUk7QUFDVixtQkFBVyxFQUFFLE9BeENNLFdBQVcsQ0F3Q0wsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUsS0FBSyxDQUFDLEVBQUUsQ0FBQyxXQUFXLEdBQUcsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO09BQy9FLENBQUMsQ0FBQztLQUNKOztBQUVELFFBQUksT0FBTyxJQUFJLE9BQU8sT0FBTyxLQUFLLFFBQVEsRUFBRTtBQUMxQyxVQUFJLE9BN0MyQyxPQUFPLENBNkMxQyxPQUFPLENBQUMsRUFBRTtBQUNwQixhQUFLLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN2QyxjQUFJLENBQUMsSUFBSSxPQUFPLEVBQUU7QUFDaEIseUJBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsS0FBSyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1dBQy9DO1NBQ0Y7T0FDRixNQUFNO0FBQ0wsWUFBSSxRQUFRLFlBQUEsQ0FBQzs7QUFFYixhQUFLLElBQUksR0FBRyxJQUFJLE9BQU8sRUFBRTtBQUN2QixjQUFJLE9BQU8sQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUU7Ozs7QUFJL0IsZ0JBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtBQUMxQiwyQkFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDaEM7QUFDRCxvQkFBUSxHQUFHLEdBQUcsQ0FBQztBQUNmLGFBQUMsRUFBRSxDQUFDO1dBQ0w7U0FDRjtBQUNELFlBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtBQUMxQix1QkFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ3RDO09BQ0Y7S0FDRjs7QUFFRCxRQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDWCxTQUFHLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3JCOztBQUVELFdBQU8sR0FBRyxDQUFDO0dBQ1osQ0FBQyxDQUFDO0NBQ0o7Ozs7Ozs7Ozs7Ozs7eUJDOUVxQixjQUFjOzs7O3FCQUVyQixVQUFTLFFBQVEsRUFBRTtBQUNoQyxVQUFRLENBQUMsY0FBYyxDQUFDLGVBQWUsRUFBRSxpQ0FBZ0M7QUFDdkUsUUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTs7QUFFMUIsYUFBTyxTQUFTLENBQUM7S0FDbEIsTUFBTTs7QUFFTCxZQUFNLDJCQUFjLG1CQUFtQixHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztLQUN2RjtHQUNGLENBQUMsQ0FBQztDQUNKOzs7Ozs7Ozs7O3FCQ1ppQyxVQUFVOztxQkFFN0IsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsVUFBUyxXQUFXLEVBQUUsT0FBTyxFQUFFO0FBQzNELFFBQUksT0FKUyxVQUFVLENBSVIsV0FBVyxDQUFDLEVBQUU7QUFBRSxpQkFBVyxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FBRTs7Ozs7QUFLdEUsUUFBSSxBQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLElBQUksQ0FBQyxXQUFXLElBQUssT0FUL0MsT0FBTyxDQVNnRCxXQUFXLENBQUMsRUFBRTtBQUN2RSxhQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDOUIsTUFBTTtBQUNMLGFBQU8sT0FBTyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUN6QjtHQUNGLENBQUMsQ0FBQzs7QUFFSCxVQUFRLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFBRSxVQUFTLFdBQVcsRUFBRSxPQUFPLEVBQUU7QUFDL0QsV0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsV0FBVyxFQUFFLEVBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxJQUFJLEVBQUMsQ0FBQyxDQUFDO0dBQ3ZILENBQUMsQ0FBQztDQUNKOzs7Ozs7Ozs7O3FCQ25CYyxVQUFTLFFBQVEsRUFBRTtBQUNoQyxVQUFRLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxrQ0FBaUM7QUFDOUQsUUFBSSxJQUFJLEdBQUcsQ0FBQyxTQUFTLENBQUM7UUFDbEIsT0FBTyxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzlDLFNBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUM3QyxVQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3pCOztBQUVELFFBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztBQUNkLFFBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxFQUFFO0FBQzlCLFdBQUssR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztLQUM1QixNQUFNLElBQUksT0FBTyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLEVBQUU7QUFDckQsV0FBSyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO0tBQzVCO0FBQ0QsUUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQzs7QUFFaEIsWUFBUSxDQUFDLEdBQUcsTUFBQSxDQUFaLFFBQVEsRUFBUyxJQUFJLENBQUMsQ0FBQztHQUN4QixDQUFDLENBQUM7Q0FDSjs7Ozs7Ozs7OztxQkNsQmMsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsVUFBUyxHQUFHLEVBQUUsS0FBSyxFQUFFO0FBQ3JELFdBQU8sR0FBRyxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztHQUMxQixDQUFDLENBQUM7Q0FDSjs7Ozs7Ozs7OztxQkNKOEUsVUFBVTs7cUJBRTFFLFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLFVBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN6RCxRQUFJLE9BSnNELFVBQVUsQ0FJckQsT0FBTyxDQUFDLEVBQUU7QUFBRSxhQUFPLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUFFOztBQUUxRCxRQUFJLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDOztBQUVwQixRQUFJLENBQUMsT0FSNEMsT0FBTyxDQVEzQyxPQUFPLENBQUMsRUFBRTtBQUNyQixVQUFJLElBQUksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDO0FBQ3hCLFVBQUksT0FBTyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFO0FBQy9CLFlBQUksR0FBRyxPQVh5QixXQUFXLENBV3hCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNqQyxZQUFJLENBQUMsV0FBVyxHQUFHLE9BWm5CLGlCQUFpQixDQVlvQixPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7T0FDaEY7O0FBRUQsYUFBTyxFQUFFLENBQUMsT0FBTyxFQUFFO0FBQ2pCLFlBQUksRUFBRSxJQUFJO0FBQ1YsbUJBQVcsRUFBRSxPQWpCTSxXQUFXLENBaUJMLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO09BQ2hFLENBQUMsQ0FBQztLQUNKLE1BQU07QUFDTCxhQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDOUI7R0FDRixDQUFDLENBQUM7Q0FDSjs7Ozs7Ozs7OztxQkN2QnFCLFNBQVM7O0FBRS9CLElBQUksTUFBTSxHQUFHO0FBQ1gsV0FBUyxFQUFFLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDO0FBQzdDLE9BQUssRUFBRSxNQUFNOzs7QUFHYixhQUFXLEVBQUUscUJBQVMsS0FBSyxFQUFFO0FBQzNCLFFBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO0FBQzdCLFVBQUksUUFBUSxHQUFHLE9BVGIsT0FBTyxDQVNjLE1BQU0sQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7QUFDOUQsVUFBSSxRQUFRLElBQUksQ0FBQyxFQUFFO0FBQ2pCLGFBQUssR0FBRyxRQUFRLENBQUM7T0FDbEIsTUFBTTtBQUNMLGFBQUssR0FBRyxRQUFRLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO09BQzdCO0tBQ0Y7O0FBRUQsV0FBTyxLQUFLLENBQUM7R0FDZDs7O0FBR0QsS0FBRyxFQUFFLGFBQVMsS0FBSyxFQUFjO0FBQy9CLFNBQUssR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDOztBQUVsQyxRQUFJLE9BQU8sT0FBTyxLQUFLLFdBQVcsSUFBSSxNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLEVBQUU7QUFDL0UsVUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNyQyxVQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFOztBQUNwQixjQUFNLEdBQUcsS0FBSyxDQUFDO09BQ2hCOzt3Q0FQbUIsT0FBTztBQUFQLGVBQU87OztBQVEzQixhQUFPLENBQUMsTUFBTSxPQUFDLENBQWYsT0FBTyxFQUFZLE9BQU8sQ0FBQyxDQUFDO0tBQzdCO0dBQ0Y7Q0FDRixDQUFDOztxQkFFYSxNQUFNOzs7Ozs7Ozs7OztxQkNqQ04sVUFBUyxVQUFVLEVBQUU7O0FBRWxDLE1BQUksSUFBSSxHQUFHLE9BQU8sTUFBTSxLQUFLLFdBQVcsR0FBRyxNQUFNLEdBQUcsTUFBTTtNQUN0RCxXQUFXLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQzs7QUFFbEMsWUFBVSxDQUFDLFVBQVUsR0FBRyxZQUFXO0FBQ2pDLFFBQUksSUFBSSxDQUFDLFVBQVUsS0FBSyxVQUFVLEVBQUU7QUFDbEMsVUFBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUM7S0FDL0I7R0FDRixDQUFDO0NBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUJDWHNCLFNBQVM7O0lBQXBCLEtBQUs7O3lCQUNLLGFBQWE7Ozs7b0JBQzhCLFFBQVE7O0FBRWxFLFNBQVMsYUFBYSxDQUFDLFlBQVksRUFBRTtBQUMxQyxNQUFNLGdCQUFnQixHQUFHLFlBQVksSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztNQUN2RCxlQUFlLFNBSmQsaUJBQWlCLEFBSWlCLENBQUM7O0FBRTFDLE1BQUksZ0JBQWdCLEtBQUssZUFBZSxFQUFFO0FBQ3hDLFFBQUksZ0JBQWdCLEdBQUcsZUFBZSxFQUFFO0FBQ3RDLFVBQU0sZUFBZSxHQUFHLE1BUkYsZ0JBQWdCLENBUUcsZUFBZSxDQUFDO1VBQ25ELGdCQUFnQixHQUFHLE1BVEgsZ0JBQWdCLENBU0ksZ0JBQWdCLENBQUMsQ0FBQztBQUM1RCxZQUFNLDJCQUFjLHlGQUF5RixHQUN2RyxxREFBcUQsR0FBRyxlQUFlLEdBQUcsbURBQW1ELEdBQUcsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLENBQUM7S0FDaEssTUFBTTs7QUFFTCxZQUFNLDJCQUFjLHdGQUF3RixHQUN0RyxpREFBaUQsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7S0FDbkY7R0FDRjtDQUNGOztBQUVNLFNBQVMsUUFBUSxDQUFDLFlBQVksRUFBRSxHQUFHLEVBQUU7O0FBRTFDLE1BQUksQ0FBQyxHQUFHLEVBQUU7QUFDUixVQUFNLDJCQUFjLG1DQUFtQyxDQUFDLENBQUM7R0FDMUQ7QUFDRCxNQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRTtBQUN2QyxVQUFNLDJCQUFjLDJCQUEyQixHQUFHLE9BQU8sWUFBWSxDQUFDLENBQUM7R0FDeEU7O0FBRUQsY0FBWSxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQzs7OztBQUlsRCxLQUFHLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7O0FBRTVDLFdBQVMsb0JBQW9CLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUU7QUFDdkQsUUFBSSxPQUFPLENBQUMsSUFBSSxFQUFFO0FBQ2hCLGFBQU8sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2xELFVBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUNmLGVBQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO09BQ3ZCO0tBQ0Y7O0FBRUQsV0FBTyxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztBQUN0RSxRQUFJLE1BQU0sR0FBRyxHQUFHLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7O0FBRXhFLFFBQUksTUFBTSxJQUFJLElBQUksSUFBSSxHQUFHLENBQUMsT0FBTyxFQUFFO0FBQ2pDLGFBQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxlQUFlLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDekYsWUFBTSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztLQUMzRDtBQUNELFFBQUksTUFBTSxJQUFJLElBQUksRUFBRTtBQUNsQixVQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUU7QUFDbEIsWUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUMvQixhQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzVDLGNBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDNUIsa0JBQU07V0FDUDs7QUFFRCxlQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdEM7QUFDRCxjQUFNLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztPQUMzQjtBQUNELGFBQU8sTUFBTSxDQUFDO0tBQ2YsTUFBTTtBQUNMLFlBQU0sMkJBQWMsY0FBYyxHQUFHLE9BQU8sQ0FBQyxJQUFJLEdBQUcsMERBQTBELENBQUMsQ0FBQztLQUNqSDtHQUNGOzs7QUFHRCxNQUFJLFNBQVMsR0FBRztBQUNkLFVBQU0sRUFBRSxnQkFBUyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFCLFVBQUksRUFBRSxJQUFJLElBQUksR0FBRyxDQUFBLEFBQUMsRUFBRTtBQUNsQixjQUFNLDJCQUFjLEdBQUcsR0FBRyxJQUFJLEdBQUcsbUJBQW1CLEdBQUcsR0FBRyxDQUFDLENBQUM7T0FDN0Q7QUFDRCxhQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNsQjtBQUNELFVBQU0sRUFBRSxnQkFBUyxNQUFNLEVBQUUsSUFBSSxFQUFFO0FBQzdCLFVBQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDMUIsV0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUM1QixZQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxFQUFFO0FBQ3hDLGlCQUFPLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN4QjtPQUNGO0tBQ0Y7QUFDRCxVQUFNLEVBQUUsZ0JBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUNqQyxhQUFPLE9BQU8sT0FBTyxLQUFLLFVBQVUsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLE9BQU8sQ0FBQztLQUN4RTs7QUFFRCxvQkFBZ0IsRUFBRSxLQUFLLENBQUMsZ0JBQWdCO0FBQ3hDLGlCQUFhLEVBQUUsb0JBQW9COztBQUVuQyxNQUFFLEVBQUUsWUFBUyxDQUFDLEVBQUU7QUFDZCxVQUFJLEdBQUcsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDMUIsU0FBRyxDQUFDLFNBQVMsR0FBRyxZQUFZLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQ3ZDLGFBQU8sR0FBRyxDQUFDO0tBQ1o7O0FBRUQsWUFBUSxFQUFFLEVBQUU7QUFDWixXQUFPLEVBQUUsaUJBQVMsQ0FBQyxFQUFFLElBQUksRUFBRSxtQkFBbUIsRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFO0FBQ25FLFVBQUksY0FBYyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1VBQ2pDLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLFVBQUksSUFBSSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksbUJBQW1CLEVBQUU7QUFDeEQsc0JBQWMsR0FBRyxXQUFXLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLG1CQUFtQixFQUFFLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztPQUMzRixNQUFNLElBQUksQ0FBQyxjQUFjLEVBQUU7QUFDMUIsc0JBQWMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO09BQzlEO0FBQ0QsYUFBTyxjQUFjLENBQUM7S0FDdkI7O0FBRUQsUUFBSSxFQUFFLGNBQVMsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUMzQixhQUFPLEtBQUssSUFBSSxLQUFLLEVBQUUsRUFBRTtBQUN2QixhQUFLLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQztPQUN2QjtBQUNELGFBQU8sS0FBSyxDQUFDO0tBQ2Q7QUFDRCxTQUFLLEVBQUUsZUFBUyxLQUFLLEVBQUUsTUFBTSxFQUFFO0FBQzdCLFVBQUksR0FBRyxHQUFHLEtBQUssSUFBSSxNQUFNLENBQUM7O0FBRTFCLFVBQUksS0FBSyxJQUFJLE1BQU0sSUFBSyxLQUFLLEtBQUssTUFBTSxBQUFDLEVBQUU7QUFDekMsV0FBRyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztPQUN2Qzs7QUFFRCxhQUFPLEdBQUcsQ0FBQztLQUNaOztBQUVELFFBQUksRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUk7QUFDakIsZ0JBQVksRUFBRSxZQUFZLENBQUMsUUFBUTtHQUNwQyxDQUFDOztBQUVGLFdBQVMsR0FBRyxDQUFDLE9BQU8sRUFBZ0I7UUFBZCxPQUFPLHlEQUFHLEVBQUU7O0FBQ2hDLFFBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUM7O0FBRXhCLE9BQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDcEIsUUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLElBQUksWUFBWSxDQUFDLE9BQU8sRUFBRTtBQUM1QyxVQUFJLEdBQUcsUUFBUSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztLQUNoQztBQUNELFFBQUksTUFBTSxZQUFBO1FBQ04sV0FBVyxHQUFHLFlBQVksQ0FBQyxjQUFjLEdBQUcsRUFBRSxHQUFHLFNBQVMsQ0FBQztBQUMvRCxRQUFJLFlBQVksQ0FBQyxTQUFTLEVBQUU7QUFDMUIsVUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFO0FBQ2xCLGNBQU0sR0FBRyxPQUFPLEtBQUssT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQztPQUM1RixNQUFNO0FBQ0wsY0FBTSxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7T0FDcEI7S0FDRjs7QUFFRCxhQUFTLElBQUksQ0FBQyxPQUFPLGdCQUFlO0FBQ2xDLGFBQU8sRUFBRSxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLE9BQU8sRUFBRSxTQUFTLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztLQUNySDtBQUNELFFBQUksR0FBRyxpQkFBaUIsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLE1BQU0sSUFBSSxFQUFFLEVBQUUsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBQ3RHLFdBQU8sSUFBSSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztHQUMvQjtBQUNELEtBQUcsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDOztBQUVqQixLQUFHLENBQUMsTUFBTSxHQUFHLFVBQVMsT0FBTyxFQUFFO0FBQzdCLFFBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFO0FBQ3BCLGVBQVMsQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7QUFFbEUsVUFBSSxZQUFZLENBQUMsVUFBVSxFQUFFO0FBQzNCLGlCQUFTLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7T0FDdEU7QUFDRCxVQUFJLFlBQVksQ0FBQyxVQUFVLElBQUksWUFBWSxDQUFDLGFBQWEsRUFBRTtBQUN6RCxpQkFBUyxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO09BQzVFO0tBQ0YsTUFBTTtBQUNMLGVBQVMsQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQztBQUNwQyxlQUFTLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUM7QUFDdEMsZUFBUyxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDO0tBQzNDO0dBQ0YsQ0FBQzs7QUFFRixLQUFHLENBQUMsTUFBTSxHQUFHLFVBQVMsQ0FBQyxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFO0FBQ2xELFFBQUksWUFBWSxDQUFDLGNBQWMsSUFBSSxDQUFDLFdBQVcsRUFBRTtBQUMvQyxZQUFNLDJCQUFjLHdCQUF3QixDQUFDLENBQUM7S0FDL0M7QUFDRCxRQUFJLFlBQVksQ0FBQyxTQUFTLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFDckMsWUFBTSwyQkFBYyx5QkFBeUIsQ0FBQyxDQUFDO0tBQ2hEOztBQUVELFdBQU8sV0FBVyxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0dBQ2pGLENBQUM7QUFDRixTQUFPLEdBQUcsQ0FBQztDQUNaOztBQUVNLFNBQVMsV0FBVyxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxtQkFBbUIsRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFO0FBQzVGLFdBQVMsSUFBSSxDQUFDLE9BQU8sRUFBZ0I7UUFBZCxPQUFPLHlEQUFHLEVBQUU7O0FBQ2pDLFFBQUksYUFBYSxHQUFHLE1BQU0sQ0FBQztBQUMzQixRQUFJLE1BQU0sSUFBSSxPQUFPLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFO0FBQ25DLG1CQUFhLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDMUM7O0FBRUQsV0FBTyxFQUFFLENBQUMsU0FBUyxFQUNmLE9BQU8sRUFDUCxTQUFTLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxRQUFRLEVBQ3JDLE9BQU8sQ0FBQyxJQUFJLElBQUksSUFBSSxFQUNwQixXQUFXLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUN4RCxhQUFhLENBQUMsQ0FBQztHQUNwQjs7QUFFRCxNQUFJLEdBQUcsaUJBQWlCLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQzs7QUFFekUsTUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7QUFDakIsTUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDeEMsTUFBSSxDQUFDLFdBQVcsR0FBRyxtQkFBbUIsSUFBSSxDQUFDLENBQUM7QUFDNUMsU0FBTyxJQUFJLENBQUM7Q0FDYjs7QUFFTSxTQUFTLGNBQWMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN4RCxNQUFJLENBQUMsT0FBTyxFQUFFO0FBQ1osUUFBSSxPQUFPLENBQUMsSUFBSSxLQUFLLGdCQUFnQixFQUFFO0FBQ3JDLGFBQU8sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0tBQ3pDLE1BQU07QUFDTCxhQUFPLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDMUM7R0FDRixNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRTs7QUFFekMsV0FBTyxDQUFDLElBQUksR0FBRyxPQUFPLENBQUM7QUFDdkIsV0FBTyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7R0FDckM7QUFDRCxTQUFPLE9BQU8sQ0FBQztDQUNoQjs7QUFFTSxTQUFTLGFBQWEsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN2RCxTQUFPLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztBQUN2QixNQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUU7QUFDZixXQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDO0dBQ3ZFOztBQUVELE1BQUksWUFBWSxZQUFBLENBQUM7QUFDakIsTUFBSSxPQUFPLENBQUMsRUFBRSxJQUFJLE9BQU8sQ0FBQyxFQUFFLEtBQUssSUFBSSxFQUFFO0FBQ3JDLFdBQU8sQ0FBQyxJQUFJLEdBQUcsTUF0TzJCLFdBQVcsQ0FzTzFCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN6QyxnQkFBWSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsT0FBTyxDQUFDLEVBQUUsQ0FBQzs7QUFFMUQsUUFBSSxZQUFZLENBQUMsUUFBUSxFQUFFO0FBQ3pCLGFBQU8sQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsT0FBTyxDQUFDLFFBQVEsRUFBRSxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7S0FDOUU7R0FDRjs7QUFFRCxNQUFJLE9BQU8sS0FBSyxTQUFTLElBQUksWUFBWSxFQUFFO0FBQ3pDLFdBQU8sR0FBRyxZQUFZLENBQUM7R0FDeEI7O0FBRUQsTUFBSSxPQUFPLEtBQUssU0FBUyxFQUFFO0FBQ3pCLFVBQU0sMkJBQWMsY0FBYyxHQUFHLE9BQU8sQ0FBQyxJQUFJLEdBQUcscUJBQXFCLENBQUMsQ0FBQztHQUM1RSxNQUFNLElBQUksT0FBTyxZQUFZLFFBQVEsRUFBRTtBQUN0QyxXQUFPLE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7R0FDbEM7Q0FDRjs7QUFFTSxTQUFTLElBQUksR0FBRztBQUFFLFNBQU8sRUFBRSxDQUFDO0NBQUU7O0FBRXJDLFNBQVMsUUFBUSxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUU7QUFDL0IsTUFBSSxDQUFDLElBQUksSUFBSSxFQUFFLE1BQU0sSUFBSSxJQUFJLENBQUEsQUFBQyxFQUFFO0FBQzlCLFFBQUksR0FBRyxJQUFJLEdBQUcsTUE3UDRCLFdBQVcsQ0E2UDNCLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNyQyxRQUFJLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQztHQUNyQjtBQUNELFNBQU8sSUFBSSxDQUFDO0NBQ2I7O0FBRUQsU0FBUyxpQkFBaUIsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRTtBQUN6RSxNQUFJLEVBQUUsQ0FBQyxTQUFTLEVBQUU7QUFDaEIsUUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDO0FBQ2YsUUFBSSxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsTUFBTSxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQzVGLFNBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO0dBQzNCO0FBQ0QsU0FBTyxJQUFJLENBQUM7Q0FDYjs7Ozs7Ozs7QUMzUUQsU0FBUyxVQUFVLENBQUMsTUFBTSxFQUFFO0FBQzFCLE1BQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0NBQ3RCOztBQUVELFVBQVUsQ0FBQyxTQUFTLENBQUMsUUFBUSxHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLFlBQVc7QUFDdkUsU0FBTyxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztDQUN6QixDQUFDOztxQkFFYSxVQUFVOzs7Ozs7Ozs7Ozs7Ozs7QUNUekIsSUFBTSxNQUFNLEdBQUc7QUFDYixLQUFHLEVBQUUsT0FBTztBQUNaLEtBQUcsRUFBRSxNQUFNO0FBQ1gsS0FBRyxFQUFFLE1BQU07QUFDWCxLQUFHLEVBQUUsUUFBUTtBQUNiLEtBQUcsRUFBRSxRQUFRO0FBQ2IsS0FBRyxFQUFFLFFBQVE7QUFDYixLQUFHLEVBQUUsUUFBUTtDQUNkLENBQUM7O0FBRUYsSUFBTSxRQUFRLEdBQUcsWUFBWTtJQUN2QixRQUFRLEdBQUcsV0FBVyxDQUFDOztBQUU3QixTQUFTLFVBQVUsQ0FBQyxHQUFHLEVBQUU7QUFDdkIsU0FBTyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7Q0FDcEI7O0FBRU0sU0FBUyxNQUFNLENBQUMsR0FBRyxvQkFBb0I7QUFDNUMsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDekMsU0FBSyxJQUFJLEdBQUcsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUU7QUFDNUIsVUFBSSxNQUFNLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFO0FBQzNELFdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDOUI7S0FDRjtHQUNGOztBQUVELFNBQU8sR0FBRyxDQUFDO0NBQ1o7O0FBRU0sSUFBSSxRQUFRLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUM7Ozs7OztBQUtoRCxJQUFJLFVBQVUsR0FBRyxvQkFBUyxLQUFLLEVBQUU7QUFDL0IsU0FBTyxPQUFPLEtBQUssS0FBSyxVQUFVLENBQUM7Q0FDcEMsQ0FBQzs7O0FBR0YsSUFBSSxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDbkIsVUFJTSxVQUFVLEdBSmhCLFVBQVUsR0FBRyxVQUFTLEtBQUssRUFBRTtBQUMzQixXQUFPLE9BQU8sS0FBSyxLQUFLLFVBQVUsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLG1CQUFtQixDQUFDO0dBQ3BGLENBQUM7Q0FDSDtRQUNPLFVBQVUsR0FBVixVQUFVOzs7OztBQUlYLElBQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFPLElBQUksVUFBUyxLQUFLLEVBQUU7QUFDdEQsU0FBTyxBQUFDLEtBQUssSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEdBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7Q0FDakcsQ0FBQzs7Ozs7QUFHSyxTQUFTLE9BQU8sQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFO0FBQ3BDLE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDaEQsUUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssS0FBSyxFQUFFO0FBQ3RCLGFBQU8sQ0FBQyxDQUFDO0tBQ1Y7R0FDRjtBQUNELFNBQU8sQ0FBQyxDQUFDLENBQUM7Q0FDWDs7QUFHTSxTQUFTLGdCQUFnQixDQUFDLE1BQU0sRUFBRTtBQUN2QyxNQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsRUFBRTs7QUFFOUIsUUFBSSxNQUFNLElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRTtBQUMzQixhQUFPLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQztLQUN4QixNQUFNLElBQUksTUFBTSxJQUFJLElBQUksRUFBRTtBQUN6QixhQUFPLEVBQUUsQ0FBQztLQUNYLE1BQU0sSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUNsQixhQUFPLE1BQU0sR0FBRyxFQUFFLENBQUM7S0FDcEI7Ozs7O0FBS0QsVUFBTSxHQUFHLEVBQUUsR0FBRyxNQUFNLENBQUM7R0FDdEI7O0FBRUQsTUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7QUFBRSxXQUFPLE1BQU0sQ0FBQztHQUFFO0FBQzlDLFNBQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLENBQUM7Q0FDN0M7O0FBRU0sU0FBUyxPQUFPLENBQUMsS0FBSyxFQUFFO0FBQzdCLE1BQUksQ0FBQyxLQUFLLElBQUksS0FBSyxLQUFLLENBQUMsRUFBRTtBQUN6QixXQUFPLElBQUksQ0FBQztHQUNiLE1BQU0sSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7QUFDL0MsV0FBTyxJQUFJLENBQUM7R0FDYixNQUFNO0FBQ0wsV0FBTyxLQUFLLENBQUM7R0FDZDtDQUNGOztBQUVNLFNBQVMsV0FBVyxDQUFDLE1BQU0sRUFBRTtBQUNsQyxNQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQy9CLE9BQUssQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO0FBQ3ZCLFNBQU8sS0FBSyxDQUFDO0NBQ2Q7O0FBRU0sU0FBUyxXQUFXLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRTtBQUN2QyxRQUFNLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQztBQUNsQixTQUFPLE1BQU0sQ0FBQztDQUNmOztBQUVNLFNBQVMsaUJBQWlCLENBQUMsV0FBVyxFQUFFLEVBQUUsRUFBRTtBQUNqRCxTQUFPLENBQUMsV0FBVyxHQUFHLFdBQVcsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFBLEdBQUksRUFBRSxDQUFDO0NBQ3BEOzs7O0FDM0dEO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDblBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDamJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdmFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDamtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3haQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3phQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKlxuICogRG9vcmF5IENhbGVuZGFyXG4gKiBAdmVyc2lvbiAwLjEuMTJcbiAqL1xuLyogZXNsaW50IHZhcnMtb24tdG9wOjAsIHN0cmljdDowICovXG5cbi8qKioqKioqKioqXG4gKiBDb21tb25cbiAqKioqKioqKioqL1xucmVxdWlyZSgndHVpLWNvZGUtc25pcHBldCcpO1xucmVxdWlyZSgnLi9zcmMvanMvdmlldy90ZW1wbGF0ZS9yZWdpc3RlckhlbHBlcnMnKTtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuL3NyYy9qcy9jb25maWcnKTtcbnZhciBkaXJ0eSA9IHJlcXVpcmUoJy4vc3JjL2pzL2NvbW1vbi9kaXJ0eScpO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi9zcmMvanMvY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgYXJyYXkgPSByZXF1aXJlKCcuL3NyYy9qcy9jb21tb24vYXJyYXknKTtcbnZhciBkb21ldmVudCA9IHJlcXVpcmUoJy4vc3JjL2pzL2NvbW1vbi9kb21ldmVudCcpO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuL3NyYy9qcy9jb21tb24vZG9tdXRpbCcpO1xudmFyIENvbGxlY2l0b24gPSByZXF1aXJlKCcuL3NyYy9qcy9jb21tb24vY29sbGVjdGlvbicpO1xudmFyIG1vZGVsID0gcmVxdWlyZSgnLi9zcmMvanMvY29tbW9uL21vZGVsJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9zcmMvanMvY29tbW9uL2NvbW1vbicpO1xudmFyIHJlcUFuaW1GcmFtZSA9IHJlcXVpcmUoJy4vc3JjL2pzL2NvbW1vbi9yZXFBbmltRnJhbWUnKTtcbnZhciBBSkFYID0gcmVxdWlyZSgnLi9zcmMvanMvY29tbW9uL2FqYXgnKTtcbnZhciBGaWxsUmVtYWluSGVpZ2h0ID0gcmVxdWlyZSgnLi9zcmMvanMvY29tbW9uL2ZpbGxSZW1haW5IZWlnaHQnKTtcblxuLyoqKioqKioqKipcbiAqIE1vZGVsc1xuICoqKioqKioqKiovXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL3NyYy9qcy9jb21tb24vcG9pbnQnKTtcbnZhciBDYWxFdmVudCA9IHJlcXVpcmUoJy4vc3JjL2pzL21vZGVsL2NhbEV2ZW50Jyk7XG52YXIgQ2FsRXZlbnRWaWV3TW9kZWwgPSByZXF1aXJlKCcuL3NyYy9qcy9tb2RlbC92aWV3TW9kZWwvY2FsRXZlbnQnKTtcblxuLyoqKioqKioqKipcbiAqIFZpZXdzXG4gKioqKioqKioqKi9cbnZhciBWaWV3ID0gcmVxdWlyZSgnLi9zcmMvanMvdmlldy92aWV3Jyk7XG5WaWV3LnByb3RvdHlwZS5jc3NQcmVmaXggPSBjb25maWcuY3NzUHJlZml4O1xuXG52YXIgTW9udGhXZWVrID0gcmVxdWlyZSgnLi9zcmMvanMvdmlldy9tb250aHdlZWsnKTtcbnZhciBXZWVrID0gcmVxdWlyZSgnLi9zcmMvanMvdmlldy93ZWVrL3dlZWsnKTtcbnZhciBEYXlOYW1lID0gcmVxdWlyZSgnLi9zcmMvanMvdmlldy93ZWVrL2RheW5hbWUnKTtcbnZhciBUaW1lR3JpZCA9IHJlcXVpcmUoJy4vc3JjL2pzL3ZpZXcvd2Vlay90aW1lR3JpZCcpO1xudmFyIFRpbWUgPSByZXF1aXJlKCcuL3NyYy9qcy92aWV3L3dlZWsvdGltZScpO1xuXG4vKioqKioqKioqKlxuICogSGFuZGxlcnNcbiAqKioqKioqKioqL1xudmFyIERyYWcgPSByZXF1aXJlKCcuL3NyYy9qcy9oYW5kbGVyL2RyYWcnKTtcbnZhciBUaW1lQ29yZSA9IHJlcXVpcmUoJy4vc3JjL2pzL2hhbmRsZXIvdGltZS9jb3JlJyk7XG52YXIgVGltZUNsaWNrID0gcmVxdWlyZSgnLi9zcmMvanMvaGFuZGxlci90aW1lL2NsaWNrJyk7XG52YXIgVGltZUNyZWF0aW9uID0gcmVxdWlyZSgnLi9zcmMvanMvaGFuZGxlci90aW1lL2NyZWF0aW9uJyk7XG52YXIgVGltZUNyZWF0aW9uR3VpZGUgPSByZXF1aXJlKCcuL3NyYy9qcy9oYW5kbGVyL3RpbWUvY3JlYXRpb25HdWlkZScpO1xudmFyIFRpbWVNb3ZlID0gcmVxdWlyZSgnLi9zcmMvanMvaGFuZGxlci90aW1lL21vdmUnKTtcbnZhciBUaW1lTW92ZUd1aWRlID0gcmVxdWlyZSgnLi9zcmMvanMvaGFuZGxlci90aW1lL21vdmVHdWlkZScpO1xudmFyIFRpbWVSZXNpemUgPSByZXF1aXJlKCcuL3NyYy9qcy9oYW5kbGVyL3RpbWUvcmVzaXplJyk7XG52YXIgVGltZVJlc2l6ZUd1aWRlID0gcmVxdWlyZSgnLi9zcmMvanMvaGFuZGxlci90aW1lL3Jlc2l6ZUd1aWRlJyk7XG5cbnZhciBBbGxkYXlDb3JlID0gcmVxdWlyZSgnLi9zcmMvanMvaGFuZGxlci9hbGxkYXkvY29yZScpO1xudmFyIEFsbGRheUNsaWNrID0gcmVxdWlyZSgnLi9zcmMvanMvaGFuZGxlci9hbGxkYXkvY2xpY2snKTtcbnZhciBBbGxkYXlDcmVhdGlvbiA9IHJlcXVpcmUoJy4vc3JjL2pzL2hhbmRsZXIvYWxsZGF5L2NyZWF0aW9uJyk7XG52YXIgQWxsZGF5Q3JlYXRpb25HdWlkZSA9IHJlcXVpcmUoJy4vc3JjL2pzL2hhbmRsZXIvYWxsZGF5L2NyZWF0aW9uR3VpZGUnKTtcbnZhciBBbGxkYXlNb3ZlID0gcmVxdWlyZSgnLi9zcmMvanMvaGFuZGxlci9hbGxkYXkvbW92ZScpO1xudmFyIEFsbGRheU1vdmVHdWlkZSA9IHJlcXVpcmUoJy4vc3JjL2pzL2hhbmRsZXIvYWxsZGF5L21vdmVHdWlkZScpO1xudmFyIEFsbGRheVJlc2l6ZSA9IHJlcXVpcmUoJy4vc3JjL2pzL2hhbmRsZXIvYWxsZGF5L3Jlc2l6ZScpO1xudmFyIEFsbGRheVJlc2l6ZUd1aWRlID0gcmVxdWlyZSgnLi9zcmMvanMvaGFuZGxlci9hbGxkYXkvcmVzaXplR3VpZGUnKTtcblxuLyoqKioqKioqKipcbiAqIEZhY3RvcnlcbiAqKioqKioqKioqL1xudmFyIGNvbnRyb2xsZXJGYWN0b3J5ID0gcmVxdWlyZSgnLi9zcmMvanMvZmFjdG9yeS9jb250cm9sbGVyJyk7XG5cbi8qKioqKioqKioqXG4gKiBTRVJWSUNFIE1PRFVMRVxuICoqKioqKioqKiovXG52YXIgTWluaUNhbGVuZGFyID0gcmVxdWlyZSgnLi9zcmMvanMvZG9vcmF5L3ZpZXcvbWluaWNhbGVuZGFyJyk7XG52YXIgRG9vcmF5RXZlbnQgPSByZXF1aXJlKCcuL3NyYy9qcy9kb29yYXkvbW9kZWwvY2FsRXZlbnQnKTtcbnZhciBEb29yYXlDb250cm9sbGVyID0gcmVxdWlyZSgnLi9zcmMvanMvZG9vcmF5L2NvbnRyb2xsZXIvYmFzZScpO1xudmFyIFRhc2tWaWV3ID0gcmVxdWlyZSgnLi9zcmMvanMvZG9vcmF5L3ZpZXcvdGFza3ZpZXcnKTtcbnZhciBNaWxlc3RvbmVDbGljayA9IHJlcXVpcmUoJy4vc3JjL2pzL2Rvb3JheS9oYW5kbGVyL21pbGVzdG9uZUNsaWNrJyk7XG52YXIgVGFza0NsaWNrID0gcmVxdWlyZSgnLi9zcmMvanMvZG9vcmF5L2hhbmRsZXIvdGFza0NsaWNrJyk7XG5cbi8qKioqKioqKioqXG4gKiBDYWxlbmRhciBGYWN0b3J5XG4gKioqKioqKioqKi9cblxudmFyIENhbGVuZGFyID0gcmVxdWlyZSgnLi9zcmMvanMvZmFjdG9yeS9jYWxlbmRhcicpO1xudmFyIFNlcnZpY2VDYWxlbmRhciA9IHJlcXVpcmUoJy4vc3JjL2pzL2Rvb3JheS9mYWN0b3J5L2NhbGVuZGFyJyk7XG5cbi8qKiBAbmFtZXNwYWNlIG5lLmRvb3JheS5jYWxlbmRhciAqL1xuZ2xvYmFsLnR1aS51dGlsLmRlZmluZU5hbWVzcGFjZSgnbmUuZG9vcmF5LmNhbGVuZGFyJywge1xuICAgIC8vIGNvbW1vblxuICAgIGNvbmZpZzogY29uZmlnLFxuICAgIGRpcnR5OiBkaXJ0eSxcbiAgICBkYXRldGltZTogZGF0ZXRpbWUsXG4gICAgYXJyYXk6IGFycmF5LFxuICAgIGRvbWV2ZW50OiBkb21ldmVudCxcbiAgICBkb211dGlsOiBkb211dGlsLFxuICAgIENvbGxlY3Rpb246IENvbGxlY2l0b24sXG4gICAgbW9kZWw6IG1vZGVsLFxuICAgIGNvbW1vbjogY29tbW9uLFxuICAgIHJlcUFuaW1GcmFtZTogcmVxQW5pbUZyYW1lLFxuICAgIEFKQVg6IEFKQVgsXG4gICAgUG9pbnQ6IFBvaW50LCBcbiAgICBGaWxsUmVtYWluSGVpZ2h0OiBGaWxsUmVtYWluSGVpZ2h0LFxuXG4gICAgLy8gbW9kZWxcbiAgICBDYWxFdmVudDogQ2FsRXZlbnQsXG4gICAgQ2FsRXZlbnRWaWV3TW9kZWw6IENhbEV2ZW50Vmlld01vZGVsLFxuXG4gICAgLy8gdmlld1xuICAgIFZpZXc6IFZpZXcsXG4gICAgV2VlazogV2VlayxcbiAgICBEYXlOYW1lOiBEYXlOYW1lLFxuICAgIFRpbWVHcmlkOiBUaW1lR3JpZCxcbiAgICBUaW1lOiBUaW1lLFxuICAgIE1vbnRoV2VlazogTW9udGhXZWVrLFxuXG4gICAgLy8gaGFuZGxlciwgZ3VpZGVcbiAgICBEcmFnOiBEcmFnLFxuXG4gICAgVGltZUNvcmU6IFRpbWVDb3JlLFxuICAgIFRpbWVDbGljazogVGltZUNsaWNrLFxuICAgIFRpbWVDcmVhdGlvbjogVGltZUNyZWF0aW9uLFxuICAgIFRpbWVDcmVhdGlvbkd1aWRlOiBUaW1lQ3JlYXRpb25HdWlkZSxcbiAgICBUaW1lTW92ZTogVGltZU1vdmUsXG4gICAgVGltZU1vdmVHdWlkZTogVGltZU1vdmVHdWlkZSxcbiAgICBUaW1lUmVzaXplOiBUaW1lUmVzaXplLFxuICAgIFRpbWVSZXNpemVHdWlkZTogVGltZVJlc2l6ZUd1aWRlLFxuXG4gICAgQWxsZGF5Q29yZTogQWxsZGF5Q29yZSxcbiAgICBBbGxkYXlDbGljazogQWxsZGF5Q2xpY2ssXG4gICAgQWxsZGF5Q3JlYXRpb246IEFsbGRheUNyZWF0aW9uLFxuICAgIEFsbGRheUNyZWF0aW9uR3VpZGU6IEFsbGRheUNyZWF0aW9uR3VpZGUsXG4gICAgQWxsZGF5TW92ZTogQWxsZGF5TW92ZSxcbiAgICBBbGxkYXlNb3ZlR3VpZGU6IEFsbGRheU1vdmVHdWlkZSxcbiAgICBBbGxkYXlSZXNpemU6IEFsbGRheVJlc2l6ZSxcbiAgICBBbGxkYXlSZXNpemVHdWlkZTogQWxsZGF5UmVzaXplR3VpZGUsXG5cbiAgICAvLyBvbmx5IGZvciB0ZXN0XG4gICAgQ29udHJvbGxlckZhY3Rvcnk6IGNvbnRyb2xsZXJGYWN0b3J5LFxuXG4gICAgLy8gc2VydmljZSBtb2R1bGVzXG4gICAgRG9vcmF5RXZlbnQ6IERvb3JheUV2ZW50LFxuICAgIERvb3JheUNvbnRyb2xsZXI6IERvb3JheUNvbnRyb2xsZXIsXG4gICAgTWluaUNhbGVuZGFyOiBNaW5pQ2FsZW5kYXIsXG4gICAgVGFza1ZpZXc6IFRhc2tWaWV3LFxuICAgIE1pbGVzdG9uZUNsaWNrOiBNaWxlc3RvbmVDbGljayxcbiAgICBUYXNrQ2xpY2s6IFRhc2tDbGljayxcblxuICAgIC8vIGZhY3RvcnkgY2xhc3NcbiAgICBPcmlnaW5DYWxlbmRhcjogQ2FsZW5kYXIsXG4gICAgRnVsbENhbGVuZGFyOiBTZXJ2aWNlQ2FsZW5kYXJcbn0pO1xuXG4iLG51bGwsImltcG9ydCAqIGFzIGJhc2UgZnJvbSAnLi9oYW5kbGViYXJzL2Jhc2UnO1xuXG4vLyBFYWNoIG9mIHRoZXNlIGF1Z21lbnQgdGhlIEhhbmRsZWJhcnMgb2JqZWN0LiBObyBuZWVkIHRvIHNldHVwIGhlcmUuXG4vLyAoVGhpcyBpcyBkb25lIHRvIGVhc2lseSBzaGFyZSBjb2RlIGJldHdlZW4gY29tbW9uanMgYW5kIGJyb3dzZSBlbnZzKVxuaW1wb3J0IFNhZmVTdHJpbmcgZnJvbSAnLi9oYW5kbGViYXJzL3NhZmUtc3RyaW5nJztcbmltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi9oYW5kbGViYXJzL2V4Y2VwdGlvbic7XG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tICcuL2hhbmRsZWJhcnMvdXRpbHMnO1xuaW1wb3J0ICogYXMgcnVudGltZSBmcm9tICcuL2hhbmRsZWJhcnMvcnVudGltZSc7XG5cbmltcG9ydCBub0NvbmZsaWN0IGZyb20gJy4vaGFuZGxlYmFycy9uby1jb25mbGljdCc7XG5cbi8vIEZvciBjb21wYXRpYmlsaXR5IGFuZCB1c2FnZSBvdXRzaWRlIG9mIG1vZHVsZSBzeXN0ZW1zLCBtYWtlIHRoZSBIYW5kbGViYXJzIG9iamVjdCBhIG5hbWVzcGFjZVxuZnVuY3Rpb24gY3JlYXRlKCkge1xuICBsZXQgaGIgPSBuZXcgYmFzZS5IYW5kbGViYXJzRW52aXJvbm1lbnQoKTtcblxuICBVdGlscy5leHRlbmQoaGIsIGJhc2UpO1xuICBoYi5TYWZlU3RyaW5nID0gU2FmZVN0cmluZztcbiAgaGIuRXhjZXB0aW9uID0gRXhjZXB0aW9uO1xuICBoYi5VdGlscyA9IFV0aWxzO1xuICBoYi5lc2NhcGVFeHByZXNzaW9uID0gVXRpbHMuZXNjYXBlRXhwcmVzc2lvbjtcblxuICBoYi5WTSA9IHJ1bnRpbWU7XG4gIGhiLnRlbXBsYXRlID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHJldHVybiBydW50aW1lLnRlbXBsYXRlKHNwZWMsIGhiKTtcbiAgfTtcblxuICByZXR1cm4gaGI7XG59XG5cbmxldCBpbnN0ID0gY3JlYXRlKCk7XG5pbnN0LmNyZWF0ZSA9IGNyZWF0ZTtcblxubm9Db25mbGljdChpbnN0KTtcblxuaW5zdFsnZGVmYXVsdCddID0gaW5zdDtcblxuZXhwb3J0IGRlZmF1bHQgaW5zdDtcbiIsImltcG9ydCB7Y3JlYXRlRnJhbWUsIGV4dGVuZCwgdG9TdHJpbmd9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuL2V4Y2VwdGlvbic7XG5pbXBvcnQge3JlZ2lzdGVyRGVmYXVsdEhlbHBlcnN9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQge3JlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnN9IGZyb20gJy4vZGVjb3JhdG9ycyc7XG5pbXBvcnQgbG9nZ2VyIGZyb20gJy4vbG9nZ2VyJztcblxuZXhwb3J0IGNvbnN0IFZFUlNJT04gPSAnNC4wLjQnO1xuZXhwb3J0IGNvbnN0IENPTVBJTEVSX1JFVklTSU9OID0gNztcblxuZXhwb3J0IGNvbnN0IFJFVklTSU9OX0NIQU5HRVMgPSB7XG4gIDE6ICc8PSAxLjAucmMuMicsIC8vIDEuMC5yYy4yIGlzIGFjdHVhbGx5IHJldjIgYnV0IGRvZXNuJ3QgcmVwb3J0IGl0XG4gIDI6ICc9PSAxLjAuMC1yYy4zJyxcbiAgMzogJz09IDEuMC4wLXJjLjQnLFxuICA0OiAnPT0gMS54LngnLFxuICA1OiAnPT0gMi4wLjAtYWxwaGEueCcsXG4gIDY6ICc+PSAyLjAuMC1iZXRhLjEnLFxuICA3OiAnPj0gNC4wLjAnXG59O1xuXG5jb25zdCBvYmplY3RUeXBlID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBIYW5kbGViYXJzRW52aXJvbm1lbnQoaGVscGVycywgcGFydGlhbHMsIGRlY29yYXRvcnMpIHtcbiAgdGhpcy5oZWxwZXJzID0gaGVscGVycyB8fCB7fTtcbiAgdGhpcy5wYXJ0aWFscyA9IHBhcnRpYWxzIHx8IHt9O1xuICB0aGlzLmRlY29yYXRvcnMgPSBkZWNvcmF0b3JzIHx8IHt9O1xuXG4gIHJlZ2lzdGVyRGVmYXVsdEhlbHBlcnModGhpcyk7XG4gIHJlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnModGhpcyk7XG59XG5cbkhhbmRsZWJhcnNFbnZpcm9ubWVudC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBIYW5kbGViYXJzRW52aXJvbm1lbnQsXG5cbiAgbG9nZ2VyOiBsb2dnZXIsXG4gIGxvZzogbG9nZ2VyLmxvZyxcblxuICByZWdpc3RlckhlbHBlcjogZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgaWYgKGZuKSB7IHRocm93IG5ldyBFeGNlcHRpb24oJ0FyZyBub3Qgc3VwcG9ydGVkIHdpdGggbXVsdGlwbGUgaGVscGVycycpOyB9XG4gICAgICBleHRlbmQodGhpcy5oZWxwZXJzLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWxwZXJzW25hbWVdID0gZm47XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVySGVscGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuaGVscGVyc1tuYW1lXTtcbiAgfSxcblxuICByZWdpc3RlclBhcnRpYWw6IGZ1bmN0aW9uKG5hbWUsIHBhcnRpYWwpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgZXh0ZW5kKHRoaXMucGFydGlhbHMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHBhcnRpYWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oYEF0dGVtcHRpbmcgdG8gcmVnaXN0ZXIgYSBwYXJ0aWFsIGNhbGxlZCBcIiR7bmFtZX1cIiBhcyB1bmRlZmluZWRgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFydGlhbHNbbmFtZV0gPSBwYXJ0aWFsO1xuICAgIH1cbiAgfSxcbiAgdW5yZWdpc3RlclBhcnRpYWw6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5wYXJ0aWFsc1tuYW1lXTtcbiAgfSxcblxuICByZWdpc3RlckRlY29yYXRvcjogZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgaWYgKGZuKSB7IHRocm93IG5ldyBFeGNlcHRpb24oJ0FyZyBub3Qgc3VwcG9ydGVkIHdpdGggbXVsdGlwbGUgZGVjb3JhdG9ycycpOyB9XG4gICAgICBleHRlbmQodGhpcy5kZWNvcmF0b3JzLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWNvcmF0b3JzW25hbWVdID0gZm47XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVyRGVjb3JhdG9yOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuZGVjb3JhdG9yc1tuYW1lXTtcbiAgfVxufTtcblxuZXhwb3J0IGxldCBsb2cgPSBsb2dnZXIubG9nO1xuXG5leHBvcnQge2NyZWF0ZUZyYW1lLCBsb2dnZXJ9O1xuIiwiaW1wb3J0IHJlZ2lzdGVySW5saW5lIGZyb20gJy4vZGVjb3JhdG9ycy9pbmxpbmUnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0RGVjb3JhdG9ycyhpbnN0YW5jZSkge1xuICByZWdpc3RlcklubGluZShpbnN0YW5jZSk7XG59XG5cbiIsImltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVyRGVjb3JhdG9yKCdpbmxpbmUnLCBmdW5jdGlvbihmbiwgcHJvcHMsIGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgIGxldCByZXQgPSBmbjtcbiAgICBpZiAoIXByb3BzLnBhcnRpYWxzKSB7XG4gICAgICBwcm9wcy5wYXJ0aWFscyA9IHt9O1xuICAgICAgcmV0ID0gZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgcGFydGlhbHMgc3RhY2sgZnJhbWUgcHJpb3IgdG8gZXhlYy5cbiAgICAgICAgbGV0IG9yaWdpbmFsID0gY29udGFpbmVyLnBhcnRpYWxzO1xuICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBleHRlbmQoe30sIG9yaWdpbmFsLCBwcm9wcy5wYXJ0aWFscyk7XG4gICAgICAgIGxldCByZXQgPSBmbihjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gb3JpZ2luYWw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHByb3BzLnBhcnRpYWxzW29wdGlvbnMuYXJnc1swXV0gPSBvcHRpb25zLmZuO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59XG4iLCJcbmNvbnN0IGVycm9yUHJvcHMgPSBbJ2Rlc2NyaXB0aW9uJywgJ2ZpbGVOYW1lJywgJ2xpbmVOdW1iZXInLCAnbWVzc2FnZScsICduYW1lJywgJ251bWJlcicsICdzdGFjayddO1xuXG5mdW5jdGlvbiBFeGNlcHRpb24obWVzc2FnZSwgbm9kZSkge1xuICBsZXQgbG9jID0gbm9kZSAmJiBub2RlLmxvYyxcbiAgICAgIGxpbmUsXG4gICAgICBjb2x1bW47XG4gIGlmIChsb2MpIHtcbiAgICBsaW5lID0gbG9jLnN0YXJ0LmxpbmU7XG4gICAgY29sdW1uID0gbG9jLnN0YXJ0LmNvbHVtbjtcblxuICAgIG1lc3NhZ2UgKz0gJyAtICcgKyBsaW5lICsgJzonICsgY29sdW1uO1xuICB9XG5cbiAgbGV0IHRtcCA9IEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuXG4gIC8vIFVuZm9ydHVuYXRlbHkgZXJyb3JzIGFyZSBub3QgZW51bWVyYWJsZSBpbiBDaHJvbWUgKGF0IGxlYXN0KSwgc28gYGZvciBwcm9wIGluIHRtcGAgZG9lc24ndCB3b3JrLlxuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBlcnJvclByb3BzLmxlbmd0aDsgaWR4KyspIHtcbiAgICB0aGlzW2Vycm9yUHJvcHNbaWR4XV0gPSB0bXBbZXJyb3JQcm9wc1tpZHhdXTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEV4Y2VwdGlvbik7XG4gIH1cblxuICBpZiAobG9jKSB7XG4gICAgdGhpcy5saW5lTnVtYmVyID0gbGluZTtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgfVxufVxuXG5FeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbmV4cG9ydCBkZWZhdWx0IEV4Y2VwdGlvbjtcbiIsImltcG9ydCByZWdpc3RlckJsb2NrSGVscGVyTWlzc2luZyBmcm9tICcuL2hlbHBlcnMvYmxvY2staGVscGVyLW1pc3NpbmcnO1xuaW1wb3J0IHJlZ2lzdGVyRWFjaCBmcm9tICcuL2hlbHBlcnMvZWFjaCc7XG5pbXBvcnQgcmVnaXN0ZXJIZWxwZXJNaXNzaW5nIGZyb20gJy4vaGVscGVycy9oZWxwZXItbWlzc2luZyc7XG5pbXBvcnQgcmVnaXN0ZXJJZiBmcm9tICcuL2hlbHBlcnMvaWYnO1xuaW1wb3J0IHJlZ2lzdGVyTG9nIGZyb20gJy4vaGVscGVycy9sb2cnO1xuaW1wb3J0IHJlZ2lzdGVyTG9va3VwIGZyb20gJy4vaGVscGVycy9sb29rdXAnO1xuaW1wb3J0IHJlZ2lzdGVyV2l0aCBmcm9tICcuL2hlbHBlcnMvd2l0aCc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHRIZWxwZXJzKGluc3RhbmNlKSB7XG4gIHJlZ2lzdGVyQmxvY2tIZWxwZXJNaXNzaW5nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJFYWNoKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJIZWxwZXJNaXNzaW5nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJJZihpbnN0YW5jZSk7XG4gIHJlZ2lzdGVyTG9nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJMb29rdXAoaW5zdGFuY2UpO1xuICByZWdpc3RlcldpdGgoaW5zdGFuY2UpO1xufVxuIiwiaW1wb3J0IHthcHBlbmRDb250ZXh0UGF0aCwgY3JlYXRlRnJhbWUsIGlzQXJyYXl9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2Jsb2NrSGVscGVyTWlzc2luZycsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBsZXQgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZSxcbiAgICAgICAgZm4gPSBvcHRpb25zLmZuO1xuXG4gICAgaWYgKGNvbnRleHQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBmbih0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRleHQgPT09IGZhbHNlIHx8IGNvbnRleHQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGludmVyc2UodGhpcyk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGNvbnRleHQpKSB7XG4gICAgICBpZiAoY29udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmlkcykge1xuICAgICAgICAgIG9wdGlvbnMuaWRzID0gW29wdGlvbnMubmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5zdGFuY2UuaGVscGVycy5lYWNoKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGludmVyc2UodGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLm5hbWUpO1xuICAgICAgICBvcHRpb25zID0ge2RhdGE6IGRhdGF9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbn1cbiIsImltcG9ydCB7YXBwZW5kQ29udGV4dFBhdGgsIGJsb2NrUGFyYW1zLCBjcmVhdGVGcmFtZSwgaXNBcnJheSwgaXNGdW5jdGlvbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuLi9leGNlcHRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignZWFjaCcsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ011c3QgcGFzcyBpdGVyYXRvciB0byAjZWFjaCcpO1xuICAgIH1cblxuICAgIGxldCBmbiA9IG9wdGlvbnMuZm4sXG4gICAgICAgIGludmVyc2UgPSBvcHRpb25zLmludmVyc2UsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICByZXQgPSAnJyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dFBhdGg7XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG4gICAgICBjb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pICsgJy4nO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRleHQpKSB7IGNvbnRleHQgPSBjb250ZXh0LmNhbGwodGhpcyk7IH1cblxuICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4ZWNJdGVyYXRpb24oZmllbGQsIGluZGV4LCBsYXN0KSB7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBkYXRhLmtleSA9IGZpZWxkO1xuICAgICAgICBkYXRhLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGRhdGEuZmlyc3QgPSBpbmRleCA9PT0gMDtcbiAgICAgICAgZGF0YS5sYXN0ID0gISFsYXN0O1xuXG4gICAgICAgIGlmIChjb250ZXh0UGF0aCkge1xuICAgICAgICAgIGRhdGEuY29udGV4dFBhdGggPSBjb250ZXh0UGF0aCArIGZpZWxkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldCA9IHJldCArIGZuKGNvbnRleHRbZmllbGRdLCB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyhbY29udGV4dFtmaWVsZF0sIGZpZWxkXSwgW2NvbnRleHRQYXRoICsgZmllbGQsIG51bGxdKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoaXNBcnJheShjb250ZXh0KSkge1xuICAgICAgICBmb3IgKGxldCBqID0gY29udGV4dC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICBpZiAoaSBpbiBjb250ZXh0KSB7XG4gICAgICAgICAgICBleGVjSXRlcmF0aW9uKGksIGksIGkgPT09IGNvbnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcHJpb3JLZXk7XG5cbiAgICAgICAgZm9yIChsZXQga2V5IGluIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBydW5uaW5nIHRoZSBpdGVyYXRpb25zIG9uZSBzdGVwIG91dCBvZiBzeW5jIHNvIHdlIGNhbiBkZXRlY3RcbiAgICAgICAgICAgIC8vIHRoZSBsYXN0IGl0ZXJhdGlvbiB3aXRob3V0IGhhdmUgdG8gc2NhbiB0aGUgb2JqZWN0IHR3aWNlIGFuZCBjcmVhdGVcbiAgICAgICAgICAgIC8vIGFuIGl0ZXJtZWRpYXRlIGtleXMgYXJyYXkuXG4gICAgICAgICAgICBpZiAocHJpb3JLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBleGVjSXRlcmF0aW9uKHByaW9yS2V5LCBpIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmlvcktleSA9IGtleTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaW9yS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBleGVjSXRlcmF0aW9uKHByaW9yS2V5LCBpIC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgcmV0ID0gaW52ZXJzZSh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cbiIsImltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi4vZXhjZXB0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbigvKiBbYXJncywgXW9wdGlvbnMgKi8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gQSBtaXNzaW5nIGZpZWxkIGluIGEge3tmb299fSBjb25zdHJ1Y3QuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTb21lb25lIGlzIGFjdHVhbGx5IHRyeWluZyB0byBjYWxsIHNvbWV0aGluZywgYmxvdyB1cC5cbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ01pc3NpbmcgaGVscGVyOiBcIicgKyBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdLm5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH0pO1xufVxuIiwiaW1wb3J0IHtpc0VtcHR5LCBpc0Z1bmN0aW9ufSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdpZicsIGZ1bmN0aW9uKGNvbmRpdGlvbmFsLCBvcHRpb25zKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oY29uZGl0aW9uYWwpKSB7IGNvbmRpdGlvbmFsID0gY29uZGl0aW9uYWwuY2FsbCh0aGlzKTsgfVxuXG4gICAgLy8gRGVmYXVsdCBiZWhhdmlvciBpcyB0byByZW5kZXIgdGhlIHBvc2l0aXZlIHBhdGggaWYgdGhlIHZhbHVlIGlzIHRydXRoeSBhbmQgbm90IGVtcHR5LlxuICAgIC8vIFRoZSBgaW5jbHVkZVplcm9gIG9wdGlvbiBtYXkgYmUgc2V0IHRvIHRyZWF0IHRoZSBjb25kdGlvbmFsIGFzIHB1cmVseSBub3QgZW1wdHkgYmFzZWQgb24gdGhlXG4gICAgLy8gYmVoYXZpb3Igb2YgaXNFbXB0eS4gRWZmZWN0aXZlbHkgdGhpcyBkZXRlcm1pbmVzIGlmIDAgaXMgaGFuZGxlZCBieSB0aGUgcG9zaXRpdmUgcGF0aCBvciBuZWdhdGl2ZS5cbiAgICBpZiAoKCFvcHRpb25zLmhhc2guaW5jbHVkZVplcm8gJiYgIWNvbmRpdGlvbmFsKSB8fCBpc0VtcHR5KGNvbmRpdGlvbmFsKSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuZm4odGhpcyk7XG4gICAgfVxuICB9KTtcblxuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcigndW5sZXNzJywgZnVuY3Rpb24oY29uZGl0aW9uYWwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuaGVscGVyc1snaWYnXS5jYWxsKHRoaXMsIGNvbmRpdGlvbmFsLCB7Zm46IG9wdGlvbnMuaW52ZXJzZSwgaW52ZXJzZTogb3B0aW9ucy5mbiwgaGFzaDogb3B0aW9ucy5oYXNofSk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvZycsIGZ1bmN0aW9uKC8qIG1lc3NhZ2UsIG9wdGlvbnMgKi8pIHtcbiAgICBsZXQgYXJncyA9IFt1bmRlZmluZWRdLFxuICAgICAgICBvcHRpb25zID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIGxldCBsZXZlbCA9IDE7XG4gICAgaWYgKG9wdGlvbnMuaGFzaC5sZXZlbCAhPSBudWxsKSB7XG4gICAgICBsZXZlbCA9IG9wdGlvbnMuaGFzaC5sZXZlbDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmRhdGEubGV2ZWwgIT0gbnVsbCkge1xuICAgICAgbGV2ZWwgPSBvcHRpb25zLmRhdGEubGV2ZWw7XG4gICAgfVxuICAgIGFyZ3NbMF0gPSBsZXZlbDtcblxuICAgIGluc3RhbmNlLmxvZyguLi4gYXJncyk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvb2t1cCcsIGZ1bmN0aW9uKG9iaiwgZmllbGQpIHtcbiAgICByZXR1cm4gb2JqICYmIG9ialtmaWVsZF07XG4gIH0pO1xufVxuIiwiaW1wb3J0IHthcHBlbmRDb250ZXh0UGF0aCwgYmxvY2tQYXJhbXMsIGNyZWF0ZUZyYW1lLCBpc0VtcHR5LCBpc0Z1bmN0aW9ufSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCd3aXRoJywgZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRleHQpKSB7IGNvbnRleHQgPSBjb250ZXh0LmNhbGwodGhpcyk7IH1cblxuICAgIGxldCBmbiA9IG9wdGlvbnMuZm47XG5cbiAgICBpZiAoIWlzRW1wdHkoY29udGV4dCkpIHtcbiAgICAgIGxldCBkYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlkcykge1xuICAgICAgICBkYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4oY29udGV4dCwge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBibG9ja1BhcmFtczogYmxvY2tQYXJhbXMoW2NvbnRleHRdLCBbZGF0YSAmJiBkYXRhLmNvbnRleHRQYXRoXSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgIH1cbiAgfSk7XG59XG4iLCJpbXBvcnQge2luZGV4T2Z9IGZyb20gJy4vdXRpbHMnO1xuXG5sZXQgbG9nZ2VyID0ge1xuICBtZXRob2RNYXA6IFsnZGVidWcnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJ10sXG4gIGxldmVsOiAnaW5mbycsXG5cbiAgLy8gTWFwcyBhIGdpdmVuIGxldmVsIHZhbHVlIHRvIHRoZSBgbWV0aG9kTWFwYCBpbmRleGVzIGFib3ZlLlxuICBsb29rdXBMZXZlbDogZnVuY3Rpb24obGV2ZWwpIHtcbiAgICBpZiAodHlwZW9mIGxldmVsID09PSAnc3RyaW5nJykge1xuICAgICAgbGV0IGxldmVsTWFwID0gaW5kZXhPZihsb2dnZXIubWV0aG9kTWFwLCBsZXZlbC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIGlmIChsZXZlbE1hcCA+PSAwKSB7XG4gICAgICAgIGxldmVsID0gbGV2ZWxNYXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbCA9IHBhcnNlSW50KGxldmVsLCAxMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxldmVsO1xuICB9LFxuXG4gIC8vIENhbiBiZSBvdmVycmlkZGVuIGluIHRoZSBob3N0IGVudmlyb25tZW50XG4gIGxvZzogZnVuY3Rpb24obGV2ZWwsIC4uLm1lc3NhZ2UpIHtcbiAgICBsZXZlbCA9IGxvZ2dlci5sb29rdXBMZXZlbChsZXZlbCk7XG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGxvZ2dlci5sb29rdXBMZXZlbChsb2dnZXIubGV2ZWwpIDw9IGxldmVsKSB7XG4gICAgICBsZXQgbWV0aG9kID0gbG9nZ2VyLm1ldGhvZE1hcFtsZXZlbF07XG4gICAgICBpZiAoIWNvbnNvbGVbbWV0aG9kXSkgeyAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICBtZXRob2QgPSAnbG9nJztcbiAgICAgIH1cbiAgICAgIGNvbnNvbGVbbWV0aG9kXSguLi5tZXNzYWdlKTsgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBsb2dnZXI7XG4iLCIvKiBnbG9iYWwgd2luZG93ICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihIYW5kbGViYXJzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGxldCByb290ID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3csXG4gICAgICAkSGFuZGxlYmFycyA9IHJvb3QuSGFuZGxlYmFycztcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgSGFuZGxlYmFycy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHJvb3QuSGFuZGxlYmFycyA9PT0gSGFuZGxlYmFycykge1xuICAgICAgcm9vdC5IYW5kbGViYXJzID0gJEhhbmRsZWJhcnM7XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4vZXhjZXB0aW9uJztcbmltcG9ydCB7IENPTVBJTEVSX1JFVklTSU9OLCBSRVZJU0lPTl9DSEFOR0VTLCBjcmVhdGVGcmFtZSB9IGZyb20gJy4vYmFzZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1JldmlzaW9uKGNvbXBpbGVySW5mbykge1xuICBjb25zdCBjb21waWxlclJldmlzaW9uID0gY29tcGlsZXJJbmZvICYmIGNvbXBpbGVySW5mb1swXSB8fCAxLFxuICAgICAgICBjdXJyZW50UmV2aXNpb24gPSBDT01QSUxFUl9SRVZJU0lPTjtcblxuICBpZiAoY29tcGlsZXJSZXZpc2lvbiAhPT0gY3VycmVudFJldmlzaW9uKSB7XG4gICAgaWYgKGNvbXBpbGVyUmV2aXNpb24gPCBjdXJyZW50UmV2aXNpb24pIHtcbiAgICAgIGNvbnN0IHJ1bnRpbWVWZXJzaW9ucyA9IFJFVklTSU9OX0NIQU5HRVNbY3VycmVudFJldmlzaW9uXSxcbiAgICAgICAgICAgIGNvbXBpbGVyVmVyc2lvbnMgPSBSRVZJU0lPTl9DSEFOR0VTW2NvbXBpbGVyUmV2aXNpb25dO1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVGVtcGxhdGUgd2FzIHByZWNvbXBpbGVkIHdpdGggYW4gb2xkZXIgdmVyc2lvbiBvZiBIYW5kbGViYXJzIHRoYW4gdGhlIGN1cnJlbnQgcnVudGltZS4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIHVwZGF0ZSB5b3VyIHByZWNvbXBpbGVyIHRvIGEgbmV3ZXIgdmVyc2lvbiAoJyArIHJ1bnRpbWVWZXJzaW9ucyArICcpIG9yIGRvd25ncmFkZSB5b3VyIHJ1bnRpbWUgdG8gYW4gb2xkZXIgdmVyc2lvbiAoJyArIGNvbXBpbGVyVmVyc2lvbnMgKyAnKS4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXNlIHRoZSBlbWJlZGRlZCB2ZXJzaW9uIGluZm8gc2luY2UgdGhlIHJ1bnRpbWUgZG9lc24ndCBrbm93IGFib3V0IHRoaXMgcmV2aXNpb24geWV0XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdUZW1wbGF0ZSB3YXMgcHJlY29tcGlsZWQgd2l0aCBhIG5ld2VyIHZlcnNpb24gb2YgSGFuZGxlYmFycyB0aGFuIHRoZSBjdXJyZW50IHJ1bnRpbWUuICcgK1xuICAgICAgICAgICAgJ1BsZWFzZSB1cGRhdGUgeW91ciBydW50aW1lIHRvIGEgbmV3ZXIgdmVyc2lvbiAoJyArIGNvbXBpbGVySW5mb1sxXSArICcpLicpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGUodGVtcGxhdGVTcGVjLCBlbnYpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKCFlbnYpIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdObyBlbnZpcm9ubWVudCBwYXNzZWQgdG8gdGVtcGxhdGUnKTtcbiAgfVxuICBpZiAoIXRlbXBsYXRlU3BlYyB8fCAhdGVtcGxhdGVTcGVjLm1haW4pIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdVbmtub3duIHRlbXBsYXRlIG9iamVjdDogJyArIHR5cGVvZiB0ZW1wbGF0ZVNwZWMpO1xuICB9XG5cbiAgdGVtcGxhdGVTcGVjLm1haW4uZGVjb3JhdG9yID0gdGVtcGxhdGVTcGVjLm1haW5fZDtcblxuICAvLyBOb3RlOiBVc2luZyBlbnYuVk0gcmVmZXJlbmNlcyByYXRoZXIgdGhhbiBsb2NhbCB2YXIgcmVmZXJlbmNlcyB0aHJvdWdob3V0IHRoaXMgc2VjdGlvbiB0byBhbGxvd1xuICAvLyBmb3IgZXh0ZXJuYWwgdXNlcnMgdG8gb3ZlcnJpZGUgdGhlc2UgYXMgcHN1ZWRvLXN1cHBvcnRlZCBBUElzLlxuICBlbnYuVk0uY2hlY2tSZXZpc2lvbih0ZW1wbGF0ZVNwZWMuY29tcGlsZXIpO1xuXG4gIGZ1bmN0aW9uIGludm9rZVBhcnRpYWxXcmFwcGVyKHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNoKSB7XG4gICAgICBjb250ZXh0ID0gVXRpbHMuZXh0ZW5kKHt9LCBjb250ZXh0LCBvcHRpb25zLmhhc2gpO1xuICAgICAgaWYgKG9wdGlvbnMuaWRzKSB7XG4gICAgICAgIG9wdGlvbnMuaWRzWzBdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJ0aWFsID0gZW52LlZNLnJlc29sdmVQYXJ0aWFsLmNhbGwodGhpcywgcGFydGlhbCwgY29udGV4dCwgb3B0aW9ucyk7XG4gICAgbGV0IHJlc3VsdCA9IGVudi5WTS5pbnZva2VQYXJ0aWFsLmNhbGwodGhpcywgcGFydGlhbCwgY29udGV4dCwgb3B0aW9ucyk7XG5cbiAgICBpZiAocmVzdWx0ID09IG51bGwgJiYgZW52LmNvbXBpbGUpIHtcbiAgICAgIG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXSA9IGVudi5jb21waWxlKHBhcnRpYWwsIHRlbXBsYXRlU3BlYy5jb21waWxlck9wdGlvbnMsIGVudik7XG4gICAgICByZXN1bHQgPSBvcHRpb25zLnBhcnRpYWxzW29wdGlvbnMubmFtZV0oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgaWYgKG9wdGlvbnMuaW5kZW50KSB7XG4gICAgICAgIGxldCBsaW5lcyA9IHJlc3VsdC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFsaW5lc1tpXSAmJiBpICsgMSA9PT0gbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGluZXNbaV0gPSBvcHRpb25zLmluZGVudCArIGxpbmVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVGhlIHBhcnRpYWwgJyArIG9wdGlvbnMubmFtZSArICcgY291bGQgbm90IGJlIGNvbXBpbGVkIHdoZW4gcnVubmluZyBpbiBydW50aW1lLW9ubHkgbW9kZScpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEp1c3QgYWRkIHdhdGVyXG4gIGxldCBjb250YWluZXIgPSB7XG4gICAgc3RyaWN0OiBmdW5jdGlvbihvYmosIG5hbWUpIHtcbiAgICAgIGlmICghKG5hbWUgaW4gb2JqKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdcIicgKyBuYW1lICsgJ1wiIG5vdCBkZWZpbmVkIGluICcgKyBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialtuYW1lXTtcbiAgICB9LFxuICAgIGxvb2t1cDogZnVuY3Rpb24oZGVwdGhzLCBuYW1lKSB7XG4gICAgICBjb25zdCBsZW4gPSBkZXB0aHMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoZGVwdGhzW2ldICYmIGRlcHRoc1tpXVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGRlcHRoc1tpXVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbGFtYmRhOiBmdW5jdGlvbihjdXJyZW50LCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGN1cnJlbnQgPT09ICdmdW5jdGlvbicgPyBjdXJyZW50LmNhbGwoY29udGV4dCkgOiBjdXJyZW50O1xuICAgIH0sXG5cbiAgICBlc2NhcGVFeHByZXNzaW9uOiBVdGlscy5lc2NhcGVFeHByZXNzaW9uLFxuICAgIGludm9rZVBhcnRpYWw6IGludm9rZVBhcnRpYWxXcmFwcGVyLFxuXG4gICAgZm46IGZ1bmN0aW9uKGkpIHtcbiAgICAgIGxldCByZXQgPSB0ZW1wbGF0ZVNwZWNbaV07XG4gICAgICByZXQuZGVjb3JhdG9yID0gdGVtcGxhdGVTcGVjW2kgKyAnX2QnXTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIHByb2dyYW1zOiBbXSxcbiAgICBwcm9ncmFtOiBmdW5jdGlvbihpLCBkYXRhLCBkZWNsYXJlZEJsb2NrUGFyYW1zLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XG4gICAgICBsZXQgcHJvZ3JhbVdyYXBwZXIgPSB0aGlzLnByb2dyYW1zW2ldLFxuICAgICAgICAgIGZuID0gdGhpcy5mbihpKTtcbiAgICAgIGlmIChkYXRhIHx8IGRlcHRocyB8fCBibG9ja1BhcmFtcyB8fCBkZWNsYXJlZEJsb2NrUGFyYW1zKSB7XG4gICAgICAgIHByb2dyYW1XcmFwcGVyID0gd3JhcFByb2dyYW0odGhpcywgaSwgZm4sIGRhdGEsIGRlY2xhcmVkQmxvY2tQYXJhbXMsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICAgICAgfSBlbHNlIGlmICghcHJvZ3JhbVdyYXBwZXIpIHtcbiAgICAgICAgcHJvZ3JhbVdyYXBwZXIgPSB0aGlzLnByb2dyYW1zW2ldID0gd3JhcFByb2dyYW0odGhpcywgaSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb2dyYW1XcmFwcGVyO1xuICAgIH0sXG5cbiAgICBkYXRhOiBmdW5jdGlvbih2YWx1ZSwgZGVwdGgpIHtcbiAgICAgIHdoaWxlICh2YWx1ZSAmJiBkZXB0aC0tKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuX3BhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIG1lcmdlOiBmdW5jdGlvbihwYXJhbSwgY29tbW9uKSB7XG4gICAgICBsZXQgb2JqID0gcGFyYW0gfHwgY29tbW9uO1xuXG4gICAgICBpZiAocGFyYW0gJiYgY29tbW9uICYmIChwYXJhbSAhPT0gY29tbW9uKSkge1xuICAgICAgICBvYmogPSBVdGlscy5leHRlbmQoe30sIGNvbW1vbiwgcGFyYW0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICBub29wOiBlbnYuVk0ubm9vcCxcbiAgICBjb21waWxlckluZm86IHRlbXBsYXRlU3BlYy5jb21waWxlclxuICB9O1xuXG4gIGZ1bmN0aW9uIHJldChjb250ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgZGF0YSA9IG9wdGlvbnMuZGF0YTtcblxuICAgIHJldC5fc2V0dXAob3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zLnBhcnRpYWwgJiYgdGVtcGxhdGVTcGVjLnVzZURhdGEpIHtcbiAgICAgIGRhdGEgPSBpbml0RGF0YShjb250ZXh0LCBkYXRhKTtcbiAgICB9XG4gICAgbGV0IGRlcHRocyxcbiAgICAgICAgYmxvY2tQYXJhbXMgPSB0ZW1wbGF0ZVNwZWMudXNlQmxvY2tQYXJhbXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICBpZiAodGVtcGxhdGVTcGVjLnVzZURlcHRocykge1xuICAgICAgaWYgKG9wdGlvbnMuZGVwdGhzKSB7XG4gICAgICAgIGRlcHRocyA9IGNvbnRleHQgIT09IG9wdGlvbnMuZGVwdGhzWzBdID8gW2NvbnRleHRdLmNvbmNhdChvcHRpb25zLmRlcHRocykgOiBvcHRpb25zLmRlcHRocztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlcHRocyA9IFtjb250ZXh0XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWluKGNvbnRleHQvKiwgb3B0aW9ucyovKSB7XG4gICAgICByZXR1cm4gJycgKyB0ZW1wbGF0ZVNwZWMubWFpbihjb250YWluZXIsIGNvbnRleHQsIGNvbnRhaW5lci5oZWxwZXJzLCBjb250YWluZXIucGFydGlhbHMsIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICAgIH1cbiAgICBtYWluID0gZXhlY3V0ZURlY29yYXRvcnModGVtcGxhdGVTcGVjLm1haW4sIG1haW4sIGNvbnRhaW5lciwgb3B0aW9ucy5kZXB0aHMgfHwgW10sIGRhdGEsIGJsb2NrUGFyYW1zKTtcbiAgICByZXR1cm4gbWFpbihjb250ZXh0LCBvcHRpb25zKTtcbiAgfVxuICByZXQuaXNUb3AgPSB0cnVlO1xuXG4gIHJldC5fc2V0dXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLnBhcnRpYWwpIHtcbiAgICAgIGNvbnRhaW5lci5oZWxwZXJzID0gY29udGFpbmVyLm1lcmdlKG9wdGlvbnMuaGVscGVycywgZW52LmhlbHBlcnMpO1xuXG4gICAgICBpZiAodGVtcGxhdGVTcGVjLnVzZVBhcnRpYWwpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gY29udGFpbmVyLm1lcmdlKG9wdGlvbnMucGFydGlhbHMsIGVudi5wYXJ0aWFscyk7XG4gICAgICB9XG4gICAgICBpZiAodGVtcGxhdGVTcGVjLnVzZVBhcnRpYWwgfHwgdGVtcGxhdGVTcGVjLnVzZURlY29yYXRvcnMpIHtcbiAgICAgICAgY29udGFpbmVyLmRlY29yYXRvcnMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5kZWNvcmF0b3JzLCBlbnYuZGVjb3JhdG9ycyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRhaW5lci5oZWxwZXJzID0gb3B0aW9ucy5oZWxwZXJzO1xuICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gb3B0aW9ucy5wYXJ0aWFscztcbiAgICAgIGNvbnRhaW5lci5kZWNvcmF0b3JzID0gb3B0aW9ucy5kZWNvcmF0b3JzO1xuICAgIH1cbiAgfTtcblxuICByZXQuX2NoaWxkID0gZnVuY3Rpb24oaSwgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocykge1xuICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlQmxvY2tQYXJhbXMgJiYgIWJsb2NrUGFyYW1zKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdtdXN0IHBhc3MgYmxvY2sgcGFyYW1zJyk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlRGVwdGhzICYmICFkZXB0aHMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ211c3QgcGFzcyBwYXJlbnQgZGVwdGhzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdyYXBQcm9ncmFtKGNvbnRhaW5lciwgaSwgdGVtcGxhdGVTcGVjW2ldLCBkYXRhLCAwLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcbiAgfTtcbiAgcmV0dXJuIHJldDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBQcm9ncmFtKGNvbnRhaW5lciwgaSwgZm4sIGRhdGEsIGRlY2xhcmVkQmxvY2tQYXJhbXMsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcbiAgZnVuY3Rpb24gcHJvZyhjb250ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgY3VycmVudERlcHRocyA9IGRlcHRocztcbiAgICBpZiAoZGVwdGhzICYmIGNvbnRleHQgIT09IGRlcHRoc1swXSkge1xuICAgICAgY3VycmVudERlcHRocyA9IFtjb250ZXh0XS5jb25jYXQoZGVwdGhzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm4oY29udGFpbmVyLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjb250YWluZXIuaGVscGVycywgY29udGFpbmVyLnBhcnRpYWxzLFxuICAgICAgICBvcHRpb25zLmRhdGEgfHwgZGF0YSxcbiAgICAgICAgYmxvY2tQYXJhbXMgJiYgW29wdGlvbnMuYmxvY2tQYXJhbXNdLmNvbmNhdChibG9ja1BhcmFtcyksXG4gICAgICAgIGN1cnJlbnREZXB0aHMpO1xuICB9XG5cbiAgcHJvZyA9IGV4ZWN1dGVEZWNvcmF0b3JzKGZuLCBwcm9nLCBjb250YWluZXIsIGRlcHRocywgZGF0YSwgYmxvY2tQYXJhbXMpO1xuXG4gIHByb2cucHJvZ3JhbSA9IGk7XG4gIHByb2cuZGVwdGggPSBkZXB0aHMgPyBkZXB0aHMubGVuZ3RoIDogMDtcbiAgcHJvZy5ibG9ja1BhcmFtcyA9IGRlY2xhcmVkQmxvY2tQYXJhbXMgfHwgMDtcbiAgcmV0dXJuIHByb2c7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUGFydGlhbChwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gIGlmICghcGFydGlhbCkge1xuICAgIGlmIChvcHRpb25zLm5hbWUgPT09ICdAcGFydGlhbC1ibG9jaycpIHtcbiAgICAgIHBhcnRpYWwgPSBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydGlhbCA9IG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIXBhcnRpYWwuY2FsbCAmJiAhb3B0aW9ucy5uYW1lKSB7XG4gICAgLy8gVGhpcyBpcyBhIGR5bmFtaWMgcGFydGlhbCB0aGF0IHJldHVybmVkIGEgc3RyaW5nXG4gICAgb3B0aW9ucy5uYW1lID0gcGFydGlhbDtcbiAgICBwYXJ0aWFsID0gb3B0aW9ucy5wYXJ0aWFsc1twYXJ0aWFsXTtcbiAgfVxuICByZXR1cm4gcGFydGlhbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludm9rZVBhcnRpYWwocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xuICBvcHRpb25zLnBhcnRpYWwgPSB0cnVlO1xuICBpZiAob3B0aW9ucy5pZHMpIHtcbiAgICBvcHRpb25zLmRhdGEuY29udGV4dFBhdGggPSBvcHRpb25zLmlkc1swXSB8fCBvcHRpb25zLmRhdGEuY29udGV4dFBhdGg7XG4gIH1cblxuICBsZXQgcGFydGlhbEJsb2NrO1xuICBpZiAob3B0aW9ucy5mbiAmJiBvcHRpb25zLmZuICE9PSBub29wKSB7XG4gICAgb3B0aW9ucy5kYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICBwYXJ0aWFsQmxvY2sgPSBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXSA9IG9wdGlvbnMuZm47XG5cbiAgICBpZiAocGFydGlhbEJsb2NrLnBhcnRpYWxzKSB7XG4gICAgICBvcHRpb25zLnBhcnRpYWxzID0gVXRpbHMuZXh0ZW5kKHt9LCBvcHRpb25zLnBhcnRpYWxzLCBwYXJ0aWFsQmxvY2sucGFydGlhbHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJ0aWFsID09PSB1bmRlZmluZWQgJiYgcGFydGlhbEJsb2NrKSB7XG4gICAgcGFydGlhbCA9IHBhcnRpYWxCbG9jaztcbiAgfVxuXG4gIGlmIChwYXJ0aWFsID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdUaGUgcGFydGlhbCAnICsgb3B0aW9ucy5uYW1lICsgJyBjb3VsZCBub3QgYmUgZm91bmQnKTtcbiAgfSBlbHNlIGlmIChwYXJ0aWFsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gcGFydGlhbChjb250ZXh0LCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHsgcmV0dXJuICcnOyB9XG5cbmZ1bmN0aW9uIGluaXREYXRhKGNvbnRleHQsIGRhdGEpIHtcbiAgaWYgKCFkYXRhIHx8ICEoJ3Jvb3QnIGluIGRhdGEpKSB7XG4gICAgZGF0YSA9IGRhdGEgPyBjcmVhdGVGcmFtZShkYXRhKSA6IHt9O1xuICAgIGRhdGEucm9vdCA9IGNvbnRleHQ7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGV4ZWN1dGVEZWNvcmF0b3JzKGZuLCBwcm9nLCBjb250YWluZXIsIGRlcHRocywgZGF0YSwgYmxvY2tQYXJhbXMpIHtcbiAgaWYgKGZuLmRlY29yYXRvcikge1xuICAgIGxldCBwcm9wcyA9IHt9O1xuICAgIHByb2cgPSBmbi5kZWNvcmF0b3IocHJvZywgcHJvcHMsIGNvbnRhaW5lciwgZGVwdGhzICYmIGRlcHRoc1swXSwgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocyk7XG4gICAgVXRpbHMuZXh0ZW5kKHByb2csIHByb3BzKTtcbiAgfVxuICByZXR1cm4gcHJvZztcbn1cbiIsIi8vIEJ1aWxkIG91dCBvdXIgYmFzaWMgU2FmZVN0cmluZyB0eXBlXG5mdW5jdGlvbiBTYWZlU3RyaW5nKHN0cmluZykge1xuICB0aGlzLnN0cmluZyA9IHN0cmluZztcbn1cblxuU2FmZVN0cmluZy5wcm90b3R5cGUudG9TdHJpbmcgPSBTYWZlU3RyaW5nLnByb3RvdHlwZS50b0hUTUwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICcnICsgdGhpcy5zdHJpbmc7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTYWZlU3RyaW5nO1xuIiwiY29uc3QgZXNjYXBlID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgJ2AnOiAnJiN4NjA7JyxcbiAgJz0nOiAnJiN4M0Q7J1xufTtcblxuY29uc3QgYmFkQ2hhcnMgPSAvWyY8PlwiJ2A9XS9nLFxuICAgICAgcG9zc2libGUgPSAvWyY8PlwiJ2A9XS87XG5cbmZ1bmN0aW9uIGVzY2FwZUNoYXIoY2hyKSB7XG4gIHJldHVybiBlc2NhcGVbY2hyXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChvYmogLyogLCAuLi5zb3VyY2UgKi8pIHtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gYXJndW1lbnRzW2ldKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3VtZW50c1tpXSwga2V5KSkge1xuICAgICAgICBvYmpba2V5XSA9IGFyZ3VtZW50c1tpXVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmV4cG9ydCBsZXQgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vLyBTb3VyY2VkIGZyb20gbG9kYXNoXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmVzdGllanMvbG9kYXNoL2Jsb2IvbWFzdGVyL0xJQ0VOU0UudHh0XG4vKiBlc2xpbnQtZGlzYWJsZSBmdW5jLXN0eWxlICovXG5sZXQgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59O1xuLy8gZmFsbGJhY2sgZm9yIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGlzRnVuY3Rpb24oL3gvKSkge1xuICBpc0Z1bmN0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICB9O1xufVxuZXhwb3J0IHtpc0Z1bmN0aW9ufTtcbi8qIGVzbGludC1lbmFibGUgZnVuYy1zdHlsZSAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykgPyB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJyA6IGZhbHNlO1xufTtcblxuLy8gT2xkZXIgSUUgdmVyc2lvbnMgZG8gbm90IGRpcmVjdGx5IHN1cHBvcnQgaW5kZXhPZiBzbyB3ZSBtdXN0IGltcGxlbWVudCBvdXIgb3duLCBzYWRseS5cbmV4cG9ydCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVFeHByZXNzaW9uKHN0cmluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBkb24ndCBlc2NhcGUgU2FmZVN0cmluZ3MsIHNpbmNlIHRoZXkncmUgYWxyZWFkeSBzYWZlXG4gICAgaWYgKHN0cmluZyAmJiBzdHJpbmcudG9IVE1MKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnRvSFRNTCgpO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2UgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcgKyAnJztcbiAgICB9XG5cbiAgICAvLyBGb3JjZSBhIHN0cmluZyBjb252ZXJzaW9uIGFzIHRoaXMgd2lsbCBiZSBkb25lIGJ5IHRoZSBhcHBlbmQgcmVnYXJkbGVzcyBhbmRcbiAgICAvLyB0aGUgcmVnZXggdGVzdCB3aWxsIGRvIHRoaXMgdHJhbnNwYXJlbnRseSBiZWhpbmQgdGhlIHNjZW5lcywgY2F1c2luZyBpc3N1ZXMgaWZcbiAgICAvLyBhbiBvYmplY3QncyB0byBzdHJpbmcgaGFzIGVzY2FwZWQgY2hhcmFjdGVycyBpbiBpdC5cbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZztcbiAgfVxuXG4gIGlmICghcG9zc2libGUudGVzdChzdHJpbmcpKSB7IHJldHVybiBzdHJpbmc7IH1cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGJhZENoYXJzLCBlc2NhcGVDaGFyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJhbWUob2JqZWN0KSB7XG4gIGxldCBmcmFtZSA9IGV4dGVuZCh7fSwgb2JqZWN0KTtcbiAgZnJhbWUuX3BhcmVudCA9IG9iamVjdDtcbiAgcmV0dXJuIGZyYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmxvY2tQYXJhbXMocGFyYW1zLCBpZHMpIHtcbiAgcGFyYW1zLnBhdGggPSBpZHM7XG4gIHJldHVybiBwYXJhbXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRDb250ZXh0UGF0aChjb250ZXh0UGF0aCwgaWQpIHtcbiAgcmV0dXJuIChjb250ZXh0UGF0aCA/IGNvbnRleHRQYXRoICsgJy4nIDogJycpICsgaWQ7XG59XG4iLCIvLyBDcmVhdGUgYSBzaW1wbGUgcGF0aCBhbGlhcyB0byBhbGxvdyBicm93c2VyaWZ5IHRvIHJlc29sdmVcbi8vIHRoZSBydW50aW1lIG9uIGEgc3VwcG9ydGVkIHBhdGguXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9janMvaGFuZGxlYmFycy5ydW50aW1lJylbJ2RlZmF1bHQnXTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImhhbmRsZWJhcnMvcnVudGltZVwiKVtcImRlZmF1bHRcIl07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTW9kdWxlIGZvciBmdWxsIG1hbmFnZW1lbnQgb2YgcmVxdWVzdGluZyBBSkFYIGZyb20gc2VydmVyLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwudHVpLnV0aWw7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEFKQVgoKSB7fVxuXG5BSkFYLkVSUk9SID0ge1xuICAgIE5PVF9TVVBQT1JUOiAn7IKs7Jqp7ZWY7Iuc64qUIOu4jOudvOyasOyggOqwgCDshJzruYTsiqQg7J207Jqp7JeQIO2VhOyalO2VnCDtlYTsiJgg6riw64ql7J2EIOyngOybkO2VmOyngCDslYrsirXri4jri6QuIOy1nOyLoCDrsoTsoITsnZgg67iM65287Jqw7KCA66W8IOyCrOyaqe2VtCDso7zshLjsmpQuJ1xufTtcblxuLyoqKioqKioqKipcbiAqIGFqYXhcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIOu5hOuPmeq4sCDsmpTssq3snYQg7JyE7ZWcIOqwneyytOulvCDrp4zrk6TslrQg67CY7ZmY7ZWc64ukXG4gKiBAcmV0dXJuIHsoWE1MSHR0cFJlcXVlc3R8QWN0aXZlWE9iamVjdCl9IOu5hOuPmeq4sCDthrXsi6Ag7KeA7JuQIOqwneyytFxuICovXG5BSkFYLnByb3RvdHlwZS5fY3JlYXRlWEhSID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHV0aWwuaXNFeGlzdHkodXRpbC5waWNrKHdpbmRvdywgJ1hNTEh0dHBSZXF1ZXN0JykpKSB7XG4gICAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNFeGlzdHkodXRpbC5waWNrKHdpbmRvdywgJ0FjdGl2ZVhPYmplY3QnKSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB9XG5cbiAgICB3aW5kb3cuYWxlcnQoQUpBWC5FUlJPUi5OT1RfU1VQUE9SVCk7XG59O1xuXG4vKipcbiAqIO2DgOyeheyXkCDrlLDrnbwg642w7J207YSw66W8IOy2lOqwgCDqsIDqs7XtlZzri6RcbiAqXG4gKiBUT0RPOiDtmITsnqzripQgSlNPTuuNsOydtO2EsOunjCDsspjrpqzspJHsnbTqs6Ag7ZWE7JqU7JeQIOuUsOudvCDripjslrTrgpjslbwg7ZWc64ukXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVR5cGUg642w7J207YSwIO2DgOyehVxuICogQHBhcmFtIHsqfSBkYXRhIOqwgOqzte2VoCDrjbDsnbTthLBcbiAqIEByZXR1cm4geyp9IOqwgOqzteuQnCDrjbDsnbTthLBcbiAqL1xuQUpBWC5wcm90b3R5cGUuX3Byb2Nlc3NSYXdEYXRhID0gZnVuY3Rpb24oZGF0YVR5cGUsIGRhdGEpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YTtcbiAgICBpZiAoZGF0YVR5cGUgPT09ICdqc29uJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZGF0YTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFhIUuydmCDsnZHri7Ug642w7J207YSw66W8IOyymOumrO2VnOuLpFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBhamF47Ji17IWYIOqwneyytFxuICogQHBhcmFtIHsoWE1MSHR0cFJlcXVlc3R8QWN0aXZlWE9iamVjdCl9IHhociAtIOu5hOuPmeq4sCDsmpTssq0g6rCd7LK0XG4gKi9cbkFKQVgucHJvdG90eXBlLl9vblJlYWR5U3RhdGVDaGFuZ2UgPSBmdW5jdGlvbihvcHRpb25zLCB4aHIpIHtcbiAgICB2YXIgc3RhdHVzLFxuICAgICAgICByZXNwb25zZSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXI7XG5cbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHhoci5zdGF0dXM7XG5cbiAgICBpZiAoKHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwKSB8fCBzdGF0dXMgPT09IDMwNCkge1xuICAgICAgICByZXNwb25zZSA9IHRoaXMuX3Byb2Nlc3NSYXdEYXRhKG9wdGlvbnMuZGF0YVR5cGUsIHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICByZXNwb25zZUhlYWRlciA9IHV0aWwucGljayhyZXNwb25zZSwgJ2hlYWRlcicpO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2VIZWFkZXIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZXJyb3IoKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZUhlYWRlci5pc1N1Y2Nlc3NmdWwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc3VjY2VzcyhyZXNwb25zZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLmZhaWwocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGF0dXMgIT09IDApIHtcbiAgICAgICAgb3B0aW9ucy5lcnJvcigpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuY29tcGxldGUoKTtcbn07XG5cblxuLyoqXG4gKiBhamF4IOyalOyyreydhCDsiJjtlontlZzri6QuXG4gKiBcbiAqIOyalOyyrSDtg4DsnoXsl5Ag65Sw66W4IOy2lOqwgCDrjbDsnbTthLAg7LKY66as64qUIOuUsOuhnCDtlZjsp4Ag7JWK7Jy866+A66GcIOyCrOyghOyXkCDrr7jrpqwg7KSA67mE7ZW07JW8IO2VnOuLpFxuICog7JiI66W8IOuTpOyWtCwgZ2V07JqU7LKt7J2AIFF1ZXJ5U3RyaW5n7Jy866GcIHVybOydhCDshKTsoJXtlbTslbwg7ZWY6rOgLCBwb3N065Ox7J2YIGRhdGHrpbwg7IKs7Jqp7ZWYXG4gKiDripQg7JqU7LKt7J2AIOuvuOumrCBzdHJpbmdmeeuQnCDqsJLsnYQgZGF0YeyYteyFmOycvOuhnCDsoITri6ztlbTslbwg7ZWc64ukLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgYWpheOyalOyyrSDtlaAgdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyDsmLXshZhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5tZXRob2Q9J1BPU1QnXSDsmpTssq0g7IucIOyCrOyaqe2VoCBodHRwIG1ldGhvZHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXN5bmM9dHJ1ZV0g67mE64+Z6riwIOyalOyyrSDsgqzsmqkg7Jes67aAXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHlwZT0nYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOCddIHR5cGUg7Zek642UIOqwklxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvbnRlbnRUeXBlPSdhcHBsaWNhdGlvbi9qc29uJ10gQ29udGVudC1UeXBlIO2XpOuNlCDqsJJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kYXRhVHlwZT0nanNvbiddIOyEnOuyhOyXkOyEnCDsnZHri7XrsJvquLAg67CU652864qUIOqysOqzvOydmCDtg4DsnoVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRvaW5zLnN1Y2Nlc3NdIC0gaXNTdWNjZXNzZnVsIHRydWXsl5Ag64yA7ZWcIOy9nOuwsVxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZmFpbF0gLSBpc1N1Y2Nlc3NmdWwgZmFsc2Ug7JeQIOuMgO2VnCDsvZzrsLFcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmVycm9yXSDsmpTssq3sl5Ag64yA7ZWcIOyXkOufrCDrsJzsg50g7IucIOyImO2Wie2VoCDsvZzrsLFcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmNvbXBsZXRlXSDsmpTssq3snbQg64Gd64Ks7J2EIOuVjCAo7ISx6rO1LCDsi6TtjKgg7Jes67aA7JmAIOustOq0gCkg7IiY7ZaJ7ZWY64qUIOy9nOuwsVxuICogQHBhcmFtIHtib2xsZWFufSBbb3B0aW9ucy5jYWNoZT10cnVlXSAtIGZhbHNlIOydvCDqsr3smrAgdGltZXN0YW1wIO2MjOudvOuvuO2EsOulvCB1cmzsl5Ag67aZ7JesIOy6kOyLnOulvCDrrLTsi5xcbiAqL1xuQUpBWC5wcm90b3R5cGUuYWpheCA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucykge1xuICAgIHZhciB4aHIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNlcGFyYXRvcixcbiAgICAgICAgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOCcsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgICAgICBmYWlsOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGRhdGEgPSB1dGlsLnBpY2sob3B0aW9ucywgJ2RhdGEnKTtcbiAgICBpZiAoIW9wdGlvbnMuY2FjaGUpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gfnVybC5pbmRleE9mKCc/JykgPyAnJicgOiAnPyc7XG4gICAgICAgIHVybCA9IHVybCArIHNlcGFyYXRvciArICdfPScgKyArKG5ldyBEYXRlKCkpO1xuICAgIH1cblxuICAgIHhociA9IHRoaXMuX2NyZWF0ZVhIUigpO1xuICAgIHhoci5vcGVuKG9wdGlvbnMubWV0aG9kLCB1cmwsIG9wdGlvbnMuYXN5bmMpO1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCd0eXBlJywgb3B0aW9ucy50eXBlKTtcbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignY29udGVudC10eXBlJywgb3B0aW9ucy5jb250ZW50VHlwZSk7XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHV0aWwuYmluZCh0aGlzLl9vblJlYWR5U3RhdGVDaGFuZ2UsIHRoaXMsIG9wdGlvbnMsIHhocik7XG4gICAgeGhyLnNlbmQoZGF0YSA/IGRhdGEgOiBudWxsKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQUpBWDtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFV0aWxpdHkgbW9kdWxlIGZvciBhcnJheSBzb3J0LCBiaW5hcnkgc2VhcmNoLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwudHVpLnV0aWw7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi9jb21tb24vZGF0ZXRpbWUnKTtcblxuLyoqXG4gKiBBIG1vZHVsZSBmb3Igc29ydGluZyBhcnJheS5cbiAqIEBtb2R1bGUgYXJyYXlcbiAqL1xuXG4vKioqKioqKioqKlxuICogU2VhcmNoXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBzZWFyY2ggaXRlbSBpbmRleCB1c2luZyBiaW5hcnkgc2VhcmNoIGFsZ29yaXRobS5cbiAqXG4gKiB0aGUgYXJyYXkgbXVzdCBiZSBzb3J0ZWQuXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYXJyYXkgdG8gc2VhcmNoLlxuICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcnxib29sZWFuKX0gc2VhcmNoIHZhbHVlIHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtmbl0gaXRlcmF0ZWUgZm9yIHJldHJpZXZlIGVhY2ggZWxlbWVudCdzIHZhbHVlIHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjb21wYXJlXSBjb21wYXJlIGZ1bmN0aW9uIGZvciBzcGVjaWZpYyBzb3J0IHN0YXR1cy4gZGVmYXVsdCBpcyBzdHJpbmcgYXNjZW5kaW5nLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBpdGVtIGluZGV4IHNlYXJjaGVkLiByZXR1cm4gbmVnYXRpdmUgbnVtYmVyIHdoZW4gbm8gZXhpc3QgdGhhdCBpdGVtLlxuICogSXQgY2FuIHVzZSBpbnNlcnQgaW5kZXggYWZ0ZXIgTWF0aC5hYnMoKVxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyID0gWzEsIDMsIDcsIDExLCAxNSwgMjNdO1xuICpcbiAqIGZ1bmN0aW9uIHNvcnROdW1iZXIoYSwgYikge1xuICogICAgIHJldHVybiBhIC0gYjtcbiAqIH1cbiAqXG4gKiBic2VhcmNoKGFyciwgMTUsIG51bGwsIHNvcnROdW1iZXIpOyAgICAvLyA0XG4gKiBic2VhcmNoKGFyciwgMjEsIG51bGwsIHNvcnROdW1iZXIpOyAgICAvLyAtNVxuICpcbiAqIGFyci5zcGxpY2UoTWF0aC5hYnMoYnNlYXJjaChhcnIsIDIxLCBudWxsLCBzb3J0TnVtYmVyKSksIDAsIDIxKTtcbiAqIC8vIFsxLCAyLCA3LCAxMSwgMTUsIDIxLCAyM11cbiAqL1xuZnVuY3Rpb24gYnNlYXJjaChhcnIsIHNlYXJjaCwgZm4sIGNvbXBhcmUpIHtcbiAgICB2YXIgbWluSW5kZXggPSAwLFxuICAgICAgICBtYXhJbmRleCA9IGFyci5sZW5ndGggLSAxLFxuICAgICAgICBjdXJyZW50SW5kZXgsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBjb21wO1xuXG4gICAgY29tcGFyZSA9IGNvbXBhcmUgfHwgc3RyaW5nQVNDO1xuXG4gICAgd2hpbGUgKG1pbkluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCA9IChtaW5JbmRleCArIG1heEluZGV4KSAvIDIgfCAwOyAgICAvLyBNYXRoLmZsb29yXG4gICAgICAgIHZhbHVlID0gZm4gPyBmbihhcnJbY3VycmVudEluZGV4XSkgOiBhcnJbY3VycmVudEluZGV4XTtcbiAgICAgICAgY29tcCA9IGNvbXBhcmUodmFsdWUsIHNlYXJjaCk7XG5cbiAgICAgICAgaWYgKGNvbXAgPCAwKSB7XG4gICAgICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcCA+IDApIHtcbiAgICAgICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50SW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gfm1heEluZGV4O1xufVxuXG4vKioqKioqKioqKlxuICogQ29tcGFyZSBGdW5jdGlvbnNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIGNvbXBhcmUgZnVuY3Rpb24gZm9yIGFycmF5IHNvcnQuXG4gKlxuICogc29ydCBhcnJheSBieSBhc2NlbmRpbmcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGEgVGhlIGJvb2xlYW4gdG8gY29tcGFyZVxuICogQHBhcmFtIHtib29sZWFufSBiIFRoZSBib29sZWFuIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXN1bHQgb2YgY29tcGFyaXNvbi5cbiAqL1xuZnVuY3Rpb24gYm9vbGVhbkFTQyhhLCBiKSB7XG4gICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPyAtMSA6IDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuXG4vKipcbiAqIGNvbXBhcmUgZnVuY3Rpb24gZm9yIGFycmF5IHNvcnQuXG4gKlxuICogc29ydCBhcnJheSBieSBkZXNjZW5kaW5nLlxuICogQHBhcmFtIHtib29sZWFufSBhIFRoZSBib29sZWFuIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYiBUaGUgYm9vbGVhbiB0byBjb21wYXJlLlxuICogQHJldHVybnMge251bWJlcn0gUmVzdWx0IG9mIGNvbXBhcmlzb24uXG4gKi9cbmZ1bmN0aW9uIGJvb2xlYW5ERVNDKGEsIGIpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICByZXR1cm4gYSA/IDEgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogY29tcGFyZSBmdW5jdGlvbiBmb3IgYXJyYXkgc29ydC5cbiAqXG4gKiBzb3J0IGFycmF5IGJ5IG51bWJlciBhc2NlbmRpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0gX2EgVGhlIG51bWJlciB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IF9iIFRoZSBudW1iZXIgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJlc3VsdCBvZiBjb21wYXJpc29uLlxuICovXG5mdW5jdGlvbiBudW1iZXJBU0MoX2EsIF9iKSB7XG4gICAgdmFyIGEgPSArX2EsXG4gICAgICAgIGIgPSArX2I7XG5cbiAgICByZXR1cm4gYSAtIGI7XG59XG5cbi8qKlxuICogY29tcGFyZSBmdW5jdGlvbiBmb3IgYXJyYXkgc29ydC5cbiAqXG4gKiBzb3J0IGFycmF5IGJ5IG51bWJlciBkZXNjZW5kaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IF9hIFRoZSBudW1iZXIgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBfYiBUaGUgbnVtYmVyIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXN1bHQgb2YgY29tcGFyaXNvbi5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyREVTQyhfYSwgX2IpIHtcbiAgICB2YXIgYSA9ICtfYSxcbiAgICAgICAgYiA9ICtfYjtcblxuICAgIHJldHVybiBiIC0gYTtcbn1cblxuLyoqXG4gKiBjb21wYXJlIGZ1bmN0aW9uIGZvciBhcnJheSBzb3J0LlxuICpcbiAqIHNvcnQgYXJyYXkgYnkgc3RyaW5nIGFzY2VuZGluZ1xuICogQHBhcmFtIHtzdHJpbmd9IF9hIFRoZSBzdHJpbmcgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBfYiBUaGUgc3RyaW5nIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXN1bHQgb2YgY29tcGFyaXNvbi5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nQVNDKF9hLCBfYikge1xuICAgIHZhciBhID0gX2EgKyAnJyxcbiAgICAgICAgYiA9IF9iICsgJyc7XG5cbiAgICBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChhIDwgYikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogY29tcGFyZSBmdW5jdGlvbiBmb3IgYXJyYXkgc29ydC5cbiAqXG4gKiBzb3J0IGFycmF5IGJ5IHN0cmluZyBkZXNjZW5kaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gX2EgVGhlIHN0cmluZyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IF9iIFRoZSBzdHJpbmcgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJlc3VsdCBvZiBjb21wYXJpc29uLlxuICovXG5mdW5jdGlvbiBzdHJpbmdERVNDKF9hLCBfYikge1xuICAgIHZhciBhID0gX2EgKyAnJyxcbiAgICAgICAgYiA9IF9iICsgJyc7XG5cbiAgICBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogY29tcGFyZSBmdW5jdGlvbiBmb3IgYXJyYXkgc29ydC5cbiAqXG4gKiBzb3J0IGFycmF5IGJ5IHN0cmluZyBhc2NlbmRpbmcgd2l0aCBpZ25vcmUgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBfYSBUaGUgc3RyaW5nIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gX2IgVGhlIHN0cmluZyB0byBjb21wYXJlLlxuICogQHJldHVybnMge251bWJlcn0gUmVzdWx0IG9mIGNvbXBhcmlzb24uXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ0FTQ0lnbm9yZUNhc2UoX2EsIF9iKSB7XG4gICAgdmFyIGEgPSAoX2EgKyAnJykudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgYiA9IChfYiArICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xufVxuXG4vKipcbiAqIGNvbXBhcmUgZnVuY3Rpb24gZm9yIGFycmF5IHNvcnQuXG4gKlxuICogc29ydCBhcnJheSBieSBzdHJpbmcgZGVzY2VuZGluZyB3aXRoIGlnbm9yZSBjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IF9hIFRoZSBzdHJpbmcgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBfYiBUaGUgc3RyaW5nIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXN1bHQgb2YgY29tcGFyaXNvbi5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nREVTQ0lnbm9yZUNhc2UoX2EsIF9iKSB7XG4gICAgdmFyIGEgPSAoX2EgKyAnJykudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgYiA9IChfYiArICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xufVxuXG4vKipcbiAqIENvbXBhcmUgZXZlbnQgbW9kZWxzIGZvciBzb3J0LlxuICpcbiAqIDEuIGFsbCBkYXkgZXZlbnQgZmlyc3QuXG4gKiAyLiBlYXJseSBzdGFydHMuXG4gKiAzLiBsb25nZXN0IGR1cmF0aW9uLlxuICogNC4gZWFybHkgY3JlYXRlZC5cbiAqIEBwYXJhbSB7Q2FsRXZlbnR8Q2FsRXZlbnRWaWV3TW9kZWx9IGEgVGhlIG9iamVjdCBldmVudCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7Q2FsRXZlbnR8Q2FsRXZlbnRWaWV3TW9kZWx9IGIgVGhlIG9iamVjdCBldmVudCBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJlc3VsdCBvZiBjb21wYXJpc29uLlxuICovXG5mdW5jdGlvbiBldmVudEFTQyhhLCBiKSB7XG4gICAgdmFyIGR1cmF0aW9uQSxcbiAgICAgICAgZHVyYXRpb25CLFxuICAgICAgICBhbGxEYXlDb21wYXJlLFxuICAgICAgICBzdGFydHNDb21wYXJlO1xuXG4gICAgYSA9IGEudmFsdWVPZigpO1xuICAgIGIgPSBiLnZhbHVlT2YoKTtcblxuICAgIGFsbERheUNvbXBhcmUgPSBib29sZWFuQVNDKGEuaXNBbGxEYXksIGIuaXNBbGxEYXkpO1xuXG4gICAgaWYgKGFsbERheUNvbXBhcmUpIHtcbiAgICAgICAgcmV0dXJuIGFsbERheUNvbXBhcmU7XG4gICAgfVxuXG4gICAgc3RhcnRzQ29tcGFyZSA9IGRhdGV0aW1lLmNvbXBhcmUoYS5nZXRTdGFydHMoKSwgYi5nZXRTdGFydHMoKSk7XG5cbiAgICBpZiAoc3RhcnRzQ29tcGFyZSkge1xuICAgICAgICByZXR1cm4gc3RhcnRzQ29tcGFyZTtcbiAgICB9XG5cbiAgICBkdXJhdGlvbkEgPSBhLmR1cmF0aW9uKCkuZ2V0VGltZSgpO1xuICAgIGR1cmF0aW9uQiA9IGIuZHVyYXRpb24oKS5nZXRUaW1lKCk7XG5cbiAgICBpZiAoZHVyYXRpb25BIDwgZHVyYXRpb25CKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZHVyYXRpb25BID4gZHVyYXRpb25CKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbC5zdGFtcChhKSAtIHV0aWwuc3RhbXAoYik7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYnNlYXJjaDogYnNlYXJjaCxcbiAgICBjb21wYXJlOiB7XG4gICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgICBhc2M6IGV2ZW50QVNDXG4gICAgICAgIH0sXG4gICAgICAgIGJvb2w6IHtcbiAgICAgICAgICAgIGFzYzogYm9vbGVhbkFTQyxcbiAgICAgICAgICAgIGRlc2M6IGJvb2xlYW5ERVNDXG4gICAgICAgIH0sXG4gICAgICAgIG51bToge1xuICAgICAgICAgICAgYXNjOiBudW1iZXJBU0MsXG4gICAgICAgICAgICBkZXNjOiBudW1iZXJERVNDXG4gICAgICAgIH0sXG4gICAgICAgIHN0cjoge1xuICAgICAgICAgICAgYXNjOiBzdHJpbmdBU0MsXG4gICAgICAgICAgICBkZXNjOiBzdHJpbmdERVNDLFxuICAgICAgICAgICAgYXNjSWdub3JlQ2FzZTogc3RyaW5nQVNDSWdub3JlQ2FzZSxcbiAgICAgICAgICAgIGRlc2NJZ25vcmVDYXNlOiBzdHJpbmdERVNDSWdub3JlQ2FzZVxuICAgICAgICB9XG4gICAgfVxufTtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEFkZCBhdXRvc2Nyb2xsIGZlYXR1cmUgdG8gZWxlbWVudHMgdGhhdCBwcmV2ZW50ZWQgdGV4dCBzZWxlY3Rpb24uXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC50dWkudXRpbDtcbnZhciBkb21ldmVudCA9IHJlcXVpcmUoJy4uL2NvbW1vbi9kb21ldmVudCcpO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vY29tbW9uL3BvaW50Jyk7XG5cbnZhciBTQ1JPTExfSU5URVJWQUwgPSAzMDtcbnZhciBTQ1JPTExfTUFYID0gMTU7XG52YXIgU0NST0xMX0NMSUNLX0lOQ1JFQVNFRCA9IDI7ICAgIC8vIElF7JeQ7IScIOyKpO2BrOuhpCDrsJQg7YG066atIOyLnCDsi6TsoJwgVUkgcGl4ZWwg67O064ukIOuEk+qyjCDsnqHtnojripQg7ZiE7IOBIG9mZnNldC5cblxuLyoqXG4gKiBBZGQgYXV0b3Njcm9sbCBmZWF0dXJlIHRvIGVsZW1lbnRzIHRoYXQgcHJldmVudGVkIHRleHQgc2VsZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgLSBIVE1MRWxlbWVudCB0byBhZGQgYXV0b3Njcm9sbCBmZWF0dXJlcy5cbiAqL1xuZnVuY3Rpb24gQXV0b1Njcm9sbChjb250YWluZXIpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXV0b1Njcm9sbC5ESVJFQ1RJT059XG4gICAgICovXG4gICAgdGhpcy5fZGlyZWN0aW9uID0gQXV0b1Njcm9sbC5ESVJFQ1RJT04uSU5TSURFO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9vZmZzZXQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogaW50ZXJ2YWwgdG8gc2Nyb2xsaW5nXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9pbnRlcnZhbElEID0gMDtcblxuICAgIGRvbWV2ZW50Lm9uKGNvbnRhaW5lciwge1xuICAgICAgICAnbW91c2Vkb3duJzogdGhpcy5fb25Nb3VzZURvd25cbiAgICB9LCB0aGlzKTtcbn1cblxuLyoqXG4gKiBAZW51bVxuICovXG5BdXRvU2Nyb2xsLkRJUkVDVElPTiA9IHtcbiAgICBJTlNJREU6IDAsXG4gICAgVE9QOiAxLFxuICAgIFJJR0hUOiAyLFxuICAgIEJPVFRPTTogMyxcbiAgICBMRUZUOiA0XG59O1xuXG4vKipcbiAqIEluc3RhbmNlIGRlc3Ryb3kgbWV0aG9kLlxuICovXG5BdXRvU2Nyb2xsLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgZG9tZXZlbnQub2ZmKHRoaXMuY29udGFpbmVyLCB7XG4gICAgICAgICdtb3VzZWRvd24nOiB0aGlzLl9vbk1vdXNlRG93bixcbiAgICAgICAgJ21vdXNlbW92ZSc6IHRoaXMuX29uTW91c2VNb3ZlLFxuICAgICAgICAnbW91c2V1cCc6IHRoaXMuX29uTW91c2VVcFxuICAgIH0sIHRoaXMpO1xuXG4gICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJRCk7XG4gICAgdGhpcy5faW50ZXJ2YWxJRCA9IHRoaXMuX2RpcmVjdGlvbiA9IHRoaXMuY29udGFpbmVyID0gbnVsbDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIENsaWVudFJlY3QgYW5kIGNhbGN1bGF0ZSBlYWNoIHBvc2l0aW9uIG9mIGVkZ2VzLlxuICogQHBhcmFtIHtDbGllbnRSZWN0fSBjbGllbnRSZWN0IC0gQ2xpZW50UmVjdCBvYmplY3Qgb2YgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtvYmplY3R9IGVkZ2VzLlxuICovXG5BdXRvU2Nyb2xsLnByb3RvdHlwZS5fZ2V0RWRnZVBvc2l0aW9ucyA9IGZ1bmN0aW9uKGNsaWVudFJlY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IGNsaWVudFJlY3QudG9wLFxuICAgICAgICByaWdodDogY2xpZW50UmVjdC5sZWZ0ICsgY2xpZW50UmVjdC53aWR0aCxcbiAgICAgICAgYm90dG9tOiBjbGllbnRSZWN0LmJvdHRvbSxcbiAgICAgICAgbGVmdDogY2xpZW50UmVjdC5sZWZ0XG4gICAgfTtcbn07XG5cbi8qKlxuICogR2V0IGVsZW1lbnQgcmVhbCBzaXplIChcInJlYWwgc2l6ZVwiIC0+IHNpemUgd2l0aG91dCBzY3JvbGxiYXIpXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIGVsZW1lbnQgd2FudCB0byBrbm93IHJlYWwgc2l6ZSAoXCJyZWFsIHNpemVcIiAtPiBzaXplIHdpdGhvdXQgc2Nyb2xsYmFyKVxuICogQHJldHVybnMge251bWJlcltdfSByZWFsIHNpemUgW3dpZHRoLCBoZWlnaHRdXG4gKi9cbkF1dG9TY3JvbGwucHJvdG90eXBlLmdldFJlYWxTaXplID0gZnVuY3Rpb24oZWwpIHtcbiAgICB2YXIgY29tcHV0ZWQgPSBkb211dGlsLmdldENvbXB1dGVkU3R5bGUoZWwpLFxuICAgICAgICBib3JkZXIsXG4gICAgICAgIHBhZGRpbmc7XG5cbiAgICBib3JkZXIgPSBwYXJzZUZsb2F0KGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci10b3Atd2lkdGgnKSkgK1xuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci1ib3R0b20td2lkdGgnKSk7XG4gICAgcGFkZGluZyA9IHBhcnNlRmxvYXQoY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy10b3AnKSkgK1xuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctYm90dG9tJykpO1xuXG4gICAgcmV0dXJuIFtlbC5jbGllbnRXaWR0aCArIGJvcmRlciArIHBhZGRpbmcsIGVsLmNsaWVudEhlaWdodCArIGJvcmRlciArIHBhZGRpbmddO1xufTtcblxuLyoqXG4gKiBDaGVjayBzdXBwbGllZCBlbGVtZW50IGhhcyBzY3JvbGxiYXIuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIGVsZW1lbnQgd2FudCB0byBrbm93IGhhcyBzY3JvbGxiYXIuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbltdfSBoYXMgc2Nyb2xsYmFyPyBbaG9yaXpvbnRhbCwgdmVydGljYWxdXG4gKi9cbkF1dG9TY3JvbGwucHJvdG90eXBlLmhhc1Njcm9sbGJhciA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgdmFyIHJlYWxTaXplID0gdGhpcy5nZXRSZWFsU2l6ZShlbCk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgICBlbC5vZmZzZXRXaWR0aCA+IE1hdGguY2VpbChyZWFsU2l6ZVswXSksXG4gICAgICAgIGVsLm9mZnNldEhlaWdodCA+IE1hdGguY2VpbChyZWFsU2l6ZVsxXSlcbiAgICBdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIGVsZW1lbnQgd2FudCB0byBrbm93LlxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50IC0gbW91c2UgZXZlbnQgb2JqZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IG1vdXNlIHBvaW50ZXIgaXMgb24gdGhlIHNjcm9sbGJhcj9cbiAqL1xuQXV0b1Njcm9sbC5wcm90b3R5cGUuaXNPblNjcm9sbGJhciA9IGZ1bmN0aW9uKGVsLCBtb3VzZUV2ZW50KSB7XG4gICAgdmFyIHJlYWxTaXplID0gdGhpcy5nZXRSZWFsU2l6ZShlbCksXG4gICAgICAgIHBvcyA9IGRvbWV2ZW50LmdldE1vdXNlUG9zaXRpb24obW91c2VFdmVudCwgZWwpLFxuICAgICAgICBtb3VzZUluU2Nyb2xsYmFyID0gZmFsc2U7XG5cbiAgICBtb3VzZUluU2Nyb2xsYmFyID0gKHJlYWxTaXplWzBdIC0gU0NST0xMX0NMSUNLX0lOQ1JFQVNFRCA8IHBvc1swXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhbFNpemVbMV0gLSBTQ1JPTExfQ0xJQ0tfSU5DUkVBU0VEIDwgcG9zWzFdKTtcblxuICAgIHJldHVybiBtb3VzZUluU2Nyb2xsYmFyO1xufTtcblxuLyoqXG4gKiBNb3VzZURvd24gZXZlbnQgaGFuZGxlclxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZURvd25FdmVudCAtIG1vdXNlIGRvd24gZXZlbnRcbiAqL1xuQXV0b1Njcm9sbC5wcm90b3R5cGUuX29uTW91c2VEb3duID0gZnVuY3Rpb24obW91c2VEb3duRXZlbnQpIHtcbiAgICAvLyBvbmx5IHByaW1hcnkgYnV0dG9uIGNhbiBzdGFydCBkcmFnLlxuICAgIGlmIChkb21ldmVudC5nZXRNb3VzZUJ1dHRvbihtb3VzZURvd25FdmVudCkgIT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGRlYWN0aXZhdGUgYXV0b3Njcm9sbCBmZWF0dXJlIHdoZW4gbW91c2UgaXMgb24gdGhlIHNjcm9sbGJhci4gKElFKVxuICAgIGlmICh1dGlsLmJyb3dzZXIubXNpZSAmJiB0aGlzLmlzT25TY3JvbGxiYXIodGhpcy5jb250YWluZXIsIG1vdXNlRG93bkV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJRCk7XG4gICAgdGhpcy5faW50ZXJ2YWxJRCA9IHdpbmRvdy5zZXRJbnRlcnZhbCh1dGlsLmJpbmQodGhpcy5fb25UaWNrLCB0aGlzKSwgU0NST0xMX0lOVEVSVkFMKTtcblxuICAgIGRvbWV2ZW50Lm9uKGdsb2JhbCwge1xuICAgICAgICAnbW91c2Vtb3ZlJzogdGhpcy5fb25Nb3VzZU1vdmUsXG4gICAgICAgICdtb3VzZXVwJzogdGhpcy5fb25Nb3VzZVVwXG4gICAgfSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIE1vdXNlTW92ZSBldmVudCBoYW5kbGVyXG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IG1vdXNlRXZlbnQgLSBtb3VzZSBtb3ZlIGV2ZW50IG9iamVjdC5cbiAqL1xuQXV0b1Njcm9sbC5wcm90b3R5cGUuX29uTW91c2VNb3ZlID0gZnVuY3Rpb24obW91c2VFdmVudCkge1xuICAgIHZhciBlZGdlID0gdGhpcy5fZ2V0RWRnZVBvc2l0aW9ucyh0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksXG4gICAgICAgIHBvcyA9IFBvaW50Lm4oZG9tZXZlbnQuZ2V0TW91c2VQb3NpdGlvbihtb3VzZUV2ZW50KSk7XG5cbiAgICBpZiAocG9zLnkgPj0gZWRnZS50b3AgJiYgcG9zLnkgPD0gZWRnZS5ib3R0b20gJiZcbiAgICAgICAgcG9zLnggPj0gZWRnZS5sZWZ0ICYmIHBvcy54IDw9IGVkZ2UucmlnaHQpIHtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gQXV0b1Njcm9sbC5ESVJFQ1RJT04uSU5TSURFO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBvcy55IDwgZWRnZS50b3ApIHtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gQXV0b1Njcm9sbC5ESVJFQ1RJT04uVE9QO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBlZGdlLnRvcCAtIHBvcy55O1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBvcy55ID4gZWRnZS5ib3R0b20pIHtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gQXV0b1Njcm9sbC5ESVJFQ1RJT04uQk9UVE9NO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBwb3MueSAtIGVkZ2UuYm90dG9tO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBvcy54IDwgZWRnZS5sZWZ0KSB7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IEF1dG9TY3JvbGwuRElSRUNUSU9OLkxFRlQ7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IGVkZ2UubGVmdCAtIHBvcy54O1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZGlyZWN0aW9uID0gQXV0b1Njcm9sbC5ESVJFQ1RJT04uUklHSFQ7XG4gICAgdGhpcy5fb2Zmc2V0ID0gcG9zLnggLSBlZGdlLnJpZ2h0O1xuICAgIHJldHVybjtcbn07XG5cbi8qKlxuICogTW91c2VVcCBldmVudCBoYW5kbGVyLlxuICovXG5BdXRvU2Nyb2xsLnByb3RvdHlwZS5fb25Nb3VzZVVwID0gZnVuY3Rpb24oKSB7XG4gICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJRCk7XG4gICAgdGhpcy5faW50ZXJ2YWxJRCA9IDA7XG4gICAgdGhpcy5fZGlyZWN0aW9uID0gQXV0b1Njcm9sbC5ESVJFQ1RJT04uSU5TSURFO1xuICAgIHRoaXMuX29mZnNldCA9IDA7XG5cbiAgICBkb21ldmVudC5vZmYoZ2xvYmFsLCB7XG4gICAgICAgICdtb3VzZW1vdmUnOiB0aGlzLl9vbk1vdXNlTW92ZSxcbiAgICAgICAgJ21vdXNldXAnOiB0aGlzLl9vbk1vdXNlVXBcbiAgICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogSW50ZXJ2YWwgdGljayBldmVudCBoYW5kbGVyXG4gKi9cbkF1dG9TY3JvbGwucHJvdG90eXBlLl9vblRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZGlyZWN0aW9uLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGZhY3RvcjtcblxuICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICBmYWN0b3IgPSBNYXRoLm1pbih0aGlzLl9vZmZzZXQsIFNDUk9MTF9NQVgpO1xuXG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSBBdXRvU2Nyb2xsLkRJUkVDVElPTi5UT1A6XG4gICAgICAgICAgICBjb250YWluZXIuc2Nyb2xsVG9wIC09IGZhY3RvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEF1dG9TY3JvbGwuRElSRUNUSU9OLlJJR0hUOlxuICAgICAgICAgICAgY29udGFpbmVyLnNjcm9sbExlZnQgKz0gZmFjdG9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQXV0b1Njcm9sbC5ESVJFQ1RJT04uQk9UVE9NOlxuICAgICAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCArPSBmYWN0b3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnRhaW5lci5zY3JvbGxMZWZ0IC09IGZhY3RvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0b1Njcm9sbDtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbW1vbiBjb2xsZWN0aW9ucy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLnR1aS51dGlsLFxuICAgIGZvckVhY2hQcm9wID0gdXRpbC5mb3JFYWNoT3duUHJvcGVydGllcyxcbiAgICBmb3JFYWNoQXJyID0gdXRpbC5mb3JFYWNoQXJyYXksXG4gICAgaXNGdW5jID0gdXRpbC5pc0Z1bmN0aW9uLFxuICAgIGlzT2JqID0gdXRpbC5pc09iamVjdDtcblxudmFyIGFwcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBDb21tb24gY29sbGVjdGlvbi5cbiAqXG4gKiBJdCBuZWVkIGZ1bmN0aW9uIGZvciBnZXQgbW9kZWwncyB1bmlxdWUgaWQuXG4gKlxuICogaWYgdGhlIGZ1bmN0aW9uIGlzIG5vdCBzdXBwbGllZCB0aGVuIGl0IHVzZSBkZWZhdWx0IGZ1bmN0aW9uIHtAbGluayBDb2xsZWN0aW9uI2dldEl0ZW1JRH1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2dldEl0ZW1JREZuXSBmdW5jdGlvbiBmb3IgZ2V0IG1vZGVsJ3MgaWQuXG4gKi9cbmZ1bmN0aW9uIENvbGxlY3Rpb24oZ2V0SXRlbUlERm4pIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7b2JqZWN0LjxzdHJpbmcsICo+fVxuICAgICAqL1xuICAgIHRoaXMuaXRlbXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgaWYgKGlzRnVuYyhnZXRJdGVtSURGbikpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0SXRlbUlEID0gZ2V0SXRlbUlERm47XG4gICAgfVxufVxuXG4vKioqKioqKioqKlxuICogc3RhdGljIHByb3BzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBDb21iaW5kIHN1cHBsaWVkIGZ1bmN0aW9uIGZpbHRlcnMgYW5kIGNvbmRpdGlvbi5cbiAqIEBwYXJhbSB7Li4uZnVuY3Rpb259IGZpbHRlcnMgLSBmdW5jdGlvbiBmaWx0ZXJzXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IGNvbWJpbmVkIGZpbHRlclxuICovXG5Db2xsZWN0aW9uLmFuZCA9IGZ1bmN0aW9uKGZpbHRlcnMpIHtcbiAgICB2YXIgY250O1xuXG4gICAgZmlsdGVycyA9IGFwcy5jYWxsKGFyZ3VtZW50cyk7XG4gICAgY250ID0gZmlsdGVycy5sZW5ndGg7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgZm9yICg7IGkgPCBjbnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKCFmaWx0ZXJzW2ldLmNhbGwobnVsbCwgaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59O1xuXG4vKipcbiAqIENvbWJpbmUgbXVsdGlwbGUgZnVuY3Rpb24gZmlsdGVycyB3aXRoIE9SIGNsYXVzZS5cbiAqIEBwYXJhbSB7Li4uZnVuY3Rpb259IGZpbHRlcnMgLSBmdW5jdGlvbiBmaWx0ZXJzXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IGNvbWJpbmVkIGZpbHRlclxuICovXG5Db2xsZWN0aW9uLm9yID0gZnVuY3Rpb24oZmlsdGVycykge1xuICAgIHZhciBjbnQ7XG5cbiAgICBmaWx0ZXJzID0gYXBzLmNhbGwoYXJndW1lbnRzKTtcbiAgICBjbnQgPSBmaWx0ZXJzLmxlbmd0aDtcblxuICAgIHJldHVybiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciBpID0gMSxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlcnNbMF0uY2FsbChudWxsLCBpdGVtKTtcblxuICAgICAgICBmb3IgKDsgaSA8IGNudDsgaSArPSAxKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IHx8IGZpbHRlcnNbaV0uY2FsbChudWxsLCBpdGVtKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59O1xuXG4vKipcbiAqIE1lcmdlIHNldmVyYWwgY29sbGVjdGlvbnMuXG4gKlxuICogWW91IGNhblxcJ3QgbWVyZ2UgY29sbGVjdGlvbnMgZGlmZmVyZW50IF9nZXRFdmVudElEIGZ1bmN0aW9ucy4gVGFrZSBjYXNlIG9mIHVzZS5cbiAqIEBwYXJhbSB7Li4uQ29sbGVjdGlvbn0gY29sbGVjdGlvbnMgY29sbGVjdGlvbiBhcmd1bWVudHMgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtDb2xsZWN0aW9ufSBtZXJnZWQgY29sbGVjdGlvbi5cbiAqL1xuQ29sbGVjdGlvbi5tZXJnZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25zKSB7ICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgY29scyA9IGFwcy5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgIG5ld0l0ZW1zID0ge30sXG4gICAgICAgIG1lcmdlZCA9IG5ldyBDb2xsZWN0aW9uKGNvbHNbMF0uZ2V0SXRlbUlEKSxcbiAgICAgICAgZXh0ZW5kID0gdXRpbC5leHRlbmQ7XG5cbiAgICBmb3JFYWNoQXJyKGNvbHMsIGZ1bmN0aW9uKGNvbCkge1xuICAgICAgICBleHRlbmQobmV3SXRlbXMsIGNvbC5pdGVtcyk7XG4gICAgfSk7XG5cbiAgICBtZXJnZWQuaXRlbXMgPSBuZXdJdGVtcztcbiAgICBtZXJnZWQubGVuZ3RoID0gdXRpbC5rZXlzKG1lcmdlZC5pdGVtcykubGVuZ3RoO1xuXG4gICAgcmV0dXJuIG1lcmdlZDtcbn07XG5cbi8qKioqKioqKioqXG4gKiBwcm90b3R5cGUgcHJvcHNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIGdldCBtb2RlbCdzIHVuaXF1ZSBpZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIG1vZGVsIGluc3RhbmNlLlxuICogQHJldHVybnMge251bWJlcn0gbW9kZWwgdW5pcXVlIGlkLlxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5nZXRJdGVtSUQgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0uX2lkICsgJyc7XG59O1xuXG4vKipcbiAqIGFkZCBtb2RlbHMuXG4gKiBAcGFyYW0gey4uLip9IGl0ZW0gbW9kZWxzIHRvIGFkZCB0aGlzIGNvbGxlY3Rpb24uXG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICB2YXIgaWQsXG4gICAgICAgIG93bkl0ZW1zO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvckVhY2hBcnIoYXBzLmNhbGwoYXJndW1lbnRzKSwgZnVuY3Rpb24obykge1xuICAgICAgICAgICAgdGhpcy5hZGQobyk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZCA9IHRoaXMuZ2V0SXRlbUlEKGl0ZW0pO1xuICAgIG93bkl0ZW1zID0gdGhpcy5pdGVtcztcblxuICAgIGlmICghb3duSXRlbXNbaWRdKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IDE7XG4gICAgfVxuICAgIG93bkl0ZW1zW2lkXSA9IGl0ZW07XG59O1xuXG4vKipcbiAqIHJlbW92ZSBtb2RlbHMuXG4gKiBAcGFyYW0gey4uLihvYmplY3R8c3RyaW5nfG51bWJlcil9IGlkIG1vZGVsIGluc3RhbmNlIG9yIHVuaXF1ZSBpZCB0byBkZWxldGUuXG4gKiBAcmV0dXJucyB7YXJyYXl9IGRlbGV0ZWQgbW9kZWwgbGlzdC5cbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgcmVtb3ZlZCA9IFtdLFxuICAgICAgICBvd25JdGVtcyxcbiAgICAgICAgaXRlbVRvUmVtb3ZlO1xuXG4gICAgaWYgKCF0aGlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmVtb3ZlZCA9IHV0aWwubWFwKGFwcy5jYWxsKGFyZ3VtZW50cyksIGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmUoaWQpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICBvd25JdGVtcyA9IHRoaXMuaXRlbXM7XG5cbiAgICBpZiAoaXNPYmooaWQpKSB7XG4gICAgICAgIGlkID0gdGhpcy5nZXRJdGVtSUQoaWQpO1xuICAgIH1cblxuICAgIGlmICghb3duSXRlbXNbaWRdKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoIC09IDE7XG4gICAgaXRlbVRvUmVtb3ZlID0gb3duSXRlbXNbaWRdO1xuICAgIGRlbGV0ZSBvd25JdGVtc1tpZF07XG5cbiAgICByZXR1cm4gaXRlbVRvUmVtb3ZlO1xufTtcblxuLyoqXG4gKiByZW1vdmUgYWxsIG1vZGVscyBpbiBjb2xsZWN0aW9uLlxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaXRlbXMgPSB7fTtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIGNoZWNrIGNvbGxlY3Rpb24gaGFzIHNwZWNpZmljIG1vZGVsLlxuICogQHBhcmFtIHsob2JqZWN0fHN0cmluZ3xudW1iZXJ8ZnVuY3Rpb24pfSBpZCBtb2RlbCBpbnN0YW5jZSBvciBpZCBvciBmaWx0ZXIgZnVuY3Rpb24gdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSBpcyBoYXMgbW9kZWw/XG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIGlzRmlsdGVyLFxuICAgICAgICBoYXM7XG5cbiAgICBpZiAoIXRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpc0ZpbHRlciA9IGlzRnVuYyhpZCk7XG4gICAgaGFzID0gZmFsc2U7XG5cbiAgICBpZiAoaXNGaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChpZChpdGVtKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGhhcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZCA9IGlzT2JqKGlkKSA/IHRoaXMuZ2V0SXRlbUlEKGlkKSA6IGlkO1xuICAgICAgICBoYXMgPSB1dGlsLmlzRXhpc3R5KHRoaXMuaXRlbXNbaWRdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzO1xufTtcblxuLyoqXG4gKiBpbnZva2UgY2FsbGJhY2sgd2hlbiBtb2RlbCBleGlzdCBpbiBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcil9IGlkIG1vZGVsIHVuaXF1ZSBpZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIHRoZSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdIGNhbGxiYWNrIGNvbnRleHQuXG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmRvV2hlbkhhcyA9IGZ1bmN0aW9uKGlkLCBmbiwgY29udGV4dCkge1xuICAgIHZhciBpdGVtID0gdGhpcy5pdGVtc1tpZF07XG5cbiAgICBpZiAoIXV0aWwuaXNFeGlzdHkoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZuLmNhbGwoY29udGV4dCB8fCB0aGlzLCBpdGVtKTtcbn07XG5cbi8qKlxuICogU2VhcmNoIG1vZGVsLiBhbmQgcmV0dXJuIG5ldyBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZmlsdGVyIGZpbHRlciBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtDb2xsZWN0aW9ufSBuZXcgY29sbGVjdGlvbiB3aXRoIGZpbHRlcmVkIG1vZGVscy5cbiAqIEBleGFtcGxlXG4gKiBjb2xsZWN0aW9uLmZpbmQoZnVuY3Rpb24oaXRlbSkge1xuICogICAgIHJldHVybiBpdGVtLmVkaXRlZCA9PT0gdHJ1ZTtcbiAqIH0pO1xuICpcbiAqIGZ1bmN0aW9uIGZpbHRlcjEoaXRlbSkge1xuICogICAgIHJldHVybiBpdGVtLmVkaXRlZCA9PT0gZmFsc2U7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gZmlsdGVyMihpdGVtKSB7XG4gKiAgICAgcmV0dXJuIGl0ZW0uZGlzYWJsZWQgPT09IGZhbHNlO1xuICogfVxuICpcbiAqIGNvbGxlY3Rpb24uZmluZChDb2xsZWN0aW9uLmFuZChmaWx0ZXIxLCBmaWx0ZXIyKSk7XG4gKlxuICogY29sbGVjdGlvbi5maW5kKENvbGxlY3Rpb24ub3IoZmlsdGVyMSwgZmlsdGVyMikpO1xuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBDb2xsZWN0aW9uKCk7XG5cbiAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eSgnZ2V0SXRlbUlEJykpIHtcbiAgICAgICAgcmVzdWx0LmdldEl0ZW1JRCA9IHRoaXMuZ2V0SXRlbUlEO1xuICAgIH1cblxuICAgIHRoaXMuZWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGlmIChmaWx0ZXIoaXRlbSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEdyb3VwIGVsZW1lbnQgYnkgc3BlY2lmaWMga2V5IHZhbHVlcy5cbiAqXG4gKiBpZiBrZXkgcGFyYW1ldGVyIGlzIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0IGFuZCB1c2UgcmV0dXJuZWQgdmFsdWUuXG4gKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyfGZ1bmN0aW9ufGFycmF5KX0ga2V5IGtleSBwcm9wZXJ0eSBvciBnZXR0ZXIgZnVuY3Rpb24uIGlmIHN0cmluZ1tdIHN1cHBsaWVkLCBjcmVhdGUgZWFjaCBjb2xsZWN0aW9uIGJlZm9yZSBncm91cGluZy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtncm91cEZ1bmNdIC0gZnVuY3Rpb24gdGhhdCByZXR1cm4gZWFjaCBncm91cCdzIGtleVxuICogQHJldHVybnMge29iamVjdC48c3RyaW5nLCBDb2xsZWN0aW9uPn0gZ3JvdXBlZCBvYmplY3RcbiAqIEBleGFtcGxlXG4gKiBcbiAqIC8vIHBhc3MgYHN0cmluZ2AsIGBudW1iZXJgLCBgYm9vbGVhbmAgdHlwZSB2YWx1ZSB0aGVuIGdyb3VwIGJ5IHByb3BlcnR5IHZhbHVlLlxuICogY29sbGVjdGlvbi5ncm91cEJ5KCdnZW5kZXInKTsgICAgLy8gZ3JvdXAgYnkgJ2dlbmRlcicgcHJvcGVydHkgdmFsdWUuXG4gKiBjb2xsZWN0aW9uLmdyb3VwQnkoNTApOyAgICAgICAgICAvLyBncm91cCBieSAnNTAnIHByb3BlcnR5IHZhbHVlLlxuICogXG4gKiAvLyBwYXNzIGBmdW5jdGlvbmAgdGhlbiBncm91cCBieSByZXR1cm4gdmFsdWUuIGVhY2ggaW52b2NhdGlvbiBgZnVuY3Rpb25gIGlzIGNhbGxlZCB3aXRoIGAoaXRlbSlgLlxuICogY29sbGVjdGlvbi5ncm91cEJ5KGZ1bmN0aW9uKGl0ZW0pIHtcbiAqICAgICBpZiAoaXRlbS5zY29yZSA+IDYwKSB7XG4gKiAgICAgICAgIHJldHVybiAncGFzcyc7XG4gKiAgICAgfVxuICogICAgIHJldHVybiAnZmFpbCc7XG4gKiB9KTtcbiAqXG4gKiAvLyBwYXNzIGBhcnJheWAgd2l0aCBmaXJzdCBhcmd1bWVudHMgdGhlbiBjcmVhdGUgZWFjaCBjb2xsZWN0aW9uIGJlZm9yZSBncm91cGluZy5cbiAqIGNvbGxlY3Rpb24uZ3JvdXBCeShbJ2dvJywgJ3J1YnknLCAnamF2YXNjcmlwdCddKTtcbiAqIC8vIHJlc3VsdDogeyAnZ28nOiBlbXB0eSBDb2xsZWN0aW9uLCAncnVieSc6IGVtcHR5IENvbGxlY3Rpb24sICdqYXZhc2NyaXB0JzogZW1wdHkgQ29sbGVjdGlvbiB9XG4gKlxuICogLy8gY2FuIHBhc3MgYGZ1bmN0aW9uYCB3aXRoIGBhcnJheWAgdGhlbiBncm91cCBlYWNoIGVsZW1lbnRzLlxuICogY29sbGVjdGlvbi5ncm91cEJ5KFsnZ28nLCAncnVieScsICdqYXZhc2NyaXB0J10sIGZ1bmN0aW9uKGl0ZW0pIHtcbiAqICAgICBpZiAoaXRlbS5pc0Zhc3QpIHtcbiAqICAgICAgICAgcmV0dXJuICdnbyc7XG4gKiAgICAgfVxuICpcbiAqICAgICByZXR1cm4gaXRlbS5uYW1lO1xuICogfSk7XG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmdyb3VwQnkgPSBmdW5jdGlvbihrZXksIGdyb3VwRnVuYykge1xuICAgIHZhciByZXN1bHQgPSB7fSxcbiAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgYmFzZVZhbHVlLFxuICAgICAgICBpc0Z1bmMgPSB1dGlsLmlzRnVuY3Rpb24sXG4gICAgICAgIGtleUlzRnVuYyA9IGlzRnVuYyhrZXkpLFxuICAgICAgICBnZXRJdGVtSURGbiA9IHRoaXMuZ2V0SXRlbUlEO1xuXG4gICAgaWYgKHV0aWwuaXNBcnJheShrZXkpKSB7XG4gICAgICAgIHV0aWwuZm9yRWFjaEFycmF5KGtleSwgZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgcmVzdWx0W2sgKyAnJ10gPSBuZXcgQ29sbGVjdGlvbihnZXRJdGVtSURGbik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghZ3JvdXBGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAga2V5ID0gZ3JvdXBGdW5jO1xuICAgICAgICBrZXlJc0Z1bmMgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuZWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGlmIChrZXlJc0Z1bmMpIHtcbiAgICAgICAgICAgIGJhc2VWYWx1ZSA9IGtleShpdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VWYWx1ZSA9IGl0ZW1ba2V5XTtcblxuICAgICAgICAgICAgaWYgKGlzRnVuYyhiYXNlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgYmFzZVZhbHVlID0gYmFzZVZhbHVlLmFwcGx5KGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29sbGVjdGlvbiA9IHJlc3VsdFtiYXNlVmFsdWVdO1xuXG4gICAgICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgICAgICAgY29sbGVjdGlvbiA9IHJlc3VsdFtiYXNlVmFsdWVdID0gbmV3IENvbGxlY3Rpb24oZ2V0SXRlbUlERm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29sbGVjdGlvbi5hZGQoaXRlbSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gc2luZ2xlIGl0ZW0gaW4gY29sbGVjdGlvbi5cbiAqXG4gKiBSZXR1cm5lZCBpdGVtIGlzIGluc2VydGVkIGluIHRoaXMgY29sbGVjdGlvbiBmaXJzdGx5LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZpbHRlcl0gLSBmdW5jdGlvbiBmaWx0ZXJcbiAqIEByZXR1cm5zIHtvYmplY3R9IGl0ZW0uXG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnNpbmdsZSA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciByZXN1bHQsXG4gICAgICAgIHVzZUZpbHRlciA9IHV0aWwuaXNGdW5jdGlvbihmaWx0ZXIpO1xuXG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaWYgKCF1c2VGaWx0ZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGl0ZW07XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBzb3J0IGEgYmFzaXMgb2Ygc3VwcGxpZWQgY29tcGFyZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmVGdW5jdGlvbiBjb21wYXJlRnVuY3Rpb25cbiAqIEByZXR1cm5zIHthcnJheX0gc29ydGVkIGFycmF5LlxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24oY29tcGFyZUZ1bmN0aW9uKSB7XG4gICAgdmFyIGFyciA9IFtdO1xuXG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgYXJyLnB1c2goaXRlbSk7XG4gICAgfSk7XG5cbiAgICBpZiAoaXNGdW5jKGNvbXBhcmVGdW5jdGlvbikpIHtcbiAgICAgICAgYXJyID0gYXJyLnNvcnQoY29tcGFyZUZ1bmN0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gKiBpdGVyYXRlIGVhY2ggbW9kZWwgZWxlbWVudC5cbiAqXG4gKiB3aGVuIGl0ZXJhdGVlIHJldHVybiBmYWxzZSB0aGVuIGJyZWFrIHRoZSBsb29wLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgaXRlcmF0ZWUoaXRlbSwgaW5kZXgsIGl0ZW1zKVxuICogQHBhcmFtIHsqfSBbY29udGV4dF0gY29udGV4dFxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24oaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBmb3JFYWNoUHJvcCh0aGlzLml0ZW1zLCBpdGVyYXRlZSwgY29udGV4dCB8fCB0aGlzKTtcbn07XG5cbi8qKlxuICogcmV0dXJuIG5ldyBhcnJheSB3aXRoIGNvbGxlY3Rpb24gaXRlbXMuXG4gKiBAcmV0dXJucyB7YXJyYXl9IG5ldyBhcnJheS5cbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlsLm1hcCh0aGlzLml0ZW1zLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0aW9uO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgY29tbW9uL2dlbmVyYWwgdXRpbGl0aWVzLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwudHVpLnV0aWw7XG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9jb2xsZWN0aW9uJyk7XG52YXIgYXBzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5mdW5jdGlvbiBldmVudElER2V0dGVyKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmNpZCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gey4uLip9IGluaXRJdGVtcyAtIGl0ZW1zIHRvIGFkZCBuZXdseSBjcmVhdGVkIGNvbGxlY3Rpb24uXG4gICAgICogQHJldHVybnMge0NvbGxlY3Rpb259IG5ldyBjb2xsZWN0aW9uIGZvciBldmVudCBtb2RlbHMuXG4gICAgICovXG4gICAgY3JlYXRlRXZlbnRDb2xsZWN0aW9uOiBmdW5jdGlvbihpbml0SXRlbXMpIHsgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICB2YXIgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKGV2ZW50SURHZXR0ZXIpO1xuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLmFkZC5hcHBseShjb2xsZWN0aW9uLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByYXRpbyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIGEgOiBiID0geSA6IFg7XG4gICAgICpcbiAgICAgKiA9XG4gICAgICpcbiAgICAgKiBYID0gKGIgKiB5KSAvIGE7XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGEgLSBhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGIgLSBiXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB5XG4gICAgICogQHJldHVybnMge251bWJlcn0gcmF0aW8gdmFsdWVcbiAgICAgKi9cbiAgICByYXRpbzogZnVuY3Rpb24oYSwgYiwgeSkge1xuICAgICAgICAvLyBhIDogYiA9IHkgOiB4O1xuICAgICAgICByZXR1cm4gKGIgKiB5KSAvIGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbmVhcmVzdCB2YWx1ZSBmcm9tIHN1cHBsaWVkIHBhcmFtcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kLlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IG5lYXJlc3QgLSBuZWFyZXN0IGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG5lYXJlc3QgdmFsdWVcbiAgICAgKi9cbiAgICBuZWFyZXN0OiBmdW5jdGlvbih2YWx1ZSwgbmVhcmVzdCkge1xuICAgICAgICB2YXIgZGlmZiA9IHV0aWwubWFwKG5lYXJlc3QsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModmFsdWUgLSB2KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbmVhcmVzdEluZGV4ID0gdXRpbC5pbkFycmF5KE1hdGgubWluLmFwcGx5KG51bGwsIGRpZmYpLCBkaWZmKTtcblxuICAgICAgICByZXR1cm4gbmVhcmVzdFtuZWFyZXN0SW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBwaWNrIHZhbHVlIGZyb20gb2JqZWN0IHRoZW4gcmV0dXJuIHV0aWxpdHkgb2JqZWN0IHRvIHRyZWF0IGl0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSBvYmplY3QgdG8gc2VhcmNoIHN1cHBsaWVkIHBhdGggcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHsuLi5zdHJpbmd9IHBhdGhzIC0gcmVzdCBwYXJhbWV0ZXIgdGhhdCBzdHJpbmcgdmFsdWUgdG8gc2VhcmNoIHByb3BlcnR5IGluIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBwaWNrIG9iamVjdC5cbiAgICAgKi9cbiAgICBwaWNrMjogZnVuY3Rpb24ob2JqLCBwYXRocykgeyAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIHZhciByZXN1bHQgPSB1dGlsLnBpY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKSxcbiAgICAgICAgICAgIHBpY2s7XG5cbiAgICAgICAgcGljayA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybnMgeyp9IHBpY2tlZCB2YWx1ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBpbnZva2Ugc3VwcGxpZWQgZnVuY3Rpb24gaW4gcGlja2VkIG9iamVjdC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiB0aGUgY2FsbGJhY2sgY29udGV4dCBpcyBzZXQgcGlja2VkIG9iamVjdC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufSBmbiAtIGZ1bmN0aW9uIHRvIGludm9rZSBpbiBwaWNrZWQgb2JqZWN0LlxuICAgICAgICAgICAgICogQHJldHVybnMgeyp9IHJlc3VsdCBvZiBpbnZva2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3M7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAgICAvL2VzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcmdzID0gYXBzLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKGZuKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHV0aWwucGljayhyZXN1bHQsIGZuKSB8fCBmdW5jdGlvbigpIHt9KS5hcHBseShyZXN1bHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHJlc3VsdCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gcGljaztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWl4aW4gbWV0aG9kLlxuICAgICAqXG4gICAgICogKGV4dGVuZCBtZXRob2RzIGV4Y2VwdCBwcm9wZXJ0eSBuYW1lICdtaXhpbicpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGZyb20gLSBtaXhpbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRvIC0gb2JqZWN0IHRvIG1peGluLlxuICAgICAqL1xuICAgIG1peGluOiBmdW5jdGlvbihmcm9tLCB0bykge1xuICAgICAgICB1dGlsLmV4dGVuZCh0by5wcm90b3R5cGUsIGZyb20pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMaW1pdCBzdXBwbGllZCB2YWx1ZSBiYXNlIG9uIGBtaW5BcnJgLCBgbWF4QXJyYFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHZhbHVlXG4gICAgICogQHBhcmFtIHthcnJheX0gbWluQXJyIC0gbWluXG4gICAgICogQHBhcmFtIHthcnJheX0gbWF4QXJyIC0gbWF4XG4gICAgICogQHJldHVybiB7bnVtYmVyfSBsaW1pdGVkIHZhbHVlXG4gICAgICovXG4gICAgbGltaXQ6IGZ1bmN0aW9uKHZhbHVlLCBtaW5BcnIsIG1heEFycikge1xuICAgICAgICB2YXIgdiA9IE1hdGgubWF4LmFwcGx5KG51bGwsIFt2YWx1ZV0uY29uY2F0KG1pbkFycikpO1xuICAgICAgICB2ID0gTWF0aC5taW4uYXBwbHkobnVsbCwgW3ZdLmNvbmNhdChtYXhBcnIpKTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfSxcblxuICAgIHN0cmlwVGFnczogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvPChbXj5dKyk+L2lnLCAnJyk7XG4gICAgfVxufTtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGRhdGV0aW1lIHV0aWxpdHkgbW9kdWxlXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC50dWkudXRpbCxcbiAgICBvcHQgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgZGF0ZUZvcm1hdFJ4ID0gL14oXFxkezR9Wy18XFwvXSpcXGR7Mn1bLXxcXC9dKlxcZHsyfSlcXHM/KFxcZHsyfTpcXGR7Mn06XFxkezJ9KT8kLztcblxudmFyIGRhdGV0aW1lLFxuICAgIHRva2VuRnVuYztcblxudmFyIG1lbW8gPSB7XG4gICAgbWlsbGlzZWNvbmRzVG86IHt9LFxuICAgIG1pbGxpc2Vjb25kc0Zyb206IHt9XG59O1xuXG50b2tlbkZ1bmMgPSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlIGRhdGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFlZWVlNTUREXG4gICAgICovXG4gICAgJ1lZWVlNTUREJzogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgICAgZGF0ZXRpbWUubGVhZGluZ1plcm8oZGF0ZS5nZXRNb250aCgpICsgMSwgMiksXG4gICAgICAgICAgICBkYXRldGltZS5sZWFkaW5nWmVybyhkYXRlLmdldERhdGUoKSwgMilcbiAgICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBkYXRlIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGZvdXIgZGlnaXQgeWVhciBudW1iZXJcbiAgICAgKi9cbiAgICAnWVlZWSc6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKSArICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUgZGF0ZSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0d28gZGlnaXQgbW9udGggbnVtYmVyXG4gICAgICovXG4gICAgJ01NJzogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZXRpbWUubGVhZGluZ1plcm8oZGF0ZS5nZXRNb250aCgpICsgMSwgMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBkYXRlIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHR3byBkaWdpdCBkYXRlIG51bWJlclxuICAgICAqL1xuICAgICdERCc6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGV0aW1lLmxlYWRpbmdaZXJvKGRhdGUuZ2V0RGF0ZSgpLCAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlIGRhdGUgb2JqZWN0XG4gICAgICogQHJldHVybnMge3N0cmluZ30gSEg6bW1cbiAgICAgKi9cbiAgICAnSEg6bW0nOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHZhciBob3VyID0gZGF0ZS5nZXRIb3VycygpLFxuICAgICAgICAgICAgbWludXRlcyA9IGRhdGUuZ2V0TWludXRlcygpO1xuXG4gICAgICAgIHJldHVybiBkYXRldGltZS5sZWFkaW5nWmVybyhob3VyLCAyKSArICc6JyArXG4gICAgICAgICAgICBkYXRldGltZS5sZWFkaW5nWmVybyhtaW51dGVzLCAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZm9ybWF0IHRvIGxvY2FsIGRhdGVcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUgZGF0ZSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAxOTg4LTA5LTI1VDA5OjAwOjAwKzA5OjAwXG4gICAgICovXG4gICAgJ0xPQ0FMJzogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB2YXIgdGltZVpvbmVPZmZzZXQgPSAtZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpLFxuICAgICAgICAgICAgZGlmZiA9IHRpbWVab25lT2Zmc2V0ID49IDAgPyAnKycgOiAnLScsXG4gICAgICAgICAgICBwYWQgPSBmdW5jdGlvbihudW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZXRpbWUubGVhZGluZ1plcm8obnVtLCAyKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKSBcbiAgICAgICAgICAgICsgJy0nICsgcGFkKGRhdGUuZ2V0TW9udGgoKSArIDEpXG4gICAgICAgICAgICArICctJyArIHBhZChkYXRlLmdldERhdGUoKSlcbiAgICAgICAgICAgICsgJ1QnICsgcGFkKGRhdGUuZ2V0SG91cnMoKSlcbiAgICAgICAgICAgICsgJzonICsgcGFkKGRhdGUuZ2V0TWludXRlcygpKSBcbiAgICAgICAgICAgICsgJzonICsgcGFkKGRhdGUuZ2V0U2Vjb25kcygpKSBcbiAgICAgICAgICAgICsgZGlmZiArIHBhZCh0aW1lWm9uZU9mZnNldCAvIDYwKSBcbiAgICAgICAgICAgICsgJzonICsgcGFkKHRpbWVab25lT2Zmc2V0ICUgNjApO1xuICAgIH1cbn07XG5cbmRhdGV0aW1lID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9uZSBkYXkuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBNSUxMSVNFQ09ORFNfUEVSX0RBWTogODY0MDAwMDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvbmUgaG91ci5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIE1JTExJU0VDT05EU19QRVJfSE9VUjogMzYwMDAwMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9uZSBtaW51dGVzLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgTUlMTElTRUNPTkRTX1BFUl9NSU5VVEVTOiA2MDAwMCxcblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnQgbWlsbGlzZWNvbmRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSB0eXBlIG9mIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgLSBpdGVyYXRlZSBmdW5jdGlvbiB0byB1c2UgcmVkdWNlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGNvbnZlcnRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBfY29udk1pbGxpc2Vjb25kczogZnVuY3Rpb24odHlwZSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBjb252ID0gWzYwLCA2MCwgMTAwMF0sXG4gICAgICAgICAgICBpbmRleCA9IHtcbiAgICAgICAgICAgICAgICBob3VyOiAwLFxuICAgICAgICAgICAgICAgIG1pbnV0ZXM6IDEsXG4gICAgICAgICAgICAgICAgc2Vjb25kczogMlxuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAoISh0eXBlIGluIGluZGV4KSB8fCBnbG9iYWwuaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXRpbC5yZWR1Y2UoW3ZhbHVlXS5jb25jYXQoY29udi5zbGljZShpbmRleFt0eXBlXSkpLCBpdGVyYXRlZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgbWlsbGlzZWNvbmRzIHZhbHVlIHRvIG90aGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge3R5cGV9IHR5cGUgY29udmVydCB0byB0eXBlIHdhbnQgdG8uIHN1cHBvcnQgXCJob3VyXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIiBvbmx5LlxuICAgICAqIEBwYXJhbSB7dmFsdWV9IHZhbHVlIC0gdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBjb252ZXJ0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgbWlsbGlzZWNvbmRzVG86IGZ1bmN0aW9uKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IG1lbW8ubWlsbGlzZWNvbmRzVG8sXG4gICAgICAgICAgICBrZXkgPSB0eXBlICsgdmFsdWU7XG5cbiAgICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FjaGVba2V5XSA9IGRhdGV0aW1lLl9jb252TWlsbGlzZWNvbmRzKHR5cGUsIHZhbHVlLCBmdW5jdGlvbihtZW1vLCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gbWVtbyAvIHY7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjYWNoZVtrZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHZhbHVlIHRvIG1pbGxpc2Vjb25kc1xuICAgICAqIEBwYXJhbSB7dHlwZX0gdHlwZSAtIHR5cGUgb2Ygc3VwcGxpZWQgdmFsdWUuIHN1cHBvcnQgXCJob3VyXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIiBvbmx5LlxuICAgICAqIEBwYXJhbSB7dmFsdWV9IHZhbHVlIC0gdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBjb252ZXJ0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgbWlsbGlzZWNvbmRzRnJvbTogZnVuY3Rpb24odHlwZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gbWVtby5taWxsaXNlY29uZHNGcm9tLFxuICAgICAgICAgICAga2V5ID0gdHlwZSArIHZhbHVlO1xuXG4gICAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhY2hlW2tleV0gPSBkYXRldGltZS5fY29udk1pbGxpc2Vjb25kcyh0eXBlLCB2YWx1ZSwgZnVuY3Rpb24obWVtbywgdikge1xuICAgICAgICAgICAgcmV0dXJuIG1lbW8gKiB2O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2FjaGVba2V5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBkYXRlIGFycmF5IGZyb20gc3VwcGxpZWQgcGFyYW10ZXJzLlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gc3RhcnQgU3RhcnQgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0RhdGV9IGVuZCBFbmQgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB1c2UgaW5jcmVtZW50LlxuICAgICAqIEByZXR1cm5zIHthcnJheX0gRGF0ZSBhcnJheS5cbiAgICAgKi9cbiAgICByYW5nZTogZnVuY3Rpb24oc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgICB2YXIgY3Vyc29yID0gbmV3IERhdGUoc3RhcnQuZ2V0VGltZSgpKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIHdoaWxlIChjdXJzb3IgPD0gZW5kKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXJzb3IpO1xuICAgICAgICAgICAgY3Vyc29yID0gbmV3IERhdGUoY3Vyc29yLmdldFRpbWUoKSArIHN0ZXApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xvbmUgc3VwcGxpZWQgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUgZGF0ZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0RhdGV9IENsb25lZCBkYXRlIG9iamVjdFxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmUgdHdvIGRhdGVzLlxuICAgICAqXG4gICAgICogd2hlbiBmaXJzdCBkYXRlIGlzIGxhdGVzdCB0aGVuIHNlY29uZHMgdGhlbiByZXR1cm4gLTEuXG4gICAgICpcbiAgICAgKiByZXR1cm4gKzEgcmV2ZXJzZSwgYW5kIHJldHVybiAwIGlzIHNhbWUuXG4gICAgICogQHBhcmFtIHtEYXRlfSBkMSBEYXRlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZDIgRGF0ZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSByZXN1bHQgb2YgY29tcGFyZVxuICAgICAqL1xuICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGQxLCBkMikge1xuICAgICAgICB2YXIgX2QxID0gZDEuZ2V0VGltZSgpLFxuICAgICAgICAgICAgX2QyID0gZDIuZ2V0VGltZSgpO1xuXG4gICAgICAgIGlmIChfZDEgPCBfZDIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChfZDEgPiBfZDIpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGQxIC0gZGF0ZSBvbmVcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGQyIC0gZGF0ZSB0d29cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gaXMgdHdvIGRhdGUgYXJlIHNhbWUgeWVhciwgbW9udGg/XG4gICAgICovXG4gICAgaXNTYW1lTW9udGg6IGZ1bmN0aW9uKGQxLCBkMikge1xuICAgICAgICByZXR1cm4gKGQxLmdldEZ1bGxZZWFyKCkgPT09IGQyLmdldEZ1bGxZZWFyKCkgJiZcbiAgICAgICAgICAgICAgICBkMS5nZXRNb250aCgpID09PSBkMi5nZXRNb250aCgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRlfSBkMSAtIGRhdGUgb25lXG4gICAgICogQHBhcmFtIHtEYXRlfSBkMiAtIGRhdGUgdHdvXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGlzIHR3byBkYXRlIGFyZSBzYW1lIHllYXIsIG1vbnRoLCBkYXRlP1xuICAgICAqL1xuICAgIGlzU2FtZURhdGU6IGZ1bmN0aW9uKGQxLCBkMikge1xuICAgICAgICB2YXIgc2FtZU1vbnRoID0gZGF0ZXRpbWUuaXNTYW1lTW9udGgoZDEsIGQyKTtcbiAgICAgICAgcmV0dXJuIHNhbWVNb250aCAmJiAoZDEuZ2V0RGF0ZSgpID09PSBkMi5nZXREYXRlKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBzdXBwbGllZCBwYXJhbWV0ZXIgaXMgdmFsaWQgZGF0ZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsqfSBkIE9iamVjdCB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJuIHRydWUgd2hlbiBwYXJhbWV0ZXIgaXMgdmFsaWQgZGF0ZSBvYmplY3QuXG4gICAgICovXG4gICAgaXNWYWxpZDogZnVuY3Rpb24oZCkge1xuICAgICAgICBpZiAob3B0LmNhbGwoZCkgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgICAgICAgICAgcmV0dXJuICF3aW5kb3cuaXNOYU4oZC5nZXRUaW1lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBub24gbG9jYWwgZGF0ZSB0byBVVEMgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0RhdGV9IGQgRGF0ZSB0byBjb252ZXJ0IFVUQy5cbiAgICAgKiBAcmV0dXJucyB7RGF0ZX0gVGhlIFVUQyBEYXRlLlxuICAgICAqL1xuICAgIHRvVVRDOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHZhciBsID0gZC5nZXRUaW1lKCksXG4gICAgICAgICAgICBvZmZzZXQgPSBkYXRldGltZS5taWxsaXNlY29uZHNGcm9tKCdtaW51dGVzJywgbmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpKTtcblxuICAgICAgICByZXR1cm4gbmV3IERhdGUobCArIG9mZnNldCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHBhZCBsZWZ0IHplcm8gY2hhcmFjdGVycy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIG51bWJlciB2YWx1ZSB0byBwYWQgemVyby5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIHBhZCBsZW5ndGggdG8gd2FudC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwYWRkZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGxlYWRpbmdaZXJvOiBmdW5jdGlvbihudW1iZXIsIGxlbmd0aCkge1xuICAgICAgICB2YXIgemVybyA9ICcnLFxuICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgaWYgKChudW1iZXIgKyAnJykubGVuZ3RoID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJyc7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaSA8IChsZW5ndGggLSAxKTsgaSArPSAxKSB7XG4gICAgICAgICAgICB6ZXJvICs9ICcwJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoemVybyArIG51bWJlcikuc2xpY2UobGVuZ3RoICogLTEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGRhdGUgc3RyaW5nIHRvIGRhdGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogT25seSBsaXN0ZWQgYmVsb3cgZm9ybWF0cyBhdmFsaWFibGUuXG4gICAgICpcbiAgICAgKiAtIFlZWVlNTUREXG4gICAgICogLSBZWVlZL01NL0REXG4gICAgICogLSBZWVlZLU1NLUREXG4gICAgICogLSBZWVlZL01NL0REIEhIOm1tOlNTXG4gICAgICogLSBZWVlZLU1NLUREIEhIOm1tOlNTXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIEZvcm1hdHRlZCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmaXhNb250aD0tMV0gLSBudW1iZXIgZm9yIGZpeCBtb250aCBjYWxjdWxhdGluZy5cbiAgICAgKiBAcmV0dXJucyB7KERhdGV8Ym9vbGVhbil9IENvbnZlcnRlZCBEYXRlIG9iamVjdC4gd2hlbiBzdXBwbGllZCBzdHIgaXMgbm90IGF2YWlsYWJsZSB0aGVuIHJldHVybiBmYWxzZS5cbiAgICAgKi9cbiAgICBwYXJzZTogZnVuY3Rpb24oc3RyLCBmaXhNb250aCkge1xuICAgICAgICB2YXIgc2VwYXJhdG9yLFxuICAgICAgICAgICAgbWF0Y2hlcyA9IHN0ci5tYXRjaChkYXRlRm9ybWF0UngpLFxuICAgICAgICAgICAgeW1kLFxuICAgICAgICAgICAgaG1zO1xuXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGZpeE1vbnRoKSkge1xuICAgICAgICAgICAgZml4TW9udGggPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPiA4KSB7XG4gICAgICAgICAgICAvLyBZWVlZL01NL0REXG4gICAgICAgICAgICAvLyBZWVlZLU1NLUREXG4gICAgICAgICAgICAvLyBZWVlZL01NL0REIEhIOm1tOlNTXG4gICAgICAgICAgICAvLyBZWVlZLU1NLUREIEhIOm1tOlNTXG4gICAgICAgICAgICBzZXBhcmF0b3IgPSB+c3RyLmluZGV4T2YoJy8nKSA/ICcvJyA6ICctJztcbiAgICAgICAgICAgIG1hdGNoZXMgPSBtYXRjaGVzLnNwbGljZSgxKTtcblxuICAgICAgICAgICAgeW1kID0gbWF0Y2hlc1swXS5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICAgICAgaG1zID0gbWF0Y2hlc1sxXSA/IG1hdGNoZXNbMV0uc3BsaXQoJzonKSA6IFswLCAwLCAwXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFlZWVlNTUREXG4gICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlc1swXTtcbiAgICAgICAgICAgIHltZCA9IFttYXRjaGVzLnN1YnN0cigwLCA0KSwgbWF0Y2hlcy5zdWJzdHIoNCwgMiksIG1hdGNoZXMuc3Vic3RyKDYsIDIpXTtcbiAgICAgICAgICAgIGhtcyA9IFswLCAwLCAwXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgreW1kWzBdLCAreW1kWzFdICsgZml4TW9udGgsICt5bWRbMl0sICtobXNbMF0sICtobXNbMV0sICtobXNbMl0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gZGF0ZSBvYmplY3QgZnJvbSBEYXRlLlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBkYXRlXG4gICAgICogQHJldHVybnMge29iamVjdH0gRGF0ZSBvYmplY3QuXG4gICAgICovXG4gICAgcmF3OiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5OiBkYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICBNOiBkYXRlLmdldE1vbnRoKCksXG4gICAgICAgICAgICBkOiBkYXRlLmdldERhdGUoKSxcbiAgICAgICAgICAgIGg6IGRhdGUuZ2V0SG91cnMoKSxcbiAgICAgICAgICAgIG06IGRhdGUuZ2V0TWludXRlcygpLFxuICAgICAgICAgICAgczogZGF0ZS5nZXRTZWNvbmRzKCksXG4gICAgICAgICAgICBtczogZGF0ZS5nZXRNaWxsaXNlY29uZHMoKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gMDA6MDA6MDAgc3VwcGxpZWQgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUgZGF0ZS5cbiAgICAgKiBAcmV0dXJucyB7RGF0ZX0gc3RhcnQgZGF0ZS5cbiAgICAgKi9cbiAgICBzdGFydDogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcbiAgICAgICAgZC5zZXRIb3VycygwLCAwLCAwLCAwKTtcblxuICAgICAgICByZXR1cm4gZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIDIzOjU5OjU5IHN1cHBsaWVkIGRhdGUuXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlIGRhdGUuXG4gICAgICogQHJldHVybnMge0RhdGV9IGVuZCBkYXRlLlxuICAgICAqL1xuICAgIGVuZDogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcbiAgICAgICAgZC5zZXRIb3VycygyMywgNTksIDU5LCAwKTtcblxuICAgICAgICByZXR1cm4gZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGZvcm1hdHRlZCBzdHJpbmcgYXMgYmFzaXMgb2Ygc3VwcGxpZWQgc3RyaW5nLlxuICAgICAqXG4gICAgICogU3VwcG9ydGVkIFRva2VuIExpc3RzLlxuICAgICAqXG4gICAgICogLSBZWVlZID0+IDE5ODhcbiAgICAgKiAtIE1NID0+IDAxIH4gMTJcbiAgICAgKiAtIEREID0+IDAxIH4gMzFcbiAgICAgKiAtIFlZWVlNTUREID0+IDE5ODgwOTI1XG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlIFN0cmluZyB3YW50IHRvIGZvcm1hdHRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IGZvcm1hdCBzdHIuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gIEZvcm1hdHRlZCBkYXRlIHN0cmluZy5cbiAgICAgKi9cbiAgICBmb3JtYXQ6IGZ1bmN0aW9uKGRhdGUsIGZvcm1hdCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZm9ybWF0O1xuICAgICAgICB1dGlsLmZvckVhY2hPd25Qcm9wZXJ0aWVzKHRva2VuRnVuYywgZnVuY3Rpb24oY29udmVydGVyLCB0b2tlbikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UodG9rZW4sIGNvbnZlcnRlcihkYXRlKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiAyLWRpbWVuc2lvbmFsIGFycmF5IG1vbnRoIGNhbGVuZGFyXG4gICAgICpcbiAgICAgKiBkYXRlcyB0aGF0IGRpZmZlcmVudCBtb250aCB3aXRoIGdpdmVuIGRhdGUgYXJlIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7RGF0ZX0gbW9udGggLSBkYXRlIHdhbnQgdG8gY2FsY3VsYXRlIG1vbnRoIGNhbGVuZGFyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydERheU9mV2Vlaz0wXSAtIHN0YXJ0IGRheSBvZiB3ZWVrXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2l0ZXJhdGVlXSAtIGl0ZXJhdGVlIGZvciBjdXN0b21pemluZyBjYWxlbmRhciBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZ1tdPn0gY2FsZW5kYXIgMmQgYXJyYXlcbiAgICAgKi9cbiAgICBhcnIyZENhbGVuZGFyOiBmdW5jdGlvbihtb250aCwgc3RhcnREYXlPZldlZWssIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciB3ZWVrQXJyLFxuICAgICAgICAgICAgc3RhcnRzLCBlbmRzLFxuICAgICAgICAgICAgc3RhcnRJbmRleCwgZW5kSW5kZXgsXG4gICAgICAgICAgICBhZnRlckRhdGVzLFxuICAgICAgICAgICAgY3Vyc29yLCB3ZWVrLFxuICAgICAgICAgICAgY2FsZW5kYXIgPSBbXTtcblxuICAgICAgICBzdGFydHMgPSBuZXcgRGF0ZShuZXcgRGF0ZSgrbW9udGgpLnNldERhdGUoMSkpO1xuICAgICAgICBlbmRzID0gbmV3IERhdGUobmV3IERhdGUoK3N0YXJ0cykuc2V0TW9udGgoc3RhcnRzLmdldE1vbnRoKCkgKyAxKSk7XG4gICAgICAgIGVuZHMgPSBuZXcgRGF0ZShuZXcgRGF0ZSgrZW5kcykuc2V0RGF0ZShlbmRzLmdldERhdGUoKSAtIDEpKTtcblxuICAgICAgICAvLyBjcmVhdGUgZGF5IG51bWJlciBhcnJheSBieSBzdGFydERheU9mV2VlayBudW1iZXJcbiAgICAgICAgLy8gNCAtPiBbNCwgNSwgNiwgMCwgMSwgMiwgM11cbiAgICAgICAgLy8gMiAtPiBbMiwgMywgNCwgNSwgNiwgMCwgMV1cbiAgICAgICAgd2Vla0FyciA9IHV0aWwucmFuZ2Uoc3RhcnREYXlPZldlZWssIDcpLmNvbmNhdCh1dGlsLnJhbmdlKDcpKS5zbGljZSgwLCA3KTtcbiAgICAgICAgc3RhcnRJbmRleCA9IHV0aWwuaW5BcnJheShzdGFydHMuZ2V0RGF5KCksIHdlZWtBcnIpO1xuICAgICAgICBlbmRJbmRleCA9IHV0aWwuaW5BcnJheShlbmRzLmdldERheSgpLCB3ZWVrQXJyKTtcbiAgICAgICAgLy8gZnJlZSBkYXRlcyBhZnRlciBsYXN0IGRhdGUgb2YgdGhpcyBtb250aFxuICAgICAgICBhZnRlckRhdGVzID0gNyAtIChlbmRJbmRleCArIDEpO1xuXG4gICAgICAgIGN1cnNvciA9IG5ldyBEYXRlKG5ldyBEYXRlKCtzdGFydHMpLnNldERhdGUoc3RhcnRzLmdldERhdGUoKSAtIHN0YXJ0SW5kZXgpKTtcbiAgICAgICAgLy8gaXRlcmF0ZWUgYWxsIGRhdGVzIHRvIHJlbmRlclxuICAgICAgICB1dGlsLmZvckVhY2hBcnJheSh1dGlsLnJhbmdlKHN0YXJ0SW5kZXggKyBlbmRzLmdldERhdGUoKSArIGFmdGVyRGF0ZXMpLCBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZTtcblxuICAgICAgICAgICAgaWYgKCEoaSAlIDcpKSB7XG4gICAgICAgICAgICAgICAgLy8gZ3JvdXAgZWFjaCBkYXRlIGJ5IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrID0gY2FsZW5kYXJbaSAvIDddID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgrY3Vyc29yKTtcbiAgICAgICAgICAgIGRhdGUgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKGRhdGUpIDogZGF0ZTtcbiAgICAgICAgICAgIHdlZWsucHVzaChkYXRlKTtcblxuICAgICAgICAgICAgLy8gYWRkIGRhdGVcbiAgICAgICAgICAgIGN1cnNvciA9IG5ldyBEYXRlKGN1cnNvci5zZXREYXRlKGN1cnNvci5nZXREYXRlKCkgKyAxKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjYWxlbmRhcjtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRhdGV0aW1lO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlydHkgZmxhZ2dpbmcgbW9kdWxlIGZvciBvYmplY3RzLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGNvbW1vbiA9IGdsb2JhbC50dWkudXRpbCxcbiAgICBleGlzdHkgPSBjb21tb24uaXNFeGlzdHksXG4gICAgcGljayA9IGNvbW1vbi5waWNrLFxuICAgIGlzRnVuYyA9IGNvbW1vbi5pc0Z1bmN0aW9uO1xuXG4vKipcbiAqIE1peGluIG1vZHVsZSBmb3IgZGlydHkgZmxhZ2dpbmcgb24gc3BlY2lmaWMgb2JqZWN0cy5cbiAqIEBtaXhpblxuICogQGV4YW1wbGVcbiAqIHZhciBvYmogPSB7IGhlbGxvOiAnZ29vZCcsIHRlc3Q6ICcxMjMnIH07XG4gKiBkaXJ0eS5taXhpbihvYmopO1xuICpcbiAqIG9iai5zZXQoJ2hlbGxvJywgJ3dvcmxkJyk7XG4gKiBvYmouaXNEaXJ0eSgpOyAgICAvLyB0cnVlXG4gKiBvYmouaXNQcm9wQ2hhbmdlZCgnaGVsbG8nKTsgICAgLy8gdHJ1ZVxuICogb2JqLmlzUHJvcENoYW5nZWQoJ3Rlc3QnKTsgICAgLy8gZmFsc2VcbiAqIG9iai5kaXJ0eShmYWxzZSk7XG4gKlxuICogb2JqLmlzRGlydHkoKTsgICAgLy8gZmFsc2VcbiAqIG9iai5pc1Byb3BDaGFuZ2VkKCdoZWxsbycpOyAgICAvLyBmYWxzZVxuICovXG52YXIgZGlydHkgPSB7XG4gICAgLyoqXG4gICAgICogU2V0IHByb3BlcnR5IHZhbHVlIHdpdGggZGlydHkgZmxhZ2dpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BOYW1lIFByb3BlcnR5IG5hbWUuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBQcm9wcnR5IHZhbHVlLlxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ocHJvcE5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBvcmlnaW5WYWx1ZSA9IHRoaXNbcHJvcE5hbWVdO1xuXG4gICAgICAgIGlmIChvcmlnaW5WYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jaGFuZ2VkKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNhdmUgY2hhbmdlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICogQG1lbWJlcm9mIGRpcnR5XG4gICAgICAgICAgICAgKiBAbmFtZSBfY2hhbmdlZFxuICAgICAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlZFtwcm9wTmFtZV0gPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXJ0eSBmbGFnXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAbmFtZSBfZGlydHlcbiAgICAgICAgICogQG1lbWJlcm9mIGRpcnR5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGRpcnR5IGZsYWcuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFByb3BlcnR5IGlzIGNoYW5nZWQuXG4gICAgICovXG4gICAgaXNEaXJ0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RpcnR5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgZGlydHkgZmxhZyBtYW51YWxseS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt0b0RpcnR5PXRydWVdIFRoaXMgd2lsbCBzZXQgZGlydHkgZmxhZyBkaXJlY3RseS5cbiAgICAgKi9cbiAgICBkaXJ0eTogZnVuY3Rpb24odG9EaXJ0eSkge1xuICAgICAgICB0b0RpcnR5ID0gZXhpc3R5KHRvRGlydHkpID8gdG9EaXJ0eSA6IHRydWU7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKCF0b0RpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRvRGlydHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBwcm9wZXJ0eSBzYWZldHkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lIFRoZSBuYW1lIG9mIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGRlbGV0ZVByb3A6IGZ1bmN0aW9uKHByb3BOYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzW3Byb3BOYW1lXTtcblxuICAgICAgICBpZiAodGhpcy5fY2hhbmdlZCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NoYW5nZWRbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoZSBjaGFuZ2VzIHdpdGggc3BlY2lmaWMgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lIFRoZSBuYW1lIG9mIHByb3BlcnR5IHlvdSB3YW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBJcyBwcm9wZXJ0eSBjaGFuZ2VkP1xuICAgICAqL1xuICAgIGlzUHJvcENoYW5nZWQ6IGZ1bmN0aW9uKHByb3BOYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2hhbmdlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZWRbcHJvcE5hbWVdID09PSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNaXhpbiB0byBzcGVjaWZpYyBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0byBtaXggdGhpcyBtb2R1bGUuXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTp1dGlsL2RpcnR5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBmdW5jdGlvbiBBbmltYWwoKSB7fVxuICAgICAqIGRpcnR5Lm1peGluKEFuaW1hbC5wcm90b3R5cGUpO1xuICAgICAqL1xuICAgIG1peGluOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgdmFyIG1ldGhvZEZpbHRlclIgPSAvKF5ffG1peGlufHdyYXApLztcblxuICAgICAgICBjb21tb24uZm9yRWFjaE93blByb3BlcnRpZXMoZGlydHksIGZ1bmN0aW9uKG8sIGspIHtcbiAgICAgICAgICAgIGlmICghbWV0aG9kRmlsdGVyUi50ZXN0KGspKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tdID0gZGlydHlba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXcmFwcGVyIG1ldGhvZCBmb3IgZGlydHkgZmxhZ2dpbmcuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2UgYWZ0ZXIgaW52b2tlZCBzcGVjaWZpYyBtZXRob2QgdGhhdCBhZGRlZCBieSB5b3UuXG4gICAgICpcbiAgICAgKiBUaGUgbWV0aG9kIHdhbnQgdG8gYWRkIGFyZSBtdXN0IGV4aXN0IGJlZm9yZSBhZGQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCBUYXJnZXQgb2JqZWN0IHRvIG1ldGhvZCB3cmFwLlxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xvYmplY3QpfSBtZXRob2ROYW1lXG4gICAgICogIE1ldGhvZCBuYW1lIHRvIHdyYXAgb3IgbWV0aG9kTmFtZTogZmxhZyBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZsYWc9dHJ1ZV1cbiAgICAgKiAgdGhpcyB3aWxsIHVzZWQgdG8gZmxhZ2dpbmcgYnkgZGlydHkgZmxhZ2dlciBhZnRlciBpbnZva2UgdGhlIG1ldGhvZHMgYWRkZWQgYnkgeW91LlxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6dXRpbC9kaXJ0eVxuICAgICAqIEBleGFtcGxlXG4gICAgICogZnVuY3Rpb24gQW5pbWFsKG5hbWUpIHtcbiAgICAgKiAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgKiB9XG4gICAgICogQW5pbWFsLnByb3RvdHlwZS5ncm93bCA9IGphc21pbmUuY3JlYXRlU3B5KCdncm93bCcpO1xuICAgICAqIEFuaW1hbC5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBkaXJ0eS5taXhpbihBbmltYWwucHJvdG90eXBlKTtcbiAgICAgKiAvLyBzaW5nbGVcbiAgICAgKiBkaXJ0eS53cmFwKEFuaW1hbC5wcm90b3R5cGUsICdncm93bCcsIHRydWUpO1xuICAgICAqIC8vIG11bHRpcGxlXG4gICAgICogZGlydHkud3JhcChBbmltYXAucHJvdG90eXBlLCB7XG4gICAgICogICAgIGdyb3dsOiB0cnVlLFxuICAgICAqICAgICB0ZXN0OiBmYWxzZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICovXG4gICAgd3JhcDogZnVuY3Rpb24odGFyZ2V0LCBtZXRob2ROYW1lLCBmbGFnKSB7XG4gICAgICAgIHZhciB3cmFwID0gZGlydHkud3JhcCxcbiAgICAgICAgICAgIGZuO1xuXG4gICAgICAgIGlmIChjb21tb24uaXNPYmplY3QobWV0aG9kTmFtZSkpIHtcbiAgICAgICAgICAgIGNvbW1vbi5mb3JFYWNoT3duUHJvcGVydGllcyhtZXRob2ROYW1lLCBmdW5jdGlvbihmbGFnLCBtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICAgICAgd3JhcCh0YXJnZXQsIG1ldGhvZE5hbWUsIGZsYWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmbGFnID0gZXhpc3R5KGZsYWcpID8gZmxhZyA6IHRydWU7XG5cbiAgICAgICAgaWYgKCF0YXJnZXQuX3dyYXBwZXIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gT3JpZ2luYWwgbWV0aG9kIHRvIHdyYXAuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZsYWdUb1NldCBUaGUgYm9vbGVhbiB2YWx1ZSB0byB1c2luZyBkaXJ0eSBmbGFnZ2luZy5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0IHZhbHVlIG9mIG9yaWdpbmFsIG1ldGhvZC5cbiAgICAgICAgICAgICAqIEBuYW1lIF93cmFwcGVyXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgZGlydHlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGFyZ2V0Ll93cmFwcGVyID0gZnVuY3Rpb24oZm4sIGZsYWdUb1NldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmxhZ1RvU2V0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4aXN0eShwaWNrKHRhcmdldCwgbWV0aG9kTmFtZSkpICYmXG4gICAgICAgICAgICBpc0Z1bmModGFyZ2V0W21ldGhvZE5hbWVdKSAmJlxuICAgICAgICAgICAgIWV4aXN0eShwaWNrKHRhcmdldCwgbWV0aG9kTmFtZSwgJ193cmFwcGVkJykpKSB7XG4gICAgICAgICAgICBmbiA9IHRhcmdldFttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIHRhcmdldFttZXRob2ROYW1lXSA9IHRhcmdldC5fd3JhcHBlcihmbiwgZmxhZyk7XG4gICAgICAgICAgICB0YXJnZXRbbWV0aG9kTmFtZV0uX3dyYXBwZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBkaXJ0eTtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFV0aWxpdHkgbW9kdWxlIGZvciBoYW5kbGluZyBET00gZXZlbnRzLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwudHVpLnV0aWwsXG4gICAgYnJvd3NlciA9IHV0aWwuYnJvd3NlcixcbiAgICBldmVudEtleSA9ICdfZXZ0JyxcbiAgICBEUkFHID0ge1xuICAgICAgICBTVEFSVDogWyd0b3VjaHN0YXJ0JywgJ21vdXNlZG93biddLFxuICAgICAgICBFTkQ6IHtcbiAgICAgICAgICAgIG1vdXNlZG93bjogJ21vdXNldXAnLFxuICAgICAgICAgICAgdG91Y2hzdGFydDogJ3RvdWNoZW5kJyxcbiAgICAgICAgICAgIHBvaW50ZXJkb3duOiAndG91Y2hlbmQnLFxuICAgICAgICAgICAgTVNQb2ludGVyRG93bjogJ3RvdWNoZW5kJ1xuICAgICAgICB9LFxuICAgICAgICBNT1ZFOiB7XG4gICAgICAgICAgICBtb3VzZWRvd246ICdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgdG91Y2hzdGFydDogJ3RvdWNobW92ZScsXG4gICAgICAgICAgICBwb2ludGVyZG93bjogJ3RvdWNobW92ZScsXG4gICAgICAgICAgICBNU1BvaW50ZXJEb3duOiAndG91Y2htb3ZlJ1xuICAgICAgICB9XG4gICAgfTtcblxudmFyIGRvbWV2ZW50ID0ge1xuICAgIC8qKlxuICAgICAqIEJpbmQgZG9tIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvYmogSFRNTEVsZW1lbnQgdG8gYmluZCBldmVudHMuXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IHR5cGVzIFNwYWNlIHNwbGl0dGVkIGV2ZW50cyBuYW1lcyBvciBldmVudE5hbWU6aGFuZGxlciBvYmplY3QuXG4gICAgICogQHBhcmFtIHsqfSBmbiBoYW5kbGVyIGZ1bmN0aW9uIG9yIGNvbnRleHQgZm9yIGhhbmRsZXIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdIGNvbnRleHQgb2JqZWN0IGZvciBoYW5kbGVyIG1ldGhvZC5cbiAgICAgKi9cbiAgICBvbjogZnVuY3Rpb24ob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcodHlwZXMpKSB7XG4gICAgICAgICAgICB1dGlsLmZvckVhY2godHlwZXMuc3BsaXQoJyAnKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgICAgIGRvbWV2ZW50Ll9vbihvYmosIHR5cGUsIGZuLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1dGlsLmZvckVhY2hPd25Qcm9wZXJ0aWVzKHR5cGVzLCBmdW5jdGlvbihoYW5kbGVyLCB0eXBlKSB7XG4gICAgICAgICAgICBkb21ldmVudC5fb24ob2JqLCB0eXBlLCBoYW5kbGVyLCBmbik7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBET00gZXZlbnQgYmluZGluZy5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvYmogSFRNTEVsZW1lbnQgdG8gYmluZCBldmVudHMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgZXZlbnRzLlxuICAgICAqIEBwYXJhbSB7Kn0gZm4gaGFuZGxlciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdIGNvbnRleHQgb2JqZWN0IGZvciBoYW5kbGVyIG1ldGhvZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbjogZnVuY3Rpb24ob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xuICAgICAgICB2YXIgaWQsXG4gICAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgICAgb3JpZ2luSGFuZGxlcjtcblxuICAgICAgICBpZCA9IHR5cGUgKyB1dGlsLnN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgdXRpbC5zdGFtcChjb250ZXh0KSA6ICcnKTtcblxuICAgICAgICBpZiAob2JqW2V2ZW50S2V5XSAmJiBvYmpbZXZlbnRLZXldW2lkXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY29udGV4dCB8fCBvYmosIGUgfHwgd2luZG93LmV2ZW50KTtcbiAgICAgICAgfTtcblxuICAgICAgICBvcmlnaW5IYW5kbGVyID0gaGFuZGxlcjtcblxuICAgICAgICBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtb3VzZWVudGVyJyB8fCB0eXBlID09PSAnbW91c2VsZWF2ZScpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9tZXZlbnQuX2NoZWNrTW91c2Uob2JqLCBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbkhhbmRsZXIoZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBvYmouYWRkRXZlbnRMaXN0ZW5lcigodHlwZSA9PT0gJ21vdXNlZW50ZXInKSA/XG4gICAgICAgICAgICAgICAgICAgICdtb3VzZW92ZXInIDogJ21vdXNlb3V0JywgaGFuZGxlciwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoJ2F0dGFjaEV2ZW50JyBpbiBvYmopIHtcbiAgICAgICAgICAgIG9iai5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICBvYmpbZXZlbnRLZXldID0gb2JqW2V2ZW50S2V5XSB8fCB7fTtcbiAgICAgICAgb2JqW2V2ZW50S2V5XVtpZF0gPSBoYW5kbGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmJpbmQgRE9NIEV2ZW50IGhhbmRsZXIuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb2JqIEhUTUxFbGVtZW50IHRvIHVuYmluZC5cbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0gdHlwZXMgU3BhY2Ugc3BsaXR0ZWQgZXZlbnRzIG5hbWVzIG9yIGV2ZW50TmFtZTpoYW5kbGVyIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyp9IGZuIGhhbmRsZXIgZnVuY3Rpb24gb3IgY29udGV4dCBmb3IgaGFuZGxlciBtZXRob2QuXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF0gY29udGV4dCBvYmplY3QgZm9yIGhhbmRsZXIgbWV0aG9kLlxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24ob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcodHlwZXMpKSB7XG4gICAgICAgICAgICB1dGlsLmZvckVhY2godHlwZXMuc3BsaXQoJyAnKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgICAgIGRvbWV2ZW50Ll9vZmYob2JqLCB0eXBlLCBmbiwgY29udGV4dCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXRpbC5mb3JFYWNoT3duUHJvcGVydGllcyh0eXBlcywgZnVuY3Rpb24oaGFuZGxlciwgdHlwZSkge1xuICAgICAgICAgICAgZG9tZXZlbnQuX29mZihvYmosIHR5cGUsIGhhbmRsZXIsIGZuKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVuYmluZCBET00gZXZlbnQgaGFuZGxlci5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvYmogSFRNTEVsZW1lbnQgdG8gdW5iaW5kLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIGV2ZW50IHRvIHVuYmluZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGZuIEV2ZW50IGhhbmRsZXIgdGhhdCBzdXBwbGllZCB3aGVuIGJpbmRpbmcuXG4gICAgICogQHBhcmFtIHsqfSBjb250ZXh0IGNvbnRleHQgb2JqZWN0IHRoYXQgc3VwcGxpZWQgd2hlbiBiaW5kaW5nLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29mZjogZnVuY3Rpb24ob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xuICAgICAgICB2YXIgaWQgPSB0eXBlICsgdXRpbC5zdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIHV0aWwuc3RhbXAoY29udGV4dCkgOiAnJyksXG4gICAgICAgICAgICBoYW5kbGVyID0gb2JqW2V2ZW50S2V5XSAmJiBvYmpbZXZlbnRLZXldW2lkXTtcblxuICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ21vdXNlZW50ZXInIHx8IHR5cGUgPT09ICdtb3VzZWxlYXZlJykge1xuICAgICAgICAgICAgICAgIG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCh0eXBlID09PSAnbW91c2VlbnRlcicpID9cbiAgICAgICAgICAgICAgICAgICAgJ21vdXNlb3ZlcicgOiAnbW91c2VvdXQnLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgaGFuZGxlciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgnZGV0YWNoRXZlbnQnIGluIG9iaikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvYmouZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge30gICAgLy9lc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgb2JqW2V2ZW50S2V5XVtpZF07XG5cbiAgICAgICAgaWYgKHV0aWwua2V5cyhvYmpbZXZlbnRLZXldKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRocm93IGV4Y2VwdGlvbiB3aGVuIGRlbGV0aW5nIGhvc3Qgb2JqZWN0J3MgcHJvcGVydHkgaW4gYmVsb3cgSUU4XG4gICAgICAgIGlmICh1dGlsLmJyb3dzZXIubXNpZSAmJiB1dGlsLmJyb3dzZXIudmVyc2lvbiA8IDkpIHtcbiAgICAgICAgICAgIG9ialtldmVudEtleV0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIG9ialtldmVudEtleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJpbmQgRE9NIGV2ZW50LiB0aGlzIGV2ZW50IHdpbGwgdW5iaW5kIGFmdGVyIGludm9rZXMuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb2JqIEhUTUxFbGVtZW50IHRvIGJpbmQgZXZlbnRzLlxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xvYmplY3QpfSB0eXBlcyBTcGFjZSBzcGxpdHRlZCBldmVudHMgbmFtZXMgb3IgZXZlbnROYW1lOmhhbmRsZXIgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gZm4gaGFuZGxlciBmdW5jdGlvbiBvciBjb250ZXh0IGZvciBoYW5kbGVyIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XSBjb250ZXh0IG9iamVjdCBmb3IgaGFuZGxlciBtZXRob2QuXG4gICAgICovXG4gICAgb25jZTogZnVuY3Rpb24ob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIGlmICh1dGlsLmlzT2JqZWN0KHR5cGVzKSkge1xuICAgICAgICAgICAgdXRpbC5mb3JFYWNoT3duUHJvcGVydGllcyh0eXBlcywgZnVuY3Rpb24oaGFuZGxlciwgdHlwZSkge1xuICAgICAgICAgICAgICAgIGRvbWV2ZW50Lm9uY2Uob2JqLCB0eXBlLCBoYW5kbGVyLCBmbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uY2VIYW5kbGVyKCkge1xuICAgICAgICAgICAgZm4uYXBwbHkoY29udGV4dCB8fCBvYmosIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGF0Ll9vZmYob2JqLCB0eXBlcywgb25jZUhhbmRsZXIsIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9tZXZlbnQub24ob2JqLCB0eXBlcywgb25jZUhhbmRsZXIsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgZXZlbnQgYnViYmxpbmcuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QuXG4gICAgICovXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgYnJvd3NlciBkZWZhdWx0IGFjdGlvbnMuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QuXG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTeW50YXRpYyBzdWdhciBvZiBzdG9wUHJvcGFnYXRpb24gYW5kIHByZXZlbnREZWZhdWx0XG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QuXG4gICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24oZSkge1xuICAgICAgICBkb21ldmVudC5wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgZG9tZXZlbnQuc3RvcFByb3BhZ2F0aW9uKGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdG9wIHNjcm9sbCBldmVudHMuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgSFRNTCBlbGVtZW50IHRvIHByZXZlbnQgc2Nyb2xsLlxuICAgICAqL1xuICAgIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbjogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgZG9tZXZlbnQub24oZWwsICdtb3VzZXdoZWVsIE1vek1vdXNlUGl4ZWxTY3JvbGwnLCBkb21ldmVudC5zdG9wUHJvcGFnYXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGFsbCBldmVudHMgcmVsYXRlZCB3aXRoIGNsaWNrLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEhUTUwgZWxlbWVudCB0byBwcmV2ZW50IGFsbCBldmVudCByZWxhdGVkIHdpdGggY2xpY2suXG4gICAgICovXG4gICAgZGlzYWJsZUNsaWNrUHJvcGFnYXRpb246IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGRvbWV2ZW50Lm9uKGVsLCBEUkFHLlNUQVJULmpvaW4oJyAnKSArICcgY2xpY2sgZGJsY2xpY2snLCBkb21ldmVudC5zdG9wUHJvcGFnYXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbW91c2UgcG9zaXRpb24gZnJvbSBtb3VzZSBldmVudC5cbiAgICAgKlxuICAgICAqIElmIHN1cHBsaWVkIHJlbGF0dmVFbGVtZW50IHBhcmFtZXRlciB0aGVuIHJldHVybiByZWxhdGl2ZSBwb3NpdGlvbiBiYXNlZCBvbiBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IG1vdXNlRXZlbnQgTW91c2UgZXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVsYXRpdmVFbGVtZW50IEhUTUwgZWxlbWVudCB0aGF0IGNhbGN1bGF0ZSByZWxhdGl2ZSBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IG1vdXNlIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIGdldE1vdXNlUG9zaXRpb246IGZ1bmN0aW9uKG1vdXNlRXZlbnQsIHJlbGF0aXZlRWxlbWVudCkge1xuICAgICAgICB2YXIgcmVjdDtcblxuICAgICAgICBpZiAoIXJlbGF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFttb3VzZUV2ZW50LmNsaWVudFgsIG1vdXNlRXZlbnQuY2xpZW50WV07XG4gICAgICAgIH1cblxuICAgICAgICByZWN0ID0gcmVsYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtb3VzZUV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQgLSByZWxhdGl2ZUVsZW1lbnQuY2xpZW50TGVmdCxcbiAgICAgICAgICAgIG1vdXNlRXZlbnQuY2xpZW50WSAtIHJlY3QudG9wIC0gcmVsYXRpdmVFbGVtZW50LmNsaWVudFRvcFxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgbW91c2Ugd2hlZWwgZXZlbnQgdGhhdCBkaWZmZXJlbnQgZWFjaCBicm93c2Vycy5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgTW91c2Ugd2hlZWwgZXZlbnQuXG4gICAgICogQHJldHVybnMge051bWJlcn0gZGVsdGFcbiAgICAgKi9cbiAgICBnZXRXaGVlbERlbHRhOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBkZWx0YSA9IDA7XG5cbiAgICAgICAgaWYgKGUud2hlZWxEZWx0YSkge1xuICAgICAgICAgICAgZGVsdGEgPSBlLndoZWVsRGVsdGEgLyAxMjA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5kZXRhaWwpIHtcbiAgICAgICAgICAgIGRlbHRhID0gLWUuZGV0YWlsIC8gMztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcHJldmVudCBmaXJpbmcgbW91c2VsZWF2ZSBldmVudCB3aGVuIG1vdXNlIGVudGVyZWQgY2hpbGQgZWxlbWVudHMuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgSFRNTCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIE1vdXNlIGV2ZW50XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IGxlYXZlP1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NoZWNrTW91c2U6IGZ1bmN0aW9uKGVsLCBlKSB7XG4gICAgICAgIHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xuXG4gICAgICAgIGlmICghcmVsYXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2hpbGUgKHJlbGF0ZWQgJiYgKHJlbGF0ZWQgIT09IGVsKSkge1xuICAgICAgICAgICAgICAgIHJlbGF0ZWQgPSByZWxhdGVkLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChyZWxhdGVkICE9PSBlbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgc3BlY2lmaWMgZXZlbnRzIHRvIGh0bWwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvYmogSFRNTEVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlIG5hbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2V2ZW50RGF0YV0gRXZlbnQgZGF0YVxuICAgICAqL1xuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKG9iaiwgdHlwZSwgZXZlbnREYXRhKSB7XG4gICAgICAgIHZhciByTW91c2VFdmVudCA9IC8obW91c2V8Y2xpY2spLztcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQoZXZlbnREYXRhKSAmJiByTW91c2VFdmVudC5leGVjKHR5cGUpKSB7XG4gICAgICAgICAgICBldmVudERhdGEgPSBkb21ldmVudC5tb3VzZUV2ZW50KHR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iai5kaXNwYXRjaEV2ZW50KSB7XG4gICAgICAgICAgICBvYmouZGlzcGF0Y2hFdmVudChldmVudERhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iai5maXJlRXZlbnQpIHtcbiAgICAgICAgICAgIG9iai5maXJlRXZlbnQoJ29uJyArIHR5cGUsIGV2ZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHZpcnR1YWwgbW91c2UgZXZlbnQuXG4gICAgICpcbiAgICAgKiBUZXN0ZWQgYXRcbiAgICAgKlxuICAgICAqIC0gSUU3IH4gSUUxMVxuICAgICAqIC0gQ2hyb21lXG4gICAgICogLSBGaXJlZm94XG4gICAgICogLSBTYWZhcmlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtldmVudE9ial0gRXZlbnQgZGF0YVxuICAgICAqIEByZXR1cm5zIHtNb3VzZUV2ZW50fSBWaXJ0dWFsIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIG1vdXNlRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIGV2ZW50T2JqKSB7XG4gICAgICAgIHZhciBldnQsXG4gICAgICAgICAgICBlO1xuXG4gICAgICAgIGUgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogKHR5cGUgIT09ICdtb3VzZW1vdmUnKSxcbiAgICAgICAgICAgIHZpZXc6IHdpbmRvdyxcbiAgICAgICAgICAgIHdoZWVsRGVsdGE6IDAsXG4gICAgICAgICAgICBkZXRhaWw6IDAsXG4gICAgICAgICAgICBzY3JlZW5YOiAwLFxuICAgICAgICAgICAgc2NyZWVuWTogMCxcbiAgICAgICAgICAgIGNsaWVudFg6IDAsXG4gICAgICAgICAgICBjbGllbnRZOiAwLFxuICAgICAgICAgICAgY3RybEtleTogZmFsc2UsXG4gICAgICAgICAgICBhbHRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgc2hpZnRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgbWV0YUtleTogZmFsc2UsXG4gICAgICAgICAgICBidXR0b246IDAsXG4gICAgICAgICAgICByZWxhdGVkVGFyZ2V0OiB1bmRlZmluZWQgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgfSwgZXZlbnRPYmopO1xuXG4gICAgICAgIC8vIHByZXZlbnQgdGhyb3cgZXJyb3Igd2hlbiBpbnNlcnRpbmcgd2hlZWxEZWx0YSBwcm9wZXJ0eSB0byBtb3VzZSBldmVudCBvbiBiZWxvdyBJRThcbiAgICAgICAgaWYgKGJyb3dzZXIubXNpZSAmJiBicm93c2VyLnZlcnNpb24gPCA5KSB7XG4gICAgICAgICAgICBkZWxldGUgZS53aGVlbERlbHRhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG4gICAgICAgICAgICBldnQuaW5pdE1vdXNlRXZlbnQodHlwZSxcbiAgICAgICAgICAgICAgICBlLmJ1YmJsZXMsIGUuY2FuY2VsYWJsZSwgZS52aWV3LCBlLmRldGFpbCxcbiAgICAgICAgICAgICAgICBlLnNjcmVlblgsIGUuc2NyZWVuWSwgZS5jbGllbnRYLCBlLmNsaWVudFksXG4gICAgICAgICAgICAgICAgZS5jdHJsS2V5LCBlLmFsdEtleSwgZS5zaGlmdEtleSwgZS5tZXRhS2V5LFxuICAgICAgICAgICAgICAgIGUuYnV0dG9uLCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QpIHtcbiAgICAgICAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCk7XG5cbiAgICAgICAgICAgIHV0aWwuZm9yRWFjaChlLCBmdW5jdGlvbih2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICBldnRbcHJvcE5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIGV2dC5idXR0b24gPSB7MDogMSwgMTogNCwgMjogMn1bZXZ0LmJ1dHRvbl0gfHwgZXZ0LmJ1dHRvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZ0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgbW91c2UgZXZlbnQncyBidXR0b24gYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIENhbiBkZXRlY3Qgd2hpY2ggYnV0dG9uIGlzIGNsaWNrZWQgYnkgdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBNZWFuaW5nIG9mIHJldHVybiBudW1iZXJzXG4gICAgICpcbiAgICAgKiAtIDA6IHByaW1hcnkgbW91c2UgYnV0dG9uXG4gICAgICogLSAxOiB3aGVlbCBidXR0b24gb3IgY2VudGVyIGJ1dHRvblxuICAgICAqIC0gMjogc2Vjb25kYXJ5IG1vdXNlIGJ1dHRvblxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gbW91c2VFdmVudCAtIFRoZSBtb3VzZSBldmVudCBvYmplY3Qgd2FudCB0byBrbm93LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIHZhbHVlIG9mIG1lYW5pbmcgd2hpY2ggYnV0dG9uIGlzIGNsaWNrZWQ/XG4gICAgICovXG4gICAgZ2V0TW91c2VCdXR0b246IGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgdmFyIGJ1dHRvbixcbiAgICAgICAgICAgIHByaW1hcnkgPSAnMCwxLDMsNSw3JyxcbiAgICAgICAgICAgIHNlY29uZGFyeSA9ICcyLDYnLFxuICAgICAgICAgICAgd2hlZWwgPSAnNCc7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ01vdXNlRXZlbnRzJywgJzIuMCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gbW91c2VFdmVudC5idXR0b247XG4gICAgICAgIH1cblxuICAgICAgICBidXR0b24gPSBtb3VzZUV2ZW50LmJ1dHRvbiArICcnO1xuICAgICAgICBpZiAofnByaW1hcnkuaW5kZXhPZihidXR0b24pKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIGlmICh+c2Vjb25kYXJ5LmluZGV4T2YoYnV0dG9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH0gZWxzZSBpZiAofndoZWVsLmluZGV4T2YoYnV0dG9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRvbWV2ZW50O1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVXRpbGl0eSBtb2R1bGVzIGZvciBtYW5pcHVsYXRlIERPTSBlbGVtZW50cy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkb21ldmVudCA9IHJlcXVpcmUoJy4vZG9tZXZlbnQnKTtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9uJyk7XG5cbnZhciB1dGlsID0gZ2xvYmFsLnR1aS51dGlsLFxuICAgIHBvc0tleSA9ICdfcG9zJyxcbiAgICBkb211dGlsO1xuXG52YXIgQ1NTX0FVVE9fUkVHRVggPSAvXmF1dG8kfF4kfCUvO1xuXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxcc1xccyovLCAnJykucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7XG59XG5cbmRvbXV0aWwgPSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIERPTSBlbGVtZW50IGFuZCByZXR1cm4gaXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgVGFnIG5hbWUgdG8gYXBwZW5kLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtjb250YWluZXJdIEhUTUwgZWxlbWVudCB3aWxsIGJlIHBhcmVudCB0byBjcmVhdGVkIGVsZW1lbnQuXG4gICAgICogaWYgbm90IHN1cHBsaWVkLCB3aWxsIHVzZSAqKmRvY3VtZW50LmJvZHkqKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2xhc3NOYW1lXSBEZXNpZ24gY2xhc3MgbmFtZXMgdG8gYXBwbGluZyBjcmVhdGVkIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBIVE1MIGVsZW1lbnQgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBhcHBlbmRIVE1MRWxlbWVudDogZnVuY3Rpb24odGFnTmFtZSwgY29udGFpbmVyLCBjbGFzc05hbWUpIHtcbiAgICAgICAgdmFyIGVsO1xuXG4gICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCAnJztcblxuICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcblxuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBlbGVtZW50IGZyb20gcGFyZW50IG5vZGUuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGlmIChlbCAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZWxlbWVudCBieSBpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBlbGVtZW50IGlkIGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgc3VwcGxpZWQgZWxlbWVudCBpcyBtYXRjaGVkIHNlbGVjdG9yLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gZWxlbWVudCB0byBjaGVja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciAtIHNlbGVjdG9yIHN0cmluZyB0byBjaGVja1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IG1hdGNoP1xuICAgICAqL1xuICAgIF9tYXRjaGVyOiBmdW5jdGlvbihlbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzU2VsZWN0b3IgPSAvXlxcLi8sXG4gICAgICAgICAgICBpZFNlbGVjdG9yID0gL14jLztcblxuICAgICAgICBpZiAoY3NzQ2xhc3NTZWxlY3Rvci50ZXN0KHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvbXV0aWwuaGFzQ2xhc3MoZWwsIHNlbGVjdG9yLnJlcGxhY2UoJy4nLCAnJykpO1xuICAgICAgICB9IGVsc2UgaWYgKGlkU2VsZWN0b3IudGVzdChzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBlbC5pZCA9PT0gc2VsZWN0b3IucmVwbGFjZSgnIycsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBzZWxlY3Rvci50b0xvd2VyQ2FzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIERPTSBlbGVtZW50IGJ5IHNwZWNpZmljIHNlbGVjdG9ycy5cbiAgICAgKiBiZWxvdyB0aHJlZSBzZWxlY3RvciBvbmx5IHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqIDEuIGNzcyBzZWxlY3RvclxuICAgICAqIDIuIGlkIHNlbGVjdG9yXG4gICAgICogMy4gbm9kZU5hbWUgc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3Igc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0geyhIVE1MRWxlbWVudHxzdHJpbmcpfSBbcm9vdF0gWW91IGNhbiBhc3NpZ24gcm9vdCBlbGVtZW50IHRvIGZpbmQuIGlmIG5vdCBzdXBwbGllZCwgZG9jdW1lbnQuYm9keSB3aWxsIHVzZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58ZnVuY3Rpb259IFttdWx0aXBsZT1mYWxzZV0gLSBzZXQgdHJ1ZSB0aGVuIHJldHVybiBhbGwgZWxlbWVudHMgdGhhdCBtZWV0IGNvbmRpdGlvbiwgaWYgc2V0IGZ1bmN0aW9uIHRoZW4gdXNlIGl0IGZpbHRlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IEhUTUwgZWxlbWVudCBmaW5kZWQuXG4gICAgICovXG4gICAgZmluZDogZnVuY3Rpb24oc2VsZWN0b3IsIHJvb3QsIG11bHRpcGxlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIGZvdW5kID0gZmFsc2UsXG4gICAgICAgICAgICBpc0ZpcnN0ID0gdXRpbC5pc1VuZGVmaW5lZChtdWx0aXBsZSkgfHwgbXVsdGlwbGUgPT09IGZhbHNlLFxuICAgICAgICAgICAgaXNGaWx0ZXIgPSB1dGlsLmlzRnVuY3Rpb24obXVsdGlwbGUpO1xuXG4gICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKHJvb3QpKSB7XG4gICAgICAgICAgICByb290ID0gZG9tdXRpbC5nZXQocm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJvb3QgPSByb290IHx8IHdpbmRvdy5kb2N1bWVudC5ib2R5O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlY3Vyc2UoZWwsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IGVsLmNoaWxkTm9kZXMsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgbGVuID0gY2hpbGROb2Rlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgY3Vyc29yO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yID0gY2hpbGROb2Rlc1tpXTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJzb3Iubm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRvbXV0aWwuX21hdGNoZXIoY3Vyc29yLCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChpc0ZpbHRlciAmJiBtdWx0aXBsZShjdXJzb3IpKSB8fCAhaXNGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnNvci5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzZShjdXJzb3IsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2Uocm9vdCwgc2VsZWN0b3IpO1xuXG4gICAgICAgIHJldHVybiBpc0ZpcnN0ID8gKHJlc3VsdFswXSB8fCBudWxsKSA6IHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBwYXJlbnQgZWxlbWVudCByZWN1cnNpdmVseS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIGJhc2UgZWxlbWVudCB0byBzdGFydCBmaW5kLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciAtIHNlbGVjdG9yIHN0cmluZyBmb3IgZmluZFxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gLSBlbGVtZW50IGZpbmRlZCBvciB1bmRlZmluZWQuXG4gICAgICovXG4gICAgY2xvc2VzdDogZnVuY3Rpb24oZWwsIHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuXG4gICAgICAgIGlmIChkb211dGlsLl9tYXRjaGVyKGVsLCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50ICE9PSB3aW5kb3cuZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgaWYgKGRvbXV0aWwuX21hdGNoZXIocGFyZW50LCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGV4dHMgaW5zaWRlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRleHQgaW5zaWRlIG5vZGVcbiAgICAgKi9cbiAgICB0ZXh0OiBmdW5jdGlvbihlbCkge1xuICAgICAgICB2YXIgcmV0ID0gJycsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIG5vZGVUeXBlID0gZWwubm9kZVR5cGU7XG5cbiAgICAgICAgaWYgKG5vZGVUeXBlKSB7XG4gICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExKSB7XG4gICAgICAgICAgICAgICAgLy8gbm9kZXMgdGhhdCBhdmFpbGFibGUgY29udGFpbiBvdGhlciBub2Rlc1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWwudGV4dENvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGVsID0gZWwuZmlyc3RDaGlsZDsgZWw7IGVsID0gZWwubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ICs9IGRvbXV0aWwudGV4dChlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIC8vIFRFWFQsIENEQVRBIFNFQ1RJT05cbiAgICAgICAgICAgICAgICByZXR1cm4gZWwubm9kZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICg7IGVsW2ldOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICByZXQgKz0gZG9tdXRpbC50ZXh0KGVsW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgZGF0YSBhdHRyaWJ1dGUgdG8gdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIGVsZW1lbnQgdG8gc2V0IGRhdGEgYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gZGF0YSAtIGRhdGEgdmFsdWVcbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbihlbCwga2V5LCBkYXRhKSB7XG4gICAgICAgIGlmICgnZGF0YXNldCcgaW4gZWwpIHtcbiAgICAgICAgICAgIGVsLmRhdGFzZXRba2V5XSA9IGRhdGE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIGtleSwgZGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBkYXRhIHZhbHVlIGZyb20gZGF0YS1hdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIGtleVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgZ2V0RGF0YTogZnVuY3Rpb24oZWwsIGtleSkge1xuICAgICAgICBpZiAoJ2RhdGFzZXQnIGluIGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwuZGF0YXNldFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnZGF0YS0nICsga2V5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgZWxlbWVudCBoYXMgc3BlY2lmaWMgZGVzaWduIGNsYXNzIG5hbWUuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBjc3MgY2xhc3NcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJuIHRydWUgd2hlbiBlbGVtZW50IGhhcyB0aGF0IGNzcyBjbGFzcyBuYW1lXG4gICAgICovXG4gICAgaGFzQ2xhc3M6IGZ1bmN0aW9uKGVsLCBuYW1lKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWU7XG5cbiAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKGVsLmNsYXNzTGlzdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc05hbWUgPSBkb211dGlsLmdldENsYXNzKGVsKTtcblxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIG5hbWUgKyAnKFxcXFxzfCQpJykudGVzdChjbGFzc05hbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgZGVzaWduIGNsYXNzIHRvIEhUTUwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNzcyBjbGFzcyBuYW1lXG4gICAgICovXG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKGVsLCBuYW1lKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWU7XG5cbiAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKGVsLmNsYXNzTGlzdCkpIHtcbiAgICAgICAgICAgIHV0aWwuZm9yRWFjaEFycmF5KG5hbWUuc3BsaXQoJyAnKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKCFkb211dGlsLmhhc0NsYXNzKGVsLCBuYW1lKSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gZG9tdXRpbC5nZXRDbGFzcyhlbCk7XG4gICAgICAgICAgICBkb211dGlsLnNldENsYXNzKGVsLCAoY2xhc3NOYW1lID8gY2xhc3NOYW1lICsgJyAnIDogJycpICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBPdmVyd3JpdGUgZGVzaWduIGNsYXNzIHRvIEhUTUwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNzcyBjbGFzcyBuYW1lXG4gICAgICovXG4gICAgc2V0Q2xhc3M6IGZ1bmN0aW9uKGVsLCBuYW1lKSB7XG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGVsLmNsYXNzTmFtZS5iYXNlVmFsKSkge1xuICAgICAgICAgICAgZWwuY2xhc3NOYW1lID0gbmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTmFtZS5iYXNlVmFsID0gbmFtZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbGVtZW507JeQIGNzc0NsYXNz7IaN7ISx7J2EIOygnOqxsO2VmOuKlCDrqZTshJzrk5xcbiAgICAgKiBSZW1vdmUgc3BlY2lmaWMgZGVzaWduIGNsYXNzIGZyb20gSFRNTCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgY2xhc3MgbmFtZSB0byByZW1vdmVcbiAgICAgKi9cbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oZWwsIG5hbWUpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSAnJztcblxuICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWQoZWwuY2xhc3NMaXN0KSkge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZWQgPSAoJyAnICsgZG9tdXRpbC5nZXRDbGFzcyhlbCkgKyAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKTtcbiAgICAgICAgICAgIGRvbXV0aWwuc2V0Q2xhc3MoZWwsIHRyaW0ocmVtb3ZlZCkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBIVE1MIGVsZW1lbnQncyBkZXNpZ24gY2xhc3Nlcy5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGVsZW1lbnQgY3NzIGNsYXNzIG5hbWVcbiAgICAgKi9cbiAgICBnZXRDbGFzczogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgaWYgKCFlbCB8fCAhZWwuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXRpbC5pc1VuZGVmaW5lZChlbC5jbGFzc05hbWUuYmFzZVZhbCkgPyBlbC5jbGFzc05hbWUgOiBlbC5jbGFzc05hbWUuYmFzZVZhbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNwZWNpZmljIENTUyBzdHlsZSB2YWx1ZSBmcm9tIEhUTUwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZSBjc3MgYXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7KHN0cmluZ3xudWxsKX0gY3NzIHN0eWxlIHZhbHVlXG4gICAgICovXG4gICAgZ2V0U3R5bGU6IGZ1bmN0aW9uKGVsLCBzdHlsZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBlbC5zdHlsZVtzdHlsZV0gfHwgKGVsLmN1cnJlbnRTdHlsZSAmJiBlbC5jdXJyZW50U3R5bGVbc3R5bGVdKSxcbiAgICAgICAgICAgIGNzcztcblxuICAgICAgICBpZiAoKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2F1dG8nKSAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldykge1xuICAgICAgICAgICAgY3NzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XG4gICAgICAgICAgICB2YWx1ZSA9IGNzcyA/IGNzc1tzdHlsZV0gOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAnYXV0bycgPyBudWxsIDogdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCBlbGVtZW50J3MgY29tcHV0ZWQgc3R5bGUgdmFsdWVzLlxuICAgICAqXG4gICAgICogaW4gbG93ZXIgSUU4LiB1c2UgcG9seWZpbGwgZnVuY3Rpb24gdGhhdCByZXR1cm4gb2JqZWN0LiBpdCBoYXMgb25seSBvbmUgZnVuY3Rpb24gJ2dldFByb3BlcnR5VmFsdWUnXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBlbGVtZW50IHdhbnQgdG8gZ2V0IHN0eWxlLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHZpcnR1YWwgQ1NTU3R5bGVEZWNsYXJhdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgZ2V0Q29tcHV0ZWRTdHlsZTogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRWaWV3ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cbiAgICAgICAgaWYgKCFkZWZhdWx0VmlldyB8fCAhZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBnZXRQcm9wZXJ0eVZhbHVlOiBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZSA9IC8oXFwtKFthLXpdKXsxfSkvZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICdmbG9hdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgPSAnc3R5bGVGbG9hdCc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocmUudGVzdChwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCA9IHByb3AucmVwbGFjZShyZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbMl0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLmN1cnJlbnRTdHlsZVtwcm9wXSA/IGVsLmN1cnJlbnRTdHlsZVtwcm9wXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHBvc2l0aW9uIENTUyBzdHlsZS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSBsZWZ0IHBpeGVsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSB0b3AgcGl4ZWwgdmFsdWUuXG4gICAgICovXG4gICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uKGVsLCB4LCB5KSB7XG4gICAgICAgIHggPSB1dGlsLmlzVW5kZWZpbmVkKHgpID8gMCA6IHg7XG4gICAgICAgIHkgPSB1dGlsLmlzVW5kZWZpbmVkKHkpID8gMCA6IHk7XG5cbiAgICAgICAgZWxbcG9zS2V5XSA9IFt4LCB5XTtcblxuICAgICAgICBlbC5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgICAgIGVsLnN0eWxlLnRvcCA9IHkgKyAncHgnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcG9zaXRpb24gZnJvbSBIVE1MIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjbGVhcj1mYWxzZV0gY2xlYXIgY2FjaGUgYmVmb3JlIGNhbGN1bGF0aW5nIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gcG9pbnRcbiAgICAgKi9cbiAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24oZWwsIGNsZWFyKSB7XG4gICAgICAgIHZhciBsZWZ0LFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgYm91bmQ7XG5cbiAgICAgICAgaWYgKGNsZWFyKSB7XG4gICAgICAgICAgICBlbFtwb3NLZXldID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbFtwb3NLZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxbcG9zS2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlZnQgPSAwO1xuICAgICAgICB0b3AgPSAwO1xuXG4gICAgICAgIGlmICgoQ1NTX0FVVE9fUkVHRVgudGVzdChlbC5zdHlsZS5sZWZ0KSB8fCBDU1NfQVVUT19SRUdFWC50ZXN0KGVsLnN0eWxlLnRvcCkpICYmXG4gICAgICAgICAgICAnZ2V0Qm91bmRpbmdDbGllbnRSZWN0JyBpbiBlbCkge1xuICAgICAgICAgICAgLy8g7JeY66as66i87Yq47J2YIGxlZnTrmJDripQgdG9w7J20ICdhdXRvJ+ydvCDrlYwg7IiY64uoXG4gICAgICAgICAgICBib3VuZCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICBsZWZ0ID0gYm91bmQubGVmdDtcbiAgICAgICAgICAgIHRvcCA9IGJvdW5kLnRvcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSBwYXJzZUZsb2F0KGVsLnN0eWxlLmxlZnQgfHwgMCk7XG4gICAgICAgICAgICB0b3AgPSBwYXJzZUZsb2F0KGVsLnN0eWxlLnRvcCB8fCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbGVmdCwgdG9wXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGVsZW1lbnQncyBzaXplXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJbXX0gd2lkdGgsIGhlaWdodFxuICAgICAqL1xuICAgIGdldFNpemU6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHZhciBib3VuZCxcbiAgICAgICAgICAgIHdpZHRoID0gZG9tdXRpbC5nZXRTdHlsZShlbCwgJ3dpZHRoJyksXG4gICAgICAgICAgICBoZWlnaHQgPSBkb211dGlsLmdldFN0eWxlKGVsLCAnaGVpZ2h0Jyk7XG5cbiAgICAgICAgaWYgKChDU1NfQVVUT19SRUdFWC50ZXN0KHdpZHRoKSB8fCBDU1NfQVVUT19SRUdFWC50ZXN0KGhlaWdodCkpICYmXG4gICAgICAgICAgICAnZ2V0Qm91bmRpbmdDbGllbnRSZWN0JyBpbiBlbCkge1xuICAgICAgICAgICAgYm91bmQgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHdpZHRoID0gYm91bmQud2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSBib3VuZC5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aWR0aCA9IHBhcnNlRmxvYXQod2lkdGggfHwgMCk7XG4gICAgICAgICAgICBoZWlnaHQgPSBwYXJzZUZsb2F0KGhlaWdodCB8fCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbd2lkdGgsIGhlaWdodF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHNwZWNpZmljIENTUyBzdHlsZSBpcyBhdmFpbGFibGUuXG4gICAgICogQHBhcmFtIHthcnJheX0gcHJvcHMgcHJvcGVydHkgbmFtZSB0byB0ZXN0aW5nXG4gICAgICogQHJldHVybiB7KHN0cmluZ3xib29sZWFuKX0gcmV0dXJuIHRydWUgd2hlbiBwcm9wZXJ0eSBpcyBhdmFpbGFibGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwcm9wcyA9IFsndHJhbnNmb3JtJywgJy13ZWJraXQtdHJhbnNmb3JtJ107XG4gICAgICogZG9tdXRpbC50ZXN0UHJvcChwcm9wcyk7ICAgIC8vICd0cmFuc2Zvcm0nXG4gICAgICovXG4gICAgdGVzdFByb3A6IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChwcm9wc1tpXSBpbiBzdHlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBmb3JtIGRhdGFcbiAgICAgKiBAcGFyYW0ge0hUTUxGb3JtRWxlbWVudH0gZm9ybUVsZW1lbnQgLSBmb3JtIGVsZW1lbnQgdG8gZXh0cmFjdCBkYXRhXG4gICAgICogQHJldHVybnMge29iamVjdH0gZm9ybSBkYXRhXG4gICAgICovXG4gICAgZ2V0Rm9ybURhdGE6IGZ1bmN0aW9uKGZvcm1FbGVtZW50KSB7XG4gICAgICAgIHZhciBncm91cGVkQnlOYW1lID0gbmV3IENvbGxlY3Rpb24oZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmxlbmd0aDsgfSksXG4gICAgICAgICAgICBub0Rpc2FibGVkRmlsdGVyID0gZnVuY3Rpb24oZWwpIHsgcmV0dXJuICFlbC5kaXNhYmxlZDsgfSxcbiAgICAgICAgICAgIG91dHB1dCA9IHt9O1xuICAgICAgICAgICAgXG4gICAgICAgIGdyb3VwZWRCeU5hbWUuYWRkLmFwcGx5KFxuICAgICAgICAgICAgZ3JvdXBlZEJ5TmFtZSwgXG4gICAgICAgICAgICBkb211dGlsLmZpbmQoJ2lucHV0JywgZm9ybUVsZW1lbnQsIG5vRGlzYWJsZWRGaWx0ZXIpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChkb211dGlsLmZpbmQoJ3NlbGVjdCcsIGZvcm1FbGVtZW50LCBub0Rpc2FibGVkRmlsdGVyKSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KGRvbXV0aWwuZmluZCgndGV4dGFyZWEnLCBmb3JtRWxlbWVudCwgbm9EaXNhYmxlZEZpbHRlcikpXG4gICAgICAgICk7XG5cbiAgICAgICAgZ3JvdXBlZEJ5TmFtZSA9IGdyb3VwZWRCeU5hbWUuZ3JvdXBCeShmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsICYmIGVsLmdldEF0dHJpYnV0ZSgnbmFtZScpIHx8ICdfb3RoZXInO1xuICAgICAgICB9KTtcblxuICAgICAgICB1dGlsLmZvckVhY2goZ3JvdXBlZEJ5TmFtZSwgZnVuY3Rpb24oZWxlbWVudHMsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnX290aGVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbWVudHMuZWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBlbC50eXBlLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtlbGVtZW50cy5maW5kKGZ1bmN0aW9uKGVsKSB7IHJldHVybiBlbC5jaGVja2VkOyB9KS50b0FycmF5KCkucG9wKCldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBlbGVtZW50cy5maW5kKGZ1bmN0aW9uKGVsKSB7IHJldHVybiBlbC5jaGVja2VkOyB9KS50b0FycmF5KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlTmFtZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMuZmluZChmdW5jdGlvbihlbCkgeyByZXR1cm4gISFlbC5jaGlsZE5vZGVzLmxlbmd0aDsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChkb211dGlsLmZpbmQoJ29wdGlvbicsIGVsLCBmdW5jdGlvbihvcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdC5zZWxlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBlbGVtZW50cy5maW5kKGZ1bmN0aW9uKGVsKSB7IHJldHVybiBlbC52YWx1ZSAhPT0gJyc7IH0pLnRvQXJyYXkoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSB1dGlsLm1hcChyZXN1bHQsIGZ1bmN0aW9uKGVsKSB7IHJldHVybiBlbC52YWx1ZTsgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFswXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvdXRwdXRbbmFtZV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG59O1xuXG4vKmVzbGludC1kaXNhYmxlKi9cbnZhciB1c2VyU2VsZWN0UHJvcGVydHkgPSBkb211dGlsLnRlc3RQcm9wKFtcbiAgICAndXNlclNlbGVjdCcsIFxuICAgICdXZWJraXRVc2VyU2VsZWN0JywgXG4gICAgJ09Vc2VyU2VsZWN0JywgXG4gICAgJ01velVzZXJTZWxlY3QnLCBcbiAgICAnbXNVc2VyU2VsZWN0J1xuXSk7XG52YXIgc3VwcG9ydFNlbGVjdFN0YXJ0ID0gJ29uc2VsZWN0c3RhcnQnIGluIGRvY3VtZW50O1xudmFyIHByZXZTZWxlY3RTdHlsZSA9ICcnO1xuLyplc2xpbnQtZW5hYmxlKi9cblxuLyoqXG4gKiBEaXNhYmxlIGJyb3dzZXIncyB0ZXh0IHNlbGVjdGlvbiBiZWhhdmlvcnMuXG4gKiBAbWV0aG9kXG4gKi9cbmRvbXV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24gPSAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHN1cHBvcnRTZWxlY3RTdGFydCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkb21ldmVudC5vbih3aW5kb3csICdzZWxlY3RzdGFydCcsIGRvbWV2ZW50LnByZXZlbnREZWZhdWx0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbiAgICAgICAgcHJldlNlbGVjdFN0eWxlID0gc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XTtcbiAgICAgICAgc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9ICdub25lJztcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBFbmFibGUgYnJvd3NlcidzIHRleHQgc2VsZWN0aW9uIGJlaGF2aW9ycy5cbiAqIEBtZXRob2RcbiAqL1xuZG9tdXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzdXBwb3J0U2VsZWN0U3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZG9tZXZlbnQub2ZmKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgZG9tZXZlbnQucHJldmVudERlZmF1bHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSBwcmV2U2VsZWN0U3R5bGU7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogRGlzYWJsZSBicm93c2VyJ3MgaW1hZ2UgZHJhZyBiZWhhdmlvcnMuXG4gKi9cbmRvbXV0aWwuZGlzYWJsZUltYWdlRHJhZyA9IGZ1bmN0aW9uKCkge1xuICAgIGRvbWV2ZW50Lm9uKHdpbmRvdywgJ2RyYWdzdGFydCcsIGRvbWV2ZW50LnByZXZlbnREZWZhdWx0KTtcbn07XG5cbi8qKlxuICogRW5hYmxlIGJyb3dzZXIncyBpbWFnZSBkcmFnIGJlaGF2aW9ycy5cbiAqL1xuZG9tdXRpbC5lbmFibGVJbWFnZURyYWcgPSBmdW5jdGlvbigpIHtcbiAgICBkb21ldmVudC5vZmYod2luZG93LCAnZHJhZ3N0YXJ0JywgZG9tZXZlbnQucHJldmVudERlZmF1bHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBkb211dGlsO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTW9kdWxlIGZvciBzcGVjaWZpYyBlbGVtZW50J3MgaGVpZ2h0IHNldCB0byByZW1haW4gaGVpZ2h0IG9mIGNvbnRhaW5lciBlbGVtZW50LlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciB1dGlsID0gZ2xvYmFsLnR1aS51dGlsO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi9jb21tb24vZG9tdXRpbCcpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfSBlbGVtZW50cyAtIGVsZW1lbnQgbGlzdCB0byBtYW5hZ2luZyBoZWlnaHRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIHdyYXBwaW5nIGNvbnRhaW5lciBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIEZpbGxSZW1haW5IZWlnaHQoZWxlbWVudHMsIGNvbnRhaW5lcikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGaWxsUmVtYWluSGVpZ2h0KSkge1xuICAgICAgICByZXR1cm4gbmV3IEZpbGxSZW1haW5IZWlnaHQoZWxlbWVudHMsIGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9pZHggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLl9saXN0ZWQgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICB1dGlsLmZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5hZGRFbGVtZW50KGVsZW1lbnQpO1xuICAgIH0sIHRoaXMpO1xufVxuXG4vKipcbiAqIERlc3Ryb3kgbWV0aG9kXG4gKi9cbkZpbGxSZW1haW5IZWlnaHQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9pZHggPSB0aGlzLl9saXN0ZWQgPSB0aGlzLl9jb250YWluZXIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byBzZXQgaGVpZ2h0IHB4XG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gcGl4ZWwgaGVpZ2h0IHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5GaWxsUmVtYWluSGVpZ2h0LnByb3RvdHlwZS5fc2V0SGVpZ2h0ID0gZnVuY3Rpb24oZWxlbWVudCwgaGVpZ2h0KSB7XG4gICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xufTtcblxuRmlsbFJlbWFpbkhlaWdodC5wcm90b3R5cGUuX2dldEhlaWdodCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG59O1xuXG4vKipcbiAqIEFkZCBtYW5hZ2VkIGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIG1hbmFnaW5nIGhlaWdodFxuICovXG5GaWxsUmVtYWluSGVpZ2h0LnByb3RvdHlwZS5hZGRFbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHZhciBpZCA9IHRoaXMuX2lkeDtcblxuICAgIGRvbXV0aWwuc2V0RGF0YShlbGVtZW50LCAnZWxpZCcsIGlkKTtcblxuICAgIHRoaXMuX2xpc3RlZFtpZF0gPSBlbGVtZW50O1xuICAgIHRoaXMuX2lkeCArPSAxO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgbWFuYWdlZCBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byByZW1vdmVcbiAqL1xuRmlsbFJlbWFpbkhlaWdodC5wcm90b3R5cGUucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB2YXIgaWQgPSBkb211dGlsLmdldERhdGEoZWxlbWVudCwgJ2VsaWQnKTtcblxuICAgIGRvbXV0aWwuc2V0RGF0YShlbGVtZW50LCAnZWxpZCcsICcnKTtcblxuICAgIGRlbGV0ZSB0aGlzLl9saXN0ZWRbaWRdO1xufTtcblxuLyoqXG4gKiBHZXQgaGVpZ2h0IG9mIGVsZW1lbnQgdGhhdCBub3QgbGlzdGVkIGluIHRoaXMgbW9kdWxlXG4gKiBAcGFyYW0ge29iamVjdH0gbGlzdGVkIC0gdGhpcy5fbGlzdGVkIHByb3BlcnR5XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byBjYWxjdWxhdGUgaGVpZ2h0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBoZWlnaHRcbiAqL1xuRmlsbFJlbWFpbkhlaWdodC5wcm90b3R5cGUuX2dldE90aGVyRWxlbWVudEhlaWdodCA9IGZ1bmN0aW9uKGxpc3RlZCwgZWxlbWVudCkge1xuICAgIHZhciBpZDtcblxuICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnI3RleHQnKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlkID0gZG9tdXRpbC5nZXREYXRhKGVsZW1lbnQsICdlbGlkJyk7XG5cbiAgICBpZiAobGlzdGVkW2lkXSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0SGVpZ2h0KGVsZW1lbnQpO1xufTtcblxuLyoqXG4gKiBjYWxjdWxhdGUgcmVzdCBoZWlnaHQgb2YgY29udGFpbmVyIGFuZCBzZXQgaXQgdG8gbGlzdGVkIGVsZW1lbnRzLlxuICovXG5GaWxsUmVtYWluSGVpZ2h0LnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcbiAgICAgICAgY29udGFpbmVySGVpZ2h0ID0gZG9tdXRpbC5nZXRTaXplKGNvbnRhaW5lcilbMV0sXG4gICAgICAgIGNoaWxkcyA9IGNvbnRhaW5lci5jaGlsZE5vZGVzLFxuICAgICAgICBpID0gMCwgbGVuID0gY2hpbGRzLmxlbmd0aCxcbiAgICAgICAgbGlzdGVkID0gdGhpcy5fbGlzdGVkLFxuICAgICAgICB1c2VkSGVpZ2h0ID0gMCxcbiAgICAgICAgaGVpZ2h0O1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB1c2VkSGVpZ2h0ICs9IHRoaXMuX2dldE90aGVyRWxlbWVudEhlaWdodChsaXN0ZWQsIGNoaWxkc1tpXSk7XG4gICAgfVxuXG4gICAgaGVpZ2h0ID0gKGNvbnRhaW5lckhlaWdodCAtIHVzZWRIZWlnaHQpIC8gdXRpbC5rZXlzKGxpc3RlZCkubGVuZ3RoO1xuICAgIHV0aWwuZm9yRWFjaChsaXN0ZWQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fc2V0SGVpZ2h0KGVsZW1lbnQsIGhlaWdodCk7XG4gICAgfSwgdGhpcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbGxSZW1haW5IZWlnaHQ7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBNaXhpbiBtb2R1bGUgZm9yIG1vZGVscy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLnR1aS51dGlsLFxuICAgIHNwYWNlUnggPSAvXlxccyp8XFxzKiQvZyxcbiAgICBtb2RlbDtcblxudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vY29tbW9uL2RhdGV0aW1lJyk7XG5cbi8qKlxuICogTWl4aW4gbW9kdWxlIGZvciBtb2RlbHMuXG4gKiBAbWl4aW5cbiAqL1xubW9kZWwgPSB7XG4gICAgLyoqXG4gICAgICogc3RyaW5nIHRyaW1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIHN0cmluZyB0byB0cmltXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdHJpbWVkIHN0cmluZ1xuICAgICAqL1xuICAgIHRyaW06IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2Uoc3BhY2VSeCwgJycpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGNvbGxlY3Rpb25zIG9mIHZhbGlkYXRvciBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgdmFsaWRhdG9yczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogY2hlY2sgYWxsIG9mIHN1cHBsaWVkIGZpZWxkcyhwcm9wZXJ0eSkgaXMgbm90IHVuZGVmaW5lZCBvciBlbXB0eSBzdHJpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0YW5jZSBtb2RlbCBpbnN0YW5jZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGRzIHByb3BlcnR5IG5hbWVzIHRvIGNoZWNrLlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJuIHRydWUgd2hlbiBzdXBwbGllZCBmaWVsZHMgYXJlIG5vdCB1bmRlZmluZWQgb3IgZW1wdHkgc3RyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVxdWlyZWQ6IGZ1bmN0aW9uKGluc3RhbmNlLCBmaWVsZHMpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZCA9IHRydWUsXG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXV0aWwuaXNVbmRlZmluZWQob2JqKSAmJiBtb2RlbC50cmltKG9iaikgIT09ICcnO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHV0aWwuZm9yRWFjaChmaWVsZHMsIGZ1bmN0aW9uKGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhbGlkID0gaXNWYWxpZChpbnN0YW5jZVtmaWVsZE5hbWVdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGVjayBzdXBwbGllZCBmaWVsZHMgYXJlIHZhbGlkIGRhdGVzIGFuZCB2YWxpZCBkYXRlIHJhbmdlcy5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGluc3RhbmNlIG1vZGVsIGluc3RhbmNlLlxuICAgICAgICAgKiBAcGFyYW0ge0RhdGVbXX0gZmllbGRzIGFycmF5IG9mIGRhdGUgcmFuZ2UgKHN0YXJ0cywgZW5kcylcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IGlzIHZhbGlkIGRhdGUgcmFuZ2U/XG4gICAgICAgICAqL1xuICAgICAgICBkYXRlUmFuZ2U6IGZ1bmN0aW9uKGluc3RhbmNlLCBmaWVsZHMpIHtcbiAgICAgICAgICAgIHZhciBzdGFydHMsXG4gICAgICAgICAgICAgICAgZW5kcztcblxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzRXhpc3R5KGluc3RhbmNlKSB8fCBmaWVsZHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXJ0cyA9IG5ldyBEYXRlKGluc3RhbmNlW2ZpZWxkc1swXV0pO1xuICAgICAgICAgICAgZW5kcyA9IG5ldyBEYXRlKGluc3RhbmNlW2ZpZWxkc1sxXV0pO1xuXG4gICAgICAgICAgICBpZiAoIWRhdGV0aW1lLmlzVmFsaWQoc3RhcnRzKSB8fCAhZGF0ZXRpbWUuaXNWYWxpZChlbmRzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGV0aW1lLmNvbXBhcmUoc3RhcnRzLCBlbmRzKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdmFsaWRhdGUgZm9yIG1vZGVsIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogVGhlIHZhbGlkYXRlIGFyZSB3b3JrcyBvbiBhIGJhc2lzIG9mIGNvbnN0cnVjdG9yJ3MgXCJzY2hlbWFcIiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gY3VzdG9taXplIHZhbGlkYXRvcnMgYWRkIHNvbWUgbWV0aG9kIHRvIG1vZGVsI3ZhbGlkYXRvcnMuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IG1vZGVsIGlzIHZhbGlkP1xuICAgICAqL1xuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICBzY2hlbWEgPSB0aGlzLmNvbnN0cnVjdG9yLnNjaGVtYSxcbiAgICAgICAgICAgIHZhbGlkYXRvcnMgPSBtb2RlbC52YWxpZGF0b3JzLFxuICAgICAgICAgICAgdmFsaWRhdG9yLFxuICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICghc2NoZW1hKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWwuZm9yRWFjaChzY2hlbWEsIGZ1bmN0aW9uKHZhbHVlcywgdmFsaWRhdG9yTmFtZSkge1xuICAgICAgICAgICAgdmFsaWRhdG9yID0gdmFsaWRhdG9yc1t2YWxpZGF0b3JOYW1lXTtcblxuICAgICAgICAgICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgICAgIHZhbGlkID0gdmFsaWRhdG9yKHRoYXQsIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgZGF0YSBvYmplY3QgZm9ybSBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEl0IHJldHVybiBvYmplY3QgZmlsbCB3aXRoIGFsbCBvd25lZCBwcm9wZXJ0aWVzIGJ1dCBleGNsdWRlIGZ1bmN0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBEYXRhIG9iamVjdFxuICAgICAqL1xuICAgIHBhcmFtZXRlcml6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IHt9LFxuICAgICAgICAgICAgaXNGdW5jID0gdXRpbC5pc0Z1bmN0aW9uO1xuXG4gICAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLCBmdW5jdGlvbih2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgICAgICAgICAgIGlmICghaXNGdW5jKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtW3Byb3BOYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1peGluIG1vZGVsIG1vZHVsZSB0byBzdXBwbGllZCB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IG9mIHdhbnQgdG8gbWl4ZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBmdW5jdGlvbiBNYW4oKSB7XG4gICAgICogICAgIHRoaXMubmFtZSA9ICdqb2huJztcbiAgICAgKiB9XG4gICAgICogbW9kZWwubWl4aW4oTWFuLnByb3RvdHlwZSk7XG4gICAgICovXG4gICAgbWl4aW46IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICB1dGlsLmZvckVhY2gobW9kZWwsIGZ1bmN0aW9uKG1ldGhvZCwgbmFtZSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgIT09ICdtaXhpbicpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBtZXRob2Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbW9kZWw7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlld1xuICogQ2xhc3MgZm9yIHJlcHJlc2VudCB0d28gZGltZW5zaW9uYWwgeCwgeSBjb29yZGluYXRlcy5cbiAqXG4gKiBJdCBzdXBwbGl5IGEgZ3JvdXAgb2YgZnVuY3Rpb25zIGZvciBtYW5pcHVsYXRlIGNvb3JkaW5hdGVzLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKiBAZXhhbXBsZVxuICogdmFyIHAgPSBwb2ludCgxMCwgMTApO1xuICogdmFyIHIxID0gcC5hZGQoUG9pbnQoNSwgNSkpO1xuICogY29uc29sZS5sb2cocC50b1N0cmluZygpKSAgICAvLyBcIlBvaW50KDEwLCAxMClcIlxuICogY29uc29sZS5sb2cocjEudG9TdHJpbmcoKSkgICAgLy8gXCJQb2ludCgxNSwgMTUpXCJcbiAqXG4gKiB2YXIgcDIgPSBuZXcgUG9pbnQoMTAsIDEwKTtcbiAqIHAyLl9hZGQocG9pbnQoNSwgNSkpO1xuICogY29uc29sZS5sb2cocDIudG9TdHJpbmcoKSkgICAvLyBcIlBvaW50KDE1LCAxNSlcIlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLnR1aS51dGlsO1xuXG4vKipcbiAqIENsYXNzIGZvciByZXByZXNlbnQgdHdvIGRpbWVudGlvbmFsIHgsIHkgY29vcmRpbmF0ZXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBudW1iZXIgb2YgWCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSBudW1iZXIgb2YgWSBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZVJvdW5kPWZhbHNlXSBzZXQgdHJ1ZSB3aGVuIGVhY2ggY29vcmRpbmF0ZXMgYXJlIHJvdW5kZWQgYmVmb3JlIGluaXRpYWxpemUuXG4gKiBAZXhhbXBsZVxuICogdmFyIHQgPSBuZXcgUG9pbnQoMTMsIDUpO1xuICovXG5mdW5jdGlvbiBQb2ludCh4LCB5LCB1c2VSb3VuZCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy54ID0gKHVzZVJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnkgPSAodXNlUm91bmQgPyBNYXRoLnJvdW5kKHkpIDogeSk7XG59XG5cbi8qKioqKioqKioqXG4gKiBzdGF0aWMgcHJvcHNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIENhbGN1bGF0ZSBwb2ludCByYXRpby5cbiAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IFRoZSBpbnN0YW5jZSBvZiBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYWN0b3IgRnJvbSBmYWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0ZhY3RvciBUbyBmYWN0b3JcbiAqIEByZXR1cm5zIHtQb2ludH0gUG9pbnQgaW5zdGFuY2UgY2FsY3VsYXRlZC5cbiAqL1xuUG9pbnQuZ2V0UmF0aW8gPSBmdW5jdGlvbihwb2ludCwgZmFjdG9yLCB0b0ZhY3Rvcikge1xuICAgIGlmIChmYWN0b3IgPT09IHRvRmFjdG9yKSB7XG4gICAgICAgIHJldHVybiBwb2ludC5jbG9uZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludC5tdWx0aXBseUJ5KHRvRmFjdG9yKS5fZGl2aWRlQnkoZmFjdG9yKTtcbn07XG5cbi8qKlxuICogU3ludGF0aWMgc3VnYXIgb2YgbmV3IFBvaW50KClcbiAqIEBwYXJhbSB7KFBvaW50fG51bWJlcnxudW1iZXJbXSl9IHggWCBjb29yZGluYXRlIHZhbHVlLlxuICogQHBhcmFtIHsobnVtYmVyfGJvb2xlYW4pfSBbeV0gWSBjb29yZGluYXRlIHZhbHVlIG9yIGJvb2xlYW4gdmFsdWUgZm9yIGNvb3JkaW5hdGVzIHJvdW5kLlxuICogQHBhcmFtIHtib29sZWFufSBbdXNlUm91bmRdIFNldCB0cnVlIHRoZW4gcm91bmQgaW5pdGlhbCBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtQb2ludH0gVGhlIGluc3RhbmNlIG9mIHBvaW50LlxuICogQGV4YW1wbGVcbiAqIHZhciBwMSA9IHBvaW50KDEwLCAxNSk7XG4gKiB2YXIgcDIgPSBwb2ludChbMTAsIDE1XSk7XG4gKi9cblBvaW50Lm4gPSBmdW5jdGlvbih4LCB5LCB1c2VSb3VuZCkge1xuICAgIGlmICh4IGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgaWYgKHV0aWwuaXNBcnJheSh4KSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHhbMF0sIHhbMV0sIHkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgdXNlUm91bmQpO1xufTtcblxuLyoqKioqKioqKipcbiAqIHByb3RvdHlwZSBwcm9wc1xuICoqKioqKioqKiovXG5cbi8qKlxuICogQ2xvbmUgcG9pbnRzXG4gKiBAcmV0dXJucyB7UG9pbnR9IFRoZSBwb2ludCBpbnN0YW5jZSBjbG9uZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xufTtcblxuLyoqXG4gKiBBZGQgcG9pbnRzLlxuICogQHBhcmFtIHtQb2ludH0gcG9pbnQgVGhlIHBvaW50IGluc3RhbmNlIHRvIGFkZC5cbiAqIEByZXR1cm4ge1BvaW50fSBQb2ludCBjYWxjdWxhdGVkLlxuICovXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQoUG9pbnQubihwb2ludCkpO1xufTtcblxuLyoqXG4gKiBBZGQgc2VsZiBwb2ludHMuXG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludCBUaGUgcG9pbnQgaW5zdGFuY2UgdG8gYWRkLlxuICogQHJldHVybiB7UG9pbnR9IFBvaW50IGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5fYWRkID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICB0aGlzLnggKz0gcG9pbnQueDtcbiAgICB0aGlzLnkgKz0gcG9pbnQueTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3VidHJhY3QgcG9pbnRzLlxuICogQHBhcmFtIHtQb2ludH0gcG9pbnQgVGhlIHBvaW50IGluc3RhbmNlIHRvIHN1YnRyYWN0LlxuICogQHJldHVybiB7UG9pbnR9IFBvaW50IGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fc3VidHJhY3QoUG9pbnQubihwb2ludCkpO1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdCBwb2ludHMuIChtYW5pcHVsYXRlIHNlbGYpXG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludCBUaGUgcG9pbnQgaW5zdGFuY2UgdG8gc3VidHJhY3QuXG4gKiBAcmV0dXJucyB7UG9pbnR9IFBvaW50IGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5fc3VidHJhY3QgPSBmdW5jdGlvbihwb2ludCkge1xuICAgIHRoaXMueCAtPSBwb2ludC54O1xuICAgIHRoaXMueSAtPSBwb2ludC55O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEaXZpZGUgcG9pbnRzLlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIGRpdmlkZS5cbiAqIEByZXR1cm5zIHtQb2ludH0gUG9pbnQgY2FsY3VsYXRlZC5cbiAqL1xuUG9pbnQucHJvdG90eXBlLmRpdmlkZUJ5ID0gZnVuY3Rpb24obnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2aWRlQnkobnVtKTtcbn07XG5cbi8qKlxuICogRGl2aWRlIHBvaW50cy4gKG1hbmlwdWxhdGUgc2VsZilcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBkaXZpZGUuXG4gKiBAcmV0dXJucyB7UG9pbnR9IFBvaW50IGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5fZGl2aWRlQnkgPSBmdW5jdGlvbihudW0pIHtcbiAgICB0aGlzLnggLz0gbnVtO1xuICAgIHRoaXMueSAvPSBudW07XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaHllbiBudW1iZXIgdG8gbXVsdGlwbHlcbiAqIEByZXR1cm4ge1BvaW50fSBQb2ludCBjYWxjdWxhdGVkLlxuICovXG5Qb2ludC5wcm90b3R5cGUubXVsdGlwbHlCeSA9IGZ1bmN0aW9uKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuX211bHRpcGx5QnkobnVtKTtcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgc2VsZiBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBtdWx0aXBseS5cbiAqIEByZXR1cm5zIHtQb2ludH0gUG9pbnQgY2FsY3VsYXRlZC5cbiAqL1xuUG9pbnQucHJvdG90eXBlLl9tdWx0aXBseUJ5ID0gZnVuY3Rpb24obnVtKSB7XG4gICAgdGhpcy54ICo9IG51bTtcbiAgICB0aGlzLnkgKj0gbnVtO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSb3VuZCBjb29yZGluYXRlcy5cbiAqIEByZXR1cm5zIHtQb2ludH0gUG9pbnQgY2FsY3VsYXRlZC5cbiAqL1xuUG9pbnQucHJvdG90eXBlLnJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTtcbn07XG5cbi8qKlxuICogUm91bmQgc2VsZiBjb29yZGluYXRlcy5cbiAqIEByZXR1cm5zIHtQb2ludH0gUG9pbnQgY2FsY3VsYXRlZC5cbiAqL1xuUG9pbnQucHJvdG90eXBlLl9yb3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcbiAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldmVyc2UgdmFsdWVzIGJldHdlZW4gcG9zaXRpdmUgYW5kIG5lZ2F0aXZlLlxuICogQHJldHVybnMge1BvaW50fSBQb2ludCBjYWxjdWxhdGVkLlxuICovXG5Qb2ludC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuX3JldmVyc2UoKTtcbn07XG5cbi8qKlxuICogUmV2ZXJzZSBzZWxmIHZhbHVlcyBiZXR3ZWVuIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZS5cbiAqIEByZXR1cm5zIHtQb2ludH0gUG9pbnQgY2FsY3VsYXRlZC5cbiAqL1xuUG9pbnQucHJvdG90eXBlLl9yZXZlcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy54ICo9IC0xO1xuICAgIHRoaXMueSAqPSAtMTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmxvb3IgY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJucyB7UG9pbnR9IFBvaW50IGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5mbG9vciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuX2Zsb29yKCk7XG59O1xuXG4vKipcbiAqIEZsb29yIHNlbGYgY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJucyB7UG9pbnR9IFBvaW50IGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5fZmxvb3IgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XG4gICAgdGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDZWlsIGNvb3JkaW5hdGVzLlxuICogQHJldHVybnMge1BvaW50fSBQb2ludCBjYWxjdWxhdGVkLlxuICovXG5Qb2ludC5wcm90b3R5cGUuY2VpbCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuX2NlaWwoKTtcbn07XG5cbi8qKlxuICogQ2VpbCBzZWxmIGNvb2RpbmF0ZXMuXG4gKiBAcmV0dXJucyB7UG9pbnR9IFBvaW50IGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5fY2VpbCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMueCA9IE1hdGguY2VpbCh0aGlzLngpO1xuICAgIHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSb3RhdGUgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVnIFRoZSBudW1iZXIgb2Ygcm90YXRlIGRlZ3JlZS5cbiAqIEBwYXJhbSB7UG9pbnR9IFtjZW50ZXI9dGhpc10gQ2VudGVyIHBvaW50IGluc3RhbmNlIHRvIHVzZSByb3RhdGUgY2VudGVyLiB1c2Ugb3duIHdoZW4gbm90IHN1cHBsaWVkLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb3NdIENvc2luZSB2YWx1ZXMgZm9yIHJvdGF0ZS4gaXQgdXNlZnVsIHdoZW4gbXVsdGkgcG9pbnQgcm90YXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaW5dIFNpbmUgdmFsdWVzIGZvciByb3RhdGUuIGl0IHVzZWZ1bCB3aGVuIG11bHRpIHBvaW50IHJvdGF0ZS5cbiAqIEByZXR1cm5zIHtQb2ludH0gVGhlIHBvaW50IGluc3RhbmNlIHJvdGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbihkZWcsIGNlbnRlciwgY29zLCBzaW4pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3RhdGUoZGVnLCBjZW50ZXIsIGNvcywgc2luKTtcbn07XG5cbi8qKlxuICogUm90YXRlIHNlbGYuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVnIFRoZSBudW1iZXIgb2Ygcm90YXRlIGRlZ3JlZS5cbiAqIEBwYXJhbSB7UG9pbnR9IFtjZW50ZXI9dGhpc10gQ2VudGVyIHBvaW50IGluc3RhbmNlIHRvIHVzZSByb3RhdGUgY2VudGVyLiB1c2Ugb3duIHdoZW4gbm90IHN1cHBsaWVkLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb3NdIENvc2luZSB2YWx1ZXMgZm9yIHJvdGF0ZS4gaXQgdXNlZnVsIHdoZW4gbXVsdGkgcG9pbnQgcm90YXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaW5dIFNpbmUgdmFsdWVzIGZvciByb3RhdGUuIGl0IHVzZWZ1bCB3aGVuIG11bHRpIHBvaW50IHJvdGF0ZS5cbiAqIEByZXR1cm5zIHtQb2ludH0gVGhlIHBvaW50IGluc3RhbmNlIHJvdGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5fcm90YXRlID0gZnVuY3Rpb24oZGVnLCBjZW50ZXIsIGNvcywgc2luKSB7XG4gICAgdmFyIHJhZCA9IGRlZyAqIChNYXRoLlBJIC8gMTgwKSxcbiAgICAgICAgeCxcbiAgICAgICAgeTtcblxuICAgIGNvcyA9IGNvcyB8fCBwYXJzZUZsb2F0KE1hdGguY29zKHJhZCkudG9GaXhlZCg4KSk7XG4gICAgc2luID0gc2luIHx8IHBhcnNlRmxvYXQoTWF0aC5zaW4ocmFkKS50b0ZpeGVkKDgpKTtcblxuICAgIHRoaXMuX3N1YnRyYWN0KGNlbnRlcik7XG5cbiAgICB4ID0gdGhpcy54O1xuICAgIHkgPSB0aGlzLnk7XG5cbiAgICB0aGlzLnggPSB4ICogY29zIC0geSAqIHNpbjtcbiAgICB0aGlzLnkgPSB4ICogc2luICsgeSAqIGNvcztcblxuICAgIHRoaXMuX2FkZChjZW50ZXIpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludCBQb2ludCBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICovXG5Qb2ludC5wcm90b3R5cGUuZGlzdGFuY2VUbyA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgdmFyIHgsXG4gICAgICAgIHk7XG5cbiAgICBwb2ludCA9IFBvaW50Lm4ocG9pbnQpO1xuXG4gICAgeCA9IHBvaW50LnggLSB0aGlzLng7XG4gICAgeSA9IHBvaW50LnkgLSB0aGlzLnk7XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xufTtcblxuLyoqXG4gKiBDaGVjayBwb2ludCBlcXVhbHMuXG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludCBQb2ludCBpbnN0YW5jZSB0byBjb21wYXJlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gZXF1YWxpdHlcbiAqL1xuUG9pbnQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgcG9pbnQgPSBQb2ludC5uKHBvaW50KTtcbiAgICByZXR1cm4gcG9pbnQueCA9PT0gdGhpcy54ICYmIHBvaW50LnkgPT09IHRoaXMueTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGZvcm1hdHRlZCBzdHJpbmcuICdQb2ludCh4LCB5KSdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHN0cmluZ1xuICovXG5Qb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ1BvaW50KCcgKyB0aGlzLnggKyAnLCAnICsgdGhpcy55ICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gY29vZGluYXRlcyB0byBhcnJheS4gW3gsIHldXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IGNvb3JkaW5hdGUgYXJyYXkuXG4gKi9cblBvaW50LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFt0aGlzLngsIHRoaXMueV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVxdWVzdEFuaW1GcmFtZVxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwudHVpLnV0aWw7XG52YXIgcmVxdWVzdEZuLFxuICAgIGNhbmNlbEZuO1xuXG5mdW5jdGlvbiBnZXRQcmVmaXhlZChuYW1lKSB7XG4gICAgcmV0dXJuIGdsb2JhbFsnd2Via2l0JyArIG5hbWVdIHx8IGdsb2JhbFsnbW96JyArIG5hbWVdIHx8IGdsb2JhbFsnbXMnICsgbmFtZV07XG59XG5cbnJlcXVlc3RGbiA9IGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICBnZXRQcmVmaXhlZCgnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHxcbiAgICBmdW5jdGlvbihmbiwgY29udGV4dCkge1xuICAgICAgICBmbi5jYWxsKGNvbnRleHQpO1xuICAgIH07XG5cbmNhbmNlbEZuID0gZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgZ2V0UHJlZml4ZWQoJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJykgfHxcbiAgICBnZXRQcmVmaXhlZCgnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHxcbiAgICBmdW5jdGlvbigpIHt9O1xuXG4vKipcbiAqIEBtb2R1bGUgbW9kdWxlOnJlcUFuaW1GcmFtZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIFNoaW0gb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHQgY29udGV4dCBmb3IgY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBVbmlxdWUgaWRcbiAgICAgKi9cbiAgICByZXF1ZXN0QW5pbUZyYW1lOiBmdW5jdGlvbihmbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcmVxdWVzdEZuLmNhbGwoZ2xvYmFsLCB1dGlsLmJpbmQoZm4sIGNvbnRleHQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hpbSBvZiBjYW5jZWxBbmltYXRpb25GcmFtZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgaWRcbiAgICAgKi9cbiAgICBjYW5jZWxBbmltRnJhbWU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbmNlbEZuLmNhbGwoZ2xvYmFsLCBpZCk7XG4gICAgfVxufTtcblxuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBHbG9iYWwgY29uZmlndXJhdGlvbiBvYmplY3QgbW9kdWxlLiBUaGlzIEBlY2hvIHN5bnRheCB3aWxsIGNoYW5nZSBwcmVwcm9jZXNzIGNvbnRleHQuIFNlZSBndWxwZmlsZS5qc1xuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGNvbmZpZyA9IHtcbiAgICB0aHJvd0Vycm9yOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgYWxlcnQobXNnKTtcbiAgICB9LFxuXG4gICAgY3NzUHJlZml4OiAnZGNhbC0nLFxuXG4gICAgY2xhc3NuYW1lOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5jc3NQcmVmaXggKyAoc3RyICsgJycpO1xuICAgIH0sXG5cbiAgICBtaW5pY2FsZW5kYXI6IHtcbiAgICAgICAgZ2V0RGF0YVJlZ0V4cDogL2RjYWwtbWluaWNhbGVuZGFyLShcXGR7NH0tXFxkezJ9LVxcZHsyfSkvXG4gICAgfSxcblxuICAgIGFsbGRheToge1xuICAgICAgICBnZXRWaWV3SURSZWdFeHA6IC9eZGNhbC1hbGxkYXktbW9udGh3ZWVrW1xcc11kY2FsLShcXGQrKS8sXG4gICAgICAgIGNoZWNrQ29uZFJlZ0V4cDogL15kY2FsLWFsbGRheS1ldmVudCgtdGl0bGUpPyQvXG4gICAgfSxcblxuICAgIHRpbWU6IHtcbiAgICAgICAgZ2V0Vmlld0lEUmVnRXhwOiAvXmRjYWwtdGltZS1kYXRlW1xcc11kY2FsLShcXGQrKS9cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmZpZztcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEJhc2UgY2FsZW5kYXIgY29udHJvbGxlclxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwudHVpLnV0aWw7XG52YXIgQ2FsRXZlbnQgPSByZXF1aXJlKCcuLi9tb2RlbC9jYWxFdmVudCcpO1xudmFyIENhbEV2ZW50Vmlld01vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWwvdmlld01vZGVsL2NhbEV2ZW50Jyk7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24vY29tbW9uJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIGJhc2UgY29udHJvbGxlclxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZ3JvdXBGdW5jXSAtIGZ1bmN0aW9uIGZvciBncm91cCBlYWNoIG1vZGVscyB7QHNlZSBDb2xsZWN0aW9uI2dyb3VwQnl9XG4gKiBAbWl4ZXMgdXRpbC5DdXN0b21FdmVudHNcbiAqL1xuZnVuY3Rpb24gQmFzZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBmdW5jdGlvbiBmb3IgZ3JvdXAgZWFjaCBldmVudCBtb2RlbHMuXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqIEBwYXJhbSB7Q2FsRXZlbnRWaWV3TW9kZWx9IHZpZXdNb2RlbCAtIHZpZXcgbW9kZWwgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IGdyb3VwIGtleVxuICAgICAqL1xuICAgIHRoaXMuZ3JvdXBGdW5jID0gb3B0aW9ucy5ncm91cEZ1bmMgfHwgZnVuY3Rpb24odmlld01vZGVsKSB7XG4gICAgICAgIGlmICh2aWV3TW9kZWwubW9kZWwuaXNBbGxEYXkpIHtcbiAgICAgICAgICAgIHJldHVybiAnYWxsZGF5JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3RpbWUnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGV2ZW50cyBjb2xsZWN0aW9uLlxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRzID0gY29tbW9uLmNyZWF0ZUV2ZW50Q29sbGVjdGlvbigpO1xuXG4gICAgLyoqXG4gICAgICogTWF0cml4IGZvciBtdWx0aWRhdGUgZXZlbnRzLlxuICAgICAqIEB0eXBlIHtvYmplY3QuPHN0cmluZywgYXJyYXk+fVxuICAgICAqL1xuICAgIHRoaXMuZGF0ZU1hdHJpeCA9IHt9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBjb250YWluIGRhdGVzIGluIGV2ZW50LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Q2FsRXZlbnR9IGV2ZW50IFRoZSBpbnN0YW5jZSBvZiBldmVudC5cbiAqIEByZXR1cm5zIHthcnJheX0gY29udGFpbiBkYXRlcy5cbiAqL1xuQmFzZS5wcm90b3R5cGUuX2dldENvbnRhaW5EYXRlc0luRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciByYW5nZSA9IGRhdGV0aW1lLnJhbmdlKFxuICAgICAgICBkYXRldGltZS5zdGFydChldmVudC5nZXRTdGFydHMoKSksXG4gICAgICAgIGRhdGV0aW1lLnN0YXJ0KGV2ZW50LmdldEVuZHMoKSksXG4gICAgICAgIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZXG4gICAgKTtcblxuICAgIHJldHVybiByYW5nZTtcbn07XG5cbi8qKioqKioqKioqXG4gKiBDUlVEXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBDcmVhdGUgYW4gZXZlbnQgaW5zdGFuY2UgZnJvbSByYXcgZGF0YS5cbiAqIEBlbWl0cyBCYXNlI2NyZWF0ZWRFdmVudFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgRGF0YSBvYmplY3QgdG8gY3JlYXRlIGV2ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBzaWxlbnQgLSBzZXQgdHJ1ZSB0aGVuIGRvbid0IGZpcmUgZXZlbnRzLlxuICogQHJldHVybnMge0NhbEV2ZW50fSBUaGUgaW5zdGFuY2Ugb2YgQ2FsRXZlbnQgdGhhdCBjcmVhdGVkLlxuICovXG5CYXNlLnByb3RvdHlwZS5jcmVhdGVFdmVudCA9IGZ1bmN0aW9uKG9wdGlvbnMsIHNpbGVudCkge1xuICAgIHZhciBldmVudCA9IHRoaXMuYWRkRXZlbnQoQ2FsRXZlbnQuY3JlYXRlKG9wdGlvbnMpKTtcblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXZlbnQgQmFzZSNjcmVhdGVkRXZlbnRcbiAgICAgICAgICogQHR5cGUge0NhbEV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maXJlKCdjcmVhdGVkRXZlbnQnLCBldmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50O1xufTtcblxuLyoqXG4gKiBAZW1pdHMgQmFzZSNiZWZvcmVDcmVhdGVFdmVudFxuICogQGVtaXRzIEJhc2UjY3JlYXRlZEV2ZW50XG4gKiBAcGFyYW0ge0NhbGVuZGFyfkNhbEV2ZW50W119IGRhdGFMaXN0IC0gZGF0YU9iamVjdCBsaXN0IHRvIGNyZWF0ZSBldmVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NpbGVudD1mYWxzZV0gLSBzZXQgdHJ1ZSB0aGVuIGRvbid0IGZpcmUgZXZlbnRzLlxuICogQHJldHVybnMge0NhbEV2ZW50W119IFRoZSBpbnN0YW5jZSBsaXN0IG9mIENhbEV2ZW50IHRoYXQgY3JlYXRlZC5cbiAqL1xuQmFzZS5wcm90b3R5cGUuY3JlYXRlRXZlbnRzID0gZnVuY3Rpb24oZGF0YUxpc3QsIHNpbGVudCkge1xuICAgIHJldHVybiB1dGlsLm1hcChkYXRhTGlzdCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFdmVudChkYXRhLCBzaWxlbnQpO1xuICAgIH0sIHRoaXMpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgYW4gZXZlbnQuXG4gKiBAZW1pdHMgQmFzZSN1cGRhdGVFdmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGlkIFRoZSB1bmlxdWUgaWQgb2YgQ2FsRXZlbnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyB1cGRhdGVkIG9iamVjdCBkYXRhLlxuICogQHJldHVybnMge0NhbEV2ZW50fGJvb2xlYW59IHVwZGF0ZWQgZXZlbnQgaW5zdGFuY2UsIHdoZW4gaXQgZmFpbCB0aGVuIHJldHVybiBmYWxzZS5cbiAqL1xuQmFzZS5wcm90b3R5cGUudXBkYXRlRXZlbnQgPSBmdW5jdGlvbihpZCwgb3B0aW9ucykge1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcblxuICAgIHRoaXMuZXZlbnRzLmRvV2hlbkhhcyhpZCwgZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUpIHtcbiAgICAgICAgICAgIG1vZGVsLnNldCgndGl0bGUnLCBvcHRpb25zLnRpdGxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmlzQWxsRGF5KSB7XG4gICAgICAgICAgICBtb2RlbC5zZXQoJ2lzQWxsRGF5Jywgb3B0aW9ucy5pc0FsbERheSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zdGFydHMpIHtcbiAgICAgICAgICAgIG1vZGVsLnNldCgnc3RhcnRzJywgbmV3IERhdGUob3B0aW9ucy5zdGFydHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmVuZHMpIHtcbiAgICAgICAgICAgIG1vZGVsLnNldCgnZW5kcycsIG5ldyBEYXRlKG9wdGlvbnMuZW5kcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVtb3ZlRnJvbU1hdHJpeChtb2RlbCk7XG4gICAgICAgIHRoaXMuX2FkZFRvTWF0cml4KG1vZGVsKTtcblxuICAgICAgICByZXN1bHQgPSBtb2RlbDtcbiAgICB9LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBCYXNlI3VwZGF0ZUV2ZW50XG4gICAgICovXG4gICAgdGhpcy5maXJlKCd1cGRhdGVFdmVudCcpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogRGVsZXRlIGV2ZW50IGluc3RhbmNlIGZyb20gY29udHJvbGxlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtIHVuaXF1ZSBpZCBvZiBtb2RlbCBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtDYWxFdmVudH0gZGVsZXRlZCBtb2RlbCBpbnN0YW5jZS5cbiAqL1xuQmFzZS5wcm90b3R5cGUuZGVsZXRlRXZlbnQgPSBmdW5jdGlvbihpZCkge1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcblxuICAgIHRoaXMuZXZlbnRzLmRvV2hlbkhhcyhpZCwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgcmVzdWx0ID0gZXZlbnQ7XG4gICAgICAgIHRoaXMuX3JlbW92ZUZyb21NYXRyaXgoZXZlbnQpO1xuICAgICAgICB0aGlzLmV2ZW50cy5yZW1vdmUoZXZlbnQpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogU2V0IGRhdGUgbWF0cml4IHRvIHN1cHBsaWVkIGV2ZW50IGluc3RhbmNlLlxuICogQHBhcmFtIHtDYWxFdmVudH0gZXZlbnQgLSBpbnN0YW5jZSBvZiBldmVudC5cbiAqL1xuQmFzZS5wcm90b3R5cGUuX2FkZFRvTWF0cml4ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgb3duTWF0cml4ID0gdGhpcy5kYXRlTWF0cml4LFxuICAgICAgICBjb250YWluRGF0ZXMgPSB0aGlzLl9nZXRDb250YWluRGF0ZXNJbkV2ZW50KGV2ZW50KTtcblxuICAgIHV0aWwuZm9yRWFjaChjb250YWluRGF0ZXMsIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgdmFyIHltZCA9IGRhdGV0aW1lLmZvcm1hdChkYXRlLCAnWVlZWU1NREQnKSxcbiAgICAgICAgICAgIG1hdHJpeCA9IG93bk1hdHJpeFt5bWRdID0gb3duTWF0cml4W3ltZF0gfHwgW107XG5cbiAgICAgICAgbWF0cml4LnB1c2godXRpbC5zdGFtcChldmVudCkpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQncyBpZCBmcm9tIG1hdHJpeC5cbiAqIEBwYXJhbSB7Q2FsRXZlbnR9IGV2ZW50IC0gaW5zdGFuY2Ugb2YgZXZlbnRcbiAqL1xuQmFzZS5wcm90b3R5cGUuX3JlbW92ZUZyb21NYXRyaXggPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBtb2RlbElEID0gdXRpbC5zdGFtcChldmVudCk7XG5cbiAgICB1dGlsLmZvckVhY2godGhpcy5kYXRlTWF0cml4LCBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdXRpbC5pbkFycmF5KG1vZGVsSUQsIG1hdHJpeCk7XG5cbiAgICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICAgICAgbWF0cml4LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGluc3RhbmNlLlxuICogQGVtaXRzIEJhc2UjYWRkZWRFdmVudFxuICogQHBhcmFtIHtDYWxFdmVudH0gZXZlbnQgVGhlIGluc3RhbmNlIG9mIENhbEV2ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBzaWxlbnQgLSBzZXQgdHJ1ZSB0aGVuIGRvbid0IGZpcmUgZXZlbnRzLlxuICogQHJldHVybnMge0NhbEV2ZW50fSBUaGUgaW5zdGFuY2Ugb2YgQ2FsRXZlbnQgdGhhdCBhZGRlZC5cbiAqL1xuQmFzZS5wcm90b3R5cGUuYWRkRXZlbnQgPSBmdW5jdGlvbihldmVudCwgc2lsZW50KSB7XG4gICAgdGhpcy5ldmVudHMuYWRkKGV2ZW50KTtcbiAgICB0aGlzLl9hZGRUb01hdHJpeChldmVudCk7XG5cbiAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGV2ZW50IEJhc2UjYWRkZWRFdmVudFxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maXJlKCdhZGRlZEV2ZW50JywgZXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudDtcbn07XG5cbi8qKlxuICogc3BsaXQgZXZlbnQgbW9kZWwgYnkgeW1kLlxuICogQHBhcmFtIHtEYXRlfSBzdGFydHMgLSBzdGFydCBkYXRlXG4gKiBAcGFyYW0ge0RhdGV9IGVuZHMgLSBlbmQgZGF0ZVxuICogQHBhcmFtIHtDb2xsZWN0aW9ufSBldmVudENvbGxlY3Rpb24gLSBjb2xsZWN0aW9uIG9mIGV2ZW50IG1vZGVsLlxuICogQHJldHVybnMge29iamVjdC48c3RyaW5nLCBDb2xsZWN0aW9uPn0gc3BsaXR0ZWQgZXZlbnQgbW9kZWwgY29sbGVjdGlvbnMuXG4gKi9cbkJhc2UucHJvdG90eXBlLnNwbGl0RXZlbnRCeURhdGVSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0cywgZW5kcywgZXZlbnRDb2xsZWN0aW9uKSB7XG4gICAgdmFyIHJhbmdlID0gZGF0ZXRpbWUucmFuZ2UoXG4gICAgICAgICAgICBkYXRldGltZS5zdGFydChzdGFydHMpLFxuICAgICAgICAgICAgZGF0ZXRpbWUuc3RhcnQoZW5kcyksXG4gICAgICAgICAgICBkYXRldGltZS5NSUxMSVNFQ09ORFNfUEVSX0RBWVxuICAgICAgICApLFxuICAgICAgICBvd25NYXRyaXggPSB0aGlzLmRhdGVNYXRyaXgsXG4gICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgdXRpbC5mb3JFYWNoQXJyYXkocmFuZ2UsIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgdmFyIHltZCA9IGRhdGV0aW1lLmZvcm1hdChkYXRlLCAnWVlZWU1NREQnKSxcbiAgICAgICAgICAgIG1hdHJpeCA9IG93bk1hdHJpeFt5bWRdLFxuICAgICAgICAgICAgY29sbGVjdGlvbjtcblxuICAgICAgICBjb2xsZWN0aW9uID0gcmVzdWx0W3ltZF0gPSBjb21tb24uY3JlYXRlRXZlbnRDb2xsZWN0aW9uKCk7XG5cbiAgICAgICAgaWYgKG1hdHJpeCAmJiBtYXRyaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICB1dGlsLmZvckVhY2hBcnJheShtYXRyaXgsIGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRDb2xsZWN0aW9uLmRvV2hlbkhhcyhpZCwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5hZGQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJldHVybiBldmVudHMgaW4gc3VwcGxpZWQgZGF0ZSByYW5nZS5cbiAqXG4gKiBhdmFpbGFibGUgb25seSBZTUQuXG4gKiBAcGFyYW0ge0RhdGV9IHN0YXJ0cyBzdGFydCBkYXRlLlxuICogQHBhcmFtIHtEYXRlfSBlbmRzIGVuZCBkYXRlLlxuICogQHJldHVybnMge29iamVjdC48c3RyaW5nLCBDb2xsZWN0aW9uPn0gZXZlbnQgY29sbGVjdGlvbiBncm91cGVkIGJ5IGRhdGVzLlxuICovXG5CYXNlLnByb3RvdHlwZS5maW5kQnlEYXRlUmFuZ2UgPSBmdW5jdGlvbihzdGFydHMsIGVuZHMpIHtcbiAgICB2YXIgcmFuZ2UgPSBkYXRldGltZS5yYW5nZShcbiAgICAgICAgICAgIGRhdGV0aW1lLnN0YXJ0KHN0YXJ0cyksXG4gICAgICAgICAgICBkYXRldGltZS5zdGFydChlbmRzKSxcbiAgICAgICAgICAgIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZXG4gICAgICAgICksXG4gICAgICAgIG93bkV2ZW50cyA9IHRoaXMuZXZlbnRzLml0ZW1zLFxuICAgICAgICBvd25NYXRyaXggPSB0aGlzLmRhdGVNYXRyaXgsXG4gICAgICAgIGRmb3JtYXQgPSBkYXRldGltZS5mb3JtYXQsXG4gICAgICAgIHJlc3VsdCA9IHt9LFxuICAgICAgICBtYXRyaXgsXG4gICAgICAgIHltZCxcbiAgICAgICAgdmlld01vZGVscztcblxuICAgIHV0aWwuZm9yRWFjaEFycmF5KHJhbmdlLCBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHltZCA9IGRmb3JtYXQoZGF0ZSwgJ1lZWVlNTUREJyk7XG4gICAgICAgIG1hdHJpeCA9IG93bk1hdHJpeFt5bWRdO1xuICAgICAgICB2aWV3TW9kZWxzID0gcmVzdWx0W3ltZF0gPSBjb21tb24uY3JlYXRlRXZlbnRDb2xsZWN0aW9uKCk7XG5cbiAgICAgICAgaWYgKG1hdHJpeCAmJiBtYXRyaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICB2aWV3TW9kZWxzLmFkZC5hcHBseSh2aWV3TW9kZWxzLCB1dGlsLm1hcChtYXRyaXgsIGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENhbEV2ZW50Vmlld01vZGVsLmNyZWF0ZShvd25FdmVudHNbaWRdKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIG1peGluXG51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihCYXNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29udHJvbGxlciBtaXhpbiBtb2R1bGVzIGZvciBkYXkgdmlld3MuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC50dWkudXRpbDtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2NvbGxlY3Rpb24nKTtcbnZhciBkYXRldGltZSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kYXRldGltZScpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9jb21tb24nKTtcbnZhciBhcnJheSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9hcnJheScpO1xudmFyIENhbEV2ZW50Vmlld01vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvdmlld01vZGVsL2NhbEV2ZW50Jyk7XG52YXIgYXBzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vKipcbiAqIEBtaXhpbiBCYXNlLldlZWtcbiAqL1xudmFyIFdlZWsgPSB7XG4gICAgLyoqKioqKioqKipcbiAgICAgKiBDT01NT05cbiAgICAgKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBjb2xsaXNpb24gZ3JvdXAuXG4gICAgICogQHRoaXMgQmFzZS5XZWVrXG4gICAgICogQHBhcmFtIHthcnJheX0gdmlld01vZGVscyBMaXN0IG9mIHZpZXdtb2RlbHMuXG4gICAgICogQHJldHVybnMge2FycmF5fSBDb2xsaXNpb24gR3JvdXAuXG4gICAgICovXG4gICAgZ2V0Q29sbGlzaW9uR3JvdXA6IGZ1bmN0aW9uKHZpZXdNb2RlbHMpIHtcbiAgICAgICAgdmFyIGNvbGxpc2lvbkdyb3VwcyA9IFtdLFxuICAgICAgICAgICAgZm91bmRQcmV2Q29sbGlzaW9uRXZlbnQgPSBmYWxzZSxcbiAgICAgICAgICAgIHByZXZpb3VzRXZlbnRMaXN0O1xuXG4gICAgICAgIGlmICghdmlld01vZGVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsaXNpb25Hcm91cHM7XG4gICAgICAgIH1cblxuICAgICAgICBjb2xsaXNpb25Hcm91cHNbMF0gPSBbdXRpbC5zdGFtcCh2aWV3TW9kZWxzWzBdLnZhbHVlT2YoKSldO1xuICAgICAgICB1dGlsLmZvckVhY2hBcnJheSh2aWV3TW9kZWxzLnNsaWNlKDEpLCBmdW5jdGlvbihldmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGZvdW5kUHJldkNvbGxpc2lvbkV2ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBwcmV2aW91c0V2ZW50TGlzdCA9IGFwcy5hcHBseSh2aWV3TW9kZWxzLCBbMCwgaW5kZXggKyAxXSkucmV2ZXJzZSgpO1xuXG4gICAgICAgICAgICB1dGlsLmZvckVhY2hBcnJheShwcmV2aW91c0V2ZW50TGlzdCwgZnVuY3Rpb24ocHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY29sbGlkZXNXaXRoKHByZXZpb3VzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyDsnbTsoIQg7J287KCV65Ok6rO8IOqyuey5mOuKlCDqsr3smrAg6rK57LmY64qUIOydvOygleydmCBDb2xsaXNpb24gR3JvdXDsnYRcbiAgICAgICAgICAgICAgICAgICAgLy8g7LC+7JWEIOydtCDsnbzsoJXsnYQg7LaU6rCA7ZWc64ukXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kUHJldkNvbGxpc2lvbkV2ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB1dGlsLmZvckVhY2hBcnJheShjb2xsaXNpb25Hcm91cHMuc2xpY2UoMCkucmV2ZXJzZSgpLCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKH51dGlsLmluQXJyYXkodXRpbC5zdGFtcChwcmV2aW91cy52YWx1ZU9mKCkpLCBncm91cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDqsrnsuZjripQg7J207KCEIOydvOygleydhCDssL7snYAg6rK97JqwIOq3uCDsnbzsoJXsnbQg7IaN7ZWcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGlzaW9uIEdyb3Vw7JeQIOydtCDsnbzsoJXsnYQg7Y+s7ZWo7Iuc7YKo64ukLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwLnB1c2godXRpbC5zdGFtcChldmVudC52YWx1ZU9mKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFmb3VuZFByZXZDb2xsaXNpb25FdmVudCkge1xuICAgICAgICAgICAgICAgIC8vIOydtCDsnbzsoJXsnYAg7J207KCE7J287KCV6rO8IOqyuey5mOyngCDslYrripQg7J287KCV7J2066+A66GcXG4gICAgICAgICAgICAgICAgLy8g7IOIIENvbGxpc2lvbiBHcm91cOydhCDqtazshLHtlZzri6QuXG4gICAgICAgICAgICAgICAgY29sbGlzaW9uR3JvdXBzLnB1c2goW3V0aWwuc3RhbXAoZXZlbnQudmFsdWVPZigpKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY29sbGlzaW9uR3JvdXBzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcm93IGxlbmd0aCBieSBjb2x1bW4gaW5kZXggaW4gMmQgbWF0cml4LlxuICAgICAqIEB0aGlzIEJhc2UuV2Vla1xuICAgICAqIEBwYXJhbSB7YXJyYXlbXX0gYXJyMmQgTWF0cml4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbCBDb2x1bW4gaW5kZXguXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBMYXN0IHJvdyBudW1iZXIgaW4gY29sdW1uLlxuICAgICAqL1xuICAgIGdldExhc3RSb3dJbkNvbHVtbjogZnVuY3Rpb24oYXJyMmQsIGNvbCkge1xuICAgICAgICB2YXIgcm93ID0gYXJyMmQubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChyb3cgPiAwKSB7XG4gICAgICAgICAgICByb3cgLT0gMTtcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZChhcnIyZFtyb3ddW2NvbF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIG1hdHJpeCBmb3IgYXBwb2ludG1lbnQgYmxvY2sgZWxlbWVudCBwbGFjaW5nLlxuICAgICAqIEB0aGlzIEJhc2UuV2Vla1xuICAgICAqIEBwYXJhbSB7Q29sbGVjdGlvbn0gY29sbGVjdGlvbiBtb2RlbCBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7YXJyYXlbXX0gY29sbGlzaW9uR3JvdXBzIENvbGxpc2lvbiBncm91cHMgZm9yIGV2ZW50IHNldC5cbiAgICAgKiBAcmV0dXJucyB7YXJyYXl9IG1hdHJpY2VzXG4gICAgICovXG4gICAgZ2V0TWF0cmljZXM6IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGNvbGxpc2lvbkdyb3Vwcykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICBnZXRMYXN0Um93SW5Db2x1bW4gPSBXZWVrLmdldExhc3RSb3dJbkNvbHVtbjtcblxuICAgICAgICB1dGlsLmZvckVhY2hBcnJheShjb2xsaXNpb25Hcm91cHMsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgbWF0cml4ID0gW1tdXTtcblxuICAgICAgICAgICAgdXRpbC5mb3JFYWNoQXJyYXkoZ3JvdXAsIGZ1bmN0aW9uKGV2ZW50SUQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBjb2xsZWN0aW9uLml0ZW1zW2V2ZW50SURdLFxuICAgICAgICAgICAgICAgICAgICBjb2wgPSAwLFxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBuZXh0Um93LFxuICAgICAgICAgICAgICAgICAgICBsYXN0Um93SW5Db2x1bW47XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RSb3dJbkNvbHVtbiA9IGdldExhc3RSb3dJbkNvbHVtbihtYXRyaXgsIGNvbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RSb3dJbkNvbHVtbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeFswXS5wdXNoKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghZXZlbnQuY29sbGlkZXNXaXRoKG1hdHJpeFtsYXN0Um93SW5Db2x1bW5dW2NvbF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Um93ID0gbGFzdFJvd0luQ29sdW1uICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKG1hdHJpeFtuZXh0Um93XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXhbbmV4dFJvd10gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeFtuZXh0Um93XVtjb2xdID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb2wgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobWF0cml4KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiBUSU1FIEdSSUQgVklFV1xuICAgICAqKioqKioqKioqL1xuXG4gICAgLyoqXG4gICAgICogTWFrZSBhcnJheSB3aXRoIHN0YXJ0IGFuZCBlbmQgdGltZXMgb24gZXZlbnRzLlxuICAgICAqIEB0aGlzIEJhc2UuV2Vla1xuICAgICAqIEBwYXJhbSB7YXJyYXlbXX0gbWF0cml4IC0gbWF0cml4IGZyb20gY29udHJvbGxlci5cbiAgICAgKiBAcmV0dXJucyB7YXJyYXlbXX0gc3RhcnR0aW1lLCBlbmR0aW1lIGFycmF5IChleGNsdWRlIGZpcnN0IHJvdydzIGV2ZW50cylcbiAgICAgKi9cbiAgICBnZW5lcmF0ZVRpbWVBcnJheUluUm93OiBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICAgICAgdmFyIHJvdyxcbiAgICAgICAgICAgIGNvbCxcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgbWFwID0gW10sXG4gICAgICAgICAgICBjdXJzb3IgPSBbXSxcbiAgICAgICAgICAgIG1heENvbExlbiA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHV0aWwubWFwKG1hdHJpeCwgZnVuY3Rpb24oY29sKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbC5sZW5ndGg7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgZm9yIChjb2wgPSAxOyBjb2wgPCBtYXhDb2xMZW47IGNvbCArPSAxKSB7XG4gICAgICAgICAgICByb3cgPSAwO1xuICAgICAgICAgICAgZXZlbnQgPSB1dGlsLnBpY2sobWF0cml4LCByb3csIGNvbCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChldmVudCkge1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoKFtldmVudC5nZXRTdGFydHMoKS5nZXRUaW1lKCksIGV2ZW50LmdldEVuZHMoKS5nZXRUaW1lKCldKTtcblxuICAgICAgICAgICAgICAgIHJvdyArPSAxO1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gdXRpbC5waWNrKG1hdHJpeCwgcm93LCBjb2wpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXAucHVzaChjdXJzb3IpO1xuICAgICAgICAgICAgY3Vyc29yID0gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29sbGlzaW9uIGluZm9ybWF0aW9uIGZyb20gbGlzdFxuICAgICAqIEB0aGlzIEJhc2UuV2Vla1xuICAgICAqIEBwYXJhbSB7YXJyYXkuPG51bWJlcltdPn0gYXJyIC0gbGlzdCB0byBkZXRlY3RpbmcgY29sbGlzaW9uLiBbW3N0YXJ0LCBlbmRdLCBbc3RhcnQsIGVuZF1dXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gZXZlbnQgc3RhcnQgdGltZSB0aGF0IHdhbnQgdG8gZGV0ZWN0IGNvbGxpc2lvbnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCAtIGV2ZW50IGVuZCB0aW1lIHRoYXQgd2FudCB0byBkZXRlY3QgY29sbGlzaW9ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdGFyZ2V0IGhhcyBjb2xsaWRlIGluIHN1cHBsaWVkIGFycmF5P1xuICAgICAqL1xuICAgIGhhc0NvbGxpZGU6IGZ1bmN0aW9uKGFyciwgc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgc3RhcnRTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0RW5kLFxuICAgICAgICAgICAgZW5kU3RhcnQsXG4gICAgICAgICAgICBlbmRFbmQsXG4gICAgICAgICAgICBnZXRGdW5jID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrW2luZGV4XTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFicyA9IE1hdGguYWJzLFxuICAgICAgICAgICAgY29tcGFyZSA9IGFycmF5LmNvbXBhcmUubnVtLmFzYyxcbiAgICAgICAgICAgIGhhc0NvbGxpZGU7XG5cbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydFN0YXJ0ID0gYWJzKGFycmF5LmJzZWFyY2goYXJyLCBzdGFydCwgZ2V0RnVuYygwKSwgY29tcGFyZSkpO1xuICAgICAgICBzdGFydEVuZCA9IGFicyhhcnJheS5ic2VhcmNoKGFyciwgc3RhcnQsIGdldEZ1bmMoMSksIGNvbXBhcmUpKTtcbiAgICAgICAgZW5kU3RhcnQgPSBhYnMoYXJyYXkuYnNlYXJjaChhcnIsIGVuZCwgZ2V0RnVuYygwKSwgY29tcGFyZSkpO1xuICAgICAgICBlbmRFbmQgPSBhYnMoYXJyYXkuYnNlYXJjaChhcnIsIGVuZCwgZ2V0RnVuYygxKSwgY29tcGFyZSkpO1xuICAgICAgICBoYXNDb2xsaWRlID0gIShzdGFydFN0YXJ0ID09PSBzdGFydEVuZCAmJiBzdGFydEVuZCA9PT0gZW5kU3RhcnQgJiYgZW5kU3RhcnQgPT09IGVuZEVuZCk7XG5cbiAgICAgICAgcmV0dXJuIGhhc0NvbGxpZGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdmFsdWVzIHRvIHZpZXdtb2RlbHMgZm9yIGRldGVjdCByZWFsIGNvbGxpc2lvbiBhdCByZW5kZXJpbmcgcGhhc2UuXG4gICAgICogQHRoaXMgQmFzZS5XZWVrXG4gICAgICogQHBhcmFtIHthcnJheVtdfSBtYXRyaWNlcyAtIE1hdHJpeCBkYXRhLlxuICAgICAqL1xuICAgIGdldENvbGxpZGVzOiBmdW5jdGlvbihtYXRyaWNlcykge1xuICAgICAgICB1dGlsLmZvckVhY2hBcnJheShtYXRyaWNlcywgZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICAgICAgICB2YXIgYmluYXJ5TWFwLFxuICAgICAgICAgICAgICAgIG1heFJvd0xlbmd0aDtcblxuICAgICAgICAgICAgYmluYXJ5TWFwID0gV2Vlay5nZW5lcmF0ZVRpbWVBcnJheUluUm93KG1hdHJpeCk7XG4gICAgICAgICAgICBtYXhSb3dMZW5ndGggPSBNYXRoLm1heC5hcHBseShudWxsLCB1dGlsLm1hcChtYXRyaXgsIGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiByb3cubGVuZ3RoO1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICB1dGlsLmZvckVhY2hBcnJheShtYXRyaXgsIGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgICAgIHV0aWwuZm9yRWFjaEFycmF5KHJvdywgZnVuY3Rpb24odmlld01vZGVsLCBjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDb2xsaWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZpZXdNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gdmlld01vZGVsLmdldFN0YXJ0cygpLmdldFRpbWUoKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGVuZFRpbWUgPSB2aWV3TW9kZWwuZ2V0RW5kcygpLmdldFRpbWUoKSAtIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gKGNvbCArIDEpOyBpIDwgbWF4Um93TGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NvbGxpZGUgPSBXZWVrLmhhc0NvbGxpZGUoYmluYXJ5TWFwW2kgLSAxXSwgc3RhcnRUaW1lLCBlbmRUaW1lKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0NvbGxpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZWwuaGFzQ29sbGlkZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdNb2RlbC5leHRyYVNwYWNlICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHRoaXMgQmFzZVxuICAgICAqIEBwYXJhbSB7RGF0ZX0gc3RhcnRzIC0gc3RhcnQgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0RhdGV9IGVuZHMgLSBlbmQgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0NvbGxlY3Rpb259IHRpbWUgLSB2aWV3IG1vZGVsIGNvbGxlY3Rpb24uXG4gICAgICogQHJldHVybnMge29iamVjdH0gdmlldyBtb2RlbCBmb3IgdGltZSBwYXJ0LlxuICAgICAqL1xuICAgIGdldFZpZXdNb2RlbEZvclRpbWVWaWV3OiBmdW5jdGlvbihzdGFydHMsIGVuZHMsIHRpbWUpIHtcbiAgICAgICAgdmFyIHltZFNwbGl0dGVkID0gdGhpcy5zcGxpdEV2ZW50QnlEYXRlUmFuZ2Uoc3RhcnRzLCBlbmRzLCB0aW1lKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIHV0aWwuZm9yRWFjaCh5bWRTcGxpdHRlZCwgZnVuY3Rpb24oY29sbGVjdGlvbiwgeW1kKSB7XG4gICAgICAgICAgICB2YXIgdmlld01vZGVscyA9IGNvbGxlY3Rpb24uc29ydChhcnJheS5jb21wYXJlLmV2ZW50LmFzYyksXG4gICAgICAgICAgICAgICAgY29sbGlzaW9uR3JvdXBzLFxuICAgICAgICAgICAgICAgIG1hdHJpY2VzO1xuXG4gICAgICAgICAgICBjb2xsaXNpb25Hcm91cHMgPSB0aGlzLmdldENvbGxpc2lvbkdyb3VwKHZpZXdNb2RlbHMpO1xuICAgICAgICAgICAgbWF0cmljZXMgPSB0aGlzLmdldE1hdHJpY2VzKGNvbGxlY3Rpb24sIGNvbGxpc2lvbkdyb3Vwcyk7XG4gICAgICAgICAgICB0aGlzLmdldENvbGxpZGVzKG1hdHJpY2VzKTtcblxuICAgICAgICAgICAgcmVzdWx0W3ltZF0gPSBtYXRyaWNlcztcbiAgICAgICAgfSwgV2Vlayk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiBBTExEQVkgVklFV1xuICAgICAqKioqKioqKioqL1xuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIHZpZXcgbW9kZWwgZm9yIGFsbGRheSB2aWV3IHBhcnQuXG4gICAgICogQHBhcmFtIHtEYXRlfSBzdGFydHMgc3RhcnQgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0RhdGV9IGVuZHMgZW5kIGRhdGUuXG4gICAgICogQHBhcmFtIHtDb2xsZWN0aW9ufSB2aWV3TW9kZWxzIC0gYWxsZGF5IGV2ZW50IHZpZXdNb2RlbCB2aWV3TW9kZWxzLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGFsbGRheSB2aWV3TW9kZWwuXG4gICAgICovXG4gICAgZ2V0Vmlld01vZGVsRm9yQWxsZGF5VmlldzogZnVuY3Rpb24oc3RhcnRzLCBlbmRzLCB2aWV3TW9kZWxzKSB7XG4gICAgICAgIHZhciBsaXN0LFxuICAgICAgICAgICAgeW1kc1RvUmVuZGVyLFxuICAgICAgICAgICAgY29sbGlzaW9uR3JvdXBzLFxuICAgICAgICAgICAgbWF0cmljZXM7XG5cbiAgICAgICAgaWYgKCF2aWV3TW9kZWxzIHx8ICF2aWV3TW9kZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgeW1kc1RvUmVuZGVyID0gdXRpbC5tYXAoXG4gICAgICAgICAgICBkYXRldGltZS5yYW5nZShzdGFydHMsIGVuZHMsIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZXRpbWUuZm9ybWF0KGRhdGUsICdZWVlZTU1ERCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGxpc3QgPSB2aWV3TW9kZWxzLnNvcnQoYXJyYXkuY29tcGFyZS5ldmVudC5hc2MpO1xuICAgICAgICBjb2xsaXNpb25Hcm91cHMgPSBXZWVrLmdldENvbGxpc2lvbkdyb3VwKGxpc3QpO1xuICAgICAgICBtYXRyaWNlcyA9IFdlZWsuZ2V0TWF0cmljZXModmlld01vZGVscywgY29sbGlzaW9uR3JvdXBzKTtcblxuICAgICAgICB1dGlsLmZvckVhY2hBcnJheShtYXRyaWNlcywgZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICAgICAgICB1dGlsLmZvckVhY2hBcnJheShtYXRyaXgsIGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHV0aWwuZm9yRWFjaEFycmF5KGNvbHVtbiwgZnVuY3Rpb24odmlld01vZGVsLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeW1kLCBkYXRlTGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmlld01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB5bWQgPSBkYXRldGltZS5mb3JtYXQodmlld01vZGVsLmdldFN0YXJ0cygpLCAnWVlZWU1NREQnKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUxlbmd0aCA9IGRhdGV0aW1lLnJhbmdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld01vZGVsLmdldFN0YXJ0cygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld01vZGVsLmdldEVuZHMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZXG4gICAgICAgICAgICAgICAgICAgICkubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIHZpZXdNb2RlbC50b3AgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdmlld01vZGVsLmxlZnQgPSB1dGlsLmluQXJyYXkoeW1kLCB5bWRzVG9SZW5kZXIpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZWwud2lkdGggPSBkYXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtYXRyaWNlcztcbiAgICB9LFxuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiBSRUFEXG4gICAgICoqKioqKioqKiovXG5cbiAgICAvKipcbiAgICAgKiBQb3B1bGF0ZSBldmVudHMgaW4gZGF0ZSByYW5nZS5cbiAgICAgKiBAdGhpcyBCYXNlXG4gICAgICogQHBhcmFtIHtEYXRlfSBzdGFydHMgc3RhcnQgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0RhdGV9IGVuZHMgZW5kIGRhdGUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFthbmRGaWx0ZXJdIC0gYWRkaXRpb25hbCBmaWx0ZXIgdG8gQU5EIGNsYXVzZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGV2ZW50cyBncm91cGVkIGJ5IGRhdGVzLlxuICAgICAqL1xuICAgIGZpbmRCeURhdGVSYW5nZTogZnVuY3Rpb24oc3RhcnRzLCBlbmRzLCBhbmRGaWx0ZXIpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgZXZlbnRzLFxuICAgICAgICAgICAgdmlld01vZGVscyxcbiAgICAgICAgICAgIGZpbHRlcjtcblxuICAgICAgICBmaWx0ZXIgPSBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAgICAgdmFyIG93blN0YXJ0cyA9IG1vZGVsLmdldFN0YXJ0cygpLFxuICAgICAgICAgICAgICAgIG93bkVuZHMgPSBtb2RlbC5nZXRFbmRzKCk7XG5cbiAgICAgICAgICAgIHJldHVybiAob3duU3RhcnRzID49IHN0YXJ0cyAmJiBvd25FbmRzIDw9IGVuZHMpIHx8XG4gICAgICAgICAgICAgICAgKG93blN0YXJ0cyA8IHN0YXJ0cyAmJiBvd25FbmRzID49IHN0YXJ0cykgfHxcbiAgICAgICAgICAgICAgICAob3duRW5kcyA+IGVuZHMgJiYgb3duU3RhcnRzIDw9IGVuZHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChhbmRGaWx0ZXIpIHtcbiAgICAgICAgICAgIGZpbHRlciA9IENvbGxlY3Rpb24uYW5kLmFwcGx5KG51bGwsIFtmaWx0ZXJdLmNvbmNhdChhbmRGaWx0ZXIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFFVRVJZIEVWRU5UU1xuICAgICAgICBldmVudHMgPSB0aGlzLmV2ZW50cy5maW5kKGZpbHRlcik7XG5cbiAgICAgICAgLy8gQ09OVkVSVCBUTyBWSUVXTU9ERUxcbiAgICAgICAgdmlld01vZGVscyA9IGNvbW1vbi5jcmVhdGVFdmVudENvbGxlY3Rpb24uYXBwbHkoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdXRpbC5tYXAoZXZlbnRzLml0ZW1zLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDYWxFdmVudFZpZXdNb2RlbC5jcmVhdGUoZXZlbnQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKS5ncm91cEJ5KFsnYWxsZGF5JywgJ3RpbWUnXSwgdGhpcy5ncm91cEZ1bmMpO1xuXG4gICAgICAgIC8vIENVU1RPTUlaRSBWSUVXTU9ERUwgRk9SIEVBQ0ggVklFV1xuICAgICAgICB1dGlsLmZvckVhY2godmlld01vZGVscywgZnVuY3Rpb24oY29sbCwga2V5LCBvYmopIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdhbGxkYXknKSB7XG4gICAgICAgICAgICAgICAgY29sbC5lYWNoKGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3duU3RhcnRzID0gdmlld01vZGVsLmdldFN0YXJ0cygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3duRW5kcyA9IHZpZXdNb2RlbC5nZXRFbmRzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG93blN0YXJ0cyA8IHN0YXJ0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlld01vZGVsLnJlbmRlclN0YXJ0cyA9IG5ldyBEYXRlKHN0YXJ0cy5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG93bkVuZHMgPiBlbmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZWwucmVuZGVyRW5kcyA9IG5ldyBEYXRlKGVuZHMuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgb2JqLmFsbGRheSA9IHV0aWwuYmluZChXZWVrLmdldFZpZXdNb2RlbEZvckFsbGRheVZpZXcsIHRoYXQpKHN0YXJ0cywgZW5kcywgY29sbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgICAgICAgICAgb2JqLnRpbWUgPSB1dGlsLmJpbmQoV2Vlay5nZXRWaWV3TW9kZWxGb3JUaW1lVmlldywgdGhhdCkoc3RhcnRzLCBlbmRzLCBjb2xsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZpZXdNb2RlbHM7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWVrO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQmFzZSBjb250cm9sbGVyIGZvciBEb29yYXkgc2VydmljZSBwcm9qZWN0LlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwudHVpLnV0aWw7XG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uLy4uL2NvbnRyb2xsZXIvYmFzZScpO1xudmFyIERvb3JheUV2ZW50ID0gcmVxdWlyZSgnLi4vbW9kZWwvY2FsRXZlbnQnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgYmFzZSBjb250cm9sbGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ncm91cEZ1bmNdIC0gZnVuY3Rpb24gZm9yIGdyb3VwIGVhY2ggbW9kZWxzIHtAc2VlIENvbGxlY3Rpb24jZ3JvdXBCeX1cbiAqIEBleHRlbmRzIHtCYXNlfVxuICovXG5mdW5jdGlvbiBEb29yYXlCYXNlKG9wdGlvbnMpIHtcbiAgICBCYXNlLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cbnV0aWwuaW5oZXJpdChEb29yYXlCYXNlLCBCYXNlKTtcblxuLyoqKioqKioqKipcbiAqIENSVUQgb3ZlcnJpZGVcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIENyZWF0ZSBhbiBldmVudCBpbnN0YW5jZSBmcm9tIHJhdyBkYXRhLlxuICogQG92ZXJyaWRlXG4gKiBAZW1pdHMgQmFzZSNiZWZvcmVDcmVhdGVFdmVudFxuICogQGVtaXRzIEJhc2UjY3JlYXRlZEV2ZW50XG4gKiBAcGFyYW0ge1NlcnZpY2VDYWxlbmRhcn5DYWxFdmVudH0gZGF0YSAtIERhdGEgb2JqZWN0IHRvIGNyZWF0ZSBldmVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IC0gc2V0IHRydWUgdGhlbiBkb24ndCBmaXJlIGV2ZW50cy5cbiAqIEByZXR1cm5zIHtEb29yYXlFdmVudH0gVGhlIGluc3RhbmNlIG9mIENhbEV2ZW50IHRoYXQgY3JlYXRlZC5cbiAqL1xuRG9vcmF5QmFzZS5wcm90b3R5cGUuY3JlYXRlRXZlbnQgPSBmdW5jdGlvbihkYXRhLCBzaWxlbnQpIHtcbiAgICB2YXIgaW5zdCxcbiAgICAgICAgZXZlbnREYXRhID0ge1xuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IEJhc2UjYmVmb3JlQ3JlYXRlRXZlbnRcbiAgICAgKiBAdHlwZSB7U2VydmljZUNhbGVuZGFyfkV2ZW50c1tdfVxuICAgICAqL1xuICAgIGlmICghdGhpcy5pbnZva2UoJ2JlZm9yZUNyZWF0ZUV2ZW50JywgZXZlbnREYXRhKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5zdCA9IHRoaXMuYWRkRXZlbnQoRG9vcmF5RXZlbnQuY3JlYXRlKGRhdGEpKTtcblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXZlbnQgQmFzZSNjcmVhdGVkRXZlbnRcbiAgICAgICAgICogQHR5cGUge0Rvb3JheUV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maXJlKCdjcmVhdGVkRXZlbnQnLCBpbnN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdDtcbn07XG5cbi8qKlxuICogVXBkYXRlIGFuIGV2ZW50LlxuICogQGVtaXRzIERvb3JheUJhc2UjdXBkYXRlRXZlbnRcbiAqIEBwYXJhbSB7Q2FsRXZlbnR9IGNhbEV2ZW50IC0gZXZlbnQgaW5zdGFuY2UgdG8gdXBkYXRlIFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgdXBkYXRlZCBvYmplY3QgZGF0YVxuICogQHJldHVybnMge0NhbEV2ZW50fGJvb2xlYW59IHVwZGF0ZWQgZXZlbnQgaW5zdGFuY2UsIHdoZW4gaXQgZmFpbCB0aGVuIHJldHVybiBmYWxzZVxuICovXG5Eb29yYXlCYXNlLnByb3RvdHlwZS51cGRhdGVFdmVudCA9IGZ1bmN0aW9uKGNhbEV2ZW50LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMudGl0bGUpIHtcbiAgICAgICAgY2FsRXZlbnQuc2V0KCd0aXRsZScsIG9wdGlvbnMudGl0bGUpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmlzQWxsRGF5KSB7XG4gICAgICAgIGNhbEV2ZW50LnNldCgnaXNBbGxEYXknLCBvcHRpb25zLmlzQWxsRGF5KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydHMpIHtcbiAgICAgICAgY2FsRXZlbnQuc2V0KCdzdGFydHMnLCBuZXcgRGF0ZShvcHRpb25zLnN0YXJ0cykpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmVuZHMpIHtcbiAgICAgICAgY2FsRXZlbnQuc2V0KCdlbmRzJywgbmV3IERhdGUob3B0aW9ucy5lbmRzKSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY29sb3IpIHtcbiAgICAgICAgY2FsRXZlbnQuc2V0KCdjb2xvcicsIG9wdGlvbnMuY29sb3IpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmJnQ29sb3IpIHtcbiAgICAgICAgY2FsRXZlbnQuc2V0KCdiZ0NvbG9yJywgb3B0aW9ucy5iZ0NvbG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZW1vdmVGcm9tTWF0cml4KGNhbEV2ZW50KTtcbiAgICB0aGlzLl9hZGRUb01hdHJpeChjYWxFdmVudCk7XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgRG9vcmF5QmFzZSN1cGRhdGVFdmVudFxuICAgICAqL1xuICAgIHRoaXMuZmlyZSgndXBkYXRlRXZlbnQnKTtcblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBEZWxldGUgZXZlbnQgaW5zdGFuY2UgZnJvbSBjb250cm9sbGVyXG4gKiBAcGFyYW0ge0NhbEV2ZW50fSBjYWxFdmVudCAtIGV2ZW50IGluc3RhbmNlIHRvIGRlbGV0ZVxuICogQHJldHVybnMge0NhbEV2ZW50fSBkZWxldGVkIG1vZGVsIGluc3RhbmNlXG4gKi9cbkRvb3JheUJhc2UucHJvdG90eXBlLmRlbGV0ZUV2ZW50ID0gZnVuY3Rpb24oY2FsRXZlbnQpIHtcbiAgICB0aGlzLl9yZW1vdmVGcm9tTWF0cml4KGNhbEV2ZW50KTtcbiAgICB0aGlzLmV2ZW50cy5yZW1vdmUoY2FsRXZlbnQpO1xuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRG9vcmF5QmFzZTtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENhbGVuZGFyIGZvciBzZXJ2aWNlLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwudHVpLnV0aWw7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vY29uZmlnJyk7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBDYWxlbmRhciA9IHJlcXVpcmUoJy4uLy4uL2ZhY3RvcnkvY2FsZW5kYXInKTtcbnZhciBEb29yYXlCYXNlID0gcmVxdWlyZSgnLi4vY29udHJvbGxlci9iYXNlJyk7XG52YXIgV2VlayA9IHJlcXVpcmUoJy4uLy4uL2NvbnRyb2xsZXIvdmlld01peGluL3dlZWsnKTtcbnZhciBzZXJ2aWNlV2Vla1ZpZXdGYWN0b3J5ID0gcmVxdWlyZSgnLi93ZWVrVmlldycpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFNlcnZpY2VDYWxlbmRhcn5Eb29yYXlFdmVudFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZF0gLSDsnbzsoJXsnZggdW5pcXVlSUQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NhbGVuZGFySURdIC0g6rCBIOydvOygleydhCDsupjrprDrjZTrs4TroZwg6re466O57KeA7J2EIOyImCDsnojripQg6rCSLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRpdGxlIC0g7J2067Kk7Yq4IOygnOuqqVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNhdGVnb3J5IC0g7J2067Kk7Yq4IO2DgOyehVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGR1ZURhdGVDbGFzcyAtIOyXheustCDsnbzsoJUg67aE66WYIChjYXRlZ29yeeqwgCAndGFzayfsnbwg65WMIOycoO2aqClcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGFydHMgLSDsnbzsoJUg7Iuc7J6RIOyLnOqwhFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGVuZHMgLSDsnbzsoJUg7KKF66OMIOyLnOqwhFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb2xvcl0gLSDsnbzsoJUg7YWN7Iqk7Yq47IOJXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2JnQ29sb3JdIC0g7J287KCVIOuwsOqyveyDiVxuICovXG5cbi8qKlxuICogQ2FsZW5kYXIgZmFjdG9yIG1vZHVsZSBmb3Igc2VydmljZSAoZG9vcmF5KVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7Q2FsZW5kYXJ9XG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIGNhbGVuZGFyXG4gKiAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNzc1ByZWZpeF0gLSBDU1MgY2xhc3NuYW1lIHByZWZpeFxuICogIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmdyb3VwRnVuY10gLSBmdW5jdGlvbiBmb3IgZ3JvdXAgZXZlbnQgbW9kZWxzIHtAc2VlIENvbGxlY3Rpb24jZ3JvdXBCeX1cbiAqICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5jb250cm9sbGVyXSAtIGNvbnRyb2xsZXIgaW5zdGFuY2VcbiAqICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGVmYXVsdFZpZXc9J3dlZWsnXSAtIGRlZmF1bHQgdmlldyBvZiBjYWxlbmRhclxuICogIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5jYWxlbmRhckNvbG9yXSAtIHtAc2VlIFNlcnZpY2VDYWxlbmRhcn5Eb29yYXlFdmVudH0g7J2YIGNhbGVuZGFySUTrs4TroZwg7Iqk7YOA7J287J2EIOuvuOumrCDsp4DsoJUg6rCA64qlXG4gKiAgQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLndlZWtdIC0gb3B0aW9ucyBmb3Igd2VlayB2aWV3XG4gKiAgIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53ZWVrLnN0YXJ0RGF5T2ZXZWVrPTBdIC0gc3RhcnQgZGF5IG9mIHdlZWtcbiAqICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMud2Vlay5yZW5kZXJTdGFydERhdGUgLSBZWVlZLU1NLUREIHJlbmRlciBzdGFydCBkYXRlXG4gKiAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLndlZWsucmVuZGVyRW5kRGF0ZSAtIFlZWVktTU0tREQgcmVuZGVyIGVuZCBkYXRlXG4gKiAgQHBhcmFtIHtTZXJ2aWNlQ2FsZW5kYXJ+RG9vcmF5RXZlbnRbXX0gb3B0aW9ucy5ldmVudHMgLSDquLDrs7gg7J287KCVIOuqqeuhnVxuICogIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5tb250aF0gLSBvcHRpb25zIGZvciBtb250aCB2aWV3XG4gKiAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubW9udGgucmVuZGVyTW9udGggLSBZWVlZLU1NIHJlbmRlciBtb250aFxuICogQHBhcmFtIHtIVE1MRGl2RWxlbWVudH0gY29udGFpbmVyID0gY29udGFpbmVyIGVsZW1lbnQgZm9yIGNhbGVuZGFyXG4gKi9cbmZ1bmN0aW9uIFNlcnZpY2VDYWxlbmRhcihvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICB2YXIgY29udHJvbGxlcjtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTZXJ2aWNlQ2FsZW5kYXIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VydmljZUNhbGVuZGFyKG9wdGlvbnMsIGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog7ISc67mE7Iqk7JeQ7IScIOyCrOyaqeuQmOuKlCDrqqjrjbgg6rWs67aE7JqpIOyYteyFmCDtlajsiJhcbiAgICAgKiBAcGFyYW0ge0NhbEV2ZW50Vmlld01vZGVsfSB2aWV3TW9kZWwgLSBEb29yYXlFdmVudOulvCDrnpjtlZHtlZwg67ewIOuqqOuNuFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IOq1rOu2hCDtgqQg6rCSXG4gICAgICovXG4gICAgb3B0aW9ucy5ncm91cEZ1bmMgPSBmdW5jdGlvbih2aWV3TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHZpZXdNb2RlbC5tb2RlbC5jYXRlZ29yeTtcbiAgICB9O1xuXG4gICAgLy8g7Luo7Yq466Gk65+sIOunjOuTpOq4sFxuICAgIGNvbnRyb2xsZXIgPSBvcHRpb25zLmNvbnRyb2xsZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb250cm9sbGVyID0gbmV3IERvb3JheUJhc2Uob3B0aW9ucyksXG4gICAgICAgICAgICBvcmlnaW5GaW5kQnlEYXRlUmFuZ2U7XG5cbiAgICAgICAgLy8g7KO867ewIOy7qO2KuOuhpOufrCDrr7nsiqTsnbhcbiAgICAgICAgY29udHJvbGxlci5XZWVrID0ge307XG4gICAgICAgIHV0aWwuZm9yRWFjaChXZWVrLCBmdW5jdGlvbihtZXRob2QsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuV2Vla1ttZXRob2ROYW1lXSA9IHV0aWwuYmluZChtZXRob2QsIGNvbnRyb2xsZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyDsnbzsoJUg7KGw7ZqMIEFQSeyXkCDquLDsobQg7LqY66aw642U7JeQIOyXhuyXiOuNmCBtaWxzdG9uZSwgdGFza+ulvCDsp4Dsm5DtlZjrj4TroZ1cbiAgICAgICAgLy8g7ZWY6riwIOychO2VtCDrqZTshJzrk5zrpbwg7Jik67KE65287J2065Sp7ZWc64ukLlxuICAgICAgICBvcmlnaW5GaW5kQnlEYXRlUmFuZ2UgPSBjb250cm9sbGVyLldlZWsuZmluZEJ5RGF0ZVJhbmdlO1xuXG4gICAgICAgIC8vIHZpc2libGXsnbQgdHJ1ZeyduCDsnbzsoJXrp4wg7ZWE7YSw66eBIO2VmOq4sCDsnITtlZwg7ZWE7YSwIO2VqOyImFxuICAgICAgICBmdW5jdGlvbiBmaWx0ZXJNb2RlbElzVmlzaWJsZShtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuICEhbW9kZWwudmlzaWJsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRyb2xsZXIuV2Vlay5maW5kQnlEYXRlUmFuZ2UgPSBmdW5jdGlvbihzdGFydHMsIGVuZHMpIHtcbiAgICAgICAgICAgIHZhciBkYXRlUmFuZ2UgPSB1dGlsLm1hcChkYXRldGltZS5yYW5nZShcbiAgICAgICAgICAgICAgICAgICAgZGF0ZXRpbWUuc3RhcnQoc3RhcnRzKSxcbiAgICAgICAgICAgICAgICAgICAgZGF0ZXRpbWUuZW5kKGVuZHMpLFxuICAgICAgICAgICAgICAgICAgICBkYXRldGltZS5NSUxMSVNFQ09ORFNfUEVSX0RBWVxuICAgICAgICAgICAgICAgICksIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGV0aW1lLmZvcm1hdChkLCAnWVlZWS1NTS1ERCcpOyB9KSxcbiAgICAgICAgICAgICAgICB2aWV3TW9kZWwgPSBvcmlnaW5GaW5kQnlEYXRlUmFuZ2Uoc3RhcnRzLCBlbmRzLCBbZmlsdGVyTW9kZWxJc1Zpc2libGVdKTtcblxuICAgICAgICAgICAgdXRpbC5mb3JFYWNoKHZpZXdNb2RlbCwgZnVuY3Rpb24oY29sbCwga2V5LCBvYmopIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBlZEJ5WU1EO1xuXG4gICAgICAgICAgICAgICAgLy8g66eI7J287Iqk7YakLCDsl4XrrLQg67ewIOu3sOuqqOuNuCDqsIDqs7VcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAndGFzaycgfHwga2V5ID09PSAnbWlsZXN0b25lJykge1xuICAgICAgICAgICAgICAgICAgICBncm91cGVkQnlZTUQgPSBjb2xsLmdyb3VwQnkoZGF0ZVJhbmdlLCBmdW5jdGlvbih2aWV3TW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRldGltZS5mb3JtYXQodmlld01vZGVsLm1vZGVsLmVuZHMsICdZWVlZLU1NLUREJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICd0YXNrJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5mb3JFYWNoKGdyb3VwZWRCeVlNRCwgZnVuY3Rpb24oY29sbCwgeW1kLCBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpbeW1kXSA9IGNvbGwuZ3JvdXBCeShmdW5jdGlvbih2aWV3TW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdNb2RlbC5tb2RlbC5kdWVEYXRlQ2xhc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gZ3JvdXBlZEJ5WU1EO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdmlld01vZGVsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH0pKCk7XG5cbiAgICAvLyBGdWxsQ2FsZW5kYXIg6riw67O4IOuqqOuTiOydgCBjYXRlZ29yeSwgZHVlRGF0ZUNsYXNzIO2UjOuemOq3uOulvCDrqqjrpoQuIOuVjOusuOyXkFxuICAgIC8vIOydtOqzs+yXkOyEnCDsnbTrsqTtirgg7ZW465Ok65+s66W8IOuTseuhne2VtOyEnCDsnbzsoJUg7IOd7ISxIOyghOyXkCBpc0FsbERhee2UjOuemOq3uOulvCDrs7Tqs6BcbiAgICAvLyBjYXRlZ29yeeulvCDsiJjrj5nsnLzroZwg7KeA7KCV7ZW07KSA64ukXG4gICAgY29udHJvbGxlci5vbignYmVmb3JlQ3JlYXRlRXZlbnQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBkYXRhID0gZS5kYXRhO1xuXG4gICAgICAgIGlmICghZGF0YS5jYXRlZ29yeSkge1xuICAgICAgICAgICAgZGF0YS5jYXRlZ29yeSA9IGRhdGEuaXNBbGxEYXkgPyAnYWxsZGF5JyA6ICd0aW1lJztcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmNhbGVuZGFyQ29sb3IgPSBvcHRpb25zLmNhbGVuZGFyQ29sb3IgfHwge307XG5cbiAgICBDYWxlbmRhci5jYWxsKHRoaXMsIG9wdGlvbnMsIGNvbnRhaW5lcik7XG59XG5cbnV0aWwuaW5oZXJpdChTZXJ2aWNlQ2FsZW5kYXIsIENhbGVuZGFyKTtcblxuLyoqKioqKioqKipcbiAqIENSVUQgb3ZlcnJpZGVcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIENyZWF0ZSBldmVudHMgaW5zdGFuY2UgYW5kIHJlbmRlciBjYWxlbmRhci5cbiAqIEBwYXJhbSB7U2VydmljZUNhbGVuZGFyfkRvb3JheUV2ZW50W119IGRhdGFPYmplY3RMaXN0IC0gYXJyYXkgb2Yge0BzZWUgU2VydmljZUNhbGVuZGFyfkRvb3JheUV2ZW50W119IG9iamVjdFxuICogQHBhcmFtIHtib29sZWFufSBbc2lsZW50PWZhbHNlXSAtIG5vIGF1dG8gcmVuZGVyIGFmdGVyIGNyZWF0aW9uIHdoZW4gc2V0IHRydWVcbiAqL1xuU2VydmljZUNhbGVuZGFyLnByb3RvdHlwZS5jcmVhdGVFdmVudHMgPSBmdW5jdGlvbihkYXRhT2JqZWN0TGlzdCwgc2lsZW50KSB7XG4gICAgdmFyIGNhbENvbG9yID0gdGhpcy5jYWxlbmRhckNvbG9yO1xuXG4gICAgdXRpbC5mb3JFYWNoKGRhdGFPYmplY3RMaXN0LCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgdmFyIGNvbG9yID0gY2FsQ29sb3Jbb2JqLmNhbGVuZGFySURdO1xuXG4gICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgb2JqLmNvbG9yID0gY29sb3IuY29sb3I7XG4gICAgICAgICAgICBvYmouYmdDb2xvciA9IGNvbG9yLmJnQ29sb3I7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5jcmVhdGVFdmVudHMuY2FsbCh0aGlzLCBkYXRhT2JqZWN0TGlzdCwgc2lsZW50KTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBpZCBvZiBldmVudCBpbnN0YW5jZSBmcm9tIHNlcnZlciBBUElcbiAqIEByZXR1cm5zIHtEb29yYXlFdmVudH0gZm91bmRlZCBldmVudCBpbnN0YW5jZS5cbiAqL1xuU2VydmljZUNhbGVuZGFyLnByb3RvdHlwZS5nZXRFdmVudCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbGxlci5ldmVudHMuc2luZ2xlKGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBtb2RlbC5pZCA9PT0gaWQ7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gSUQgb2YgZXZlbnQgaW5zdGFuY2UgdG8gdXBkYXRlIGRhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gZGF0YSBvYmplY3QgdG8gdXBkYXRlIGV2ZW50XG4gKi9cblNlcnZpY2VDYWxlbmRhci5wcm90b3R5cGUudXBkYXRlRXZlbnQgPSBmdW5jdGlvbihpZCwgZGF0YSkge1xuICAgIHZhciBjdHJsID0gdGhpcy5jb250cm9sbGVyLFxuICAgICAgICBvd25FdmVudHMgPSBjdHJsLmV2ZW50cyxcbiAgICAgICAgY2FsRXZlbnQgPSBvd25FdmVudHMuc2luZ2xlKGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWwuaWQgPT09IGlkO1xuICAgICAgICB9KTtcblxuICAgIGlmIChjYWxFdmVudCkge1xuICAgICAgICBjdHJsLnVwZGF0ZUV2ZW50KGNhbEV2ZW50LCBkYXRhKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIERlbGV0ZSBEb29yYXlFdmVudCBpbnN0YW5jZVxuICogQG92ZXJyaWRlXG4gKiBAZmlyZXMgU2VydmljZUNhbGVuZGFyI2JlZm9yZURlbGV0ZUV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBJRCBvZiBldmVudCB0byBkZWxldGVcbiAqL1xuU2VydmljZUNhbGVuZGFyLnByb3RvdHlwZS5kZWxldGVFdmVudCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIGN0cmwgPSB0aGlzLmNvbnRyb2xsZXIsXG4gICAgICAgIG93bkV2ZW50cyA9IGN0cmwuZXZlbnRzLFxuICAgICAgICBjYWxFdmVudCA9IG93bkV2ZW50cy5zaW5nbGUoZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbC5pZCA9PT0gaWQ7XG4gICAgICAgIH0pO1xuXG4gICAgaWYgKCFjYWxFdmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFNlcnZpY2VDYWxlbmRhciNiZWZvcmVEZWxldGVFdmVudFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtDYWxFdmVudH0gbW9kZWwgLSBtb2RlbCBpbnN0YW5jZSB0byBkZWxldGVcbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ2JlZm9yZURlbGV0ZUV2ZW50Jywge1xuICAgICAgICBtb2RlbDogY2FsRXZlbnQgXG4gICAgfSk7XG4gICAgXG4gICAgY3RybC5kZWxldGVFdmVudChjYWxFdmVudCk7XG4gICAgdGhpcy5yZW5kZXIoKTtcbn07XG5cbi8qKioqKioqKioqXG4gKiBDdXN0b20gRXZlbnRzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiDqsIEg67ew7J2YIO2BtOumrSDtlbjrk6Trn6zsmYAg7IKs7Jqp7J6QIO2BtOumrSDsnbTrsqTtirgg7ZW465Ok65+s66W8IOyeh+q4sCDsnITtlZwg67iM66a/7KeAIOqwnOuFkOydmCDsnbTrsqTtirgg7ZW465Ok65+sXG4gKiBAZW1pdHMgU2VydmljZUNhbGVuZGFyI2NsaWNrRXZlbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBjbGlja0V2ZW50RGF0YSAtICdjbGlja0V2ZW50JyDtlbjrk6Trn6zsnZgg7J2067Kk7Yq4IOuNsOydtO2EsFxuICovXG5TZXJ2aWNlQ2FsZW5kYXIucHJvdG90eXBlLl9vbkNsaWNrID0gZnVuY3Rpb24oY2xpY2tFdmVudERhdGEpIHtcbiAgICAvKipcbiAgICAgKiBAZXZlbnRzIFNlcnZpY2VDYWxlbmRhciNjbGlja0V2ZW50XG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0Rvb3JheUV2ZW50fSBtb2RlbCAtIO2BtOumrSDsnbTrsqTtirgg67iU66Gd6rO8IOq0gOugqOuQnCDsnbzsoJUg66qo6424IOyduOyKpO2EtOyKpFxuICAgICAqIEBwcm9wZXJ0eSB7TW91c2VFdmVudH0ganNFdmVudCAtIOuniOyasOyKpCDsnbTrsqTtirhcbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ2NsaWNrRXZlbnQnLCBjbGlja0V2ZW50RGF0YSk7XG59O1xuXG4vKipcbiAqIEBmaXJlcyB7U2VydmljZUNhbGVuZGFyI2JlZm9yZUNyZWF0ZUV2ZW50fVxuICogQHBhcmFtIHtvYmplY3R9IGNyZWF0ZUV2ZW50RGF0YSAtIHNlbGVjdCBldmVudCBkYXRhIGZyb20gYWxsZGF5LCB0aW1lXG4gKi9cblNlcnZpY2VDYWxlbmRhci5wcm90b3R5cGUuX29uQmVmb3JlQ3JlYXRlID0gZnVuY3Rpb24oY3JlYXRlRXZlbnREYXRhKSB7XG4gICAgLyoqXG4gICAgICogQGV2ZW50cyBTZXJ2aWNlQ2FsZW5kYXIjYmVmb3JlQ3JlYXRlRXZlbnRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7RGF0ZX0gc3RhcnRzIC0gc2VsZWN0IHN0YXJ0IGRhdGVcbiAgICAgKiBAcHJvcGVydHkge0RhdGVdIGVuZHMgLSBzZWxlY3QgZW5kIGRhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ2JlZm9yZUNyZWF0ZUV2ZW50JywgY3JlYXRlRXZlbnREYXRhKTtcbn07XG5cbi8qKlxuICogQGZpcmVzIFNlcnZpY2VDYWxlbmRhciNiZWZvcmVVcGRhdGVFdmVudFxuICogQHBhcmFtIHtvYmplY3R9IHVwZGF0ZUV2ZW50RGF0YSAtIHVwZGF0ZSBldmVudCBkYXRhXG4gKi9cblNlcnZpY2VDYWxlbmRhci5wcm90b3R5cGUuX29uQmVmb3JlVXBkYXRlID0gZnVuY3Rpb24odXBkYXRlRXZlbnREYXRhKSB7XG4gICAgLyoqXG4gICAgICogQGV2ZW50IFNlcnZpY2VDYWxlbmRhciNiZWZvcmVVcGRhdGVFdmVudFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtDYWxFdmVudH0gbW9kZWwgLSBtb2RlbCBpbnN0YW5jZSB0byB1cGRhdGVcbiAgICAgKiBAcHJvcGVydHkge0RhdGV9IHN0YXJ0cyAtIHNlbGVjdCBzdGFydCBkYXRlXG4gICAgICogQHByb3BlcnR5IHtEYXRlXSBlbmRzIC0gc2VsZWN0IGVuZCBkYXRlXG4gICAgICovXG4gICAgdGhpcy5maXJlKCdiZWZvcmVVcGRhdGVFdmVudCcsIHVwZGF0ZUV2ZW50RGF0YSk7XG59O1xuXG4vKipcbiAqIOy6mOumsOuNlCDtjKnthqDrpqwg7YG0656Y7Iqk7JmAIOyjvOu3sCwg7JuU67ew7J2YIOydtOuypO2KuCDsl7DqsrDsnYQg7Yag6riA7ZWc64ukXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzQXR0YWNoIC0gdHJ1ZeuptCDsnbTrsqTtirgg7Jew6rKw7ZWoLlxuICogQHBhcmFtIHtXZWVrfE1vbnRofSB2aWV3IC0g7KO867ewIOuYkOuKlCDsm5Trt7BcbiAqIEBwYXJhbSB7U2VydmljZUNhbGVuZGFyfSBjYWxlbmRhciAtIOy6mOumsOuNlCDtjKnthqDrpqwg7YG0656Y7IqkXG4gKi9cblNlcnZpY2VDYWxlbmRhci5wcm90b3R5cGUuX3RvZ2dsZVZpZXdFdmVudCA9IGZ1bmN0aW9uKGlzQXR0YWNoLCB2aWV3LCBjYWxlbmRhcikge1xuICAgIHZhciBoYW5kbGVyID0gdmlldy5oYW5kbGVyLFxuICAgICAgICBjYWxlbmRhciA9IHRoaXMsXG4gICAgICAgIG1ldGhvZCA9IGlzQXR0YWNoID8gJ29uJyA6ICdvZmYnO1xuXG4gICAgdXRpbC5mb3JFYWNoKGhhbmRsZXIuY2xpY2ssIGZ1bmN0aW9uKGhhbmRsZXJJbnN0YW5jZSkge1xuICAgICAgICBoYW5kbGVySW5zdGFuY2VbbWV0aG9kXSgnY2xpY2tFdmVudCcsIGNhbGVuZGFyLl9vbkNsaWNrLCBjYWxlbmRhcik7XG4gICAgfSk7XG5cbiAgICB1dGlsLmZvckVhY2goaGFuZGxlci5jcmVhdGlvbiwgZnVuY3Rpb24oaGFuZGxlckluc3RhbmNlKSB7XG4gICAgICAgIGhhbmRsZXJJbnN0YW5jZVttZXRob2RdKCdiZWZvcmVDcmVhdGVFdmVudCcsIGNhbGVuZGFyLl9vbkJlZm9yZUNyZWF0ZSwgY2FsZW5kYXIpO1xuICAgIH0pO1xuXG4gICAgdXRpbC5mb3JFYWNoKGhhbmRsZXIubW92ZSwgZnVuY3Rpb24oaGFuZGxlckluc3RhbmNlKSB7XG4gICAgICAgIGhhbmRsZXJJbnN0YW5jZVttZXRob2RdKCdiZWZvcmVVcGRhdGVFdmVudCcsIGNhbGVuZGFyLl9vbkJlZm9yZVVwZGF0ZSwgY2FsZW5kYXIpO1xuICAgIH0pO1xuXG4gICAgdXRpbC5mb3JFYWNoKGhhbmRsZXIucmVzaXplLCBmdW5jdGlvbihoYW5kbGVySW5zdGFuY2UpIHtcbiAgICAgICAgaGFuZGxlckluc3RhbmNlW21ldGhvZF0oJ2JlZm9yZVVwZGF0ZUV2ZW50JywgY2FsZW5kYXIuX29uQmVmb3JlVXBkYXRlLCBjYWxlbmRhcik7XG4gICAgfSk7XG59O1xuXG4vKioqKioqKioqKlxuICogTWV0aG9kc1xuICoqKioqKioqKiovXG5cbi8qKlxuICog6rCZ7J2AIGNhbGVuZGFySUTrpbwg6rCA7KeEIOuqqOuToCDsnbzsoJXsl5Ag64yA7ZW0IOq4gOyekOyDiSwg67Cw6rK97IOJ7J2EIOyerOyngOygle2VmOqzoCDrt7Drpbwg7IOI66Gc6rOg7Lmo7ZWc64ukXG4gKiBAcGFyYW0ge3N0cmluZ30gY2FsZW5kYXJJRCAtIGNhbGVuZGFySUQgdmFsdWVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb24gLSBjb2xvciBkYXRhIG9iamVjdFxuICogIEBwYXJhbSB7c3RyaW5nfSBvcHRpb24uY29sb3IgLSB0ZXh0IGNvbG9yIG9mIGV2ZW50IGVsZW1lbnRcbiAqICBAcGFyYW0ge3N0cmluZ30gb3B0aW9uLmJnQ29sb3IgLSBiZyBjb2xvciBvZiBldmVudCBlbGVtZW50XG4gKiAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9uLnJlbmRlcj10cnVlXSAtIHNldCBmYWxzZSB0aGVuIGRvZXMgbm90IGF1dG8gcmVuZGVyLlxuICovXG5TZXJ2aWNlQ2FsZW5kYXIucHJvdG90eXBlLnNldENhbGVuZGFyQ29sb3IgPSBmdW5jdGlvbihjYWxlbmRhcklELCBvcHRpb24pIHtcbiAgICB2YXIgY2FsQ29sb3IgPSB0aGlzLmNhbGVuZGFyQ29sb3IsXG4gICAgICAgIG93bkV2ZW50cyA9IHRoaXMuY29udHJvbGxlci5ldmVudHMsXG4gICAgICAgIG93bkNvbG9yID0gY2FsQ29sb3JbY2FsZW5kYXJJRF07XG5cbiAgICBpZiAoIXV0aWwuaXNPYmplY3Qob3B0aW9uKSkge1xuICAgICAgICBjb25maWcudGhyb3dFcnJvcignQ2FsZW5kYXIjY2hhbmdlQ2FsZW5kYXJDb2xvcigpOiBjb2xvciDripQge2NvbG9yOiBcXCdcXCcsIGJnQ29sb3I6IFxcJ1xcJ30g7ZiV7YOc7Jes7JW8IO2VqeuLiOuLpC4nKTtcbiAgICB9XG5cbiAgICBvd25Db2xvciA9IGNhbENvbG9yW2NhbGVuZGFySURdID0gdXRpbC5leHRlbmQoe1xuICAgICAgICBjb2xvcjogJyMwMDAnLFxuICAgICAgICBiZ0NvbG9yOiAnI2ExYjU2YycsXG4gICAgICAgIHJlbmRlcjogdHJ1ZVxuICAgIH0sIG9wdGlvbik7XG5cbiAgICBvd25FdmVudHMuZWFjaChmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICBpZiAobW9kZWwuY2FsZW5kYXJJRCAhPT0gY2FsZW5kYXJJRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kZWwuY29sb3IgPSBvd25Db2xvci5jb2xvcjtcbiAgICAgICAgbW9kZWwuYmdDb2xvciA9IG93bkNvbG9yLmJnQ29sb3I7XG4gICAgfSk7XG5cbiAgICBpZiAoISFvd25Db2xvci5yZW5kZXIpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRvZ2dsZSBldmVudHMgdmlzaWJpbGl0eSBieSBjYWxlbmRhciBJRFxuICogQHBhcmFtIHtzdHJpbmd9IGNhbGVuZGFySUQgLSBjYWxlbmRhciBpZCB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSB0b0hpZGUgLSBzZXQgdHJ1ZSB0byBoaWRlIGV2ZW50c1xuICogQHBhcmFtIHtib29sZWFufSByZW5kZXIgLSBzZXQgdHJ1ZSB0aGVuIHJlbmRlciBhZnRlciBjaGFuZ2UgdmlzaWJsZSBwcm9wZXJ0eSBlYWNoIG1vZGVsc1xuICogQHByaXZhdGVcbiAqL1xuU2VydmljZUNhbGVuZGFyLnByb3RvdHlwZS5fdG9nZ2xlRXZlbnRzQnlDYWxlbmRhcklEID0gZnVuY3Rpb24oY2FsZW5kYXJJRCwgdG9IaWRlLCByZW5kZXIpIHtcbiAgICB2YXIgb3duRXZlbnRzID0gdGhpcy5jb250cm9sbGVyLmV2ZW50cztcblxuICAgIGNhbGVuZGFySUQgPSB1dGlsLmlzQXJyYXkoY2FsZW5kYXJJRCkgPyBjYWxlbmRhcklEIDogW2NhbGVuZGFySURdO1xuXG4gICAgb3duRXZlbnRzLmVhY2goZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgaWYgKH51dGlsLmluQXJyYXkobW9kZWwuY2FsZW5kYXJJRCwgY2FsZW5kYXJJRCkpIHtcbiAgICAgICAgICAgIG1vZGVsLnNldCgndmlzaWJsZScsICF0b0hpZGUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocmVuZGVyKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTaG93IGV2ZW50cyB2aXNpYmlsaXR5IGJ5IGNhbGVuZGFyIElEXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gY2FsZW5kYXJJRCAtIGNhbGVuZGFyIGlkIHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZW5kZXI9dHJ1ZV0gLSBzZXQgZmFsc2UgdGhlbiBkb2Vzbid0IHJlbmRlciBhZnRlciBjaGFuZ2UgbW9kZWwncyBwcm9wZXJ0eS5cbiAqL1xuU2VydmljZUNhbGVuZGFyLnByb3RvdHlwZS5zaG93RXZlbnRzQnlDYWxlbmRhcklEID0gZnVuY3Rpb24oY2FsZW5kYXJJRCwgcmVuZGVyKSB7XG4gICAgcmVuZGVyID0gdXRpbC5pc0V4aXN0eShyZW5kZXIpID8gcmVuZGVyIDogdHJ1ZTtcbiAgICB0aGlzLl90b2dnbGVFdmVudHNCeUNhbGVuZGFySUQoY2FsZW5kYXJJRCwgZmFsc2UsIHJlbmRlcik7XG59O1xuXG4vKipcbiAqIEhpZGUgZXZlbnRzIHZpc2liaWxpdHkgYnkgY2FsZW5kYXIgSURcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBjYWxlbmRhcklEIC0gY2FsZW5kYXIgaWQgdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbmRlcj10cnVlXSAtIHNldCBmYWxzZSB0aGVuIGRvZXNuJ3QgcmVuZGVyIGFmdGVyIGNoYW5nZSBtb2RlbCdzIHByb3BlcnR5LlxuICovXG5TZXJ2aWNlQ2FsZW5kYXIucHJvdG90eXBlLmhpZGVFdmVudHNCeUNhbGVuZGFySUQgPSBmdW5jdGlvbihjYWxlbmRhcklELCByZW5kZXIpIHtcbiAgICByZW5kZXIgPSB1dGlsLmlzRXhpc3R5KHJlbmRlcikgPyByZW5kZXIgOiB0cnVlO1xuICAgIHRoaXMuX3RvZ2dsZUV2ZW50c0J5Q2FsZW5kYXJJRChjYWxlbmRhcklELCB0cnVlLCByZW5kZXIpO1xufTtcblxuLyoqXG4gKiDso7zrt7AsIOyblOu3sCDqsIQg7KCE7ZmYXG4gKiBAb3ZlcnJpZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3TmFtZSAtICd3ZWVrJywgJ21vbnRoJyDspJEg7ZWY64KYXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZT1mYWxzZV0gLSB0cnVlIOyngOygleyLnCDrt7Ag7KCE7ZmY7J20IOyXhuyWtOuPhCDsoITtmZjsnYQg7JyE7ZWcIOuPmeyekeydhCDsiJjtlontlZzri6RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NpbGVudD1mYWxzZV0gLSBubyBhdXRvIHJlbmRlciBhZnRlciBjcmVhdGlvbiB3aGVuIHNldCB0cnVlXG4gKi9cblNlcnZpY2VDYWxlbmRhci5wcm90b3R5cGUudG9nZ2xlVmlldyA9IGZ1bmN0aW9uKHZpZXdOYW1lLCBmb3JjZSwgc2lsZW50KSB7XG4gICAgdmFyIGxheW91dCA9IHRoaXMubGF5b3V0LFxuICAgICAgICBjb250cm9sbGVyID0gdGhpcy5jb250cm9sbGVyLFxuICAgICAgICBkcmFnSGFuZGxlciA9IHRoaXMuZHJhZ0hhbmRsZXIsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGNyZWF0ZWQ7XG5cbiAgICBpZiAoIWZvcmNlICYmIHRoaXMuY3VycmVudFZpZXdOYW1lID09PSB2aWV3TmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGxheW91dC5jaGlsZHMuZG9XaGVuSGFzKHZpZXdOYW1lLCBmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZVZpZXdFdmVudChmYWxzZSwgdmlldywgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG4gICAgbGF5b3V0LmNsZWFyKCk7XG5cbiAgICBpZiAodmlld05hbWUgPT09ICd3ZWVrJykge1xuICAgICAgICBjcmVhdGVkID0gc2VydmljZVdlZWtWaWV3RmFjdG9yeShjb250cm9sbGVyLCBsYXlvdXQuY29udGFpbmVyLCBkcmFnSGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgIGxheW91dC5hZGRDaGlsZChjcmVhdGVkLnZpZXcpO1xuICAgICAgICB0aGlzLl9yZWZyZXNoTWV0aG9kID0gY3JlYXRlZC5yZWZyZXNoO1xuICAgIH0gZWxzZSBpZiAodmlld05hbWUgPT09ICdtb250aCcpIHtcbiAgICAgICAgLy9UT0RPOiBtb250aCB2aWV3LiBcbiAgICB9XG5cbiAgICBsYXlvdXQuY2hpbGRzLmRvV2hlbkhhcyh2aWV3TmFtZSwgZnVuY3Rpb24odmlldykge1xuICAgICAgICB0aGlzLl90b2dnbGVWaWV3RXZlbnQodHJ1ZSwgdmlldywgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLmN1cnJlbnRWaWV3TmFtZSA9IHZpZXdOYW1lO1xuXG4gICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2VDYWxlbmRhcjtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEZhY3RvcnkgbW9kdWxlIGZvciBXZWVrVmlldyAoY3VzdG9taXplZCBmb3Igc2VydmljZSlcbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLnR1aS51dGlsO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL2NvbmZpZycpO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIGZpbGxSZW1haW5IZWlnaHQgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZmlsbFJlbWFpbkhlaWdodCcpO1xuXG4vLyBQYXJlbnQgdmlld3NcbnZhciBXZWVrID0gcmVxdWlyZSgnLi4vLi4vdmlldy93ZWVrL3dlZWsnKTtcblxuLy8gU3ViIHZpZXdzXG52YXIgRGF5TmFtZSA9IHJlcXVpcmUoJy4uLy4uL3ZpZXcvd2Vlay9kYXluYW1lJyk7XG52YXIgTWlsZXN0b25lID0gcmVxdWlyZSgnLi4vdmlldy9taWxlc3RvbmUnKTtcbnZhciBUYXNrVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXcvdGFza3ZpZXcnKTtcbnZhciBUaW1lR3JpZCA9IHJlcXVpcmUoJy4uLy4uL3ZpZXcvd2Vlay90aW1lR3JpZCcpO1xudmFyIEFsbGRheSA9IHJlcXVpcmUoJy4uLy4uL3ZpZXcvd2Vlay9hbGxkYXknKTtcblxuLy8gSGFuZGxlcnNcbnZhciBBbGxkYXlDbGljayA9IHJlcXVpcmUoJy4uLy4uL2hhbmRsZXIvYWxsZGF5L2NsaWNrJyk7XG52YXIgQWxsZGF5Q3JlYXRpb24gPSByZXF1aXJlKCcuLi8uLi9oYW5kbGVyL2FsbGRheS9jcmVhdGlvbicpO1xudmFyIEFsbGRheU1vdmUgPSByZXF1aXJlKCcuLi8uLi9oYW5kbGVyL2FsbGRheS9tb3ZlJyk7XG52YXIgQWxsZGF5UmVzaXplID0gcmVxdWlyZSgnLi4vLi4vaGFuZGxlci9hbGxkYXkvcmVzaXplJyk7XG52YXIgVGltZUNsaWNrID0gcmVxdWlyZSgnLi4vLi4vaGFuZGxlci90aW1lL2NsaWNrJyk7XG52YXIgVGltZUNyZWF0aW9uID0gcmVxdWlyZSgnLi4vLi4vaGFuZGxlci90aW1lL2NyZWF0aW9uJyk7XG52YXIgVGltZU1vdmUgPSByZXF1aXJlKCcuLi8uLi9oYW5kbGVyL3RpbWUvbW92ZScpO1xudmFyIFRpbWVSZXNpemUgPSByZXF1aXJlKCcuLi8uLi9oYW5kbGVyL3RpbWUvcmVzaXplJyk7XG52YXIgTWlsZXN0b25lQ2xpY2sgPSByZXF1aXJlKCcuLi9oYW5kbGVyL21pbGVzdG9uZUNsaWNrJyk7XG52YXIgVGFza0NsaWNrID0gcmVxdWlyZSgnLi4vaGFuZGxlci90YXNrQ2xpY2snKTtcblxuLy8gQmFzZSBUZW1wbGF0ZXNcbnZhciB3ZWVrVmlld1RtcGwgPSByZXF1aXJlKCcuLi8uLi9kb29yYXkvdmlldy90ZW1wbGF0ZS9mYWN0b3J5L3dlZWtWaWV3LmhicycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJhc2VDb250cm9sbGVyLCBsYXlvdXRDb250YWluZXIsIGRyYWdIYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIHdlZWtWaWV3LFxuICAgICAgICBkYXlOYW1lVmlldyxcbiAgICAgICAgbWlsZXN0b25lVmlldyxcbiAgICAgICAgdGFza1ZpZXcsXG4gICAgICAgIGFsbGRheVZpZXcsXG4gICAgICAgIHRpbWVHcmlkQ29udGFpbmVyLFxuICAgICAgICB0aW1lR3JpZFZpZXcsXG4gICAgICAgIG1pbGVzdG9uZUNsaWNrSGFuZGxlcixcbiAgICAgICAgdGFza0NsaWNrSGFuZGxlcixcbiAgICAgICAgYWxsZGF5Q2xpY2tIYW5kbGVyLFxuICAgICAgICBhbGxkYXlDcmVhdGlvbkhhbmRsZXIsXG4gICAgICAgIGFsbGRheU1vdmVIYW5kbGVyLFxuICAgICAgICBhbGxkYXlSZXNpemVIYW5kbGVyLFxuICAgICAgICB0aW1lQ2xpY2tIYW5kbGVyLFxuICAgICAgICB0aW1lQ3JlYXRpb25IYW5kbGVyLFxuICAgICAgICB0aW1lTW92ZUhhbmRsZXIsXG4gICAgICAgIHRpbWVSZXNpemVIYW5kbGVyLFxuICAgICAgICBmcmg7XG5cbiAgICB3ZWVrVmlldyA9IG5ldyBXZWVrKG51bGwsIG9wdGlvbnMud2VlaywgbGF5b3V0Q29udGFpbmVyKTtcbiAgICB3ZWVrVmlldy5jb250YWluZXIuaW5uZXJIVE1MID0gd2Vla1ZpZXdUbXBsKCk7XG5cbiAgICAvKioqKioqKioqKlxuICAgICAqIOydvOyekO2RnOq4sCAo7IOB64uoIOydvOyblO2ZlOyImC4uLilcbiAgICAgKioqKioqKioqKi9cbiAgICBkYXlOYW1lVmlldyA9IG5ldyBEYXlOYW1lKG51bGwsIGRvbXV0aWwuZmluZCgnLicgKyBjb25maWcuY2xhc3NuYW1lKCdkYXluYW1lLWxheW91dCcpLCB3ZWVrVmlldy5jb250YWluZXIpKTtcbiAgICB3ZWVrVmlldy5hZGRDaGlsZChkYXlOYW1lVmlldyk7XG5cbiAgICAvKioqKioqKioqKlxuICAgICAqIOuniOydvOyKpO2GpFxuICAgICAqKioqKioqKioqL1xuICAgIG1pbGVzdG9uZVZpZXcgPSBuZXcgTWlsZXN0b25lKG9wdGlvbnMud2VlaywgZG9tdXRpbC5maW5kKCcuJyArIGNvbmZpZy5jbGFzc25hbWUoJ21pbGVzdG9uZS1sYXlvdXQnKSkpO1xuICAgIHdlZWtWaWV3LmFkZENoaWxkKG1pbGVzdG9uZVZpZXcpO1xuICAgIG1pbGVzdG9uZUNsaWNrSGFuZGxlciA9IG5ldyBNaWxlc3RvbmVDbGljayhkcmFnSGFuZGxlciwgbWlsZXN0b25lVmlldywgYmFzZUNvbnRyb2xsZXIpO1xuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiDsl4XrrLRcbiAgICAgKioqKioqKioqKi9cbiAgICB0YXNrVmlldyA9IG5ldyBUYXNrVmlldyhvcHRpb25zLndlZWssIGRvbXV0aWwuZmluZCgnLicgKyBjb25maWcuY2xhc3NuYW1lKCdtaWxlc3RvbmUtbGF5b3V0JykpKTtcbiAgICB3ZWVrVmlldy5hZGRDaGlsZCh0YXNrVmlldyk7XG4gICAgdGFza0NsaWNrSGFuZGxlciA9IG5ldyBUYXNrQ2xpY2soZHJhZ0hhbmRsZXIsIHRhc2tWaWV3LCBiYXNlQ29udHJvbGxlcik7XG5cbiAgICAvKioqKioqKioqKlxuICAgICAqIOyiheydvOydvOyglVxuICAgICAqKioqKioqKioqL1xuICAgIGFsbGRheVZpZXcgPSBuZXcgQWxsZGF5KG9wdGlvbnMud2VlaywgZG9tdXRpbC5maW5kKCcuJyArIGNvbmZpZy5jbGFzc25hbWUoJ2FsbGRheS1sYXlvdXQnKSwgd2Vla1ZpZXcuY29udGFpbmVyKSk7XG4gICAgd2Vla1ZpZXcuYWRkQ2hpbGQoYWxsZGF5Vmlldyk7XG4gICAgYWxsZGF5Q2xpY2tIYW5kbGVyID0gbmV3IEFsbGRheUNsaWNrKGRyYWdIYW5kbGVyLCBhbGxkYXlWaWV3LCBiYXNlQ29udHJvbGxlcik7XG4gICAgYWxsZGF5Q3JlYXRpb25IYW5kbGVyID0gbmV3IEFsbGRheUNyZWF0aW9uKGRyYWdIYW5kbGVyLCBhbGxkYXlWaWV3LCBiYXNlQ29udHJvbGxlcik7XG4gICAgYWxsZGF5TW92ZUhhbmRsZXIgPSBuZXcgQWxsZGF5TW92ZShkcmFnSGFuZGxlciwgYWxsZGF5VmlldywgYmFzZUNvbnRyb2xsZXIpO1xuICAgIGFsbGRheVJlc2l6ZUhhbmRsZXIgPSBuZXcgQWxsZGF5UmVzaXplKGRyYWdIYW5kbGVyLCBhbGxkYXlWaWV3LCBiYXNlQ29udHJvbGxlcik7XG5cbiAgICAvKioqKioqKioqKlxuICAgICAqIOyLnOqwhOuzhCDsnbzsoJVcbiAgICAgKioqKioqKioqKi9cbiAgICB0aW1lR3JpZENvbnRhaW5lciA9IGRvbXV0aWwuZmluZCgnLicgKyBjb25maWcuY2xhc3NuYW1lKCd0aW1lZ3JpZC1sYXlvdXQnKSwgd2Vla1ZpZXcuY29udGFpbmVyKTtcbiAgICB0aW1lR3JpZFZpZXcgPSBuZXcgVGltZUdyaWQob3B0aW9ucy53ZWVrLCB0aW1lR3JpZENvbnRhaW5lcik7XG4gICAgd2Vla1ZpZXcuYWRkQ2hpbGQodGltZUdyaWRWaWV3KTtcbiAgICB0aW1lQ2xpY2tIYW5kbGVyID0gbmV3IFRpbWVDbGljayhkcmFnSGFuZGxlciwgdGltZUdyaWRWaWV3LCBiYXNlQ29udHJvbGxlcik7XG4gICAgdGltZUNyZWF0aW9uSGFuZGxlciA9IG5ldyBUaW1lQ3JlYXRpb24oZHJhZ0hhbmRsZXIsIHRpbWVHcmlkVmlldywgYmFzZUNvbnRyb2xsZXIpO1xuICAgIHRpbWVNb3ZlSGFuZGxlciA9IG5ldyBUaW1lTW92ZShkcmFnSGFuZGxlciwgdGltZUdyaWRWaWV3LCBiYXNlQ29udHJvbGxlcik7XG4gICAgdGltZVJlc2l6ZUhhbmRsZXIgPSBuZXcgVGltZVJlc2l6ZShkcmFnSGFuZGxlciwgdGltZUdyaWRWaWV3LCBiYXNlQ29udHJvbGxlcik7XG5cbiAgICAvLyDqsIDrs4DrhpLsnbQg66qo65OIIOy0iOq4sO2ZlFxuICAgIGZyaCA9IGZpbGxSZW1haW5IZWlnaHQoW3RpbWVHcmlkQ29udGFpbmVyXSwgd2Vla1ZpZXcuY29udGFpbmVyKTtcblxuICAgIHdlZWtWaWV3Lm9uKCdhZnRlclJlbmRlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBmcmgucmVmcmVzaCgpO1xuICAgIH0pO1xuXG4gICAgd2Vla1ZpZXcuaGFuZGxlciA9IHtcbiAgICAgICAgY2xpY2s6IHtcbiAgICAgICAgICAgIG1pbGVzdG9uZTogbWlsZXN0b25lQ2xpY2tIYW5kbGVyLFxuICAgICAgICAgICAgdGFzazogdGFza0NsaWNrSGFuZGxlcixcbiAgICAgICAgICAgIGFsbGRheTogYWxsZGF5Q2xpY2tIYW5kbGVyLFxuICAgICAgICAgICAgdGltZTogdGltZUNsaWNrSGFuZGxlclxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGlvbjoge1xuICAgICAgICAgICAgYWxsZGF5OiBhbGxkYXlDcmVhdGlvbkhhbmRsZXIsXG4gICAgICAgICAgICB0aW1lOiB0aW1lQ3JlYXRpb25IYW5kbGVyXG4gICAgICAgIH0sXG4gICAgICAgIG1vdmU6IHtcbiAgICAgICAgICAgIGFsbGRheTogYWxsZGF5TW92ZUhhbmRsZXIsXG4gICAgICAgICAgICB0aW1lOiB0aW1lTW92ZUhhbmRsZXJcbiAgICAgICAgfSxcbiAgICAgICAgcmVzaXplOiB7XG4gICAgICAgICAgICBhbGxkYXk6IGFsbGRheVJlc2l6ZUhhbmRsZXIsXG4gICAgICAgICAgICB0aW1lOiB0aW1lUmVzaXplSGFuZGxlclxuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLy8gYWRkIGNvbnRyb2xsZXJcbiAgICB3ZWVrVmlldy5jb250cm9sbGVyID0gYmFzZUNvbnRyb2xsZXIuV2VlaztcblxuICAgIC8vIGFkZCBkZXN0cm95XG4gICAgd2Vla1ZpZXcuX2JlZm9yZURlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdXRpbC5mb3JFYWNoKHdlZWtWaWV3LmhhbmRsZXJzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICB1dGlsLmZvckVhY2godHlwZSwgZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub2ZmKCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHZpZXc6IHdlZWtWaWV3LFxuICAgICAgICByZWZyZXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZyaC5yZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyDrp4jsnbzsiqTthqQg7ZWt66qpIO2BtOumrSDsnbTrsqTtirgg7ZW465Ok65+sIOuqqOuTiFxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwudHVpLnV0aWw7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vY29uZmlnJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG5cbi8qKlxuICog66eI7J287Iqk7YakIO2BtOumrSDsnbTrsqTtirgg7ZW465Ok65+sIOuqqOuTiFxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVsZW1lbnRzIHtIYW5kbGVyfVxuICogQG1peGVzIHV0aWwuQ3VzdG9tRXZlbnRzXG4gKiBAcGFyYW0ge0RyYWd9IGRyYWdIYW5kbGVyIC0gZHJhZ0hhbmRsZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7TWlsZXN0b25lfSBtaWxlc3RvbmVWaWV3IC0gbWlsc3RvbmUgdmlldyBpbnN0YW5jZVxuICogQHBhcmFtIHtCYXNlfSBiYXNlQ29udHJvbGxlciAtIGJhc2VDb250cm9sbGVyIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIE1pbGVzdG9uZUNsaWNrKGRyYWdIYW5kbGVyLCBtaWxlc3RvbmVWaWV3LCBiYXNlQ29udHJvbGxlcikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEcmFnfVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBkcmFnSGFuZGxlcjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNaWxlc3RvbmV9XG4gICAgICovXG4gICAgdGhpcy5taWxlc3RvbmVWaWV3ID0gbWlsZXN0b25lVmlldztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCYXNlfVxuICAgICAqL1xuICAgIHRoaXMuYmFzZUNvbnRyb2xsZXIgPSBiYXNlQ29udHJvbGxlcjtcblxuICAgIGRyYWdIYW5kbGVyLm9uKHtcbiAgICAgICAgJ2NsaWNrJzogdGhpcy5fb25DbGlja1xuICAgIH0sIHRoaXMpO1xufVxuXG4vKipcbiAqIERlc3Ryb3lcbiAqL1xuTWlsZXN0b25lQ2xpY2sucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9mZih0aGlzKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gdGhpcy5taWxlc3RvbmVWaWV3ID0gdGhpcy5iYXNlQ29udHJvbGxlciA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIGNoZWNrIHJlcG9uc2liaWxpdHkgdG8gdGhpcyBoYW5kbGVyIG1vZHVsZSBzdXBwbGllZCBlbGVtZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbnxzdHJpbmd9IHJldHVybiBmYWxzZSB3aGVuIGhhbmRsZXIgaGFzIG5vIHJlc3BvbnNpYmlsaXR5IGZvciBzdXBwbGllZCBlbGVtZW50LiBcbiAqIG90aGVyd2lzZSwgcmV0dXJuIGV2ZW50IG1vZGVsIGlkIHRoYXQgcmVsYXRlZCB3aXRoIHRhcmdldCBlbGVtZW50LlxuICovXG5NaWxlc3RvbmVDbGljay5wcm90b3R5cGUuY2hlY2tFeHBlY3RlZENvbmRpdGlvbiA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgIHRhcmdldCA9IGRvbXV0aWwuY2xvc2VzdCh0YXJnZXQsICcuJyArIGNvbmZpZy5jbGFzc25hbWUoJ21pbGVzdG9uZS1pdGVtJykpO1xuICAgIFxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9tdXRpbC5nZXREYXRhKHRhcmdldCwgJ2lkJyk7XG59O1xuXG4vKipcbiAqIEBlbWl0cyBNaWxlc3RvbmVDbGljayNjbGlja0V2ZW50XG4gKiBAcGFyYW0ge29iamVjdH0gY2xpY2tFdmVudCAtIGNsaWNrIGV2ZW50IG9iamVjdFxuICovXG5NaWxlc3RvbmVDbGljay5wcm90b3R5cGUuX29uQ2xpY2sgPSBmdW5jdGlvbihjbGlja0V2ZW50KSB7XG4gICAgdmFyIG1vZGVsSUQgPSB0aGlzLmNoZWNrRXhwZWN0ZWRDb25kaXRpb24oY2xpY2tFdmVudC50YXJnZXQpO1xuXG4gICAgaWYgKCFtb2RlbElEKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmJhc2VDb250cm9sbGVyLmV2ZW50cy5kb1doZW5IYXMobW9kZWxJRCwgZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudHMgTWlsZXN0b25lQ2xpY2sjY2xpY2tFdmVudFxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJvcGVydHkge0NhbEV2ZW50fSBtb2RlbCAtIG1vZGVsIGluc3RhbmNlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TW91c2VFdmVudH0ganNFdmVudCAtIE1vdXNlRXZlbnQgb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpcmUoJ2NsaWNrRXZlbnQnLCB7XG4gICAgICAgICAgICBtb2RlbDogIG1vZGVsLFxuICAgICAgICAgICAganNFdmVudDogY2xpY2tFdmVudC5vcmlnaW5FdmVudFxuICAgICAgICB9KTtcbiAgICB9LCB0aGlzKTtcbn07XG5cbnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKE1pbGVzdG9uZUNsaWNrKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNaWxlc3RvbmVDbGljaztcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IOuniOydvOyKpO2GpCDtla3rqqkg7YG066atIOydtOuypO2KuCDtlbjrk6Trn6wg66qo65OIXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC50dWkudXRpbDtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi8uLi9jb25maWcnKTtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcblxuLyoqXG4gKiDrp4jsnbzsiqTthqQg7YG066atIOydtOuypO2KuCDtlbjrk6Trn6wg66qo65OIXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZWxlbWVudHMge0hhbmRsZXJ9XG4gKiBAbWl4ZXMgdXRpbC5DdXN0b21FdmVudHNcbiAqIEBwYXJhbSB7RHJhZ30gZHJhZ0hhbmRsZXIgLSBkcmFnSGFuZGxlciBpbnN0YW5jZVxuICogQHBhcmFtIHtUYXNrfSB0YXNrVmlldyAtIG1pbHN0b25lIHZpZXcgaW5zdGFuY2VcbiAqIEBwYXJhbSB7QmFzZX0gYmFzZUNvbnRyb2xsZXIgLSBiYXNlQ29udHJvbGxlciBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBUYXNrQ2xpY2soZHJhZ0hhbmRsZXIsIHRhc2tWaWV3LCBiYXNlQ29udHJvbGxlcikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEcmFnfVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBkcmFnSGFuZGxlcjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtUYXNrfVxuICAgICAqL1xuICAgIHRoaXMudGFza1ZpZXcgPSB0YXNrVmlldztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCYXNlfVxuICAgICAqL1xuICAgIHRoaXMuYmFzZUNvbnRyb2xsZXIgPSBiYXNlQ29udHJvbGxlcjtcblxuICAgIGRyYWdIYW5kbGVyLm9uKHtcbiAgICAgICAgJ2NsaWNrJzogdGhpcy5fb25DbGlja1xuICAgIH0sIHRoaXMpO1xufVxuXG4vKipcbiAqIERlc3Ryb3lcbiAqL1xuVGFza0NsaWNrLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kcmFnSGFuZGxlci5vZmYodGhpcyk7XG4gICAgdGhpcy5kcmFnSGFuZGxlciA9IHRoaXMudGFza1ZpZXcgPSB0aGlzLmJhc2VDb250cm9sbGVyID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gY2hlY2sgcmVwb25zaWJpbGl0eSB0byB0aGlzIGhhbmRsZXIgbW9kdWxlIHN1cHBsaWVkIGVsZW1lbnRcbiAqIEByZXR1cm5zIHtib29sZWFufHN0cmluZ30gcmV0dXJuIGZhbHNlIHdoZW4gaGFuZGxlciBoYXMgbm8gcmVzcG9uc2liaWxpdHkgZm9yIHN1cHBsaWVkIGVsZW1lbnQuIFxuICogb3RoZXJ3aXNlLCByZXR1cm4gZXZlbnQgbW9kZWwgaWQgdGhhdCByZWxhdGVkIHdpdGggdGFyZ2V0IGVsZW1lbnQuXG4gKi9cblRhc2tDbGljay5wcm90b3R5cGUuY2hlY2tFeHBlY3RlZENvbmRpdGlvbiA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgIHRhcmdldCA9IGRvbXV0aWwuY2xvc2VzdCh0YXJnZXQsICcuJyArIGNvbmZpZy5jbGFzc25hbWUoJ3Rhc2staXRlbScpKTtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9tdXRpbC5nZXREYXRhKHRhcmdldCwgJ2lkJyk7XG59O1xuXG4vKipcbiAqIEBlbWl0cyBUYXNrQ2xpY2sjY2xpY2tFdmVudFxuICogQHBhcmFtIHtvYmplY3R9IGNsaWNrRXZlbnQgLSBjbGljayBldmVudCBvYmplY3RcbiAqL1xuVGFza0NsaWNrLnByb3RvdHlwZS5fb25DbGljayA9IGZ1bmN0aW9uKGNsaWNrRXZlbnQpIHtcbiAgICB2YXIgbW9kZWxJRCA9IHRoaXMuY2hlY2tFeHBlY3RlZENvbmRpdGlvbihjbGlja0V2ZW50LnRhcmdldCk7XG5cbiAgICBpZiAoIW1vZGVsSUQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYmFzZUNvbnRyb2xsZXIuZXZlbnRzLmRvV2hlbkhhcyhtb2RlbElELCBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGV2ZW50cyBUYXNrQ2xpY2sjY2xpY2tFdmVudFxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJvcGVydHkge0NhbEV2ZW50fSBtb2RlbCAtIG1vZGVsIGluc3RhbmNlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TW91c2VFdmVudH0ganNFdmVudCAtIE1vdXNlRXZlbnQgb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpcmUoJ2NsaWNrRXZlbnQnLCB7XG4gICAgICAgICAgICBtb2RlbDogIG1vZGVsLFxuICAgICAgICAgICAganNFdmVudDogY2xpY2tFdmVudC5vcmlnaW5FdmVudFxuICAgICAgICB9KTtcbiAgICB9LCB0aGlzKTtcbn07XG5cbnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKFRhc2tDbGljayk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGFza0NsaWNrO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgRXh0ZW5kIG1vZGVsIGNsYXNzIGZvciBEb29yYXkgQ2FsZW5kYXIgcHJvamVjdC5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLnR1aS51dGlsO1xudmFyIENhbEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvY2FsRXZlbnQnKTtcblxuLyoqXG4gKiDsnbzsoJUg7Lm07YWM6rOg66asXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbnZhciBFVkVOVF9DQVRFR09SWSA9IHtcbiAgICAvKiog66eI7J287Iqk7YakICovXG4gICAgTUlMRVNUT05FOiAnbWlsZXN0b25lJyxcblxuICAgIC8qKiDsl4XrrLQgKi9cbiAgICBUQVNLOiAndGFzaycsXG4gICAgXG4gICAgLyoqIOyiheydvOydvOyglSAqL1xuICAgIEFMTERBWTogJ2FsbGRheScsXG5cbiAgICAvKiog7Iuc6rCE67OEIOydvOyglSAqL1xuICAgIFRJTUU6ICd0aW1lJ1xufTtcblxuLyoqXG4gKiBDYWxFdmVudCBjbGFzcyBmb3IgZG9vcmF5IHByb2plY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0NhbEV2ZW50fVxuICovXG5mdW5jdGlvbiBEb29yYXlFdmVudCgpIHtcbiAgICBDYWxFdmVudC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICog7LqY66aw642UIElEXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNhbGVuZGFySUQgPSAnJztcblxuICAgIC8qKlxuICAgICAqIOydvOyglSDsubTthYzqs6DrpqwgKOuniOydvOyKpO2GpCwg7JeF66y0LCDsooXsnbzsnbzsoJUsIOyLnOqwhOuzhOydvOyglSlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY2F0ZWdvcnkgPSAnJztcblxuICAgIC8qKlxuICAgICAqIOyXheustCDsnbzsoJXsnZgg6rK97JqwIOq1rOu2hCAo7Lac6re87KCELCDsoJDsi6zsoIQsIO2HtOq3vOyghClcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZHVlRGF0ZUNsYXNzID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiDsnbzsoJUg64W47LacIOyXrOu2gFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiDroIzrjZTrp4Hqs7wg6rSA6rOEIOyXhuuKlCDrs4Trj4Qg642w7J207YSwIOyggOyepSDqs7XqsIQuXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnJhdyA9IG51bGw7XG59XG5cbnV0aWwuaW5oZXJpdChEb29yYXlFdmVudCwgQ2FsRXZlbnQpO1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5Eb29yYXlFdmVudC5jcmVhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIGluc3QgPSBuZXcgRG9vcmF5RXZlbnQoKTtcbiAgICBpbnN0LmluaXQoZGF0YSk7XG5cbiAgICByZXR1cm4gaW5zdDtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBvcHRpb25zLlxuICovXG5Eb29yYXlFdmVudC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIENhbEV2ZW50LnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmlzQWxsRGF5ID0gb3B0aW9ucy5jYXRlZ29yeSA9PT0gRVZFTlRfQ0FURUdPUlkuQUxMREFZO1xuICAgIHRoaXMuY2FsZW5kYXJJRCA9IG9wdGlvbnMuY2FsZW5kYXJJRDtcbiAgICB0aGlzLmNhdGVnb3J5ID0gb3B0aW9ucy5jYXRlZ29yeTtcbiAgICB0aGlzLmR1ZURhdGVDbGFzcyA9IG9wdGlvbnMuZHVlRGF0ZUNsYXNzO1xuICAgIHRoaXMudmlzaWJsZSA9IHV0aWwuaXNFeGlzdHkob3B0aW9ucy52aXNpYmxlKSA/IG9wdGlvbnMudmlzaWJsZSA6IHRydWU7XG5cbiAgICBpZiAob3B0aW9ucy5jYXRlZ29yeSA9PT0gRVZFTlRfQ0FURUdPUlkuTUlMRVNUT05FIHx8XG4gICAgICAgIG9wdGlvbnMuY2F0ZWdvcnkgPT09IEVWRU5UX0NBVEVHT1JZLlRBU0spIHtcbiAgICAgICAgdGhpcy5zdGFydHMgPSBuZXcgRGF0ZSgrdGhpcy5lbmRzKTtcbiAgICAgICAgdGhpcy5zdGFydHMuc2V0TWludXRlcyh0aGlzLnN0YXJ0cy5nZXRNaW51dGVzKCkgLSAzMCk7XG4gICAgfVxuXG4gICAgdGhpcy5yYXcgPSBvcHRpb25zLnJhdyB8fCBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEb29yYXlFdmVudDtcblxuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcIjFcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sIGFsaWFzMj1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGFsaWFzMz1cImZ1bmN0aW9uXCIsIGFsaWFzND1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbiwgYWxpYXM1PWNvbnRhaW5lci5sYW1iZGE7XG5cbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwibWlsZXN0b25lLWRheVxcXCIgXFxuICAgICBzdHlsZT1cXFwid2lkdGg6XCJcbiAgICArIGFsaWFzNChhbGlhczUoKChzdGFjazEgPSAoZGF0YSAmJiBkYXRhLnJvb3QpKSAmJiBzdGFjazEud2lkdGgpLCBkZXB0aDApKVxuICAgICsgXCIlO2xlZnQ6XCJcbiAgICArIGFsaWFzNCgoaGVscGVycy5tdWx0aXBseSB8fCAoZGVwdGgwICYmIGRlcHRoMC5tdWx0aXBseSkgfHwgYWxpYXMyKS5jYWxsKGFsaWFzMSwoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS53aWR0aCksKGRhdGEgJiYgZGF0YS5pbmRleCkse1wibmFtZVwiOlwibXVsdGlwbHlcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpXG4gICAgKyBcIiU7bWluLWhlaWdodDpcIlxuICAgICsgYWxpYXM0KGFsaWFzNSgoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS5taW5IZWlnaHQpLCBkZXB0aDApKVxuICAgICsgXCJweDtoZWlnaHQ6XCJcbiAgICArIGFsaWFzNChhbGlhczUoKChzdGFjazEgPSAoZGF0YSAmJiBkYXRhLnJvb3QpKSAmJiBzdGFjazEuaGVpZ2h0KSwgZGVwdGgwKSlcbiAgICArIFwicHhcXFwiPlxcbiAgICA8dWwgY2xhc3M9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIm1pbGVzdG9uZS1saXN0XFxcIj5cXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLml0ZW1zIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDIsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIjwvdWw+XFxuPC9kaXY+XFxuXCI7XG59LFwiMlwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMSwgaGVscGVyLCBhbGlhczE9ZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSwgYWxpYXMyPWhlbHBlcnMuaGVscGVyTWlzc2luZywgYWxpYXMzPWNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uLCBhbGlhczQ9Y29udGFpbmVyLmxhbWJkYTtcblxuICByZXR1cm4gXCI8bGkgZGF0YS1pZD1cXFwiXCJcbiAgICArIGFsaWFzMygoaGVscGVycy5zdGFtcCB8fCAoZGVwdGgwICYmIGRlcHRoMC5zdGFtcCkgfHwgYWxpYXMyKS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubW9kZWwgOiBkZXB0aDApLHtcIm5hbWVcIjpcInN0YW1wXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKVxuICAgICsgXCJcXFwiIFxcbiAgICAgICAgZGF0YS10aXRsZT1cXFwiXCJcbiAgICArIGFsaWFzMyhhbGlhczQoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubW9kZWwgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLnRpdGxlIDogc3RhY2sxKSwgZGVwdGgwKSlcbiAgICArIFwiXFxcIiBcXG4gICAgICAgIGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXMzKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBcImZ1bmN0aW9uXCIgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJtaWxlc3RvbmUtaXRlbVxcXCIgXFxuICAgICAgICBzdHlsZT1cXFwibGluZS1oZWlnaHQ6XCJcbiAgICArIGFsaWFzMyhhbGlhczQoKChzdGFjazEgPSAoZGF0YSAmJiBkYXRhLnJvb3QpKSAmJiBzdGFjazEubGluZUhlaWdodCksIGRlcHRoMCkpXG4gICAgKyBcInB4O2NvbG9yOlwiXG4gICAgKyBhbGlhczMoYWxpYXM0KCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1vZGVsIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5jb2xvciA6IHN0YWNrMSksIGRlcHRoMCkpXG4gICAgKyBcIlxcXCI+XCJcbiAgICArICgoc3RhY2sxID0gKGhlbHBlcnNbXCJtaWxlc3RvbmUtdG1wbFwiXSB8fCAoZGVwdGgwICYmIGRlcHRoMFtcIm1pbGVzdG9uZS10bXBsXCJdKSB8fCBhbGlhczIpLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tb2RlbCA6IGRlcHRoMCkse1wibmFtZVwiOlwibWlsZXN0b25lLXRtcGxcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L2xpPlxcblwiO1xufSxcImNvbXBpbGVyXCI6WzcsXCI+PSA0LjAuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sIGFsaWFzMj1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGFsaWFzMz1cImZ1bmN0aW9uXCIsIGFsaWFzND1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbjtcblxuICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJtaWxlc3RvbmUtbGVmdFxcXCI+XFxuICAgIDxzcGFuPuuniOydvOyKpO2GpDwvc3Bhbj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJtaWxlc3RvbmUtcmlnaHQgXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiY2xlYXJcXFwiPlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZXZlbnRzIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDEsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIjwvZGl2PlxcblwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcg66eI7J287Iqk7YakIOu3sFxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwudHVpLnV0aWw7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vY29uZmlnJyk7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciBWaWV3ID0gcmVxdWlyZSgnLi4vLi4vdmlldy92aWV3Jyk7XG52YXIgdG1wbCA9IHJlcXVpcmUoJy4vbWlsZXN0b25lLmhicycpO1xuXG52YXIgUEFERElORyA9IDQ7ICAgIC8vIOuniOydvOyKpO2GpCDqt7jrpqzrk5wg64K0IO2MqOuUqSDqsJIgKHRvcCArIGhlaWdodClcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtWaWV3fVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yZW5kZXJTdGFydERhdGUgLSBzdGFydCBkYXRlIG9mIGFsbGRheSB2aWV3J3MgcmVuZGVyIGRhdGUuIFlZWVktTU0tRERcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJlbmRlckVuZERhdGUgLSBlbmQgZGF0ZSBvZiBhbGxkYXkgdmlldydzIHJlbmRlciBkYXRlLiBZWVlZLU1NLUREXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWluSGVpZ2h0PTQwXSAtIG1pbi1oZWlnaHQgb2YgbWlsZXN0b25lIHZpZXcgXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGluZUhlaWdodD0xMl0gLSBsaW5lIGhlaWdodCBvZiBtaWxlc3RvbmUgdmlld1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIC0gY29udGFpbmVyIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gTWlsZXN0b25lKG9wdGlvbnMsIGNvbnRhaW5lcikge1xuICAgIGNvbnRhaW5lciA9IGRvbXV0aWwuYXBwZW5kSFRNTEVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGNvbmZpZy5jbGFzc25hbWUoJ21pbGVzdG9uZS1jb250YWluZXInKVxuICAgICk7XG5cbiAgICBWaWV3LmNhbGwodGhpcywgY29udGFpbmVyKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICByZW5kZXJTdGFydERhdGU6ICcnLFxuICAgICAgICByZW5kZXJFbmREYXRlOiAnJyxcbiAgICAgICAgbWluSGVpZ2h0OiA0MCxcbiAgICAgICAgbGluZUhlaWdodDogMTJcbiAgICB9LCBvcHRpb25zKTtcbn1cblxudXRpbC5pbmhlcml0KE1pbGVzdG9uZSwgVmlldyk7XG5cbi8qKlxuICogR2V0IGJhc2Ugdmlld21vZGVsIGZvciB0YXNrIHZpZXdcbiAqIEBwYXJhbSB7b2JqZWN0fSBbdmlld01vZGVsXSAtIHZpZXcgbW9kZWwgZnJvbSBwYXJlbnQgdmlld1xuICogQHJldHVybnMge29iamVjdH0gdmlldyBtb2RlbCBmb3IgdGFzayB2aWV3XG4gKi9cbk1pbGVzdG9uZS5wcm90b3R5cGUuX2dldEJhc2VWaWV3TW9kZWwgPSBmdW5jdGlvbih2aWV3TW9kZWwpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZXZlbnRzID0ge30sXG4gICAgICAgIHJhbmdlID0gZGF0ZXRpbWUucmFuZ2UoXG4gICAgICAgICAgICBkYXRldGltZS5zdGFydChkYXRldGltZS5wYXJzZShvcHRpb25zLnJlbmRlclN0YXJ0RGF0ZSkpLFxuICAgICAgICAgICAgZGF0ZXRpbWUuZW5kKGRhdGV0aW1lLnBhcnNlKG9wdGlvbnMucmVuZGVyRW5kRGF0ZSkpLFxuICAgICAgICAgICAgZGF0ZXRpbWUuTUlMTElTRUNPTkRTX1BFUl9EQVlcbiAgICAgICAgKSxcbiAgICAgICAgaGVpZ2h0O1xuXG4gICAgdXRpbC5mb3JFYWNoKHJhbmdlLCBmdW5jdGlvbihkKSB7XG4gICAgICAgIGV2ZW50c1tkYXRldGltZS5mb3JtYXQoZCwgJ1lZWVktTU0tREQnKV0gPSB7fTtcbiAgICB9KTtcblxuICAgIHV0aWwuZXh0ZW5kKGV2ZW50cywgdmlld01vZGVsKTtcblxuICAgIGhlaWdodCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHV0aWwubWFwKGV2ZW50cywgZnVuY3Rpb24oY29sbCkge1xuICAgICAgICByZXR1cm4gY29sbC5sZW5ndGg7XG4gICAgfSkpICogb3B0aW9ucy5saW5lSGVpZ2h0O1xuXG4gICAgaGVpZ2h0ID0gTWF0aC5tYXgob3B0aW9ucy5taW5IZWlnaHQsIGhlaWdodCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBldmVudHM6IGV2ZW50cyxcbiAgICAgICAgd2lkdGg6IDEwMCAvIHJhbmdlLmxlbmd0aCxcbiAgICAgICAgbWluSGVpZ2h0OiBvcHRpb25zLm1pbkhlaWdodCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyBQQURESU5HLFxuICAgICAgICBsaW5lSGVpZ2h0OiBvcHRpb25zLmxpbmVIZWlnaHRcbiAgICB9O1xufTtcblxuLyoqXG4gKiDrp4jsnbzsiqTthqQg67ewIOugjOuNlOungVxuICogQG92ZXJyaWRlXG4gKi9cbk1pbGVzdG9uZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24odmlld01vZGVsKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLFxuICAgICAgICBiYXNlVmlld01vZGVsID0gdGhpcy5fZ2V0QmFzZVZpZXdNb2RlbCh1dGlsLnBpY2sodmlld01vZGVsLmV2ZW50c0luRGF0ZVJhbmdlLCAnbWlsZXN0b25lJykpO1xuXG4gICAgY29udGFpbmVyLnN0eWxlLm1pbkhlaWdodCA9IHRoaXMub3B0aW9ucy5taW5IZWlnaHQgKyAncHgnO1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSB0bXBsKGJhc2VWaWV3TW9kZWwpO1xuXG4gICAgdXRpbC5mb3JFYWNoKGRvbXV0aWwuZmluZCgnbGknLCBjb250YWluZXIsIHRydWUpLCBmdW5jdGlvbihlbCkge1xuICAgICAgICBpZiAoZWwub2Zmc2V0V2lkdGggPCBlbC5zY3JvbGxXaWR0aCkge1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCd0aXRsZScsIGRvbXV0aWwuZ2V0RGF0YShlbCwgJ3RpdGxlJykpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1pbGVzdG9uZTtcblxuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcIjFcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHJldHVybiBcIjx0aD5cIlxuICAgICsgY29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb24oY29udGFpbmVyLmxhbWJkYShkZXB0aDAsIGRlcHRoMCkpXG4gICAgKyBcIjwvdGg+XFxuXCI7XG59LFwiM1wiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMTtcblxuICByZXR1cm4gXCI8dHI+XFxuXCJcbiAgICArICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSxkZXB0aDAse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSg0LCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L3RyPlxcblwiO1xufSxcIjRcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sIGFsaWFzMj1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGFsaWFzMz1cImZ1bmN0aW9uXCIsIGFsaWFzND1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbjtcblxuICByZXR1cm4gXCI8dGQgY2xhc3M9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIm1pbmljYWxlbmRhci1cIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMueW1kIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC55bWQgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcInltZFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCIgXFxuXCJcbiAgICArICgoc3RhY2sxID0gaGVscGVyc1tcImlmXCJdLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5pc05vdFRoaXNNb250aCA6IGRlcHRoMCkse1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oNSwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArICgoc3RhY2sxID0gaGVscGVyc1tcImlmXCJdLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5zZWxlY3RlZCA6IGRlcHRoMCkse1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oNywgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArICgoc3RhY2sxID0gaGVscGVyc1tcImlmXCJdLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50b2RheSA6IGRlcHRoMCkse1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oOSwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArICgoc3RhY2sxID0gaGVscGVyc1tcImlmXCJdLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5oYXNTY2hlZHVsZSA6IGRlcHRoMCkse1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMTEsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAud2Vla2VuZCA6IGRlcHRoMCkse1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMTMsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIlxcXCI+XFxuPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgY2xhc3M9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIm1pbmljYWxlbmRhci1kYXRlXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwibWluaWNhbGVuZGFyLWxhYmVsXFxcIj48c3Bhbj5cIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuZCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiZFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCI8L3NwYW4+PC9kaXY+XFxuPC9idXR0b24+XFxuPC90ZD5cXG5cIjtcbn0sXCI1XCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgaGVscGVyO1xuXG4gIHJldHVybiBjb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVycy5oZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gXCJmdW5jdGlvblwiID8gaGVscGVyLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIm1pbmljYWxlbmRhci1vdGhlciBcIjtcbn0sXCI3XCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgaGVscGVyO1xuXG4gIHJldHVybiBjb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVycy5oZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gXCJmdW5jdGlvblwiID8gaGVscGVyLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIm1pbmljYWxlbmRhci1mb2N1c2VkIFwiO1xufSxcIjlcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBoZWxwZXI7XG5cbiAgcmV0dXJuIGNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJzLmhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBcImZ1bmN0aW9uXCIgPyBoZWxwZXIuY2FsbChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwibWluaWNhbGVuZGFyLXRvZGF5IFwiO1xufSxcIjExXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgaGVscGVyO1xuXG4gIHJldHVybiBjb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVycy5oZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gXCJmdW5jdGlvblwiID8gaGVscGVyLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIm1pbmljYWxlbmRhci1oYXMtc2NoZWR1bGUgXCI7XG59LFwiMTNcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBoZWxwZXI7XG5cbiAgcmV0dXJuIGNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJzLmhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBcImZ1bmN0aW9uXCIgPyBoZWxwZXIuY2FsbChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwibWluaWNhbGVuZGFyLXdlZWtlbmQgXCI7XG59LFwiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMSwgaGVscGVyLCBhbGlhczE9ZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSwgYWxpYXMyPWhlbHBlcnMuaGVscGVyTWlzc2luZywgYWxpYXMzPVwiZnVuY3Rpb25cIiwgYWxpYXM0PWNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uO1xuXG4gIHJldHVybiBcIjx0YWJsZT5cXG48Y2FwdGlvbj5cXG4gICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJtaW5pY2FsZW5kYXItbmF2IFwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIm1pbmljYWxlbmRhci1wcmV2XFxcIj48c3Bhbj4mbHQ7PC9zcGFuPjwvYnV0dG9uPlxcbiAgICA8c3BhbiBjbGFzcz1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwibWluaWNhbGVuZGFyLXRpdGxlXFxcIj5cIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudGl0bGUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnRpdGxlIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJ0aXRsZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCI8L3NwYW4+XFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwibWluaWNhbGVuZGFyLW5hdiBcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJtaW5pY2FsZW5kYXItbmV4dFxcXCI+PHNwYW4+Jmd0Ozwvc3Bhbj48L2J1dHRvbj5cXG48L2NhcHRpb24+XFxuPHRoZWFkPjx0cj5cXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmRheW5hbWUgOiBkZXB0aDApLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMSwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiPC90cj48L3RoZWFkPlxcbjx0Ym9keT5cXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNhbGVuZGFyIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDMsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIjwvdGJvZHk+XFxuPC90YWJsZT5cXG5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1pbmljYWxlbmRhciB2aWV3LlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwudHVpLnV0aWw7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vY29uZmlnJyk7XG52YXIgVmlldyA9IHJlcXVpcmUoJy4uLy4uL3ZpZXcvdmlldycpO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIGRvbWV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbWV2ZW50Jyk7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciB0bXBsID0gcmVxdWlyZSgnLi9taW5pY2FsZW5kYXIuaGJzJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7Vmlld31cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgbWluaWNhbGVuZGFyIHZpZXdcbiAqICBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RhcnREYXlPZldlZWs9MF0gLSBzdGFydCBkYXkgb2Ygd2Vlay4gZGVmYXVsdCAwIChzdW5kYXkpXG4gKiAgQHBhcmFtIHtzdHJpbmd8RGF0ZX0gW29wdGlvbnMucmVuZGVyTW9udGhdIC0gbW9udGggdG8gcmVuZGVyXG4gKiAgQHBhcmFtIHtzdHJpbmdbXX0gW29wdGlvbnMuaGlnaGxpZ2h0RGF0ZV0gLSBkYXRlcyB0byBoaWdobGlnaHRcbiAqICBAcGFyYW0ge3N0cmluZ1tdfSBbb3B0aW9ucy5kYXluYW1lc10gLSBhcnJheSBvZiBlYWNoIGRheXMgbmFtZS5cbiAqIEBwYXJhbSB7SFRNTERpdkVsZW1lbnR9IGNvbnRhaW5lciAtIGVsZW1lbnQgdG8gdXNlIGNvbnRhaW5lclxuICovXG5mdW5jdGlvbiBNaW5pQ2FsZW5kYXIob3B0aW9ucywgY29udGFpbmVyKSB7XG4gICAgdmFyIHRvZGF5ID0gZGF0ZXRpbWUuc3RhcnQobmV3IERhdGUoKSk7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWluaUNhbGVuZGFyKSkge1xuICAgICAgICByZXR1cm4gbmV3IE1pbmlDYWxlbmRhcihvcHRpb25zLCBjb250YWluZXIpO1xuICAgIH1cblxuICAgIFZpZXcuY2FsbCh0aGlzLCBjb250YWluZXIpO1xuICAgIGRvbXV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCBjb25maWcuY2xhc3NuYW1lKCdtaW5pY2FsZW5kYXInKSk7XG4gICAgZG9tZXZlbnQub24odGhpcy5jb250YWluZXIsICdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICBzdGFydERheU9mV2VlazogMCxcbiAgICAgICAgcmVuZGVyTW9udGg6IG5ldyBEYXRlKCt0b2RheSksXG4gICAgICAgIGhpZ2hsaWdodERhdGU6IFtdLFxuICAgICAgICBkYXluYW1lczogWyfsnbwnLCAn7JuUJywgJ+2ZlCcsICfsiJgnLCAn66qpJywgJ+q4iCcsICfthqAnXVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgLy8gcGFyc2UgcmVuZGVyTW9udGggb3B0aW9ucyBpZiBpdCBpcyBhbiBzdHJpbmdcbiAgICBpZiAodXRpbC5pc1N0cmluZyhvcHRpb25zLnJlbmRlck1vbnRoKSkge1xuICAgICAgICBvcHRpb25zLnJlbmRlck1vbnRoID0gZGF0ZXRpbWUuc3RhcnQoZGF0ZXRpbWUucGFyc2Uob3B0aW9ucy5yZW5kZXJNb250aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOydvOyekCDqsJXsobAg642w7J207YSwXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmhsRGF0YSA9IHt9O1xuICAgIGlmIChvcHRpb25zLmhpZ2hsaWdodERhdGUubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0RGF0ZShvcHRpb25zLmhpZ2hsaWdodERhdGUpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyKCk7XG59XG5cbnV0aWwuaW5oZXJpdChNaW5pQ2FsZW5kYXIsIFZpZXcpO1xuXG4vKipcbiAqIE5leHQsIFByZXYgYnV0dG9uIGV2ZW50IGhhbmRsZXJcbiAqIEBmaXJlcyBNaW5pY2FsZW5kYXIjY2hhbmdlXG4gKiBAcGFyYW0ge0hUTUxCdXR0b25FbGVtZW50fSBidXR0b25FbGVtZW50IC0gbmV4dCwgcHJldiBidXR0b24gZnJvbSBfb25DbGljayBldmVudCBoYW5kbGVyXG4gKi9cbk1pbmlDYWxlbmRhci5wcm90b3R5cGUuX25hdiA9IGZ1bmN0aW9uKGJ1dHRvbkVsZW1lbnQpIHtcbiAgICB2YXIgaXNOZXh0ID0gZG9tdXRpbC5oYXNDbGFzcyhidXR0b25FbGVtZW50LCBjb25maWcuY2xhc3NuYW1lKCdtaW5pY2FsZW5kYXItbmV4dCcpKSxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgb2Zmc2V0ID0gaXNOZXh0ID8gMSA6IC0xLFxuICAgICAgICBldmVudERhdGEgPSB7XG4gICAgICAgICAgICBiZWZvcmU6IHRoaXMuZ2V0U2VsZWN0ZWREYXRlKClcbiAgICAgICAgfTtcblxuICAgIG9wdGlvbnMucmVuZGVyTW9udGguc2V0TW9udGgob3B0aW9ucy5yZW5kZXJNb250aC5nZXRNb250aCgpICsgb2Zmc2V0KTtcblxuICAgIHRoaXMucmVuZGVyKCk7XG5cbiAgICBldmVudERhdGEuYWZ0ZXIgPSB0aGlzLmdldFNlbGVjdGVkRGF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IE1pbmlDYWxlbmRhciNjaGFuZ2VcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7RGF0ZX0gYmVmb3JlIC0gdGhlIGRhdGUgb2YgYmVmb3JlIGNoYW5nZWRcbiAgICAgKiBAcHJvcGVydHkge0RhdGV9IGFmdGVyIC0gdGhlIGRhdGUgb2YgYWZ0ZXIgY2hhbmdlZFxuICAgICAqL1xuICAgIHRoaXMuZmlyZSgnY2hhbmdlJywgZXZlbnREYXRhKTtcbn07XG5cbi8qKlxuICogRGF0ZSBidXR0b24gZXZlbnQgaGFuZGxlclxuICogQGZpcmVzIE1pbmljYWxlbmRhciNjaGFuZ2VcbiAqIEBwYXJhbSB7SFRNTEJ1dHRvbkVsZW1lbnR9IGJ1dHRvbkVsZW1lbnQgLSBkYXRlIGJ1dHRvbiBmcm9tIF9vbkNsaWNrIGV2ZW50IGhhbmRsZXJcbiAqL1xuTWluaUNhbGVuZGFyLnByb3RvdHlwZS5fZGF0ZSA9IGZ1bmN0aW9uKGJ1dHRvbkVsZW1lbnQpIHtcbiAgICB2YXIgdGQgPSBkb211dGlsLmNsb3Nlc3QoYnV0dG9uRWxlbWVudCwgJ3RkJyksXG4gICAgICAgIHRvZGF5ID0gKG5ldyBEYXRlKCkpLFxuICAgICAgICBwcmV2aW91cyxcbiAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgIGV2ZW50RGF0YSA9IHtcbiAgICAgICAgICAgIGJlZm9yZTogdGhpcy5nZXRTZWxlY3RlZERhdGUoKVxuICAgICAgICB9O1xuXG4gICAgaWYgKHRkKSB7XG4gICAgICAgIHByZXZpb3VzID0gZG9tdXRpbC5maW5kKCcuJyArIGNvbmZpZy5jbGFzc25hbWUoJ21pbmljYWxlbmRhci1mb2N1c2VkJyksIHRoaXMuY29udGFpbmVyKTtcblxuICAgICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgICAgIGRvbXV0aWwucmVtb3ZlQ2xhc3MocHJldmlvdXMsIGNvbmZpZy5jbGFzc25hbWUoJ21pbmljYWxlbmRhci1mb2N1c2VkJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9tdXRpbC5hZGRDbGFzcyh0ZCwgY29uZmlnLmNsYXNzbmFtZSgnbWluaWNhbGVuZGFyLWZvY3VzZWQnKSk7XG5cbiAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLmdldFNlbGVjdGVkRGF0ZSgpO1xuXG4gICAgICAgIGlmIChkYXRldGltZS5pc1NhbWVEYXRlKHNlbGVjdGVkLCB0b2RheSkpIHtcbiAgICAgICAgICAgIGRvbXV0aWwuYWRkQ2xhc3ModGQsIGNvbmZpZy5jbGFzc25hbWUoJ21pbmljYWxlbmRhci10b2RheScpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50RGF0YS5hZnRlciA9IHNlbGVjdGVkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXZlbnQgTWluaUNhbGVuZGFyI2NoYW5nZVxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJvcGVydHkge0RhdGV9IGJlZm9yZSAtIHRoZSBkYXRlIG9mIGJlZm9yZSBjaGFuZ2VkXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7RGF0ZX0gYWZ0ZXIgLSB0aGUgZGF0ZSBvZiBhZnRlciBjaGFuZ2VkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpcmUoJ2NoYW5nZScsIGV2ZW50RGF0YSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDbGljayBldmVudCBoYW5kbGVyXG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IGNsaWNrRXZlbnQgLSBjbGljayBtb3VzZSBldmVudCBvYmplY3RcbiAqL1xuTWluaUNhbGVuZGFyLnByb3RvdHlwZS5fb25DbGljayA9IGZ1bmN0aW9uKGNsaWNrRXZlbnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gY2xpY2tFdmVudC5zcmNFbGVtZW50IHx8IGNsaWNrRXZlbnQudGFyZ2V0LFxuICAgICAgICBidXR0b24gPSBkb211dGlsLmNsb3Nlc3QodGFyZ2V0LCAnYnV0dG9uJyk7XG5cbiAgICBpZiAoIWJ1dHRvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRvbXV0aWwuaGFzQ2xhc3MoYnV0dG9uLCBjb25maWcuY2xhc3NuYW1lKCdtaW5pY2FsZW5kYXItZGF0ZScpKSkge1xuICAgICAgICB0aGlzLl9kYXRlKGJ1dHRvbik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZG9tdXRpbC5oYXNDbGFzcyhidXR0b24sIGNvbmZpZy5jbGFzc25hbWUoJ21pbmljYWxlbmRhci1uYXYnKSkpIHtcbiAgICAgICAgdGhpcy5fbmF2KGJ1dHRvbik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCBzZWxlY3RlZCBkYXRhXG4gKiBAcmV0dXJucyB7RGF0ZX0gc2VsZWN0ZWQgZGF0ZVxuICovXG5NaW5pQ2FsZW5kYXIucHJvdG90eXBlLmdldFNlbGVjdGVkRGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvbXV0aWwuZmluZCgnLicgKyBjb25maWcuY2xhc3NuYW1lKCdtaW5pY2FsZW5kYXItZm9jdXNlZCcpLCB0aGlzLmNvbnRhaW5lciksXG4gICAgICAgIG1hdGNoZXM7XG5cbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIG1hdGNoZXMgPSBzZWxlY3RlZC5jbGFzc05hbWUubWF0Y2goY29uZmlnLm1pbmljYWxlbmRhci5nZXREYXRhUmVnRXhwKTtcblxuICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRldGltZS5wYXJzZShtYXRjaGVzWzFdKTtcbn07XG5cbi8qKlxuICogc2VsZWN0IHNwZWNpZmljIGRhdGUuXG4gKiBAcGFyYW0ge0RhdGV8c3RyaW5nfSBkYXRlIC0gZGF0ZSB0byBzZWxlY3RcbiAqL1xuTWluaUNhbGVuZGFyLnByb3RvdHlwZS5zZWxlY3REYXRlID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciBfZGF0ZSwgdGQsIGJ1dHRvbjtcblxuICAgIGlmICh1dGlsLmlzU3RyaW5nKGRhdGUpKSB7XG4gICAgICAgIGRhdGUgPSBkYXRldGltZS5wYXJzZShkYXRlKTtcbiAgICB9XG5cbiAgICBfZGF0ZSA9IGRhdGV0aW1lLmZvcm1hdChkYXRlLCAnWVlZWS1NTS1ERCcpO1xuICAgIHRkID0gZG9tdXRpbC5maW5kKCcuJyArIGNvbmZpZy5jbGFzc25hbWUoJ21pbmljYWxlbmRhci0nKSArIF9kYXRlLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgYnV0dG9uID0gZG9tdXRpbC5maW5kKCdidXR0b24nLCB0ZCk7XG5cbiAgICBpZiAoIXRkIHx8ICFidXR0b24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2RhdGUoYnV0dG9uKTtcbn07XG5cbi8qKlxuICogR2V0IG1pbmljYWxlbmRhciB2aWV3IG1vZGVsXG4gKiBAcGFyYW0ge0RhdGV9IHJlbmRlckRhdGUgLSBEYXRlIHRvIHJlbmRlciBtaW5pY2FsZW5kYXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydERheU9mV2VlayAtIG51bWJlciBvZiBzdGFydCBvZiB3ZWVrICgwOnN1biAuLi4pXG4gKiBAcmV0dXJucyB7b2JqZWN0fSB2aWV3bW9kZWxcbiAqL1xuTWluaUNhbGVuZGFyLnByb3RvdHlwZS5fZ2V0Vmlld01vZGVsID0gZnVuY3Rpb24ocmVuZGVyRGF0ZSwgc3RhcnREYXlPZldlZWspIHtcbiAgICB2YXIgZGF5bmFtZXMgPSB0aGlzLm9wdGlvbnMuZGF5bmFtZXMsXG4gICAgICAgIGhsRGF0YSA9IHRoaXMuaGxEYXRhLFxuICAgICAgICB0b2RheSA9IGRhdGV0aW1lLnN0YXJ0KG5ldyBEYXRlKCkpLFxuICAgICAgICBpc0N1cnJlbnRNb250aCA9IGRhdGV0aW1lLmlzU2FtZU1vbnRoKHJlbmRlckRhdGUsIHRvZGF5KSxcbiAgICAgICAgdmlld01vZGVsID0ge1xuICAgICAgICAgICAgdGl0bGU6IGRhdGV0aW1lLmZvcm1hdChyZW5kZXJEYXRlLCAnWVlZWS5NTScpLFxuICAgICAgICAgICAgc3RhcnREYXlPZldlZWs6IHN0YXJ0RGF5T2ZXZWVrXG4gICAgICAgIH07XG5cbiAgICB2aWV3TW9kZWwuZGF5bmFtZSA9IHV0aWwubWFwKFxuICAgICAgICB1dGlsLnJhbmdlKHN0YXJ0RGF5T2ZXZWVrLCA3KS5jb25jYXQodXRpbC5yYW5nZSg3KSkuc2xpY2UoMCwgNyksXG4gICAgICAgIGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGRheW5hbWVzW2ldOyB9IFxuICAgICk7XG5cbiAgICB2aWV3TW9kZWwuY2FsZW5kYXIgPSBkYXRldGltZS5hcnIyZENhbGVuZGFyKHJlbmRlckRhdGUsIHN0YXJ0RGF5T2ZXZWVrLCBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHZhciBkID0gZGF0ZS5nZXREYXRlKCksXG4gICAgICAgICAgICB5bWQgPSBkYXRldGltZS5mb3JtYXQoZGF0ZSwgJ1lZWVktTU0tREQnKSxcbiAgICAgICAgICAgIGRheSA9IGRhdGUuZ2V0RGF5KCksXG4gICAgICAgICAgICBzZWxlY3RlZCA9IGZhbHNlLFxuICAgICAgICAgICAgaXNUb2RheSA9IGRhdGV0aW1lLmlzU2FtZURhdGUoZGF0ZSwgdG9kYXkpLFxuICAgICAgICAgICAgZGF0ZUlzSW5UaGlzTW9udGggPSBkYXRldGltZS5pc1NhbWVNb250aChkYXRlLCByZW5kZXJEYXRlKTtcblxuICAgICAgICBpZiAoZGF0ZUlzSW5UaGlzTW9udGgpIHtcbiAgICAgICAgICAgIGlmIChpc0N1cnJlbnRNb250aCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1RvZGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaXNUb2RheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChkID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGQ6IGQsXG4gICAgICAgICAgICB5bWQ6IHltZCxcbiAgICAgICAgICAgIGhhc1NjaGVkdWxlOiBobERhdGFbeW1kXSxcbiAgICAgICAgICAgIGlzTm90VGhpc01vbnRoOiAhZGF0ZUlzSW5UaGlzTW9udGgsXG4gICAgICAgICAgICB3ZWVrZW5kOiAoZGF5ID09PSAwIHx8IGRheSA9PT0gNiksXG4gICAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICAgICAgICB0b2RheTogaXNUb2RheVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHZpZXdNb2RlbDtcbn07XG5cbi8qKlxuICogUmVuZGVyIHZpZXdcbiAqL1xuTWluaUNhbGVuZGFyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHJlbmRlckRhdGUgPSBvcHRpb25zLnJlbmRlck1vbnRoLFxuICAgICAgICBzdGFydERheU9mV2VlayA9IG9wdGlvbnMuc3RhcnREYXlPZldlZWssXG4gICAgICAgIHZpZXdNb2RlbDtcblxuICAgIHZpZXdNb2RlbCA9IHRoaXMuX2dldFZpZXdNb2RlbChyZW5kZXJEYXRlLCBzdGFydERheU9mV2Vlayk7XG5cbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gdG1wbCh2aWV3TW9kZWwpO1xufTtcblxuLyoqXG4gKiBDYWNoZSBkYXRhIGZvciBoaWdobGlnaHQgc3BlY2lmaWMgZGF0ZXMgaW4gY2FsZW5kYXIuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBkYXRlU3RyTGlzdCAtIHRoZSBhcnJheSBvZiBkYXRlcyB0byBoaWdobGlnaHQuIChZWVlZLU1NLUREKVxuICogQHBhcmFtIHtib29sZWFufSBbc2lsZW50PWZhbHNlXSAtIHNldCB0cnVlIGZvciBwcmV2ZW50IGF1dG8gcmVuZGVyaW5nLlxuICovXG5NaW5pQ2FsZW5kYXIucHJvdG90eXBlLmhpZ2hsaWdodERhdGUgPSBmdW5jdGlvbihkYXRlU3RyTGlzdCwgc2lsZW50KSB7XG4gICAgdmFyIG93bkRhdGEgPSB0aGlzLmhsRGF0YTtcblxuICAgIHV0aWwuZm9yRWFjaChkYXRlU3RyTGlzdCwgZnVuY3Rpb24oeW1kKSB7XG4gICAgICAgIG93bkRhdGFbeW1kXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2xlYXIgY2FjaGVkIGRhdGEgZm9yIGhpZ2hsaWdodGluZyBzcGVjaWZpYyBkYXRlIGZvciByZXByZXNlbnQgdGhlIGRhdGUgaGFzIHNjaGVkdWxlLlxuICogQHBhcmFtIHtib29sZWFufSBbc2lsZW50PWZhbHNlXSAtIHNldCB0cnVlIGZvciBwcmV2ZW50IGF1dG8gcmVuZGVyaW5nLlxuICovXG5NaW5pQ2FsZW5kYXIucHJvdG90eXBlLmNsZWFySGlnaGxpZ2h0RGF0ZSA9IGZ1bmN0aW9uKHNpbGVudCkge1xuICAgIGRlbGV0ZSB0aGlzLmhsRGF0YTtcbiAgICB0aGlzLmhsRGF0YSA9IHt9O1xuXG4gICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG59O1xuXG51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihNaW5pQ2FsZW5kYXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1pbmlDYWxlbmRhcjtcblxuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcIjFcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sIGFsaWFzMj1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGFsaWFzMz1cImZ1bmN0aW9uXCIsIGFsaWFzND1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbiwgYWxpYXM1PWNvbnRhaW5lci5sYW1iZGE7XG5cbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwidGFzay1kYXlcXFwiIHN0eWxlPVxcXCJ3aWR0aDpcIlxuICAgICsgYWxpYXM0KGFsaWFzNSgoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS53aWR0aCksIGRlcHRoMCkpXG4gICAgKyBcIiU7bGVmdDpcIlxuICAgICsgYWxpYXM0KChoZWxwZXJzLm11bHRpcGx5IHx8IChkZXB0aDAgJiYgZGVwdGgwLm11bHRpcGx5KSB8fCBhbGlhczIpLmNhbGwoYWxpYXMxLCgoc3RhY2sxID0gKGRhdGEgJiYgZGF0YS5yb290KSkgJiYgc3RhY2sxLndpZHRoKSwoZGF0YSAmJiBkYXRhLmluZGV4KSx7XCJuYW1lXCI6XCJtdWx0aXBseVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSlcbiAgICArIFwiJTttaW4taGVpZ2h0OlwiXG4gICAgKyBhbGlhczQoYWxpYXM1KCgoc3RhY2sxID0gKGRhdGEgJiYgZGF0YS5yb290KSkgJiYgc3RhY2sxLm1pbkhlaWdodCksIGRlcHRoMCkpXG4gICAgKyBcInB4O2hlaWdodDpcIlxuICAgICsgYWxpYXM0KGFsaWFzNSgoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS5oZWlnaHQpLCBkZXB0aDApKVxuICAgICsgXCJweDtcXFwiPlxcbjxkaXYgY2xhc3M9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcInRhc2stZGF5LXdyYXBcXFwiPlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubW9ybmluZyA6IGRlcHRoMCkse1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMiwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArICgoc3RhY2sxID0gaGVscGVyc1tcImlmXCJdLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5sdW5jaCA6IGRlcHRoMCkse1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oNSwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArICgoc3RhY2sxID0gaGVscGVyc1tcImlmXCJdLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5ldmVuaW5nIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSg3LCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbn0sXCIyXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxLCBoZWxwZXIsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LCBhbGlhczI9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBhbGlhczM9XCJmdW5jdGlvblwiLCBhbGlhczQ9Y29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwidGFzay1kdWVkYXRlLWNsYXNzXFxcIiBzdHlsZT1cXFwibGluZS1oZWlnaHQ6XCJcbiAgICArIGFsaWFzNChjb250YWluZXIubGFtYmRhKCgoc3RhY2sxID0gKGRhdGEgJiYgZGF0YS5yb290KSkgJiYgc3RhY2sxLmxpbmVIZWlnaHQpLCBkZXB0aDApKVxuICAgICsgXCJweFxcXCI+PHN0cm9uZz7stpzqt7wg7KCEPC9zdHJvbmc+PC9kaXY+XFxuICAgIDx1bCBjbGFzcz1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwidGFzay1saXN0XFxcIj5cXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChhbGlhczEsKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubW9ybmluZyA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuaXRlbXMgOiBzdGFjazEpLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMywgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiPC91bD5cXG5cIjtcbn0sXCIzXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxLCBoZWxwZXIsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LCBhbGlhczI9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBhbGlhczM9Y29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb24sIGFsaWFzND1jb250YWluZXIubGFtYmRhO1xuXG4gIHJldHVybiBcIjxsaSBkYXRhLWlkPVxcXCJcIlxuICAgICsgYWxpYXMzKChoZWxwZXJzLnN0YW1wIHx8IChkZXB0aDAgJiYgZGVwdGgwLnN0YW1wKSB8fCBhbGlhczIpLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tb2RlbCA6IGRlcHRoMCkse1wibmFtZVwiOlwic3RhbXBcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpXG4gICAgKyBcIlxcXCIgXFxuICAgICAgICBkYXRhLXRpdGxlPVxcXCJcIlxuICAgICsgYWxpYXMzKGFsaWFzNCgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tb2RlbCA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEudGl0bGUgOiBzdGFjazEpLCBkZXB0aDApKVxuICAgICsgXCJcXFwiIFxcbiAgICAgICAgY2xhc3M9XFxcIlwiXG4gICAgKyBhbGlhczMoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IFwiZnVuY3Rpb25cIiA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcInRhc2staXRlbVxcXCIgXFxuICAgICAgICBzdHlsZT1cXFwibGluZS1oZWlnaHQ6XCJcbiAgICArIGFsaWFzMyhhbGlhczQoKChzdGFjazEgPSAoZGF0YSAmJiBkYXRhLnJvb3QpKSAmJiBzdGFjazEubGluZUhlaWdodCksIGRlcHRoMCkpXG4gICAgKyBcInB4O2NvbG9yOlwiXG4gICAgKyBhbGlhczMoYWxpYXM0KCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1vZGVsIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5jb2xvciA6IHN0YWNrMSksIGRlcHRoMCkpXG4gICAgKyBcIlxcXCI+XCJcbiAgICArICgoc3RhY2sxID0gKGhlbHBlcnNbXCJ0YXNrLXRtcGxcIl0gfHwgKGRlcHRoMCAmJiBkZXB0aDBbXCJ0YXNrLXRtcGxcIl0pIHx8IGFsaWFzMikuY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1vZGVsIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJ0YXNrLXRtcGxcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L2xpPlxcblwiO1xufSxcIjVcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sIGFsaWFzMj1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGFsaWFzMz1cImZ1bmN0aW9uXCIsIGFsaWFzND1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbiwgYWxpYXM1PWNvbnRhaW5lci5sYW1iZGE7XG5cbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwidGFzay1kdWVkYXRlLWNsYXNzXFxcIiBzdHlsZT1cXFwibGluZS1oZWlnaHQ6XCJcbiAgICArIGFsaWFzNChhbGlhczUoKChzdGFjazEgPSAoZGF0YSAmJiBkYXRhLnJvb3QpKSAmJiBzdGFjazEubGluZUhlaWdodCksIGRlcHRoMCkpXG4gICAgKyBcInB4XFxcIj48c3Ryb25nPuygkOyLrCDsoIQ8L3N0cm9uZz48L2Rpdj5cXG4gICAgPGRpdiBzdHlsZT1cXFwibGluZS1oZWlnaHQ6XCJcbiAgICArIGFsaWFzNChhbGlhczUoKChzdGFjazEgPSAoZGF0YSAmJiBkYXRhLnJvb3QpKSAmJiBzdGFjazEubGluZUhlaWdodCksIGRlcHRoMCkpXG4gICAgKyBcInB4XFxcIj7soJDsi6wg7KCEPC9kaXY+XFxuICAgIDx1bCBjbGFzcz1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwidGFzay1saXN0XFxcIj5cXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChhbGlhczEsKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubHVuY2ggOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLml0ZW1zIDogc3RhY2sxKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDMsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIjwvdWw+XFxuXCI7XG59LFwiN1wiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMSwgaGVscGVyLCBhbGlhczE9ZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSwgYWxpYXMyPWhlbHBlcnMuaGVscGVyTWlzc2luZywgYWxpYXMzPVwiZnVuY3Rpb25cIiwgYWxpYXM0PWNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uO1xuXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcInRhc2stZHVlZGF0ZS1jbGFzc1xcXCIgc3R5bGU9XFxcImxpbmUtaGVpZ2h0OlwiXG4gICAgKyBhbGlhczQoY29udGFpbmVyLmxhbWJkYSgoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS5saW5lSGVpZ2h0KSwgZGVwdGgwKSlcbiAgICArIFwicHhcXFwiPjxzdHJvbmc+7Ye06re8IOyghDwvc3Ryb25nPjwvZGl2PlxcbiAgICA8dWwgY2xhc3M9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcInRhc2stbGlzdFxcXCI+XFxuXCJcbiAgICArICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoYWxpYXMxLCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmV2ZW5pbmcgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLml0ZW1zIDogc3RhY2sxKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDMsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIjwvdWw+XFxuXCI7XG59LFwiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMSwgaGVscGVyLCBhbGlhczE9ZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSwgYWxpYXMyPWhlbHBlcnMuaGVscGVyTWlzc2luZywgYWxpYXMzPVwiZnVuY3Rpb25cIiwgYWxpYXM0PWNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uO1xuXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcInRhc2stbGVmdFxcXCI+XFxuICAgIDxzcGFuPuyXheustDwvc3Bhbj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJ0YXNrLXJpZ2h0IHNjaGVkdWxlLXZpZXcgY2xlYXJcXFwiPlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZXZlbnRzIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDEsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIjwvZGl2PlxcblwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGFzayB2aWV3IGZvciB1cHBlciBhcmVhIG9mIFdlZWsgdmlldy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLnR1aS51dGlsO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL2NvbmZpZycpO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgVmlldyA9IHJlcXVpcmUoJy4uLy4uL3ZpZXcvdmlldycpO1xudmFyIHRtcGwgPSByZXF1aXJlKCcuL3Rhc2t2aWV3LmhicycpO1xuXG52YXIgUEFERElORyA9IDQ7ICAgIC8vIOq3uOumrOuTnCDrgrQg7Yyo65SpIOqwkiAodG9wICsgaGVpZ2h0KVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge1ZpZXd9XG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIFRhc2tWaWV3XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yZW5kZXJTdGFydERhdGUgLSBzdGFydCBkYXRlIG9mIGFsbGRheSB2aWV3J3MgcmVuZGVyIGRhdGUuIFlZWVktTU0tRERcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJlbmRlckVuZERhdGUgLSBlbmQgZGF0ZSBvZiBhbGxkYXkgdmlldydzIHJlbmRlciBkYXRlLiBZWVlZLU1NLUREXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWluSGVpZ2h0PTQwXSAtIG1pbi1oZWlnaHQgb2YgdGFza3ZpZXdcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5saW5lSGVpZ2h0PTEyXSAtIGxpbmUgaGVpZ2h0IG9mIG1pbGVzdG9uZSB2aWV3XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgLSBjb250YWluZXIgZWxlbWVudFxuICovXG5mdW5jdGlvbiBUYXNrVmlldyhvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICBjb250YWluZXIgPSBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBjb25maWcuY2xhc3NuYW1lKCd0YXNrLWNvbnRhaW5lcicpXG4gICAgKTtcblxuICAgIFZpZXcuY2FsbCh0aGlzLCBjb250YWluZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgIHJlbmRlclN0YXJ0RGF0ZTogJycsXG4gICAgICAgIHJlbmRlckVuZERhdGU6ICcnLFxuICAgICAgICBtaW5IZWlnaHQ6IDQwLFxuICAgICAgICBsaW5lSGVpZ2h0OiAxMlxuICAgIH0sIG9wdGlvbnMpO1xufVxuXG51dGlsLmluaGVyaXQoVGFza1ZpZXcsIFZpZXcpO1xuXG4vKipcbiAqIEdldCBiYXNlIHZpZXdtb2RlbCBmb3IgdGFzayB2aWV3XG4gKiBAcGFyYW0ge29iamVjdH0gW3ZpZXdNb2RlbF0gLSB2aWV3IG1vZGVsIGZyb20gcGFyZW50IHZpZXdcbiAqIEByZXR1cm5zIHtvYmplY3R9IHZpZXcgbW9kZWwgZm9yIHRhc2sgdmlld1xuICovXG5UYXNrVmlldy5wcm90b3R5cGUuX2dldEJhc2VWaWV3TW9kZWwgPSBmdW5jdGlvbih2aWV3TW9kZWwpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZXZlbnRzID0ge30sXG4gICAgICAgIHJhbmdlID0gZGF0ZXRpbWUucmFuZ2UoXG4gICAgICAgICAgICBkYXRldGltZS5zdGFydChkYXRldGltZS5wYXJzZShvcHRpb25zLnJlbmRlclN0YXJ0RGF0ZSkpLFxuICAgICAgICAgICAgZGF0ZXRpbWUuZW5kKGRhdGV0aW1lLnBhcnNlKG9wdGlvbnMucmVuZGVyRW5kRGF0ZSkpLFxuICAgICAgICAgICAgZGF0ZXRpbWUuTUlMTElTRUNPTkRTX1BFUl9EQVlcbiAgICAgICAgKSxcbiAgICAgICAgaGVpZ2h0ID0gMCxcbiAgICAgICAgbW1heCA9IE1hdGgubWF4O1xuXG4gICAgdXRpbC5mb3JFYWNoKHJhbmdlLCBmdW5jdGlvbihkKSB7XG4gICAgICAgIGV2ZW50c1tkYXRldGltZS5mb3JtYXQoZCwgJ1lZWVktTU0tREQnKV0gPSB7fTtcbiAgICB9KTtcblxuICAgIHV0aWwuZXh0ZW5kKGV2ZW50cywgdmlld01vZGVsKTtcblxuICAgIC8vICjstpzqt7zsoIQsIOygkOyLrOyghCwg7Ye06re87KCEIO2VreuqqSDsiJggKiAxMnB4KSArICjqsIEg7ZWt66qp7J2YIOyVhOydtO2FnCDsiJggKiAxMnB4KVxuICAgIGhlaWdodCA9IG1tYXguYXBwbHkobnVsbCwgdXRpbC5tYXAoZXZlbnRzLCBmdW5jdGlvbihnKSB7XG4gICAgICAgIHZhciBzdWJjb3VudCA9IHV0aWwua2V5cyhnKS5sZW5ndGg7XG5cbiAgICAgICAgdXRpbC5mb3JFYWNoKGcsIGZ1bmN0aW9uKGNvbGwpIHtcbiAgICAgICAgICAgIHN1YmNvdW50ICs9IGNvbGwubGVuZ3RoO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc3ViY291bnQ7XG4gICAgfSkpICogb3B0aW9ucy5saW5lSGVpZ2h0O1xuXG4gICAgaGVpZ2h0ID0gbW1heChvcHRpb25zLm1pbkhlaWdodCwgaGVpZ2h0KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGV2ZW50czogZXZlbnRzLFxuICAgICAgICB3aWR0aDogMTAwIC8gcmFuZ2UubGVuZ3RoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCArIFBBRERJTkcsXG4gICAgICAgIGxpbmVIZWlnaHQ6IG9wdGlvbnMubGluZUhlaWdodFxuICAgIH07XG59O1xuXG4vKipcbiAqIOyXheustCDrt7Ag66CM642U66eBXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVGFza1ZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgYmFzZVZpZXdNb2RlbCA9IHRoaXMuX2dldEJhc2VWaWV3TW9kZWwodXRpbC5waWNrKHZpZXdNb2RlbC5ldmVudHNJbkRhdGVSYW5nZSwgJ3Rhc2snKSk7XG5cbiAgICBjb250YWluZXIuc3R5bGUubWluSGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1pbkhlaWdodCArICdweCc7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IHRtcGwoYmFzZVZpZXdNb2RlbCk7XG5cbiAgICB1dGlsLmZvckVhY2goZG9tdXRpbC5maW5kKCdsaScsIGNvbnRhaW5lciwgdHJ1ZSksIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGlmIChlbC5vZmZzZXRXaWR0aCA8IGVsLnNjcm9sbFdpZHRoKSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgZG9tdXRpbC5nZXREYXRhKGVsLCAndGl0bGUnKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGFza1ZpZXc7XG5cbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZSh7XCJjb21waWxlclwiOls3LFwiPj0gNC4wLjBcIl0sXCJtYWluXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgaGVscGVyLCBhbGlhczE9ZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSwgYWxpYXMyPWhlbHBlcnMuaGVscGVyTWlzc2luZywgYWxpYXMzPVwiZnVuY3Rpb25cIiwgYWxpYXM0PWNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uO1xuXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcInNjcm9sbC15IFwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcImRheW5hbWUtbGF5b3V0XFxcIj48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJzY3JvbGwteSBcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJtaWxlc3RvbmUtbGF5b3V0XFxcIiBzdHlsZT1cXFwibWluLWhlaWdodDo4MHB4O21heC1oZWlnaHQ6MTAwcHhcXFwiPjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcInNjcm9sbC15IFwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcImFsbGRheS1sYXlvdXRcXFwiIHN0eWxlPVxcXCJtaW4taGVpZ2h0OjQ4eDttYXgtaGVpZ2h0OjY4cHhcXFwiPjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcInRpbWVncmlkLWxheW91dFxcXCI+PC9kaXY+XFxuXCI7XG59LFwidXNlRGF0YVwiOnRydWV9KTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBGYWN0b3J5IG1vZHVsZSBmb3IgY29udHJvbCBhbGwgb3RoZXIgZmFjdG9yeS5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLnR1aS51dGlsO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9jb21tb24nKTtcbnZhciBkYXRldGltZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9kYXRldGltZScpO1xudmFyIExheW91dCA9IHJlcXVpcmUoJy4uL3ZpZXcvbGF5b3V0Jyk7XG52YXIgRHJhZyA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvZHJhZycpO1xudmFyIGNvbnRyb2xsZXJGYWN0b3J5ID0gcmVxdWlyZSgnLi9jb250cm9sbGVyJyk7XG52YXIgd2Vla1ZpZXdGYWN0b3J5ID0gcmVxdWlyZSgnLi93ZWVrVmlldycpO1xudmFyIEhhbmRsZWJhcnMgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gQ2FsZW5kYXJ+Q2FsRXZlbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0aXRsZSAtIOydtOuypO2KuCDsoJzrqqlcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNBbGxEYXkgLSDsooXsnbzsnbzsoJXsl6zrtoBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGFydHMgLSDsnbzsoJUg7Iuc7J6RIOyLnOqwhFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGVuZHMgLSDsnbzsoJUg7KKF66OMIOyLnOqwhFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb2xvcl0gLSDsnbzsoJUg7YWN7Iqk7Yq47IOJXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2JnQ29sb3JdIC0g7J287KCVIOuwsOqyveyDiVxuICovXG5cbi8qKlxuICogQ2FsZW5kYXIgY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQG1peGVzIHV0aWwuQ3VzdG9tRXZlbnRzXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIGNhbGVuZGFyXG4gKiAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZ3JvdXBGdW5jXSAtIGZ1bmN0aW9uIGZvciBncm91cCBldmVudCBtb2RlbHMge0BzZWUgQ29sbGVjdGlvbiNncm91cEJ5fVxuICogIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmNvbnRyb2xsZXJdIC0gY29udHJvbGxlciBpbnN0YW5jZVxuICogIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kZWZhdWx0Vmlldz0nd2VlayddIC0gZGVmYXVsdCB2aWV3IG9mIGNhbGVuZGFyXG4gKiAgQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnRlbXBsYXRlXSAtIHRlbXBsYXRlIG9wdGlvblxuICogICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy50ZW1wbGF0ZS5hbGxkYXldIC0gYWxsZGF5IHRlbXBsYXRlIGZ1bmN0aW9uXG4gKiAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnRlbXBsYXRlLnRpbWVdIC0gdGltZSB0ZW1wbGF0ZSBmdW5jdGlvblxuICogIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy53ZWVrXSAtIG9wdGlvbnMgZm9yIHdlZWsgdmlld1xuICogICBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud2Vlay5zdGFydERheU9mV2Vlaz0wXSAtIHN0YXJ0IGRheSBvZiB3ZWVrXG4gKiAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLndlZWsucmVuZGVyU3RhcnREYXRlIC0gWVlZWS1NTS1ERCByZW5kZXIgc3RhcnQgZGF0ZVxuICogICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy53ZWVrLnJlbmRlckVuZERhdGUgLSBZWVlZLU1NLUREIHJlbmRlciBlbmQgZGF0ZVxuICogIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5tb250aF0gLSBvcHRpb25zIGZvciBtb250aCB2aWV3XG4gKiAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm1vbnRoLnJlbmRlck1vbnRoIC0gWVlZWS1NTSByZW5kZXIgbW9udGhcbiAqICBAcGFyYW0ge0NhbGVuZGFyfkNhbEV2ZW50W119IFtvcHRpb25zLmV2ZW50c10gLSBhcnJheSBvZiBDYWxFdmVudCBkYXRhIGZvciBhZGQgY2FsZW5kYXIgYWZ0ZXIgaW5pdGlhbGl6ZS5cbiAqIEBwYXJhbSB7SFRNTERpdkVsZW1lbnR9IGNvbnRhaW5lciA9IGNvbnRhaW5lciBlbGVtZW50IGZvciBjYWxlbmRhclxuICovXG5mdW5jdGlvbiBDYWxlbmRhcihvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ2FsZW5kYXIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2FsZW5kYXIob3B0aW9ucywgY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBiYXNlIGRhdGUgb2YgdmlldyAodG9kYXkoKSB3aWxsIHVzZSB0aGlzIHByb3BlcnR5KVxuICAgICAqIEB0eXBlIHtEYXRlfVxuICAgICAqL1xuICAgIHRoaXMuYmFzZURhdGUgPSBkYXRldGltZS5zdGFydChuZXcgRGF0ZSgpKTtcblxuICAgIC8qKlxuICAgICAqIGRlZmF1bHQgb3B0aW9uIGZyb20gc2VydmljZSBwYWdlXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBvcmlnaW5hbCBvcHRpb25zIGZvciByZWZlcmVuY2Ugd2hlbiB1aSByZXNldFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5PcHRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLm9wdGlvbnMpKTtcblxuICAgIC8qKlxuICAgICAqIGJhc2UgY29udHJvbGxlclxuICAgICAqIEB0eXBlIHtCYXNlfVxuICAgICAqL1xuICAgIHRoaXMuY29udHJvbGxlciA9IG9wdGlvbnMuY29udHJvbGxlciB8fCBjb250cm9sbGVyRmFjdG9yeShvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIGxheW91dCB2aWV3IChsYXlvdXQgbWFuYWdlcilcbiAgICAgKiBAdHlwZSB7TGF5b3V0fVxuICAgICAqL1xuICAgIHRoaXMubGF5b3V0ID0gbmV3IExheW91dChjb250YWluZXIpO1xuXG4gICAgLyoqXG4gICAgICogZ2xvYmFsIGRyYWcgaGFuZGxlclxuICAgICAqIEB0eXBlIHtEcmFnfVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBuZXcgRHJhZyh7XG4gICAgICAgIGRpc3RhbmNlOiA1XG4gICAgfSwgdGhpcy5sYXlvdXQpO1xuXG5cbiAgICAvKipcbiAgICAgKiBjdXJyZW50IHJlbmRlcmVkIHZpZXcgbmFtZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudFZpZXdOYW1lID0gb3B0aW9ucy5kZWZhdWx0VmlldyB8fCAnd2Vlayc7XG5cbiAgICAvKioqKioqKioqKlxuICAgICAqIFNFVFRJTkdcbiAgICAgKioqKioqKioqKi9cbiAgICB0aGlzLmxheW91dC5jb250cm9sbGVyID0gdGhpcy5jb250cm9sbGVyO1xuXG4gICAgZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoQ2hpbGRWaWV3KCk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250cm9sbGVyLm9uKHtcbiAgICAgICAgdXBkYXRlRXZlbnQ6IHJlZnJlc2gsXG4gICAgICAgIGNyZWF0ZWRFdmVudDogcmVmcmVzaFxuICAgIH0sIHRoaXMpO1xuXG4gICAgaWYgKG9wdGlvbnMuZXZlbnRzICYmIG9wdGlvbnMuZXZlbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmNyZWF0ZUV2ZW50KG9wdGlvbnMuZXZlbnRzLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLl9jdXJyZW50U3RhcnREYXRlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEYXRlfVxuICAgICAqL1xuICAgIHRoaXMuX2N1cnJlbnRFbmREYXRlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLl9yZWZyZXNoTWV0aG9kID0gbnVsbDtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZVZpZXcoKTtcbn1cblxuLyoqKioqKioqKipcbiAqIENSVUQgTWV0aG9kc1xuICoqKioqKioqKiovXG5cbi8qKlxuICogQ3JlYXRlIGV2ZW50cyBpbnN0YW5jZSBhbmQgcmVuZGVyIGNhbGVuZGFyLlxuICogQHBhcmFtIHtDYWxlbmRhcn5FdmVudFtdfSBkYXRhT2JqZWN0TGlzdCAtIGFycmF5IG9mIHtAc2VlIENhbGVuZGFyfkV2ZW50fSBvYmplY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NpbGVudD1mYWxzZV0gLSBubyBhdXRvIHJlbmRlciBhZnRlciBjcmVhdGlvbiB3aGVuIHNldCB0cnVlXG4gKi9cbkNhbGVuZGFyLnByb3RvdHlwZS5jcmVhdGVFdmVudHMgPSBmdW5jdGlvbihkYXRhT2JqZWN0TGlzdCwgc2lsZW50KSB7XG4gICAgdGhpcy5jb250cm9sbGVyLmNyZWF0ZUV2ZW50cyhkYXRhT2JqZWN0TGlzdCwgc2lsZW50KTtcblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgZXZlbnQgaW5zdGFuY2UgYnkgZXZlbnQgaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIElEIG9mIGV2ZW50IGluc3RhbmNlXG4gKiBAcmV0dXJucyB7Q2FsRXZlbnR9IGV2ZW50IGluc3RhbmNlXG4gKi9cbkNhbGVuZGFyLnByb3RvdHlwZS5nZXRFdmVudCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHV0aWwucGljayh0aGlzLmNvbnRyb2xsZXIuZXZlbnRzLml0ZW1zLCBpZCk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBldmVudCBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gSUQgb2YgZXZlbnQgaW5zdGFuY2UgdG8gdXBkYXRlIGRhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gb2JqZWN0IGRhdGEgdG8gdXBkYXRlIGluc3RhbmNlXG4gKi9cbkNhbGVuZGFyLnByb3RvdHlwZS51cGRhdGVFdmVudCA9IGZ1bmN0aW9uKGlkLCBkYXRhKSB7XG4gICAgdmFyIGZvdW5kO1xuXG4gICAgdGhpcy5jb250cm9sbGVyLmV2ZW50cy5kb1doZW5IYXMoaWQsIGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIGZvdW5kID0gbW9kZWw7XG4gICAgICAgIHV0aWwuZm9yRWFjaChkYXRhLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBtb2RlbC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgICBmb3VuZC5kaXJ0eShmYWxzZSk7XG59O1xuXG4vKipcbiAqIERlbGV0ZSBldmVudCBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gSUQgb2YgZXZlbnQgaW5zdGFuY2UgdG8gZGVsZXRlXG4gKi9cbkNhbGVuZGFyLnByb3RvdHlwZS5kZWxldGVFdmVudCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdGhpcy5jb250cm9sbGVyLmV2ZW50cy5yZW1vdmUoaWQpO1xuICAgIHRoaXMucmVuZGVyKCk7XG59O1xuXG4vKioqKioqKioqKlxuICogUHJpdmF0ZSBNZXRob2RzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBTZXQgY2hpbGQgdmlldydzIG9wdGlvbnMgcmVjdXJzaXZlbHlcbiAqIEBwYXJhbSB7Vmlld30gdmlldyAtIHBhcmVudCB2aWV3XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIC0gb3B0aW9uIG1hbmlwdWxhdGUgZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbkNhbGVuZGFyLnByb3RvdHlwZS5fc2V0T3B0aW9uUmVjdXJzZWl2ZWx5ID0gZnVuY3Rpb24odmlldywgZnVuYykge1xuICAgIHZpZXcucmVjdXJzaXZlKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICB2YXIgb3B0ID0gY2hpbGRWaWV3Lm9wdGlvbnM7XG5cbiAgICAgICAgaWYgKCFvcHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmMob3B0KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8RGF0ZX0gZGF0ZSAtIGRhdGUgdG8gc2hvdyBpbiBjYWxlbmRhclxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydERheU9mV2Vlaz0wXSAtIHN0YXJ0IGRheSBvZiB3ZWVrXG4gKiBAcmV0dXJuIHthcnJheX0gcmVuZGVyIHJhbmdlXG4gKiBAcHJpdmF0ZVxuICovXG5DYWxlbmRhci5wcm90b3R5cGUuX2dldFdlZWtSZW5kZXJSYW5nZSA9IGZ1bmN0aW9uKGRhdGUsIHN0YXJ0RGF5T2ZXZWVrKSB7XG4gICAgdmFyIGRheSwgc3RhcnQsIGVuZDtcblxuICAgIGRhdGUgPSB1dGlsLmlzRGF0ZShkYXRlKSA/IGRhdGUgOiBuZXcgRGF0ZShkYXRlKTtcbiAgICBzdGFydERheU9mV2VlayA9IChzdGFydERheU9mV2VlayB8fCAwKTtcbiAgICBkYXkgPSBkYXRlLmdldERheSgpO1xuXG4gICAgZnVuY3Rpb24gbWlsKGQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZICogZDtcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgZGVmYXVsdCByZW5kZXIgcmFuZ2UgZmlyc3QuXG4gICAgc3RhcnQgPSBuZXcgRGF0ZSgrZGF0ZSAtIG1pbChkYXkpICsgbWlsKHN0YXJ0RGF5T2ZXZWVrKSk7XG4gICAgZW5kID0gbmV3IERhdGUoK3N0YXJ0ICsgbWlsKDYpKTtcblxuICAgIGlmIChkYXkgPCBzdGFydERheU9mV2Vlaykge1xuICAgICAgICBzdGFydCA9IG5ldyBEYXRlKCtzdGFydCAtIG1pbCg3KSk7XG4gICAgICAgIGVuZCA9IG5ldyBEYXRlKCtlbmQgLSBtaWwoNykpO1xuICAgIH1cblxuICAgIHJldHVybiBbc3RhcnQsIGVuZF07XG59O1xuXG4vKioqKioqKioqKlxuICogR2VuZXJhbCBNZXRob2RzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBEZWxldGUgYWxsIGRhdGEgYW5kIGNsZWFyIHZpZXcuXG4gKi9cbkNhbGVuZGFyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udHJvbGxlci5kYXRlTWF0cml4ID0ge307XG4gICAgdGhpcy5jb250cm9sbGVyLmV2ZW50cy5jbGVhcigpO1xuICAgIHRoaXMucmVuZGVyKCk7XG59O1xuXG4vKipcbiAqIFJlbmRlciBjYWxlbmRhci5cbiAqL1xuQ2FsZW5kYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubGF5b3V0LnJlbmRlcigpO1xufTtcblxuLyoqXG4gKiBSZWZyZXNoIGNhbGVuZGFyIGxheW91dC5cbiAqL1xuQ2FsZW5kYXIucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fcmVmcmVzaE1ldGhvZCkge1xuICAgICAgICB0aGlzLl9yZWZyZXNoTWV0aG9kKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGN1cnJlbnQgdmlldy5cbiAqL1xuQ2FsZW5kYXIucHJvdG90eXBlLmluaXRpYWxpemVWaWV3ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1cnJlbnRWaWV3TmFtZSA9IHRoaXMuY3VycmVudFZpZXdOYW1lLFxuICAgICAgICBvcHRpb25zO1xuXG4gICAgdGhpcy50b2dnbGVWaWV3KGN1cnJlbnRWaWV3TmFtZSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50Vmlld05hbWUgPT09ICd3ZWVrJykge1xuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLndlZWs7XG4gICAgICAgIHRoaXMuc2V0RGF0ZShvcHRpb25zLnJlbmRlclN0YXJ0RGF0ZSwgb3B0aW9ucy5yZW5kZXJFbmREYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvL1RPRE86IG1vbnRoIHZpZXcuXG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXQgY2FsZW5kYXIncyByZW5kZXIgZGF0ZSByYW5nZSBhbmQgcmVmcmVzaCB2aWV3XG4gKiBAcGFyYW0ge3N0cmluZ3xEYXRlfSBzdGFydCAtIHN0YXJ0IGRhdGUgb2YgcmVuZGVyXG4gKiBAcGFyYW0ge3N0cmluZ3xEYXRlfSBlbmQgLSBlbmQgZGF0ZSBvZiByZW5kZXJcbiAqL1xuQ2FsZW5kYXIucHJvdG90eXBlLnNldERhdGUgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgdmFyIHltZCA9ICdZWVlZLU1NLUREJztcbiAgICBzdGFydCA9IHV0aWwuaXNEYXRlKHN0YXJ0KSA/IHN0YXJ0IDogbmV3IERhdGUoc3RhcnQpO1xuXG4gICAgaWYgKHRoaXMuY3VycmVudFZpZXdOYW1lID09PSAnd2VlaycpIHtcbiAgICAgICAgaWYgKCFlbmQpIHtcbiAgICAgICAgICAgIGNvbmZpZy50aHJvd0Vycm9yKCdDYWxlbmRhciNzZXREYXRlKCkgTmVlZCAyIHBhcmFtZXRlciAoc3RhcnQsIGVuZCkgaW4gXCJ3ZWVrXCIgdmlldy4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbmQgPSB1dGlsLmlzRGF0ZShlbmQpID8gZW5kIDogbmV3IERhdGUoZW5kKTtcblxuICAgICAgICB0aGlzLl9jdXJyZW50U3RhcnREYXRlID0gbmV3IERhdGUoK3N0YXJ0KTtcbiAgICAgICAgdGhpcy5fY3VycmVudEVuZERhdGUgPSBuZXcgRGF0ZSgrZW5kKTtcblxuICAgICAgICBzdGFydCA9IGRhdGV0aW1lLmZvcm1hdChzdGFydCwgeW1kKTtcbiAgICAgICAgZW5kID0gZGF0ZXRpbWUuZm9ybWF0KGVuZCwgeW1kKTtcblxuICAgICAgICB0aGlzLl9zZXRPcHRpb25SZWN1cnNlaXZlbHkodGhpcy5nZXRDdXJyZW50VmlldygpLCBmdW5jdGlvbih2aWV3T3B0aW9uKSB7XG4gICAgICAgICAgICB2aWV3T3B0aW9uLnJlbmRlclN0YXJ0RGF0ZSA9IHN0YXJ0O1xuICAgICAgICAgICAgdmlld09wdGlvbi5yZW5kZXJFbmREYXRlID0gZW5kO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvL1RPRE86IG1vbnRoIHZpZXcuXG4gICAgfVxuXG4gICAgdGhpcy5yZWZyZXNoQ2hpbGRWaWV3KHRoaXMuY3VycmVudFZpZXdOYW1lKTtcbn07XG5cbi8qKlxuICogTW92ZSBjdXJyZW50IHJlbmRlciByYW5nZSB0byByYW5nZSB0aGF0IGluY2x1ZGUgc3VwcGxpZWQgZGF0ZVxuICogQHBhcmFtIHtzdHJpbmd8RGF0ZX0gZGF0ZSAtIGRhdGUgdG8gc2hvd1xuICovXG5DYWxlbmRhci5wcm90b3R5cGUuc2hvd0RhdGUgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBkYXRlID0gdXRpbC5pc0RhdGUoZGF0ZSkgPyBkYXRlIDogbmV3IERhdGUoZGF0ZSk7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50Vmlld05hbWUgPT09ICd3ZWVrJykge1xuICAgICAgICB0aGlzLnNldERhdGUuYXBwbHkodGhpcywgdGhpcy5fZ2V0V2Vla1JlbmRlclJhbmdlKGRhdGUsIG9wdGlvbnMuc3RhcnREYXlPZldlZWspKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvL1RPRE86IG1vbnRoIHZpZXcuXG4gICAgfVxufTtcblxuLyoqXG4gKiBNb3ZlIHRvIHRvZGF5LlxuICovXG5DYWxlbmRhci5wcm90b3R5cGUudG9kYXkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNob3dEYXRlKG5ldyBEYXRlKCkpO1xufTtcblxuLyoqXG4gKiBNb3ZlIHRoZSBjYWxlbmRhciBhbW91bnQgb2Ygb2Zmc2V0IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gb2Zmc2V0IHZhbHVlLlxuICogQGV4YW1wbGVcbiAqIC8vIG1vdmUgcHJldmlvdXMgd2VlayB3aGVuIFwid2Vla1wiIHZpZXcuXG4gKiAvLyBtb3ZlIHByZXZpb3VzIG1vbnRoIHdoZW4gXCJtb250aFwiIHZpZXcuXG4gKiBjYWxlbmRhci5tb3ZlKC0xKTtcbiAqL1xuQ2FsZW5kYXIucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9jdXJyZW50U3RhcnREYXRlLFxuICAgICAgICBlbmQgPSB0aGlzLl9jdXJyZW50RW5kRGF0ZSxcbiAgICAgICAgZGlmZjtcblxuICAgIGlmICh0aGlzLmN1cnJlbnRWaWV3TmFtZSA9PT0gJ3dlZWsnKSB7XG4gICAgICAgIGRpZmYgPSAoKGVuZCAtIHN0YXJ0KSArIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZKSAqIChvZmZzZXQgfHwgMCk7XG5cbiAgICAgICAgc3RhcnQgPSBuZXcgRGF0ZSgrc3RhcnQgKyBkaWZmKTtcbiAgICAgICAgZW5kID0gbmV3IERhdGUoK2VuZCArIGRpZmYpO1xuXG4gICAgICAgIHRoaXMuc2V0RGF0ZShzdGFydCwgZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvL1RPRE86IG1vbnRoIHZpZXcuXG4gICAgfVxufTtcblxuLyoqXG4gKiBNb3ZlIHRoZSBjYWxlbmRhciBmb3J3YXJkIGFuIGFydml0cmFyeSBhbW91bnQgb2YgdW5pdFxuICovXG5DYWxlbmRhci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW92ZSgxKTtcbn07XG5cbi8qKlxuICogTW92ZSB0aGUgY2FsZW5kYXIgYmFja3dhcmQgYW4gYXJ2aXRyYXJ5IGFtb3VudCBvZiB1bml0XG4gKi9cbkNhbGVuZGFyLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb3ZlKC0xKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGN1cnJlbnQgcmVuZGVyZWQgdmlldy5cbiAqIEByZXR1cm5zIHtWaWV3fSBjdXJyZW50IHZpZXcgaW5zdGFuY2VcbiAqL1xuQ2FsZW5kYXIucHJvdG90eXBlLmdldEN1cnJlbnRWaWV3ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHV0aWwucGljayh0aGlzLmxheW91dC5jaGlsZHMuaXRlbXMsIHRoaXMuY3VycmVudFZpZXdOYW1lKTtcbn1cblxuLyoqXG4gKiBUb2dnbGUgY3VycmVudCB2aWV3XG4gKiBAcGFyYW0ge3N0cmluZ30gdmlld05hbWUgLSB0aGUgbmFtZSBvZiB2aWV3LlxuICogQHBhcmFtIHtib29sZWFufSBmb3JjZSAtIGZvcmNlIHJlbmRlciBkZXNwaXRlIG9mIGN1cnJlbnQgdmlldyBhbmQgbmV3IHZpZXcgYXJlIGVxdWFsXG4gKi9cbkNhbGVuZGFyLnByb3RvdHlwZS50b2dnbGVWaWV3ID0gZnVuY3Rpb24odmlld05hbWUsIGZvcmNlKSB7XG4gICAgdmFyIGxheW91dCA9IHRoaXMubGF5b3V0LFxuICAgICAgICBjb250cm9sbGVyID0gdGhpcy5jb250cm9sbGVyLFxuICAgICAgICBkcmFnSGFuZGxlciA9IHRoaXMuZHJhZ0hhbmRsZXIsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAoIWZvcmNlICYmIHRoaXMuY3VycmVudFZpZXdOYW1lID09PSB2aWV3TmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50Vmlld05hbWUgPSB2aWV3TmFtZTtcbiAgICBsYXlvdXQuY2xlYXIoKTtcblxuICAgIGlmICh2aWV3TmFtZSA9PT0gJ3dlZWsnKSB7XG4gICAgICAgIGxheW91dC5hZGRDaGlsZCh3ZWVrVmlld0ZhY3RvcnkoY29udHJvbGxlciwgbGF5b3V0LmNvbnRhaW5lciwgZHJhZ0hhbmRsZXIsIG9wdGlvbnMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogRGVzdHJveSBjYWxlbmRhciBpbnN0YW5jZS5cbiAqL1xuQ2FsZW5kYXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRyYWdIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmNvbnRyb2xsZXIub2ZmKCk7XG4gICAgdGhpcy5sYXlvdXQuY2xlYXIoKTtcbiAgICB0aGlzLmxheW91dC5kZXN0cm95KCk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmJhc2VEYXRlID0gdGhpcy5jb250cm9sbGVyID1cbiAgICAgICAgdGhpcy5sYXlvdXQgPSB0aGlzLmRyYWdIYW5kbGVyID0gbnVsbDtcbn1cblxuLyoqXG4gKiBSZWZyZXNoIGNoaWxkIHZpZXdzXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ZpZXdOYW1lXSAtIHRoZSBuYW1lIG9mIHZpZXcgdG8gcmVuZGVyLiBpZiBub3Qgc3VwcGxpZWQgdGhlbiByZWZyZXNoIGFsbC5cbiAqL1xuQ2FsZW5kYXIucHJvdG90eXBlLnJlZnJlc2hDaGlsZFZpZXcgPSBmdW5jdGlvbih2aWV3TmFtZSkge1xuICAgIGlmICghdmlld05hbWUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubGF5b3V0LmNoaWxkcy5pdGVtc1t2aWV3TmFtZV0ucmVuZGVyKCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBkZWZhdWx0IG9wdGlvblxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvcHRpb24gZnJvbSBzZXJ2aWNlIHBhZ2VcbiAqIEByZXR1cm5zIHtvYmplY3R9IGRlZmF1bHQgb3B0aW9uLiBcbiAqL1xuQ2FsZW5kYXIucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIHRvZGF5ID0gdGhpcy5iYXNlRGF0ZSxcbiAgICAgICAgeW1kID0gJ1lZWVktTU0tREQnLFxuICAgICAgICByZW5kZXJSYW5nZSxcbiAgICAgICAgd2Vla09wdCA9IG9wdGlvbnMud2VlayxcbiAgICAgICAgdG1wbE9wdCA9IG9wdGlvbnMudGVtcGxhdGU7XG5cbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICBkZWZhdWx0VmlldzogJ3dlZWsnLCAgICAvLyDquLDrs7gg7KO86rCEIOu3sCDshKTsoJVcbiAgICAgICAgd2VlazogbnVsbCxcbiAgICAgICAgbW9udGg6IG51bGwgXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICB3ZWVrT3B0ID0gb3B0aW9ucy53ZWVrID0gdXRpbC5leHRlbmQoe1xuICAgICAgICBzdGFydERheU9mV2VlazogMFxuICAgIH0sIG9wdGlvbnMud2Vlayk7XG5cbiAgICBpZiAoIXdlZWtPcHQucmVuZGVyU3RhcnREYXRlIHx8ICF3ZWVrT3B0LnJlbmRlckVuZERhdGUpIHtcbiAgICAgICAgcmVuZGVyUmFuZ2UgPSB0aGlzLl9nZXRXZWVrUmVuZGVyUmFuZ2UobmV3IERhdGUoKSwgd2Vla09wdC5zdGFydERheU9mV2Vlayk7XG4gICAgICAgIHdlZWtPcHQucmVuZGVyU3RhcnREYXRlID0gZGF0ZXRpbWUuZm9ybWF0KHJlbmRlclJhbmdlWzBdLCB5bWQpO1xuICAgICAgICB3ZWVrT3B0LnJlbmRlckVuZERhdGUgPSBkYXRldGltZS5mb3JtYXQocmVuZGVyUmFuZ2VbMV0sIHltZCk7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLm1vbnRoKSB7XG4gICAgICAgIG9wdGlvbnMubW9udGggPSB7XG4gICAgICAgICAgICByZW5kZXJNb250aDogZGF0ZXRpbWUuZm9ybWF0KHRvZGF5LCAnWVlZWS1NTScpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdXRpbC5mb3JFYWNoKHRtcGxPcHQsIGZ1bmN0aW9uKGZ1bmMsIG5hbWUpIHtcbiAgICAgICAgSGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcihuYW1lICsgJy10bXBsJywgZnVuYyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5cbnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKENhbGVuZGFyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYWxlbmRhcjtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbnRyb2xsZXIgZmFjdG9yeSBtb2R1bGUuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC50dWkudXRpbDtcbnZhciBCYXNlID0gcmVxdWlyZSgnLi4vY29udHJvbGxlci9iYXNlJyk7XG52YXIgV2VlayA9IHJlcXVpcmUoJy4uL2NvbnRyb2xsZXIvdmlld01peGluL3dlZWsnKTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIGJhc2UgY29udHJvbGxlclxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZ3JvdXBGdW5jXSAtIGZ1bmN0aW9uIGZvciBncm91cCBlYWNoIG1vZGVscyB7QHNlZSBDb2xsZWN0aW9uI2dyb3VwQnl9XG4gKiBAcmV0dXJucyB7QmFzZX0gVGhlIGNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBjb250cm9sbGVyID0gbmV3IEJhc2Uob3B0aW9ucyk7XG5cbiAgICBjb250cm9sbGVyLldlZWsgPSB7fTtcbiAgICB1dGlsLmZvckVhY2goV2VlaywgZnVuY3Rpb24obWV0aG9kLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuV2Vla1ttZXRob2ROYW1lXSA9IHV0aWwuYmluZChtZXRob2QsIGNvbnRyb2xsZXIpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbnRyb2xsZXI7XG59O1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgRmFjdG9yeSBtb2R1bGUgZm9yIFdlZWtWaWV3XG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uL2NvbW1vbi9kb211dGlsJyk7XG4vLyBQYXJlbnQgdmlld3NcbnZhciBXZWVrID0gcmVxdWlyZSgnLi4vdmlldy93ZWVrL3dlZWsnKTtcbi8vIFN1YiB2aWV3c1xudmFyIERheU5hbWUgPSByZXF1aXJlKCcuLi92aWV3L3dlZWsvZGF5bmFtZScpO1xudmFyIFRpbWVHcmlkID0gcmVxdWlyZSgnLi4vdmlldy93ZWVrL3RpbWVHcmlkJyk7XG52YXIgQWxsZGF5ID0gcmVxdWlyZSgnLi4vdmlldy93ZWVrL2FsbGRheScpO1xuLy8gSGFuZGxlcnNcbnZhciBBbGxkYXlDbGljayA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvYWxsZGF5L2NsaWNrJyk7XG52YXIgQWxsZGF5Q3JlYXRpb24gPSByZXF1aXJlKCcuLi9oYW5kbGVyL2FsbGRheS9jcmVhdGlvbicpO1xudmFyIEFsbGRheU1vdmUgPSByZXF1aXJlKCcuLi9oYW5kbGVyL2FsbGRheS9tb3ZlJyk7XG52YXIgQWxsZGF5UmVzaXplID0gcmVxdWlyZSgnLi4vaGFuZGxlci9hbGxkYXkvcmVzaXplJyk7XG52YXIgVGltZUNsaWNrID0gcmVxdWlyZSgnLi4vaGFuZGxlci90aW1lL2NsaWNrJyk7XG52YXIgVGltZUNyZWF0aW9uID0gcmVxdWlyZSgnLi4vaGFuZGxlci90aW1lL2NyZWF0aW9uJyk7XG52YXIgVGltZU1vdmUgPSByZXF1aXJlKCcuLi9oYW5kbGVyL3RpbWUvbW92ZScpO1xudmFyIFRpbWVSZXNpemUgPSByZXF1aXJlKCcuLi9oYW5kbGVyL3RpbWUvcmVzaXplJyk7XG4vLyBCYXNlIFRlbXBsYXRlc1xudmFyIHdlZWtWaWV3VG1wbCA9IHJlcXVpcmUoJy4uL3ZpZXcvdGVtcGxhdGUvZmFjdG9yeS93ZWVrVmlldy5oYnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiYXNlQ29udHJvbGxlciwgbGF5b3V0Q29udGFpbmVyLCBkcmFnSGFuZGxlciwgb3B0aW9ucykge1xuICAgIHZhciB3ZWVrVmlldyxcbiAgICAgICAgZGF5TmFtZVZpZXcsXG4gICAgICAgIGFsbGRheVZpZXcsXG4gICAgICAgIHRpbWVHcmlkVmlldyxcbiAgICAgICAgYWxsZGF5Q2xpY2tIYW5kbGVyLFxuICAgICAgICBhbGxkYXlDcmVhdGlvbkhhbmRsZXIsXG4gICAgICAgIGFsbGRheU1vdmVIYW5kbGVyLFxuICAgICAgICBhbGxkYXlSZXNpemVIYW5kbGVyLFxuICAgICAgICB0aW1lQ2xpY2tIYW5kbGVyLFxuICAgICAgICB0aW1lQ3JlYXRpb25IYW5kbGVyLFxuICAgICAgICB0aW1lTW92ZUhhbmRsZXIsXG4gICAgICAgIHRpbWVSZXNpemVIYW5kbGVyO1xuXG4gICAgd2Vla1ZpZXcgPSBuZXcgV2VlayhudWxsLCBvcHRpb25zLndlZWssIGxheW91dENvbnRhaW5lcik7XG4gICAgd2Vla1ZpZXcuY29udGFpbmVyLmlubmVySFRNTCA9IHdlZWtWaWV3VG1wbCgpO1xuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiDsnbzsnpDtkZzquLAgKOyDgeuLqCDsnbzsm5TtmZTsiJguLi4pXG4gICAgICoqKioqKioqKiovXG4gICAgZGF5TmFtZVZpZXcgPSBuZXcgRGF5TmFtZShudWxsLCBkb211dGlsLmZpbmQoJy4nICsgY29uZmlnLmNsYXNzbmFtZSgnZGF5bmFtZS1sYXlvdXQnKSwgd2Vla1ZpZXcuY29udGFpbmVyKSk7XG4gICAgd2Vla1ZpZXcuYWRkQ2hpbGQoZGF5TmFtZVZpZXcpO1xuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiDsooXsnbzsnbzsoJVcbiAgICAgKioqKioqKioqKi9cbiAgICBhbGxkYXlWaWV3ID0gbmV3IEFsbGRheShvcHRpb25zLndlZWssIGRvbXV0aWwuZmluZCgnLicgKyBjb25maWcuY2xhc3NuYW1lKCdhbGxkYXktbGF5b3V0JyksIHdlZWtWaWV3LmNvbnRhaW5lcikpO1xuICAgIHdlZWtWaWV3LmFkZENoaWxkKGFsbGRheVZpZXcpO1xuICAgIGFsbGRheUNsaWNrSGFuZGxlciA9IG5ldyBBbGxkYXlDbGljayhkcmFnSGFuZGxlciwgYWxsZGF5VmlldywgYmFzZUNvbnRyb2xsZXIpO1xuICAgIGFsbGRheUNyZWF0aW9uSGFuZGxlciA9IG5ldyBBbGxkYXlDcmVhdGlvbihkcmFnSGFuZGxlciwgYWxsZGF5VmlldywgYmFzZUNvbnRyb2xsZXIpO1xuICAgIGFsbGRheU1vdmVIYW5kbGVyID0gbmV3IEFsbGRheU1vdmUoZHJhZ0hhbmRsZXIsIGFsbGRheVZpZXcsIGJhc2VDb250cm9sbGVyKTtcbiAgICBhbGxkYXlSZXNpemVIYW5kbGVyID0gbmV3IEFsbGRheVJlc2l6ZShkcmFnSGFuZGxlciwgYWxsZGF5VmlldywgYmFzZUNvbnRyb2xsZXIpO1xuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiDsi5zqsITrs4Qg7J287KCVXG4gICAgICoqKioqKioqKiovXG4gICAgdGltZUdyaWRWaWV3ID0gbmV3IFRpbWVHcmlkKG9wdGlvbnMud2VlaywgZG9tdXRpbC5maW5kKCcuJyArIGNvbmZpZy5jbGFzc25hbWUoJ3RpbWVncmlkLWxheW91dCcpLCB3ZWVrVmlldy5jb250YWluZXIpKTtcbiAgICB3ZWVrVmlldy5hZGRDaGlsZCh0aW1lR3JpZFZpZXcpO1xuICAgIHRpbWVDbGlja0hhbmRsZXIgPSBuZXcgVGltZUNsaWNrKGRyYWdIYW5kbGVyLCB0aW1lR3JpZFZpZXcsIGJhc2VDb250cm9sbGVyKTtcbiAgICB0aW1lQ3JlYXRpb25IYW5kbGVyID0gbmV3IFRpbWVDcmVhdGlvbihkcmFnSGFuZGxlciwgdGltZUdyaWRWaWV3LCBiYXNlQ29udHJvbGxlcik7XG4gICAgdGltZU1vdmVIYW5kbGVyID0gbmV3IFRpbWVNb3ZlKGRyYWdIYW5kbGVyLCB0aW1lR3JpZFZpZXcsIGJhc2VDb250cm9sbGVyKTtcbiAgICB0aW1lUmVzaXplSGFuZGxlciA9IG5ldyBUaW1lUmVzaXplKGRyYWdIYW5kbGVyLCB0aW1lR3JpZFZpZXcsIGJhc2VDb250cm9sbGVyKTtcblxuICAgIHdlZWtWaWV3LmhhbmRsZXJzID0ge1xuICAgICAgICBjbGljazoge1xuICAgICAgICAgICAgYWxsZGF5OiBhbGxkYXlDbGlja0hhbmRsZXIsXG4gICAgICAgICAgICB0aW1lOiB0aW1lQ2xpY2tIYW5kbGVyXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0aW9uOiB7XG4gICAgICAgICAgICBhbGxkYXk6IGFsbGRheUNyZWF0aW9uSGFuZGxlcixcbiAgICAgICAgICAgIHRpbWU6IHRpbWVDcmVhdGlvbkhhbmRsZXJcbiAgICAgICAgfSxcbiAgICAgICAgbW92ZToge1xuICAgICAgICAgICAgYWxsZGF5OiBhbGxkYXlNb3ZlSGFuZGxlcixcbiAgICAgICAgICAgIHRpbWU6IHRpbWVNb3ZlSGFuZGxlclxuICAgICAgICB9LFxuICAgICAgICByZXNpemU6IHtcbiAgICAgICAgICAgIGFsbGRheTogYWxsZGF5UmVzaXplSGFuZGxlcixcbiAgICAgICAgICAgIHRpbWU6IHRpbWVSZXNpemVIYW5kbGVyXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gYWRkIGNvbnRyb2xsZXJcbiAgICB3ZWVrVmlldy5jb250cm9sbGVyID0gYmFzZUNvbnRyb2xsZXIuV2VlaztcblxuICAgIC8vIGFkZCBkZXN0cm95XG4gICAgd2Vla1ZpZXcuX2JlZm9yZURlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdXRpbC5mb3JFYWNoKHdlZWtWaWV3LmhhbmRsZXJzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICB1dGlsLmZvckVhY2godHlwZSwgZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub2ZmKCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiB3ZWVrVmlldztcbn07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2xpY2sgaGFuZGxlIG1vZHVsZSBmb3IgYWxsZGF5IGV2ZW50c1xuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwudHVpLnV0aWw7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vY29uZmlnJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgQWxsZGF5TW92ZSA9IHJlcXVpcmUoJy4vbW92ZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge0hhbmRsZXJ9XG4gKiBAbWl4ZXMgQ3VzdG9tRXZlbnRzXG4gKiBAcGFyYW0ge0RyYWd9IFtkcmFnSGFuZGxlcl0gLSBEcmFnIGhhbmRsZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0FsbGRheX0gW2FsbGRheVZpZXddIC0gTW9udGhXZWVrIHZpZXcgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0Jhc2V9IFtiYXNlQ29udHJvbGxlcl0gLSBCYXNlIGNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIEFsbGRheUNsaWNrKGRyYWdIYW5kbGVyLCBhbGxkYXlWaWV3LCBiYXNlQ29udHJvbGxlcikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEcmFnfVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBkcmFnSGFuZGxlcjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBbGxkYXl9XG4gICAgICovXG4gICAgdGhpcy5hbGxkYXlWaWV3ID0gYWxsZGF5VmlldztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCYXNlfVxuICAgICAqL1xuICAgIHRoaXMuYmFzZUNvbnRyb2xsZXIgPSBiYXNlQ29udHJvbGxlcjtcblxuICAgIGRyYWdIYW5kbGVyLm9uKHtcbiAgICAgICAgJ2NsaWNrJzogdGhpcy5fb25DbGlja1xuICAgIH0sIHRoaXMpO1xufVxuXG4vKipcbiAqIERlc3Ryb3kgaGFuZGxlciBtb2R1bGVcbiAqL1xuQWxsZGF5Q2xpY2sucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9mZih0aGlzKTtcbiAgICB0aGlzLmFsbGRheVZpZXcgPSB0aGlzLmJhc2VDb250cm9sbGVyID0gdGhpcy5kcmFnSGFuZGxlciA9IG51bGw7XG59O1xuXG4vKipcbiAqIENoZWNrIHRhcmdldCBlbGVtZW50IGlzIGV4cGVjdGVkIGNvbmRpdGlvbiBmb3IgYWN0aXZhdGUgdGhpcyBwbHVnaW5zLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gVGhlIGVsZW1lbnQgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gbW9kZWwgaWRcbiAqL1xuQWxsZGF5Q2xpY2sucHJvdG90eXBlLmNoZWNrRXhwZWN0Q29uZGl0aW9uID0gQWxsZGF5TW92ZS5wcm90b3R5cGUuY2hlY2tFeHBlY3RlZENvbmRpdGlvbjtcblxuLyoqXG4gKiBDbGljayBldmVudCBoYW5kbGVyXG4gKiBAcGFyYW0ge29iamVjdH0gY2xpY2tFdmVudCAtIGNsaWNrIGV2ZW50IGRhdGFcbiAqIEBlbWl0cyBBbGxkYXlDbGljayNjbGlja0V2ZW50XG4gKi9cbkFsbGRheUNsaWNrLnByb3RvdHlwZS5fb25DbGljayA9IGZ1bmN0aW9uKGNsaWNrRXZlbnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gY2xpY2tFdmVudC50YXJnZXQsXG4gICAgICAgIHRpbWVWaWV3ID0gdGhpcy5jaGVja0V4cGVjdENvbmRpdGlvbih0YXJnZXQpLFxuICAgICAgICBibG9ja0VsZW1lbnQgPSBkb211dGlsLmNsb3Nlc3QodGFyZ2V0LCAnLicgKyBjb25maWcuY2xhc3NuYW1lKCdhbGxkYXktZXZlbnQtYmxvY2snKSksXG4gICAgICAgIGV2ZW50Q29sbGVjdGlvbiA9IHRoaXMuYmFzZUNvbnRyb2xsZXIuZXZlbnRzO1xuXG4gICAgaWYgKCF0aW1lVmlldyB8fCAhYmxvY2tFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudENvbGxlY3Rpb24uZG9XaGVuSGFzKGRvbXV0aWwuZ2V0RGF0YShibG9ja0VsZW1lbnQsICdpZCcpLCBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGV2ZW50cyBBbGxkYXlDbGljayNjbGlja0V2ZW50XG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Q2FsRXZlbnR9IG1vZGVsIC0gbW9kZWwgaW5zdGFuY2VcbiAgICAgICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBqc0V2ZW50IC0gTW91c2VFdmVudCBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlyZSgnY2xpY2tFdmVudCcsIHtcbiAgICAgICAgICAgIG1vZGVsOiAgbW9kZWwsXG4gICAgICAgICAgICBqc0V2ZW50OiBjbGlja0V2ZW50Lm9yaWdpbkV2ZW50XG4gICAgICAgIH0pO1xuICAgIH0sIHRoaXMpO1xufTtcblxudXRpbC5DdXN0b21FdmVudHMubWl4aW4oQWxsZGF5Q2xpY2spO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFsbGRheUNsaWNrO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQmFzZSBtaXhpbiBvYmplY3QgZm9yIGhhbmRsZXIvYWxsZGF5XG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIGRvbWV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbWV2ZW50Jyk7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi8uLi9jb21tb24vY29tbW9uJyk7XG5cbnZhciBtbWF4ID0gTWF0aC5tYXgsXG4gICAgbW1pbiA9IE1hdGgubWluLFxuICAgIENPTlRBSU5FUl9QQURESU5HX0xFRlQgPSA2MDtcblxuLyoqXG4gKiBAbWl4aW4gQWxsZGF5LkNvcmVcbiAqL1xudmFyIGFsbGRheUNvcmUgPSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBbGxkYXl9IGFsbGRheVZpZXcgLSB2aWV3IGluc3RhbmNlIG9mIGFsbGRheS5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IG1vdXNlRXZlbnQgLSBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9ufSBmdW5jdGlvbiB0aGF0IHJldHVybiBldmVudCBkYXRhIGJ5IG1vdXNlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBfcmV0cml2ZUV2ZW50RGF0YTogZnVuY3Rpb24oYWxsZGF5VmlldywgbW91c2VFdmVudCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gYWxsZGF5Vmlldy5jb250YWluZXIsXG4gICAgICAgICAgICByZW5kZXJTdGFydERhdGUsXG4gICAgICAgICAgICByZW5kZXJFbmREYXRlLFxuICAgICAgICAgICAgZGF0ZXNJblJhbmdlLFxuICAgICAgICAgICAgY29udGFpbmVyV2lkdGgsXG4gICAgICAgICAgICBtb3VzZVBvcyxcbiAgICAgICAgICAgIGRyYWdTdGFydFhJbmRleDtcblxuICAgICAgICByZW5kZXJTdGFydERhdGUgPSBkYXRldGltZS5wYXJzZShhbGxkYXlWaWV3Lm9wdGlvbnMucmVuZGVyU3RhcnREYXRlKTtcbiAgICAgICAgcmVuZGVyRW5kRGF0ZSA9IGRhdGV0aW1lLmVuZChkYXRldGltZS5wYXJzZShhbGxkYXlWaWV3Lm9wdGlvbnMucmVuZGVyRW5kRGF0ZSkpO1xuICAgICAgICBkYXRlc0luUmFuZ2UgPSBkYXRldGltZS5yYW5nZShyZW5kZXJTdGFydERhdGUsIHJlbmRlckVuZERhdGUsIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZKS5sZW5ndGg7XG4gICAgICAgIGNvbnRhaW5lcldpZHRoID0gZG9tdXRpbC5nZXRTaXplKGNvbnRhaW5lcilbMF0gLSBDT05UQUlORVJfUEFERElOR19MRUZUOyAgICAvLyBzdWJ0cmFjdCBjb250YWluZXIgbGVmdCBwYWRkaW5nLlxuXG4gICAgICAgIG1vdXNlUG9zID0gZG9tZXZlbnQuZ2V0TW91c2VQb3NpdGlvbihtb3VzZUV2ZW50LCBjb250YWluZXIpO1xuICAgICAgICBkcmFnU3RhcnRYSW5kZXggPSBjb21tb24ucmF0aW8oY29udGFpbmVyV2lkdGgsIGRhdGVzSW5SYW5nZSwgbW91c2VQb3NbMF0gLSBDT05UQUlORVJfUEFERElOR19MRUZUKSB8IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gbW91c2VFdmVudCAtIG1vdXNlIGV2ZW50IGluIGRyYWcgYWN0aW9ucy5cbiAgICAgICAgICogQHJldHVybnMge29iamVjdH0gZXZlbnQgZGF0YS5cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihtb3VzZUV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gZG9tZXZlbnQuZ2V0TW91c2VQb3NpdGlvbihtb3VzZUV2ZW50LCBjb250YWluZXIpLFxuICAgICAgICAgICAgICAgIG1vdXNlWCA9IHBvc1swXSAtIENPTlRBSU5FUl9QQURESU5HX0xFRlQsXG4gICAgICAgICAgICAgICAgeEluZGV4ID0gY29tbW9uLnJhdGlvKGNvbnRhaW5lcldpZHRoLCBkYXRlc0luUmFuZ2UsIG1vdXNlWCkgfCAwO1xuXG4gICAgICAgICAgICAvLyBhcHBseSBsaW1pdGF0aW9uIG9mIGNyZWF0aW9uIGV2ZW50IFggaW5kZXguXG4gICAgICAgICAgICB4SW5kZXggPSBtbWF4KHhJbmRleCwgMCk7XG4gICAgICAgICAgICB4SW5kZXggPSBtbWluKHhJbmRleCwgZGF0ZXNJblJhbmdlIC0gMSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVsYXRlZFZpZXc6IGFsbGRheVZpZXcsXG4gICAgICAgICAgICAgICAgZHJhZ1N0YXJ0WEluZGV4OiBkcmFnU3RhcnRYSW5kZXgsXG4gICAgICAgICAgICAgICAgZGF0ZXNJblJhbmdlOiBkYXRlc0luUmFuZ2UsXG4gICAgICAgICAgICAgICAgeEluZGV4OiB4SW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhbGxkYXlDb3JlO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgSGFuZGxlciBtb2R1bGUgZm9yIE1vbnRoV2VlayB2aWV3J3MgY3JlYXRpb24gYWN0aW9ucy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgdXRpbCA9IGdsb2JhbC50dWkudXRpbDtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi8uLi9jb25maWcnKTtcbnZhciBkYXRldGltZSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kYXRldGltZScpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9jb21tb24nKTtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciBhbGxkYXlDb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG52YXIgQWxsZGF5Q3JlYXRpb25HdWlkZSA9IHJlcXVpcmUoJy4vY3JlYXRpb25HdWlkZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge0hhbmRsZXJ9XG4gKiBAbWl4ZXMgQWxsZGF5Q29yZVxuICogQG1peGVzIEN1dG9tRXZlbnRzXG4gKiBAcGFyYW0ge0RyYWd9IFtkcmFnSGFuZGxlcl0gLSBEcmFnIGhhbmRsZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0FsbGRheX0gW2FsbGRheVZpZXddIC0gTW9udGhXZWVrIHZpZXcgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0Jhc2V9IFtiYXNlQ29udHJvbGxlcl0gLSBCYXNlIGNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIEFsbGRheUNyZWF0aW9uKGRyYWdIYW5kbGVyLCBhbGxkYXlWaWV3LCBiYXNlQ29udHJvbGxlcikgeyAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgLyoqXG4gICAgICogRHJhZyBoYW5kbGVyIGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtEcmFnfVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogYWxsZGF5IHZpZXcgaW5zdGFuY2UuXG4gICAgICogQHR5cGUge0FsbGRheX1cbiAgICAgKi9cbiAgICB0aGlzLmFsbGRheVZpZXcgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQmFzZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtCYXNlfVxuICAgICAqL1xuICAgIHRoaXMuYmFzZUNvbnRyb2xsZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuZ2V0RXZlbnREYXRhRnVuYyA9IG51bGw7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmNvbm5lY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QWxsZGF5Q3JlYXRpb25HdWlkZX1cbiAgICAgKi9cbiAgICB0aGlzLmd1aWRlID0gbmV3IEFsbGRheUNyZWF0aW9uR3VpZGUodGhpcyk7XG59XG5cbi8qKlxuICogRGVzdHJveSBtZXRob2RcbiAqL1xuQWxsZGF5Q3JlYXRpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmd1aWRlLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9mZih0aGlzKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gdGhpcy5hbGxkYXlWaWV3ID0gdGhpcy5iYXNlQ29udHJvbGxlciA9XG4gICAgICAgIHRoaXMuZ2V0RXZlbnREYXRhRnVuYyA9IG51bGw7XG59O1xuXG4vKipcbiAqIENoZWNrIGRyYWdzdGFydCB0YXJnZXQgaXMgZXhwZWN0ZWQgY29uZGl0aW9ucyBmb3IgdGhpcyBoYW5kbGVyLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gZHJhZ3N0YXJ0IGV2ZW50IGhhbmRsZXIncyB0YXJnZXQgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufE1vbnRoV2Vla30gcmV0dXJuIE1vbnRoV2VlayB2aWV3IGluc3RhbmNlIHdoZW4gc2F0aWF0ZSBjb25kaXRpb24uXG4gKi9cbkFsbGRheUNyZWF0aW9uLnByb3RvdHlwZS5jaGVja0V4cGVjdGVkQ29uZGl0aW9uID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgdmFyIGNzc0NsYXNzID0gZG9tdXRpbC5nZXRDbGFzcyh0YXJnZXQpLFxuICAgICAgICBtYXRjaGVzO1xuXG4gICAgaWYgKGNzc0NsYXNzICE9PSBjb25maWcuY2xhc3NuYW1lKCdtb250aHdlZWstZXZlbnRzJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgIGNzc0NsYXNzID0gZG9tdXRpbC5nZXRDbGFzcyh0YXJnZXQpO1xuICAgIG1hdGNoZXMgPSBjc3NDbGFzcy5tYXRjaChjb25maWcuYWxsZGF5LmdldFZpZXdJRFJlZ0V4cCk7XG5cbiAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbC5waWNrKHRoaXMuYWxsZGF5Vmlldy5jaGlsZHMuaXRlbXMsIG1hdGNoZXNbMV0pO1xufTtcblxuLyoqXG4gKiBDb25uZWN0IGhhbmRsZXIsIHZpZXcsIGNvbnRyb2xsZXIuXG4gKiBAcGFyYW0ge0RyYWd9IFtkcmFnSGFuZGxlcl0gLSBEcmFnIGhhbmRsZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0FsbGRheX0gW2FsbGRheVZpZXddIC0gTW9udGhXZWVrIHZpZXcgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0Jhc2V9IFtiYXNlQ29udHJvbGxlcl0gLSBCYXNlIGNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gKi9cbkFsbGRheUNyZWF0aW9uLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oZHJhZ0hhbmRsZXIsIGFsbGRheVZpZXcsIGJhc2VDb250cm9sbGVyKSB7XG4gICAgdGhpcy5kcmFnSGFuZGxlciA9IGRyYWdIYW5kbGVyO1xuICAgIHRoaXMuYWxsZGF5VmlldyA9IGFsbGRheVZpZXc7XG4gICAgdGhpcy5iYXNlQ29udHJvbGxlciA9IGJhc2VDb250cm9sbGVyO1xuXG4gICAgZHJhZ0hhbmRsZXIub24oe1xuICAgICAgICBkcmFnU3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0XG4gICAgfSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgZXZlbnQgbW9kZWwgY3JlYXRpb24gdG8gY29udHJvbGxlciBieSBjdXN0b20gZXZlbnRzLlxuICogQGZpcmVzIHtBbGxkYXlDcmVhdGlvbiNiZWZvcmVDcmVhdGVFdmVudH1cbiAqIEBwYXJhbSB7b2JqZWN0fSBldmVudERhdGEgLSBldmVudCBkYXRhIGZyb20gQWxsZGF5Q3JlYXRpb24gbW9kdWxlLlxuICovXG5BbGxkYXlDcmVhdGlvbi5wcm90b3R5cGUuX2NyZWF0ZUV2ZW50ID0gZnVuY3Rpb24oZXZlbnREYXRhKSB7XG4gICAgdmFyIHZpZXdPcHRpb25zID0gZXZlbnREYXRhLnJlbGF0ZWRWaWV3Lm9wdGlvbnMsXG4gICAgICAgIGRhdGVSYW5nZSA9IGRhdGV0aW1lLnJhbmdlKFxuICAgICAgICAgICAgZGF0ZXRpbWUuc3RhcnQoZGF0ZXRpbWUucGFyc2Uodmlld09wdGlvbnMucmVuZGVyU3RhcnREYXRlKSksXG4gICAgICAgICAgICBkYXRldGltZS5lbmQoZGF0ZXRpbWUucGFyc2Uodmlld09wdGlvbnMucmVuZGVyRW5kRGF0ZSkpLFxuICAgICAgICAgICAgZGF0ZXRpbWUuTUlMTElTRUNPTkRTX1BFUl9EQVlcbiAgICAgICAgKSxcbiAgICAgICAgc3RhcnRYSW5kZXggPSBldmVudERhdGEuZHJhZ1N0YXJ0WEluZGV4LFxuICAgICAgICB4SW5kZXggPSBldmVudERhdGEueEluZGV4LFxuICAgICAgICBzdGFydHMsIGVuZHM7XG5cbiAgICAvLyB3aGVuIGludmVyc2Ugc3RhcnQsIGVuZCB0aGVuIGNoYW5nZSBpdC5cbiAgICBpZiAoeEluZGV4IDwgc3RhcnRYSW5kZXgpIHtcbiAgICAgICAgc3RhcnRYSW5kZXggPSB4SW5kZXggKyBzdGFydFhJbmRleDtcbiAgICAgICAgeEluZGV4ID0gc3RhcnRYSW5kZXggLSB4SW5kZXg7XG4gICAgICAgIHN0YXJ0WEluZGV4ID0gc3RhcnRYSW5kZXggLSB4SW5kZXg7XG4gICAgfVxuXG4gICAgc3RhcnRzID0gbmV3IERhdGUoZGF0ZVJhbmdlW3N0YXJ0WEluZGV4XS5nZXRUaW1lKCkpO1xuICAgIGVuZHMgPSBkYXRldGltZS5lbmQoZGF0ZVJhbmdlW3hJbmRleF0pO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IHtBbGxkYXlDcmVhdGlvbiNiZWZvcmVDcmVhdGVFdmVudH1cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNBbGxEYXkgLSB3aGV0aGVyIGV2ZW50IGlzIGZpcmVkIGluIGFsbGRheSB2aWV3IGFyZWE/XG4gICAgICogQHByb3BlcnR5IHtEYXRlfSBzdGFydHMgLSBzZWxlY3Qgc3RhcnQgZGF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7RGF0ZV0gZW5kcyAtIHNlbGVjdCBlbmQgZGF0ZVxuICAgICAqL1xuICAgIHRoaXMuZmlyZSgnYmVmb3JlQ3JlYXRlRXZlbnQnLCB7XG4gICAgICAgIGlzQWxsRGF5OiB0cnVlLFxuICAgICAgICBzdGFydHM6IHN0YXJ0cyxcbiAgICAgICAgZW5kczogZW5kc1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBEcmFnU3RhcnQgZXZlbnQgaGFuZGxlciBtZXRob2QuXG4gKiBAZW1pdHMgQWxsZGF5Q3JlYXRpb24jYWxsZGF5X2NyZWF0aW9uX2RyYWdzdGFydFxuICogQHBhcmFtIHtvYmplY3R9IGRyYWdTdGFydEV2ZW50RGF0YSAtIERyYWcjZHJhZ1N0YXJ0IGV2ZW50IGhhbmRsZXIgZXZlbnQgZGF0YS5cbiAqL1xuQWxsZGF5Q3JlYXRpb24ucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGRyYWdTdGFydEV2ZW50RGF0YSkge1xuICAgIHZhciB0YXJnZXQgPSBkcmFnU3RhcnRFdmVudERhdGEudGFyZ2V0LFxuICAgICAgICByZXN1bHQgPSB0aGlzLmNoZWNrRXhwZWN0ZWRDb25kaXRpb24odGFyZ2V0KSxcbiAgICAgICAgZ2V0RXZlbnREYXRhRnVuYyxcbiAgICAgICAgZXZlbnREYXRhO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZHJhZ0hhbmRsZXIub24oe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIGdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLmdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9yZXRyaXZlRXZlbnREYXRhKHRoaXMuYWxsZGF5VmlldywgZHJhZ1N0YXJ0RXZlbnREYXRhLm9yaWdpbkV2ZW50KTtcbiAgICBldmVudERhdGEgPSBnZXRFdmVudERhdGFGdW5jKGRyYWdTdGFydEV2ZW50RGF0YS5vcmlnaW5FdmVudCk7XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgQWxsZGF5Q3JlYXRpb24jYWxsZGF5X2NyZWF0aW9uX2RyYWdzdGFydFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtBbGxkYXlWaWV3fSByZWxhdGVkVmlldyAtIGFsbGRheSB2aWV3IGluc3RhbmNlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRlc0luUmFuZ2UgLSBkYXRlIGNvdW50IG9mIHRoaXMgdmlldy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZHJhZ1N0YXJ0WEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIGRyYWdzdGFydCBncmlkIGluZGV4LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4SW5kZXggLSBpbmRleCBudW1iZXIgb2YgbW91c2UgcG9zaXRpb25zLlxuICAgICAqL1xuICAgIHRoaXMuZmlyZSgnYWxsZGF5X2NyZWF0aW9uX2RyYWdzdGFydCcsIGV2ZW50RGF0YSk7XG59O1xuXG4vKipcbiAqIERyYWcgZXZlbnQgaGFuZGxlciBtZXRob2QuXG4gKiBAZW1pdHMgQWxsZGF5Q3JlYXRpb24jYWxsZGF5X2NyZWF0aW9uX2RyYWdcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnRXZlbnREYXRhIC0gRHJhZyNkcmFnIGV2ZW50IGhhbmRsZXIgZXZlbnRkYXRhLlxuICovXG5BbGxkYXlDcmVhdGlvbi5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uKGRyYWdFdmVudERhdGEpIHtcbiAgICB2YXIgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuZ2V0RXZlbnREYXRhRnVuYyxcbiAgICAgICAgZXZlbnREYXRhO1xuXG4gICAgaWYgKCFnZXRFdmVudERhdGFGdW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudERhdGEgPSBnZXRFdmVudERhdGFGdW5jKGRyYWdFdmVudERhdGEub3JpZ2luRXZlbnQpO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IEFsbGRheUNyZWF0aW9uI2FsbGRheV9jcmVhdGlvbl9kcmFnXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0FsbGRheVZpZXd9IHJlbGF0ZWRWaWV3IC0gYWxsZGF5IHZpZXcgaW5zdGFuY2UuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGVzSW5SYW5nZSAtIGRhdGUgY291bnQgb2YgdGhpcyB2aWV3LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkcmFnU3RhcnRYSW5kZXggLSBpbmRleCBudW1iZXIgb2YgZHJhZ3N0YXJ0IGdyaWQgaW5kZXguXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHhJbmRleCAtIGluZGV4IG51bWJlciBvZiBtb3VzZSBwb3NpdGlvbnMuXG4gICAgICovXG4gICAgdGhpcy5maXJlKCdhbGxkYXlfY3JlYXRpb25fZHJhZycsIGV2ZW50RGF0YSk7XG59O1xuXG4vKipcbiAqIERyYWdFbmQgZXZlbnQgaGFuZGVyIG1ldGhvZC5cbiAqIEBlbWl0cyBBbGxkYXlDcmVhdGlvbiNhbGxkYXlfY3JlYXRpb25fZHJhZ2VuZFxuICogQHBhcmFtIHtvYmplY3R9IGRyYWdFbmRFdmVudERhdGEgLSBEcmFnI0RyYWdFbmQgZXZlbnQgaGFuZGxlciBkYXRhLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvdmVycmlkZUV2ZW50TmFtZV0gLSBvdmVycmlkZSBlbWl0dGVkIGV2ZW50IG5hbWUgd2hlbiBzdXBwbGllZC5cbiAqL1xuQWxsZGF5Q3JlYXRpb24ucHJvdG90eXBlLl9vbkRyYWdFbmQgPSBmdW5jdGlvbihkcmFnRW5kRXZlbnREYXRhLCBvdmVycmlkZUV2ZW50TmFtZSkge1xuICAgIHZhciBnZXRFdmVudERhdGFGdW5jID0gdGhpcy5nZXRFdmVudERhdGFGdW5jLFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICBpZiAoIWdldEV2ZW50RGF0YUZ1bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZHJhZ0hhbmRsZXIub2ZmKHtcbiAgICAgICAgZHJhZzogdGhpcy5fb25EcmFnLFxuICAgICAgICBkcmFnRW5kOiB0aGlzLl9vbkRyYWdFbmQsXG4gICAgICAgIGNsaWNrOiB0aGlzLl9vbkNsaWNrXG4gICAgfSwgdGhpcyk7XG5cbiAgICBldmVudERhdGEgPSBnZXRFdmVudERhdGFGdW5jKGRyYWdFbmRFdmVudERhdGEub3JpZ2luRXZlbnQpO1xuXG4gICAgdGhpcy5fY3JlYXRlRXZlbnQoZXZlbnREYXRhKTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBBbGxkYXlDcmVhdGlvbiNhbGxkYXlfY3JlYXRpb25fZHJhZ2VuZFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtBbGxkYXlWaWV3fSByZWxhdGVkVmlldyAtIGFsbGRheSB2aWV3IGluc3RhbmNlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRlc0luUmFuZ2UgLSBkYXRlIGNvdW50IG9mIHRoaXMgdmlldy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZHJhZ1N0YXJ0WEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIGRyYWdzdGFydCBncmlkIGluZGV4LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4SW5kZXggLSBpbmRleCBudW1iZXIgb2YgbW91c2UgcG9zaXRpb25zLlxuICAgICAqL1xuICAgIHRoaXMuZmlyZShvdmVycmlkZUV2ZW50TmFtZSB8fCAnYWxsZGF5X2NyZWF0aW9uX2RyYWdlbmQnLCBldmVudERhdGEpO1xuXG4gICAgdGhpcy5nZXRFdmVudERhdGFGdW5jID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xpY2sgZXZlbnQgaGFuZGxlciBtZXRob2QuXG4gKiBAZW1pdHMgQWxsZGF5Q3JlYXRpb24jYWxsZGF5X2NyZWF0aW9uX2NsaWNrXG4gKiBAcGFyYW0ge29iamVjdH0gY2xpY2tFdmVudERhdGEgLSBEcmFnI0NsaWNrIGV2ZW50IGhhbmRsZXIgZGF0YS5cbiAqL1xuQWxsZGF5Q3JlYXRpb24ucHJvdG90eXBlLl9vbkNsaWNrID0gZnVuY3Rpb24oY2xpY2tFdmVudERhdGEpIHtcbiAgICAvKipcbiAgICAgKiBAZXZlbnQgQWxsZGF5Q3JlYXRpb24jYWxsZGF5X2NyZWF0aW9uX2NsaWNrXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0FsbGRheVZpZXd9IHJlbGF0ZWRWaWV3IC0gYWxsZGF5IHZpZXcgaW5zdGFuY2UuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGVzSW5SYW5nZSAtIGRhdGUgY291bnQgb2YgdGhpcyB2aWV3LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkcmFnU3RhcnRYSW5kZXggLSBpbmRleCBudW1iZXIgb2YgZHJhZ3N0YXJ0IGdyaWQgaW5kZXguXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHhJbmRleCAtIGluZGV4IG51bWJlciBvZiBtb3VzZSBwb3NpdGlvbnMuXG4gICAgICovXG4gICAgdGhpcy5fb25EcmFnRW5kKGNsaWNrRXZlbnREYXRhLCAnYWxsZGF5X2NyZWF0aW9uX2NsaWNrJyk7XG59O1xuXG5jb21tb24ubWl4aW4oYWxsZGF5Q29yZSwgQWxsZGF5Q3JlYXRpb24pO1xudXRpbC5DdXN0b21FdmVudHMubWl4aW4oQWxsZGF5Q3JlYXRpb24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFsbGRheUNyZWF0aW9uO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgR3VpZGUgZWxlbWVudCBmb3IgQWxsZGF5LkNyZWF0aW9uXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL2NvbmZpZycpO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIHJlcUFuaW1GcmFtZSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9yZXFBbmltRnJhbWUnKTtcblxudmFyIENSRUFURV9ORVdfTEFCRUwgPSAn7IOIIOydvOyglSc7XG5cbi8qKlxuICogQ2xhc3MgZm9yIEFsbGRheS5DcmVhdGlvbiBkcmFnZ2luZyBlZmZlY3QuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QWxsZGF5Q3JlYXRpb259IGFsbGRheUNyZWF0aW9uIC0gaW5zdGFuY2Ugb2YgQWxsZGF5Q3JlYXRpb24uXG4gKi9cbmZ1bmN0aW9uIEFsbGRheUNyZWF0aW9uR3VpZGUoYWxsZGF5Q3JlYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QWxsZGF5Q3JlYXRpb259XG4gICAgICovXG4gICAgdGhpcy5hbGxkYXlDcmVhdGlvbiA9IGFsbGRheUNyZWF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0hUTUxESVZFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRDb250YWluZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0hUTUxESVZFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZ3VpZGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICB0aGlzLmluaXRpYWxpemVHdWlkZUVsZW1lbnQoKTtcblxuICAgIGFsbGRheUNyZWF0aW9uLm9uKHtcbiAgICAgICAgJ2FsbGRheV9jcmVhdGlvbl9kcmFnc3RhcnQnOiB0aGlzLl9vbkRyYWdTdGFydCxcbiAgICAgICAgJ2FsbGRheV9jcmVhdGlvbl9kcmFnJzogdGhpcy5fb25EcmFnLFxuICAgICAgICAnYWxsZGF5X2NyZWF0aW9uX2NsaWNrJzogdGhpcy5jbGVhckd1aWRlRWxlbWVudFxuICAgIH0sIHRoaXMpO1xufVxuXG4vKipcbiAqIERlc3Ryb3kgbWV0aG9kXG4gKi9cbkFsbGRheUNyZWF0aW9uR3VpZGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyR3VpZGVFbGVtZW50KCk7XG4gICAgdGhpcy5hbGxkYXlDcmVhdGlvbi5vZmYodGhpcyk7XG4gICAgdGhpcy5hbGxkYXlDcmVhdGlvbiA9IHRoaXMuZXZlbnRDb250YWluZXIgPVxuICAgICAgICB0aGlzLmd1aWRlRWxlbWVudCA9IG51bGw7XG59O1xuXG4vKipcbiAqIGluaXRpYWxpemUgZ3VpZGUgZWxlbWVudCdzIGRlZmF1bHQgc3R5bGUuXG4gKi9cbkFsbGRheUNyZWF0aW9uR3VpZGUucHJvdG90eXBlLmluaXRpYWxpemVHdWlkZUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ3VpZGVFbGVtZW50ID0gdGhpcy5ndWlkZUVsZW1lbnQsXG4gICAgICAgIHNwYW5FbGVtZW50O1xuXG4gICAgZG9tdXRpbC5hZGRDbGFzcyhndWlkZUVsZW1lbnQsIGNvbmZpZy5jbGFzc25hbWUoJ2FsbGRheS1ndWlkZS1jcmVhdGlvbi1ibG9jaycpKTtcbiAgICBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KCdkaXYnLCBndWlkZUVsZW1lbnQsIGNvbmZpZy5jbGFzc25hbWUoJ2FsbGRheS1ndWlkZS1jcmVhdGlvbicpKTtcblxuICAgIHNwYW5FbGVtZW50ID0gZG9tdXRpbC5hcHBlbmRIVE1MRWxlbWVudCgnc3BhbicsIGd1aWRlRWxlbWVudCk7XG4gICAgc3BhbkVsZW1lbnQuaW5uZXJIVE1MID0gQ1JFQVRFX05FV19MQUJFTDtcbn07XG5cbi8qKlxuICogUmVmcmVzaCBndWlkZSBlbGVtZW50LlxuICogQHBhcmFtIHtvYmplY3R9IGV2ZW50RGF0YSAtIGV2ZW50IGRhdGEgZnJvbSBBbGxkYXkuQ3JlYXRpb24gaGFuZGxlci5cbiAqL1xuQWxsZGF5Q3JlYXRpb25HdWlkZS5wcm90b3R5cGUuX3JlZnJlc2hHdWlkZUVsZW1lbnQgPSBmdW5jdGlvbihldmVudERhdGEpIHtcbiAgICB2YXIgZ3VpZGVFbGVtZW50ID0gdGhpcy5ndWlkZUVsZW1lbnQsXG4gICAgICAgIGJhc2VXaWR0aFBlcmNlbnQgPSAoMTAwIC8gZXZlbnREYXRhLmRhdGVzSW5SYW5nZSksXG4gICAgICAgIGRyYWdTdGFydFhJbmRleCA9IGV2ZW50RGF0YS5kcmFnU3RhcnRYSW5kZXgsXG4gICAgICAgIHhJbmRleCA9IGV2ZW50RGF0YS54SW5kZXgsXG4gICAgICAgIGxlbmd0aCA9IHhJbmRleCAtIGRyYWdTdGFydFhJbmRleCxcbiAgICAgICAgbGVmdFBlcmNlbnQsXG4gICAgICAgIHdpZHRoUGVyY2VudDtcblxuICAgIC8vIHdoZW4gcmV2ZXJ0IGRyYWdnaW5nLlxuICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgIGRyYWdTdGFydFhJbmRleCA9IHhJbmRleDtcbiAgICAgICAgbGVuZ3RoID0gTWF0aC5hYnMobGVuZ3RoKTtcbiAgICB9XG5cbiAgICBsZWZ0UGVyY2VudCA9IGJhc2VXaWR0aFBlcmNlbnQgKiBkcmFnU3RhcnRYSW5kZXg7XG4gICAgd2lkdGhQZXJjZW50ID0gYmFzZVdpZHRoUGVyY2VudCAqIChsZW5ndGggKyAxKTtcblxuICAgIHJlcUFuaW1GcmFtZS5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICBndWlkZUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIGd1aWRlRWxlbWVudC5zdHlsZS5sZWZ0ID0gbGVmdFBlcmNlbnQgKyAnJSc7XG4gICAgICAgIGd1aWRlRWxlbWVudC5zdHlsZS53aWR0aCA9IHdpZHRoUGVyY2VudCArICclJztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ2xlYXIgZ3VpZGUgZWxlbWVudC5cbiAqL1xuQWxsZGF5Q3JlYXRpb25HdWlkZS5wcm90b3R5cGUuY2xlYXJHdWlkZUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ3VpZGVFbGVtZW50ID0gdGhpcy5ndWlkZUVsZW1lbnQ7XG5cbiAgICBkb211dGlsLnJlbW92ZShndWlkZUVsZW1lbnQpO1xuXG4gICAgZ3VpZGVFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgZ3VpZGVFbGVtZW50LnN0eWxlLmxlZnQgPSAnJztcbiAgICBndWlkZUVsZW1lbnQuc3R5bGUud2lkdGggPSAnJztcbn07XG5cbi8qKlxuICogRHJhZ1N0YXJ0IGV2ZW50IGhhbmRsZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ1N0YXJ0RXZlbnREYXRhIC0gZXZlbnQgZGF0YSBvYmplY3Qgb2YgQWxsZGF5LkNyZWF0aW9uLlxuICovXG5BbGxkYXlDcmVhdGlvbkd1aWRlLnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbihkcmFnU3RhcnRFdmVudERhdGEpIHtcbiAgICB2YXIgYWxsZGF5Q3JlYXRpb24gPSB0aGlzLmFsbGRheUNyZWF0aW9uLFxuICAgICAgICBhbGxkYXlWaWV3ID0gYWxsZGF5Q3JlYXRpb24uYWxsZGF5VmlldyxcbiAgICAgICAgYWxsZGF5Q29udGFpbmVyRWxlbWVudCA9IGFsbGRheVZpZXcuY29udGFpbmVyLFxuICAgICAgICBldmVudENvbnRhaW5lciA9IGRvbXV0aWwuZmluZCgnLicgKyBjb25maWcuY2xhc3NuYW1lKCdtb250aHdlZWstZXZlbnRzJyksIGFsbGRheUNvbnRhaW5lckVsZW1lbnQpO1xuXG4gICAgZXZlbnRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5ndWlkZUVsZW1lbnQpO1xuICAgIHRoaXMuX3JlZnJlc2hHdWlkZUVsZW1lbnQoZHJhZ1N0YXJ0RXZlbnREYXRhKTtcbn07XG5cbi8qKlxuICogRHJhZyBldmVudCBoYW5kbGVyLlxuICogQHBhcmFtIHtvYmplY3R9IGRyYWdFdmVudERhdGEgLSBldmVudCBkYXRhIG9iamVjdCBvZiBBbGxkYXkuQ3JlYXRpb24uXG4gKi9cbkFsbGRheUNyZWF0aW9uR3VpZGUucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbihkcmFnRXZlbnREYXRhKSB7XG4gICAgdGhpcy5fcmVmcmVzaEd1aWRlRWxlbWVudChkcmFnRXZlbnREYXRhKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWxsZGF5Q3JlYXRpb25HdWlkZTtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1vdmUgaGFuZGxlciBmb3IgQWxsZGF5IHZpZXcuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWwgPSBnbG9iYWwudHVpLnV0aWw7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vY29uZmlnJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2NvbW1vbicpO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIEFsbGRheUNvcmUgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBBbGxkYXlNb3ZlR3VpZGUgPSByZXF1aXJlKCcuL21vdmVHdWlkZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge0hhbmRsZXJ9XG4gKiBAbWl4ZXMgQWxsZGF5Q29yZVxuICogQG1peGVzIEN1c3RvbUV2ZW50c1xuICogQHBhcmFtIHtEcmFnfSBbZHJhZ0hhbmRsZXJdIC0gRHJhZyBoYW5kbGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHtBbGxkYXl9IFthbGxkYXlWaWV3XSAtIE1vbnRoV2VlayB2aWV3IGluc3RhbmNlLlxuICogQHBhcmFtIHtCYXNlfSBbYmFzZUNvbnRyb2xsZXJdIC0gQmFzZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBBbGxkYXlNb3ZlKGRyYWdIYW5kbGVyLCBhbGxkYXlWaWV3LCBiYXNlQ29udHJvbGxlcikge1xuICAgIC8qKlxuICAgICAqIERyYWcgaGFuZGxlciBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7RHJhZ31cbiAgICAgKi9cbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gZHJhZ0hhbmRsZXI7XG5cbiAgICAvKipcbiAgICAgKiBhbGxkYXkgdmlldyBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7QWxsZGF5fVxuICAgICAqL1xuICAgIHRoaXMuYWxsZGF5VmlldyA9IGFsbGRheVZpZXc7XG5cbiAgICAvKipcbiAgICAgKiBCYXNlIGNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICogQHR5cGUge0Jhc2V9XG4gICAgICovXG4gICAgdGhpcy5iYXNlQ29udHJvbGxlciA9IGJhc2VDb250cm9sbGVyO1xuXG4gICAgLyoqXG4gICAgICogVGVtcG9yYXJ5IHZhcmlhYmxlIGZvciBkcmFnc3RhcnQgZXZlbnQgZGF0YS5cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuX2RyYWdTdGFydCA9IG51bGw7XG5cbiAgICBkcmFnSGFuZGxlci5vbih7XG4gICAgICAgIGRyYWdTdGFydDogdGhpcy5fb25EcmFnU3RhcnRcbiAgICB9LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBbGxkYXlNb3ZlR3VpZGV9XG4gICAgICovXG4gICAgdGhpcy5ndWlkZSA9IG5ldyBBbGxkYXlNb3ZlR3VpZGUodGhpcyk7XG59XG5cbkFsbGRheU1vdmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmd1aWRlLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9mZih0aGlzKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gdGhpcy5hbGxkYXlWaWV3ID0gdGhpcy5iYXNlQ29udHJvbGxlciA9XG4gICAgICAgIHRoaXMuZ3VpZGUgPSB0aGlzLl9kcmFnU3RhcnQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDaGVjayBkcmFnc3RhcnQgdGFyZ2V0IGlzIGV4cGVjdGVkIGNvbmRpdGlvbnMgZm9yIHRoaXMgaGFuZGxlci5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIGRyYWdzdGFydCBldmVudCBoYW5kbGVyJ3MgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbnxNb250aFdlZWt9IHJldHVybiBNb250aFdlZWsgdmlldyBpbnN0YW5jZSB3aGVuIHNhdGlhdGUgY29uZGl0aW9uLlxuICovXG5BbGxkYXlNb3ZlLnByb3RvdHlwZS5jaGVja0V4cGVjdGVkQ29uZGl0aW9uID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgdmFyIGNzc0NsYXNzID0gZG9tdXRpbC5nZXRDbGFzcyh0YXJnZXQpLFxuICAgICAgICBwYXJlbnRWaWV3LFxuICAgICAgICBtYXRjaGVzO1xuXG4gICAgaWYgKH5jc3NDbGFzcy5pbmRleE9mKGNvbmZpZy5jbGFzc25hbWUoJ2FsbGRheS1yZXNpemUtaGFuZGxlJykpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwYXJlbnRWaWV3ID0gZG9tdXRpbC5jbG9zZXN0KHRhcmdldCwgJy4nICsgY29uZmlnLmNsYXNzbmFtZSgnYWxsZGF5LW1vbnRod2VlaycpKTtcblxuICAgIGlmICghcGFyZW50Vmlldykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY3NzQ2xhc3MgPSBkb211dGlsLmdldENsYXNzKHBhcmVudFZpZXcpO1xuICAgIG1hdGNoZXMgPSBjc3NDbGFzcy5tYXRjaChjb25maWcuYWxsZGF5LmdldFZpZXdJRFJlZ0V4cCk7XG5cbiAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbC5waWNrKHRoaXMuYWxsZGF5Vmlldy5jaGlsZHMuaXRlbXMsIG1hdGNoZXNbMV0pO1xufTtcblxuLyoqXG4gKiBEcmFnU3RhcnQgZXZlbnQgaGFuZGxlciBtZXRob2QuXG4gKiBAZW1pdHMgQWxsZGF5TW92ZSNhbGxkYXlfbW92ZV9kcmFnc3RhcnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnU3RhcnRFdmVudERhdGEgLSBEcmFnI2RyYWdTdGFydCBldmVudCBoYW5kbGVyIGV2ZW50IGRhdGEuXG4gKi9cbkFsbGRheU1vdmUucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGRyYWdTdGFydEV2ZW50RGF0YSkge1xuICAgIHZhciB0YXJnZXQgPSBkcmFnU3RhcnRFdmVudERhdGEudGFyZ2V0LFxuICAgICAgICByZXN1bHQgPSB0aGlzLmNoZWNrRXhwZWN0ZWRDb25kaXRpb24odGFyZ2V0KSxcbiAgICAgICAgY29udHJvbGxlciA9IHRoaXMuYmFzZUNvbnRyb2xsZXIsXG4gICAgICAgIGV2ZW50QmxvY2tFbGVtZW50LFxuICAgICAgICBtb2RlbElELFxuICAgICAgICB0YXJnZXRNb2RlbCxcbiAgICAgICAgZ2V0RXZlbnREYXRhRnVuYyxcbiAgICAgICAgZXZlbnREYXRhO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50QmxvY2tFbGVtZW50ID0gZG9tdXRpbC5jbG9zZXN0KHRhcmdldCwgJy4nICsgY29uZmlnLmNsYXNzbmFtZSgnYWxsZGF5LWV2ZW50LWJsb2NrJykpO1xuICAgIGlmICghZXZlbnRCbG9ja0VsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1vZGVsSUQgPSBkb211dGlsLmdldERhdGEoZXZlbnRCbG9ja0VsZW1lbnQsICdpZCcpO1xuICAgIHRhcmdldE1vZGVsID0gY29udHJvbGxlci5ldmVudHMuaXRlbXNbbW9kZWxJRF07XG5cbiAgICBpZiAoIXRhcmdldE1vZGVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBnZXRFdmVudERhdGFGdW5jID0gdGhpcy5nZXRFdmVudERhdGFGdW5jID0gdGhpcy5fcmV0cml2ZUV2ZW50RGF0YSh0aGlzLmFsbGRheVZpZXcsIGRyYWdTdGFydEV2ZW50RGF0YS5vcmlnaW5FdmVudCk7XG4gICAgZXZlbnREYXRhID0gdGhpcy5fZHJhZ1N0YXJ0ID0gZ2V0RXZlbnREYXRhRnVuYyhkcmFnU3RhcnRFdmVudERhdGEub3JpZ2luRXZlbnQpO1xuXG4gICAgdXRpbC5leHRlbmQoZXZlbnREYXRhLCB7XG4gICAgICAgIGV2ZW50QmxvY2tFbGVtZW50OiBldmVudEJsb2NrRWxlbWVudCxcbiAgICAgICAgbW9kZWw6IHRhcmdldE1vZGVsXG4gICAgfSk7XG5cbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9uKHtcbiAgICAgICAgZHJhZzogdGhpcy5fb25EcmFnLFxuICAgICAgICBkcmFnRW5kOiB0aGlzLl9vbkRyYWdFbmQsXG4gICAgICAgIGNsaWNrOiB0aGlzLl9vbkNsaWNrXG4gICAgfSwgdGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgQWxsZGF5TW92ZSNhbGxkYXlfbW92ZV9kcmFnc3RhcnRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7QWxsZGF5Vmlld30gcmVsYXRlZFZpZXcgLSBhbGxkYXkgdmlldyBpbnN0YW5jZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGF0ZXNJblJhbmdlIC0gZGF0ZSBjb3VudCBvZiB0aGlzIHZpZXcuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRyYWdTdGFydFhJbmRleCAtIGluZGV4IG51bWJlciBvZiBkcmFnc3RhcnQgZ3JpZCBpbmRleC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIG1vdXNlIHBvc2l0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkge0NhbEV2ZW50fSBtb2RlbCAtIGRhdGEgb2JqZWN0IG9mIG1vZGVsIGlzbnRhbmNlLlxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTERpdkVsZW1lbnR9IGV2ZW50QmxvY2tFbGVtZW50IC0gdGFyZ2V0IGV2ZW50IGJsb2NrIGVsZW1lbnQuXG4gICAgICovXG4gICAgdGhpcy5maXJlKCdhbGxkYXlfbW92ZV9kcmFnc3RhcnQnLCBldmVudERhdGEpO1xufTtcblxuXG4vKipcbiAqIERyYWcgZXZlbnQgaGFuZGxlciBtZXRob2QuXG4gKiBAZW1pdHMgQWxsZGF5TW92ZSNhbGxkYXlfbW92ZV9kcmFnXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ0V2ZW50RGF0YSAtIERyYWcjZHJhZyBldmVudCBoYW5kbGVyIGV2ZW50ZGF0YS5cbiAqL1xuQWxsZGF5TW92ZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uKGRyYWdFdmVudERhdGEpIHtcbiAgICB2YXIgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuZ2V0RXZlbnREYXRhRnVuYztcblxuICAgIGlmICghZ2V0RXZlbnREYXRhRnVuYykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IEFsbGRheU1vdmUjYWxsZGF5X21vdmVfZHJhZ1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtBbGxkYXlWaWV3fSByZWxhdGVkVmlldyAtIGFsbGRheSB2aWV3IGluc3RhbmNlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRlc0luUmFuZ2UgLSBkYXRlIGNvdW50IG9mIHRoaXMgdmlldy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZHJhZ1N0YXJ0WEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIGRyYWdzdGFydCBncmlkIGluZGV4LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4SW5kZXggLSBpbmRleCBudW1iZXIgb2YgbW91c2UgcG9zaXRpb25zLlxuICAgICAqL1xuICAgIHRoaXMuZmlyZSgnYWxsZGF5X21vdmVfZHJhZycsIGdldEV2ZW50RGF0YUZ1bmMoZHJhZ0V2ZW50RGF0YS5vcmlnaW5FdmVudCkpO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IHVwZGF0ZSBldmVudCBtb2RlbCB0byBiYXNlIGNvbnRyb2xsZXIuXG4gKiBAZmlyZXMgQWxsZGF5TW92ZSNiZWZvcmVVcGRhdGVFdmVudFxuICogQHBhcmFtIHtvYmplY3R9IGV2ZW50RGF0YSAtIGV2ZW50IGRhdGEgZnJvbSBBbGxkYXlNb3ZlIGhhbmRsZXIgbW9kdWxlLlxuICovXG5BbGxkYXlNb3ZlLnByb3RvdHlwZS5fdXBkYXRlRXZlbnQgPSBmdW5jdGlvbihldmVudERhdGEpIHtcbiAgICB2YXIgbW9kZWwgPSBldmVudERhdGEudGFyZ2V0TW9kZWwsXG4gICAgICAgIGRhdGVPZmZzZXQgPSBldmVudERhdGEueEluZGV4IC0gZXZlbnREYXRhLmRyYWdTdGFydFhJbmRleCxcbiAgICAgICAgbmV3U3RhcnRzID0gbmV3IERhdGUobW9kZWwuc3RhcnRzLmdldFRpbWUoKSksXG4gICAgICAgIG5ld0VuZHMgPSBuZXcgRGF0ZShtb2RlbC5lbmRzLmdldFRpbWUoKSk7XG5cbiAgICBuZXdTdGFydHMgPSBuZXcgRGF0ZShuZXdTdGFydHMuc2V0RGF0ZShuZXdTdGFydHMuZ2V0RGF0ZSgpICsgZGF0ZU9mZnNldCkpO1xuICAgIG5ld0VuZHMgPSBuZXcgRGF0ZShuZXdFbmRzLnNldERhdGUobmV3RW5kcy5nZXREYXRlKCkgKyBkYXRlT2Zmc2V0KSk7XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgQWxsZGF5TW92ZSNiZWZvcmVVcGRhdGVFdmVudFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtDYWxFdmVudH0gbW9kZWwgLSBtb2RlbCBpbnN0YW5jZSB0byB1cGRhdGVcbiAgICAgKiBAcHJvcGVydHkge2RhdGV9IHN0YXJ0cyAtIHN0YXJ0IHRpbWUgdG8gdXBkYXRlXG4gICAgICogQHByb3BlcnR5IHtkYXRlfSBlbmRzIC0gZW5kIHRpbWUgdG8gdXBkYXRlXG4gICAgICovXG4gICAgdGhpcy5maXJlKCdiZWZvcmVVcGRhdGVFdmVudCcsIHtcbiAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICBzdGFydHM6IG5ld1N0YXJ0cyxcbiAgICAgICAgZW5kczogbmV3RW5kc1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBEcmFnRW5kIGV2ZW50IGhhbmRlciBtZXRob2QuXG4gKiBAZW1pdHMgQWxsZGF5TW92ZSNhbGxkYXlfbW92ZV9kcmFnZW5kXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ0VuZEV2ZW50RGF0YSAtIERyYWcjRHJhZ0VuZCBldmVudCBoYW5kbGVyIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gW292ZXJyaWRlRXZlbnROYW1lXSAtIG92ZXJyaWRlIGVtaXR0ZWQgZXZlbnQgbmFtZSB3aGVuIHN1cHBsaWVkLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gc2tpcFVwZGF0ZSAtIHRydWUgdGhlbiBza2lwIHVwZGF0ZSBldmVudCBtb2RlbC5cbiAqL1xuQWxsZGF5TW92ZS5wcm90b3R5cGUuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uKGRyYWdFbmRFdmVudERhdGEsIG92ZXJyaWRlRXZlbnROYW1lLCBza2lwVXBkYXRlKSB7XG4gICAgdmFyIGdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLmdldEV2ZW50RGF0YUZ1bmMsXG4gICAgICAgIGRyYWdTdGFydCA9IHRoaXMuX2RyYWdTdGFydCxcbiAgICAgICAgZXZlbnREYXRhO1xuXG4gICAgaWYgKCFnZXRFdmVudERhdGFGdW5jIHx8ICFkcmFnU3RhcnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZHJhZ0hhbmRsZXIub2ZmKHtcbiAgICAgICAgZHJhZzogdGhpcy5fb25EcmFnLFxuICAgICAgICBkcmFnRW5kOiB0aGlzLl9vbkRyYWdFbmQsXG4gICAgICAgIGNsaWNrOiB0aGlzLl9vbkNsaWNrXG4gICAgfSwgdGhpcyk7XG5cbiAgICBldmVudERhdGEgPSBnZXRFdmVudERhdGFGdW5jKGRyYWdFbmRFdmVudERhdGEub3JpZ2luRXZlbnQpO1xuICAgIHV0aWwuZXh0ZW5kKGV2ZW50RGF0YSwge1xuICAgICAgICB0YXJnZXRNb2RlbDogZHJhZ1N0YXJ0Lm1vZGVsXG4gICAgfSk7XG4gICAgXG4gICAgaWYgKCFza2lwVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUV2ZW50KGV2ZW50RGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IEFsbGRheU1vdmUjYWxsZGF5X21vdmVfZHJhZ2VuZFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtBbGxkYXlWaWV3fSByZWxhdGVkVmlldyAtIGFsbGRheSB2aWV3IGluc3RhbmNlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRlc0luUmFuZ2UgLSBkYXRlIGNvdW50IG9mIHRoaXMgdmlldy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZHJhZ1N0YXJ0WEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIGRyYWdzdGFydCBncmlkIGluZGV4LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4SW5kZXggLSBpbmRleCBudW1iZXIgb2YgbW91c2UgcG9zaXRpb25zLlxuICAgICAqL1xuICAgIHRoaXMuZmlyZShvdmVycmlkZUV2ZW50TmFtZSB8fCAnYWxsZGF5X21vdmVfZHJhZ2VuZCcsIGV2ZW50RGF0YSk7XG5cbiAgICB0aGlzLmdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9kcmFnU3RhcnQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDbGljayBldmVudCBoYW5kbGVyIG1ldGhvZC5cbiAqIEBlbWl0cyBBbGxkYXlNb3ZlI2FsbGRheV9tb3ZlX2NsaWNrXG4gKiBAcGFyYW0ge29iamVjdH0gY2xpY2tFdmVudERhdGEgLSBEcmFnI0NsaWNrIGV2ZW50IGhhbmRsZXIgZGF0YS5cbiAqL1xuQWxsZGF5TW92ZS5wcm90b3R5cGUuX29uQ2xpY2sgPSBmdW5jdGlvbihjbGlja0V2ZW50RGF0YSkge1xuICAgIC8qKlxuICAgICAqIEBldmVudCBBbGxkYXlNb3ZlI2FsbGRheV9tb3ZlX2NsaWNrXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0FsbGRheVZpZXd9IHJlbGF0ZWRWaWV3IC0gYWxsZGF5IHZpZXcgaW5zdGFuY2UuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGVzSW5SYW5nZSAtIGRhdGUgY291bnQgb2YgdGhpcyB2aWV3LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkcmFnU3RhcnRYSW5kZXggLSBpbmRleCBudW1iZXIgb2YgZHJhZ3N0YXJ0IGdyaWQgaW5kZXguXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHhJbmRleCAtIGluZGV4IG51bWJlciBvZiBtb3VzZSBwb3NpdGlvbnMuXG4gICAgICovXG4gICAgdGhpcy5fb25EcmFnRW5kKGNsaWNrRXZlbnREYXRhLCAnYWxsZGF5X21vdmVfY2xpY2snLCB0cnVlKTtcbn07XG5cbmNvbW1vbi5taXhpbihBbGxkYXlDb3JlLCBBbGxkYXlNb3ZlKTtcbnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKEFsbGRheU1vdmUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFsbGRheU1vdmU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBFZmZlY3QgbW9kdWxlIGZvciBBbGxkYXkuTW92ZVxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciB1dGlsID0gZ2xvYmFsLnR1aS51dGlsO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL2NvbmZpZycpO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgcmVxQW5pbUZyYW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL3JlcUFuaW1GcmFtZScpO1xuXG4vKipcbiAqIENsYXNzIGZvciBBbGxkYXkuTW92ZSBkcmFnZ2luZyBlZmZlY3QuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QWxsZGF5TW92ZX0gYWxsZGF5TW92ZSAtIGluc3RhbmNlIG9mIEFsbGRheU1vdmUuXG4gKi9cbmZ1bmN0aW9uIEFsbGRheU1vdmVHdWlkZShhbGxkYXlNb3ZlKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FsbGRheU1vdmV9XG4gICAgICovXG4gICAgdGhpcy5hbGxkYXlNb3ZlID0gYWxsZGF5TW92ZTtcblxuICAgIC8qKlxuICAgICAqIOyLpOygnOuhnCDsnbTrsqTtirgg7JeY66as66i87Yq466W8IOuLtOuKlCDsl5jrpqzrqLztirhcbiAgICAgKiBAdHlwZSB7SFRNTERJVkVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5ldmVudENvbnRhaW5lciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX2RyYWdTdGFydFhJbmRleCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTERJVkVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5ndWlkZUVsZW1lbnQgPSBudWxsO1xuXG4gICAgYWxsZGF5TW92ZS5vbih7XG4gICAgICAgICdhbGxkYXlfbW92ZV9kcmFnc3RhcnQnOiB0aGlzLl9vbkRyYWdTdGFydCxcbiAgICAgICAgJ2FsbGRheV9tb3ZlX2RyYWcnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgICdhbGxkYXlfbW92ZV9kcmFnZW5kJzogdGhpcy5fY2xlYXJHdWlkZUVsZW1lbnQsXG4gICAgICAgICdhbGxkYXlfbW92ZV9jbGljayc6IHRoaXMuX2NsZWFyR3VpZGVFbGVtZW50XG4gICAgfSwgdGhpcyk7XG59XG5cbi8qKlxuICogRGVzdHJveSBtZXRob2RcbiAqL1xuQWxsZGF5TW92ZUd1aWRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2xlYXJHdWlkZUVsZW1lbnQoKTtcbiAgICB0aGlzLmFsbGRheU1vdmUub2ZmKHRoaXMpO1xuICAgIHRoaXMuYWxsZGF5TW92ZSA9IHRoaXMuZXZlbnRDb250YWluZXIgPSB0aGlzLl9kcmFnU3RhcnRYSW5kZXggPVxuICAgICAgICB0aGlzLmd1aWRlRWxlbWVudCA9IG51bGw7XG59O1xuXG4vKipcbiAqIENsZWFyIGd1aWRlIGVsZW1lbnQuXG4gKi9cbkFsbGRheU1vdmVHdWlkZS5wcm90b3R5cGUuX2NsZWFyR3VpZGVFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgZG9tdXRpbC5yZW1vdmUodGhpcy5ndWlkZUVsZW1lbnQpO1xuXG4gICAgaWYgKCF1dGlsLmJyb3dzZXIubXNpZSkge1xuICAgICAgICBkb211dGlsLnJlbW92ZUNsYXNzKGdsb2JhbC5kb2N1bWVudC5ib2R5LCBjb25maWcuY2xhc3NuYW1lKCdkcmFnZ2luZycpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kcmFnU3RhcnRYSW5kZXggPSB0aGlzLmdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLmd1aWRlRWxlbWVudCA9IG51bGw7XG59O1xuXG4vKipcbiAqIFJlZnJlc2ggZ3VpZGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0UGVyY2VudCAtIGxlZnQgcGVyY2VudCBvZiBndWlkZSBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoUGVyY2VudCAtIHdpZHRoIHBlcmNlbnQgb2YgZ3VpZGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNFeGNlZWRlZExlZnQgLSBldmVudCBzdGFydHMgaXMgZmFzdGVyIHRoZW4gcmVuZGVyIHN0YXJ0IGRhdGU/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRXhjZWVkZWRSaWdodCAtIGV2ZW50IGVuZHMgaXMgbGF0ZXIgdGhlbiByZW5kZXIgZW5kIGRhdGU/XG4gKi9cbkFsbGRheU1vdmVHdWlkZS5wcm90b3R5cGUucmVmcmVzaEd1aWRlRWxlbWVudCA9IGZ1bmN0aW9uKGxlZnRQZXJjZW50LCB3aWR0aFBlcmNlbnQsIGlzRXhjZWVkZWRMZWZ0LCBpc0V4Y2VlZGVkUmlnaHQpIHtcbiAgICB2YXIgZ3VpZGVFbGVtZW50ID0gdGhpcy5ndWlkZUVsZW1lbnQ7XG5cbiAgICByZXFBbmltRnJhbWUucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgZ3VpZGVFbGVtZW50LnN0eWxlLmxlZnQgPSBsZWZ0UGVyY2VudCArICclJztcbiAgICAgICAgZ3VpZGVFbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGhQZXJjZW50ICsgJyUnO1xuXG4gICAgICAgIGlmIChpc0V4Y2VlZGVkTGVmdCkge1xuICAgICAgICAgICAgZG9tdXRpbC5hZGRDbGFzcyhndWlkZUVsZW1lbnQsIGNvbmZpZy5jbGFzc25hbWUoJ2FsbGRheS1leGNlZWQtbGVmdCcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbXV0aWwucmVtb3ZlQ2xhc3MoZ3VpZGVFbGVtZW50LCBjb25maWcuY2xhc3NuYW1lKCdhbGxkYXktZXhjZWVkLWxlZnQnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNFeGNlZWRlZFJpZ2h0KSB7XG4gICAgICAgICAgICBkb211dGlsLmFkZENsYXNzKGd1aWRlRWxlbWVudCwgY29uZmlnLmNsYXNzbmFtZSgnYWxsZGF5LWV4Y2VlZC1yaWdodCcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbXV0aWwucmVtb3ZlQ2xhc3MoZ3VpZGVFbGVtZW50LCBjb25maWcuY2xhc3NuYW1lKCdhbGxkYXktZXhjZWVkLXJpZ2h0JykpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEdldCBldmVudCBibG9jayBpbmZvcm1hdGlvbiBmcm9tIGV2ZW50IGRhdGEuXG4gKlxuICogRm9yIGV4YW1wbGUsIHRoZXJlIGlzIHNpbmdsZSBldmVudCBoYXMgMTAgbGVuZ3RoLiBidXQgcmVuZGVyIHJhbmdlIGluIHZpZXcgaXMgNSB0aGVuXG4gKiByZW5kZXJlZCBibG9jayBtdXN0IGJlIGN1dCBvdXQgdG8gcmVuZGVyIHByb3Blcmx5LiBpbiB0aGlzIGNhc2UsIHRoaXMgbWV0aG9kIHJldHVyblxuICogaG93IG1hbnkgYmxvY2sgYXJlIGN1dCBiZWZvcmUgcmVuZGVyaW5nLlxuICogXG4gKiDsnbTrsqTtirgg642w7J207YSw7JeQ7IScIOydtOuypO2KuCDruJTroZ0g7JeY66as66i87Yq4IOugjOuNlOungeyXkCDrjIDtlZwg7ZWE7JqUIOygleuztOulvCDstpTstpztlZzri6QuXG4gKlxuICogZXgpIOugjOuNlOungSDrkJwg67iU66Gd7J2YIOq4uOydtOuKlCA17KeA66eMIOyLpOygnCDsnbQg7J2067Kk7Yq464qUIDEw7J2YIOq4uOydtOulvCDqsIDsp4Dqs6Ag7J6I7J2EIOuVjFxuICog7KKMIOyasOuhnCDrqocg66eM7YG8IOyemOugpOyeiOuKlOyngOyXkCDqtIDtlZwg7KCV67O066W8IOuwmO2ZmO2VqC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnU3RhcnRFdmVudERhdGEgLSBldmVudCBkYXRhIGZyb20gQWxsZGF5Lk1vdmUgaGFuZGxlci5cbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gZnVuY3Rpb24gdGhhdCByZXR1cm4gZXZlbnQgYmxvY2sgaW5mb3JtYXRpb24uXG4gKi9cbkFsbGRheU1vdmVHdWlkZS5wcm90b3R5cGUuX2dldEV2ZW50QmxvY2tEYXRhRnVuYyA9IGZ1bmN0aW9uKGRyYWdTdGFydEV2ZW50RGF0YSkge1xuICAgIHZhciBtb2RlbCA9IGRyYWdTdGFydEV2ZW50RGF0YS5tb2RlbCxcbiAgICAgICAgZGF0ZXNJblJhbmdlID0gZHJhZ1N0YXJ0RXZlbnREYXRhLmRhdGVzSW5SYW5nZSxcbiAgICAgICAgYmFzZVdpZHRoUGVyY2VudCA9ICgxMDAgLyBkYXRlc0luUmFuZ2UpLFxuICAgICAgICBvcmlnaW5FdmVudFN0YXJ0cyA9IGRhdGV0aW1lLnN0YXJ0KG1vZGVsLnN0YXJ0cyksXG4gICAgICAgIG9yaWdpbkV2ZW50RW5kcyA9IGRhdGV0aW1lLmVuZChtb2RlbC5lbmRzKSxcbiAgICAgICAgdmlld09wdGlvbnMgPSB0aGlzLmFsbGRheU1vdmUuYWxsZGF5Vmlldy5vcHRpb25zLFxuICAgICAgICByZW5kZXJTdGFydERhdGUgPSBkYXRldGltZS5zdGFydChkYXRldGltZS5wYXJzZSh2aWV3T3B0aW9ucy5yZW5kZXJTdGFydERhdGUpKSxcbiAgICAgICAgcmVuZGVyRW5kRGF0ZSA9IGRhdGV0aW1lLmVuZChkYXRldGltZS5wYXJzZSh2aWV3T3B0aW9ucy5yZW5kZXJFbmREYXRlKSksXG4gICAgICAgIGZyb21MZWZ0ID0gKG5ldyBEYXRlKG9yaWdpbkV2ZW50U3RhcnRzLmdldFRpbWUoKSAtIHJlbmRlclN0YXJ0RGF0ZS5nZXRUaW1lKCkpKSAvIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZIHwgMCxcbiAgICAgICAgZnJvbVJpZ2h0ID0gKG5ldyBEYXRlKG9yaWdpbkV2ZW50RW5kcy5nZXRUaW1lKCkgLSByZW5kZXJFbmREYXRlLmdldFRpbWUoKSkpIC8gZGF0ZXRpbWUuTUlMTElTRUNPTkRTX1BFUl9EQVkgfCAwO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGluZGV4T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiYXNlV2lkdGhQZXJjZW50OiBiYXNlV2lkdGhQZXJjZW50LFxuICAgICAgICAgICAgZnJvbUxlZnQ6IGZyb21MZWZ0ICsgaW5kZXhPZmZzZXQsXG4gICAgICAgICAgICBmcm9tUmlnaHQ6IGZyb21SaWdodCArIGluZGV4T2Zmc2V0XG4gICAgICAgIH07XG4gICAgfTtcbn07XG5cbi8qKlxuICogRHJhZ1N0YXJ0IGV2ZW50IGhhbmRsZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ1N0YXJ0RXZlbnREYXRhIC0gZXZlbnQgZGF0YS5cbiAqL1xuQWxsZGF5TW92ZUd1aWRlLnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbihkcmFnU3RhcnRFdmVudERhdGEpIHtcbiAgICB2YXIgYWxsZGF5Vmlld0NvbnRhaW5lciA9IHRoaXMuYWxsZGF5TW92ZS5hbGxkYXlWaWV3LmNvbnRhaW5lcixcbiAgICAgICAgZ3VpZGVFbGVtZW50ID0gdGhpcy5ndWlkZUVsZW1lbnQgPSBkcmFnU3RhcnRFdmVudERhdGEuZXZlbnRCbG9ja0VsZW1lbnQuY2xvbmVOb2RlKHRydWUpLFxuICAgICAgICBldmVudENvbnRhaW5lcjtcblxuICAgIGlmICghdXRpbC5icm93c2VyLm1zaWUpIHtcbiAgICAgICAgZG9tdXRpbC5hZGRDbGFzcyhnbG9iYWwuZG9jdW1lbnQuYm9keSwgY29uZmlnLmNsYXNzbmFtZSgnZHJhZ2dpbmcnKSk7XG4gICAgfVxuXG4gICAgZXZlbnRDb250YWluZXIgPSBkb211dGlsLmZpbmQoJy4nICsgY29uZmlnLmNsYXNzbmFtZSgnbW9udGh3ZWVrLWV2ZW50cycpLCBhbGxkYXlWaWV3Q29udGFpbmVyKTtcbiAgICBkb211dGlsLmFkZENsYXNzKGd1aWRlRWxlbWVudCwgY29uZmlnLmNsYXNzbmFtZSgnYWxsZGF5LWd1aWRlLW1vdmUnKSk7XG4gICAgZXZlbnRDb250YWluZXIuYXBwZW5kQ2hpbGQoZ3VpZGVFbGVtZW50KTtcblxuICAgIHRoaXMuX2RyYWdTdGFydFhJbmRleCA9IGRyYWdTdGFydEV2ZW50RGF0YS54SW5kZXg7XG4gICAgdGhpcy5nZXRFdmVudERhdGFGdW5jID0gdGhpcy5fZ2V0RXZlbnRCbG9ja0RhdGFGdW5jKGRyYWdTdGFydEV2ZW50RGF0YSk7XG59O1xuXG4vKipcbiAqIERyYWcgZXZlbnQgaGFuZGxlci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnRXZlbnREYXRhIC0gZXZlbnQgZGF0YS5cbiAqL1xuQWxsZGF5TW92ZUd1aWRlLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24oZHJhZ0V2ZW50RGF0YSkge1xuICAgIHZhciBnZXRFdmVudERhdGFGdW5jID0gdGhpcy5nZXRFdmVudERhdGFGdW5jLFxuICAgICAgICBkcmFnU3RhcnRYSW5kZXggPSB0aGlzLl9kcmFnU3RhcnRYSW5kZXgsXG4gICAgICAgIGRhdGVzSW5SYW5nZSA9IGRyYWdFdmVudERhdGEuZGF0ZXNJblJhbmdlLFxuICAgICAgICBldmVudERhdGEsXG4gICAgICAgIGlzRXhjZWVkZWRMZWZ0LFxuICAgICAgICBpc0V4Y2VlZGVkUmlnaHQsXG4gICAgICAgIG9yaWdpbkxlbmd0aCxcbiAgICAgICAgbmV3TGVmdCxcbiAgICAgICAgbmV3V2lkdGg7XG5cbiAgICBpZiAoIWdldEV2ZW50RGF0YUZ1bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50RGF0YSA9IGdldEV2ZW50RGF0YUZ1bmMoZHJhZ0V2ZW50RGF0YS54SW5kZXggLSBkcmFnU3RhcnRYSW5kZXgpO1xuICAgIGlzRXhjZWVkZWRMZWZ0ID0gZXZlbnREYXRhLmZyb21MZWZ0IDwgMDtcbiAgICBpc0V4Y2VlZGVkUmlnaHQgPSBldmVudERhdGEuZnJvbVJpZ2h0ID4gMDtcblxuICAgIG5ld0xlZnQgPSBNYXRoLm1heCgwLCBldmVudERhdGEuZnJvbUxlZnQpO1xuICAgIG9yaWdpbkxlbmd0aCA9IChldmVudERhdGEuZnJvbUxlZnQgKiAtMSkgKyAoZGF0ZXNJblJhbmdlICsgZXZlbnREYXRhLmZyb21SaWdodCk7XG4gICAgbmV3V2lkdGggPSBpc0V4Y2VlZGVkTGVmdCA/IChvcmlnaW5MZW5ndGggKyBldmVudERhdGEuZnJvbUxlZnQpIDogb3JpZ2luTGVuZ3RoO1xuICAgIG5ld1dpZHRoID0gaXNFeGNlZWRlZFJpZ2h0ID8gKG5ld1dpZHRoIC0gZXZlbnREYXRhLmZyb21SaWdodCkgOiBuZXdXaWR0aDtcblxuICAgIG5ld0xlZnQgKj0gZXZlbnREYXRhLmJhc2VXaWR0aFBlcmNlbnQ7XG4gICAgbmV3V2lkdGggKj0gZXZlbnREYXRhLmJhc2VXaWR0aFBlcmNlbnQ7XG5cbiAgICB0aGlzLnJlZnJlc2hHdWlkZUVsZW1lbnQobmV3TGVmdCwgbmV3V2lkdGgsIGlzRXhjZWVkZWRMZWZ0LCBpc0V4Y2VlZGVkUmlnaHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbGxkYXlNb3ZlR3VpZGU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBSZXNpemUgaGFuZGxlciBtb2R1bGUgZm9yIEFsbGRheSB2aWV3LlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciB1dGlsID0gZ2xvYmFsLnR1aS51dGlsO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL2NvbmZpZycpO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2NvbW1vbicpO1xudmFyIEFsbGRheUNvcmUgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBBbGxkYXlSZXNpemVHdWlkZSA9IHJlcXVpcmUoJy4vcmVzaXplR3VpZGUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtIYW5kbGVyfVxuICogQG1peGVzIEFsbGRheUNvcmVcbiAqIEBtaXhlcyBDdXN0b21FdmVudHNcbiAqIEBwYXJhbSB7RHJhZ30gW2RyYWdIYW5kbGVyXSAtIERyYWcgaGFuZGxlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7QWxsZGF5fSBbYWxsZGF5Vmlld10gLSBNb250aFdlZWsgdmlldyBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7QmFzZX0gW2Jhc2VDb250cm9sbGVyXSAtIEJhc2UgY29udHJvbGxlciBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gQWxsZGF5UmVzaXplKGRyYWdIYW5kbGVyLCBhbGxkYXlWaWV3LCBiYXNlQ29udHJvbGxlcikge1xuICAgIC8qKlxuICAgICAqIERyYWcgaGFuZGxlciBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7RHJhZ31cbiAgICAgKi9cbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gZHJhZ0hhbmRsZXI7XG5cbiAgICAvKipcbiAgICAgKiBhbGxkYXkgdmlldyBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7QWxsZGF5fVxuICAgICAqL1xuICAgIHRoaXMuYWxsZGF5VmlldyA9IGFsbGRheVZpZXc7XG5cbiAgICAvKipcbiAgICAgKiBCYXNlIGNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICogQHR5cGUge0Jhc2V9XG4gICAgICovXG4gICAgdGhpcy5iYXNlQ29udHJvbGxlciA9IGJhc2VDb250cm9sbGVyO1xuXG4gICAgLyoqXG4gICAgICogVGVtcG9yYXJ5IHZhcmlhYmxlIGZvciBkcmFnU3RhcnQgZXZlbnQgZGF0YS5cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuX2RyYWdTdGFydCA9IG51bGw7XG5cbiAgICBkcmFnSGFuZGxlci5vbih7XG4gICAgICAgIGRyYWdTdGFydDogdGhpcy5fb25EcmFnU3RhcnRcbiAgICB9LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBbGxkYXlSZXNpemVHdWlkZX1cbiAgICAgKi9cbiAgICB0aGlzLmd1aWRlID0gbmV3IEFsbGRheVJlc2l6ZUd1aWRlKHRoaXMpO1xufVxuXG4vKipcbiAqIERlc3Ryb3kgbWV0aG9kXG4gKi9cbkFsbGRheVJlc2l6ZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZ3VpZGUuZGVzdHJveSgpO1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIub2ZmKHRoaXMpO1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSB0aGlzLmFsbGRheVZpZXcgPSB0aGlzLmJhc2VDb250cm9sbGVyID1cbiAgICAgICAgdGhpcy5ndWlkZSA9IHRoaXMuX2RyYWdTdGFydCA9IG51bGw7XG59O1xuXG4vKipcbiAqIENoZWNrIGRyYWdzdGFydCB0YXJnZXQgaXMgZXhwZWN0ZWQgY29uZGl0aW9ucyBmb3IgdGhpcyBoYW5kbGVyLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gZHJhZ3N0YXJ0IGV2ZW50IGhhbmRsZXIncyB0YXJnZXQgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufE1vbnRoV2Vla30gcmV0dXJuIE1vbnRoV2VlayB2aWV3IGluc3RhbmNlIHdoZW4gc2F0aWF0ZSBjb25kaXRpb24uXG4gKi9cbkFsbGRheVJlc2l6ZS5wcm90b3R5cGUuY2hlY2tFeHBlY3RlZENvbmRpdGlvbiA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgIHZhciBjc3NDbGFzcyA9IGRvbXV0aWwuZ2V0Q2xhc3ModGFyZ2V0KSxcbiAgICAgICAgbWF0Y2hlcztcblxuICAgIGlmICghfmNzc0NsYXNzLmluZGV4T2YoY29uZmlnLmNsYXNzbmFtZSgnYWxsZGF5LXJlc2l6ZS1oYW5kbGUnKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRhcmdldCA9IGRvbXV0aWwuY2xvc2VzdCh0YXJnZXQsICcuJyArIGNvbmZpZy5jbGFzc25hbWUoJ2FsbGRheS1tb250aHdlZWsnKSk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY3NzQ2xhc3MgPSBkb211dGlsLmdldENsYXNzKHRhcmdldCk7XG4gICAgbWF0Y2hlcyA9IGNzc0NsYXNzLm1hdGNoKGNvbmZpZy5hbGxkYXkuZ2V0Vmlld0lEUmVnRXhwKTtcblxuICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlsLnBpY2sodGhpcy5hbGxkYXlWaWV3LmNoaWxkcy5pdGVtcywgbWF0Y2hlc1sxXSk7XG59O1xuXG4vKipcbiAqIERyYWdTdGFydCBldmVudCBoYW5kbGVyLlxuICogQGVtaXRzIEFsbGRheVJlc2l6ZSNhbGxkYXlfcmVzaXplX2RyYWdzdGFydFxuICogQHBhcmFtIHtvYmplY3R9IGRyYWdTdGFydEV2ZW50RGF0YSAtIGV2ZW50IGRhdGEuXG4gKi9cbkFsbGRheVJlc2l6ZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZHJhZ1N0YXJ0RXZlbnREYXRhKSB7XG4gICAgdmFyIHRhcmdldCA9IGRyYWdTdGFydEV2ZW50RGF0YS50YXJnZXQsXG4gICAgICAgIHJlc3VsdCA9IHRoaXMuY2hlY2tFeHBlY3RlZENvbmRpdGlvbih0YXJnZXQpLFxuICAgICAgICBjb250cm9sbGVyID0gdGhpcy5iYXNlQ29udHJvbGxlcixcbiAgICAgICAgZXZlbnRCbG9ja0VsZW1lbnQsXG4gICAgICAgIG1vZGVsSUQsXG4gICAgICAgIHRhcmdldE1vZGVsLFxuICAgICAgICBnZXRFdmVudERhdGFGdW5jLFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnRCbG9ja0VsZW1lbnQgPSBkb211dGlsLmNsb3Nlc3QodGFyZ2V0LCAnLicgKyBjb25maWcuY2xhc3NuYW1lKCdhbGxkYXktZXZlbnQtYmxvY2snKSk7XG4gICAgbW9kZWxJRCA9IGRvbXV0aWwuZ2V0RGF0YShldmVudEJsb2NrRWxlbWVudCwgJ2lkJyk7XG4gICAgdGFyZ2V0TW9kZWwgPSBjb250cm9sbGVyLmV2ZW50cy5pdGVtc1ttb2RlbElEXTtcblxuICAgIGlmICghdGFyZ2V0TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLmdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9yZXRyaXZlRXZlbnREYXRhKHRoaXMuYWxsZGF5VmlldywgZHJhZ1N0YXJ0RXZlbnREYXRhLm9yaWdpbkV2ZW50KTtcbiAgICBldmVudERhdGEgPSB0aGlzLl9kcmFnU3RhcnQgPSBnZXRFdmVudERhdGFGdW5jKGRyYWdTdGFydEV2ZW50RGF0YS5vcmlnaW5FdmVudCk7XG5cbiAgICB1dGlsLmV4dGVuZChldmVudERhdGEsIHtcbiAgICAgICAgZXZlbnRCbG9ja0VsZW1lbnQ6IGV2ZW50QmxvY2tFbGVtZW50LFxuICAgICAgICBtb2RlbDogdGFyZ2V0TW9kZWxcbiAgICB9KTtcblxuICAgIHRoaXMuZHJhZ0hhbmRsZXIub24oe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBBbGxkYXlSZXNpemUjYWxsZGF5X3Jlc2l6ZV9kcmFnc3RhcnRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7QWxsZGF5Vmlld30gcmVsYXRlZFZpZXcgLSBhbGxkYXkgdmlldyBpbnN0YW5jZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGF0ZXNJblJhbmdlIC0gZGF0ZSBjb3VudCBvZiB0aGlzIHZpZXcuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRyYWdTdGFydFhJbmRleCAtIGluZGV4IG51bWJlciBvZiBkcmFnc3RhcnQgZ3JpZCBpbmRleC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIG1vdXNlIHBvc2l0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkge0NhbEV2ZW50fSBtb2RlbCAtIGRhdGEgb2JqZWN0IG9mIG1vZGVsIGlzbnRhbmNlLlxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTERpdkVsZW1lbnR9IGV2ZW50QmxvY2tFbGVtZW50IC0gdGFyZ2V0IGV2ZW50IGJsb2NrIGVsZW1lbnQuXG4gICAgICovXG4gICAgdGhpcy5maXJlKCdhbGxkYXlfcmVzaXplX2RyYWdzdGFydCcsIGV2ZW50RGF0YSk7XG59O1xuXG4vKipcbiAqIERyYWcgZXZlbnQgaGFuZGxlciBtZXRob2QuXG4gKiBAZW1pdHMgQWxsZGF5UmVzaXplI2FsbGRheV9yZXNpemVfZHJhZ1xuICogQHBhcmFtIHtvYmplY3R9IGRyYWdFdmVudERhdGEgLSBEcmFnI2RyYWcgZXZlbnQgaGFuZGxlciBldmVudGRhdGEuXG4gKi9cbkFsbGRheVJlc2l6ZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uKGRyYWdFdmVudERhdGEpIHtcbiAgICB2YXIgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuZ2V0RXZlbnREYXRhRnVuYztcblxuICAgIGlmICghZ2V0RXZlbnREYXRhRnVuYykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IEFsbGRheVJlc2l6ZSNhbGxkYXlfcmVzaXplX2RyYWdcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7QWxsZGF5Vmlld30gcmVsYXRlZFZpZXcgLSBhbGxkYXkgdmlldyBpbnN0YW5jZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGF0ZXNJblJhbmdlIC0gZGF0ZSBjb3VudCBvZiB0aGlzIHZpZXcuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRyYWdTdGFydFhJbmRleCAtIGluZGV4IG51bWJlciBvZiBkcmFnc3RhcnQgZ3JpZCBpbmRleC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIG1vdXNlIHBvc2l0aW9ucy5cbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ2FsbGRheV9yZXNpemVfZHJhZycsIGdldEV2ZW50RGF0YUZ1bmMoZHJhZ0V2ZW50RGF0YS5vcmlnaW5FdmVudCkpO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IHVwZGF0ZSBldmVudCBpbnN0YW5jZSB0byBiYXNlIGNvbnRyb2xsZXIuXG4gKiBAZmlyZXMgQWxsZGF5UmVzaXplI2JlZm9yZVVwZGF0ZUV2ZW50XG4gKiBAcGFyYW0ge29iamVjdH0gZXZlbnREYXRhIC0gZXZlbnQgZGF0YSBmcm9tIEFsbGRheVJlc2l6ZSBoYW5kbGVyLlxuICovXG5BbGxkYXlSZXNpemUucHJvdG90eXBlLl91cGRhdGVFdmVudCA9IGZ1bmN0aW9uKGV2ZW50RGF0YSkge1xuICAgIHZhciBtb2RlbCA9IGV2ZW50RGF0YS50YXJnZXRNb2RlbCxcbiAgICAgICAgZGF0ZU9mZnNldCA9IGV2ZW50RGF0YS54SW5kZXggLSBldmVudERhdGEuZHJhZ1N0YXJ0WEluZGV4LFxuICAgICAgICBuZXdFbmRzID0gbmV3IERhdGUobW9kZWwuZW5kcy5nZXRUaW1lKCkpO1xuXG4gICAgbmV3RW5kcyA9IG5ldyBEYXRlKG5ld0VuZHMuc2V0RGF0ZShuZXdFbmRzLmdldERhdGUoKSArIGRhdGVPZmZzZXQpKTtcbiAgICBuZXdFbmRzID0gbmV3IERhdGUoTWF0aC5tYXgoZGF0ZXRpbWUuZW5kKG1vZGVsLnN0YXJ0cykuZ2V0VGltZSgpLCBuZXdFbmRzLmdldFRpbWUoKSkpO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IEFsbGRheVJlc2l6ZSNiZWZvcmVVcGRhdGVFdmVudFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtDYWxFdmVudH0gbW9kZWwgLSBtb2RlbCBpbnN0YW5jZSB0byB1cGRhdGVcbiAgICAgKiBAcHJvcGVydHkge2RhdGV9IHN0YXJ0cyAtIHN0YXJ0IHRpbWUgdG8gdXBkYXRlXG4gICAgICogQHByb3BlcnR5IHtkYXRlfSBlbmRzIC0gZW5kIHRpbWUgdG8gdXBkYXRlXG4gICAgICovXG4gICAgdGhpcy5maXJlKCdiZWZvcmVVcGRhdGVFdmVudCcsIHtcbiAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICBzdGFydHM6IG1vZGVsLmdldFN0YXJ0cygpLFxuICAgICAgICBlbmRzOiBuZXdFbmRzXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIERyYWdFbmQgZXZlbnQgaGFuZGVyIG1ldGhvZC5cbiAqIEBlbWl0cyBBbGxkYXlSZXNpemUjYWxsZGF5X3Jlc2l6ZV9kcmFnZW5kXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ0VuZEV2ZW50RGF0YSAtIERyYWcjRHJhZ0VuZCBldmVudCBoYW5kbGVyIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gW292ZXJyaWRlRXZlbnROYW1lXSAtIG92ZXJyaWRlIGVtaXR0ZWQgZXZlbnQgbmFtZSB3aGVuIHN1cHBsaWVkLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gc2tpcFVwZGF0ZSAtIHRydWUgdGhlbiBza2lwIHVwZGF0ZSBldmVudCBtb2RlbC5cbiAqL1xuQWxsZGF5UmVzaXplLnByb3RvdHlwZS5fb25EcmFnRW5kID0gZnVuY3Rpb24oZHJhZ0VuZEV2ZW50RGF0YSwgb3ZlcnJpZGVFdmVudE5hbWUsIHNraXBVcGRhdGUpIHtcbiAgICB2YXIgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuZ2V0RXZlbnREYXRhRnVuYyxcbiAgICAgICAgZHJhZ1N0YXJ0ID0gdGhpcy5fZHJhZ1N0YXJ0LFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICBpZiAoIWdldEV2ZW50RGF0YUZ1bmMgfHwgIWRyYWdTdGFydCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnSGFuZGxlci5vZmYoe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIGV2ZW50RGF0YSA9IGdldEV2ZW50RGF0YUZ1bmMoZHJhZ0VuZEV2ZW50RGF0YS5vcmlnaW5FdmVudCk7XG4gICAgdXRpbC5leHRlbmQoZXZlbnREYXRhLCB7XG4gICAgICAgIHRhcmdldE1vZGVsOiBkcmFnU3RhcnQubW9kZWxcbiAgICB9KTtcblxuICAgIGlmICghc2tpcFVwZGF0ZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVFdmVudChldmVudERhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBldmVudCBBbGxkYXlSZXNpemUjYWxsZGF5X3Jlc2l6ZV9kcmFnZW5kXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0FsbGRheVZpZXd9IHJlbGF0ZWRWaWV3IC0gYWxsZGF5IHZpZXcgaW5zdGFuY2UuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGVzSW5SYW5nZSAtIGRhdGUgY291bnQgb2YgdGhpcyB2aWV3LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkcmFnU3RhcnRYSW5kZXggLSBpbmRleCBudW1iZXIgb2YgZHJhZ3N0YXJ0IGdyaWQgaW5kZXguXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHhJbmRleCAtIGluZGV4IG51bWJlciBvZiBtb3VzZSBwb3NpdGlvbnMuXG4gICAgICovXG4gICAgdGhpcy5maXJlKG92ZXJyaWRlRXZlbnROYW1lIHx8ICdhbGxkYXlfcmVzaXplX2RyYWdlbmQnLCBldmVudERhdGEpO1xuXG4gICAgdGhpcy5nZXRFdmVudERhdGFGdW5jID0gdGhpcy5fZHJhZ1N0YXJ0ID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xpY2sgZXZlbnQgaGFuZGxlciBtZXRob2QuXG4gKiBAZW1pdHMgQWxsZGF5UmVzaXplI2FsbGRheV9yZXNpemVfY2xpY2tcbiAqIEBwYXJhbSB7b2JqZWN0fSBjbGlja0V2ZW50RGF0YSAtIERyYWcjQ2xpY2sgZXZlbnQgaGFuZGxlciBkYXRhLlxuICovXG5BbGxkYXlSZXNpemUucHJvdG90eXBlLl9vbkNsaWNrID0gZnVuY3Rpb24oY2xpY2tFdmVudERhdGEpIHtcbiAgICAvKipcbiAgICAgKiBAZXZlbnQgQWxsZGF5UmVzaXplI2FsbGRheV9yZXNpemVfY2xpY2tcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7QWxsZGF5Vmlld30gcmVsYXRlZFZpZXcgLSBhbGxkYXkgdmlldyBpbnN0YW5jZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGF0ZXNJblJhbmdlIC0gZGF0ZSBjb3VudCBvZiB0aGlzIHZpZXcuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRyYWdTdGFydFhJbmRleCAtIGluZGV4IG51bWJlciBvZiBkcmFnc3RhcnQgZ3JpZCBpbmRleC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIG1vdXNlIHBvc2l0aW9ucy5cbiAgICAgKi9cbiAgICB0aGlzLl9vbkRyYWdFbmQoY2xpY2tFdmVudERhdGEsICdhbGxkYXlfcmVzaXplX2NsaWNrJywgdHJ1ZSk7XG59O1xuXG5jb21tb24ubWl4aW4oQWxsZGF5Q29yZSwgQWxsZGF5UmVzaXplKTtcbnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKEFsbGRheVJlc2l6ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWxsZGF5UmVzaXplO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVzaXplIEd1aWRlIG1vZHVsZS5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgdXRpbCA9IGdsb2JhbC50dWkudXRpbDtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi8uLi9jb25maWcnKTtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciBkYXRldGltZSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kYXRldGltZScpO1xudmFyIHJlcUFuaW1GcmFtZSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9yZXFBbmltRnJhbWUnKTtcblxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBbGxkYXlSZXNpemV9IGFsbGRheVJlc2l6ZSAtIGluc3RhbmNlIG9mIEFsbGRheVJlc2l6ZVxuICovXG5mdW5jdGlvbiBBbGxkYXlSZXNpemVHdWlkZShhbGxkYXlSZXNpemUpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QWxsZGF5UmVzaXplfVxuICAgICAqL1xuICAgIHRoaXMuYWxsZGF5UmVzaXplID0gYWxsZGF5UmVzaXplO1xuXG4gICAgLyoqXG4gICAgICog7Iuk7KCc66GcIOydtOuypO2KuCDsl5jrpqzrqLztirjrpbwg64u064qUIOyXmOumrOuovO2KuFxuICAgICAqIEB0eXBlIHtIVE1MRElWRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmV2ZW50Q29udGFpbmVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmdldEV2ZW50RGF0YUZ1bmMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0hUTUxESVZFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZ3VpZGVFbGVtZW50ID0gbnVsbDtcblxuICAgIGFsbGRheVJlc2l6ZS5vbih7XG4gICAgICAgICdhbGxkYXlfcmVzaXplX2RyYWdzdGFydCc6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuICAgICAgICAnYWxsZGF5X3Jlc2l6ZV9kcmFnJzogdGhpcy5fb25EcmFnLFxuICAgICAgICAnYWxsZGF5X3Jlc2l6ZV9kcmFnZW5kJzogdGhpcy5fY2xlYXJHdWlkZUVsZW1lbnQsXG4gICAgICAgICdhbGxkYXlfcmVzaXplX2NsaWNrJzogdGhpcy5fY2xlYXJHdWlkZUVsZW1lbnRcbiAgICB9LCB0aGlzKTtcbn1cblxuLyoqXG4gKiBEZXN0cm95IG1ldGhvZFxuICovXG5BbGxkYXlSZXNpemVHdWlkZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NsZWFyR3VpZGVFbGVtZW50KCk7XG4gICAgdGhpcy5hbGxkYXlSZXNpemUub2ZmKHRoaXMpO1xuICAgIHRoaXMuYWxsZGF5UmVzaXplID0gdGhpcy5ldmVudENvbnRhaW5lciA9IHRoaXMuZ2V0RXZlbnREYXRhRnVuYyA9XG4gICAgICAgIHRoaXMuZ3VpZGVFbGVtZW50ID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xlYXIgZ3VpZGUgZWxlbWVudC5cbiAqL1xuQWxsZGF5UmVzaXplR3VpZGUucHJvdG90eXBlLl9jbGVhckd1aWRlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIGRvbXV0aWwucmVtb3ZlKHRoaXMuZ3VpZGVFbGVtZW50KTtcblxuICAgIGlmICghdXRpbC5icm93c2VyLm1zaWUpIHtcbiAgICAgICAgZG9tdXRpbC5yZW1vdmVDbGFzcyhnbG9iYWwuZG9jdW1lbnQuYm9keSwgY29uZmlnLmNsYXNzbmFtZSgncmVzaXppbmcteCcpKTtcbiAgICB9XG5cbiAgICB0aGlzLmdldEV2ZW50RGF0YUZ1bmMgPSBudWxsO1xufTtcblxuLyoqXG4gKiBSZWZyZXNoIGd1aWRlIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdXaWR0aCAtIG5ldyB3aWR0aCBwZXJjZW50YWdlIHZhbHVlIHRvIHJlc2l6ZSBndWlkZSBlbGVtZW50LlxuICovXG5BbGxkYXlSZXNpemVHdWlkZS5wcm90b3R5cGUucmVmcmVzaEd1aWRlRWxlbWVudCA9IGZ1bmN0aW9uKG5ld1dpZHRoKSB7XG4gICAgdmFyIGd1aWRlRWxlbWVudCA9IHRoaXMuZ3VpZGVFbGVtZW50O1xuXG4gICAgcmVxQW5pbUZyYW1lLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgIGd1aWRlRWxlbWVudC5zdHlsZS53aWR0aCA9IG5ld1dpZHRoICsgJyUnO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gZnVuY3Rpb24gdGhhdCBjYWxjdWxhdGUgZ3VpZGUgZWxlbWVudCdzIG5ldyB3aWR0aCBwZXJjZW50YWdlIHZhbHVlLlxuICogQHBhcmFtIHtvYmplY3R9IGRyYWdTdGFydEV2ZW50RGF0YSAtIGRyYWdzdGFydCBldmVudCBkYXRhLlxuICogQHJldHVybnMge2Z1bmN0aW9ufSByZXR1cm4gZnVuY3Rpb24gdGhhdCBjYWxjdWxhdGUgZ3VpZGUgZWxlbWVudCBuZXcgd2lkdGggcGVyY2VudGFnZS5cbiAqL1xuQWxsZGF5UmVzaXplR3VpZGUucHJvdG90eXBlLmdldEd1aWRlRWxlbWVudFdpZHRoRnVuYyA9IGZ1bmN0aW9uKGRyYWdTdGFydEV2ZW50RGF0YSkge1xuICAgIHZhciBtb2RlbCA9IGRyYWdTdGFydEV2ZW50RGF0YS5tb2RlbCxcbiAgICAgICAgdmlld09wdGlvbnMgPSB0aGlzLmFsbGRheVJlc2l6ZS5hbGxkYXlWaWV3Lm9wdGlvbnMsXG4gICAgICAgIHN0YXJ0RGF0ZSA9IGRhdGV0aW1lLnN0YXJ0KG5ldyBEYXRlKE1hdGgubWF4KG1vZGVsLnN0YXJ0cy5nZXRUaW1lKCksIGRhdGV0aW1lLnBhcnNlKHZpZXdPcHRpb25zLnJlbmRlclN0YXJ0RGF0ZSkuZ2V0VGltZSgpKSkpLFxuICAgICAgICBlbmREYXRlID0gZGF0ZXRpbWUuZW5kKG5ldyBEYXRlKE1hdGgubWluKG1vZGVsLmVuZHMuZ2V0VGltZSgpLCBkYXRldGltZS5wYXJzZSh2aWV3T3B0aW9ucy5yZW5kZXJFbmREYXRlKS5nZXRUaW1lKCkpKSksXG4gICAgICAgIG9yaWdpbkxlbmd0aCA9IGRhdGV0aW1lLnJhbmdlKHN0YXJ0RGF0ZSwgZW5kRGF0ZSwgZGF0ZXRpbWUuTUlMTElTRUNPTkRTX1BFUl9EQVkpLmxlbmd0aCxcbiAgICAgICAgYmFzZVdpZHRoUGVyY2VudCA9IDEwMCAvIGRyYWdTdGFydEV2ZW50RGF0YS5kYXRlc0luUmFuZ2UsXG4gICAgICAgIGRyYWdTdGFydEluZGV4ID0gZHJhZ1N0YXJ0RXZlbnREYXRhLnhJbmRleDtcblxuICAgIHJldHVybiBmdW5jdGlvbih4SW5kZXgpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHhJbmRleCAtIGRyYWdTdGFydEluZGV4LFxuICAgICAgICAgICAgbmV3TGVuZ3RoID0gb3JpZ2luTGVuZ3RoICsgb2Zmc2V0O1xuXG4gICAgICAgIG5ld0xlbmd0aCA9IE1hdGgubWF4KDEsIG5ld0xlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIG5ld0xlbmd0aCAqIGJhc2VXaWR0aFBlcmNlbnQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEcmFnU3RhcnQgZXZlbnQgaGFuZGxlci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnU3RhcnRFdmVudERhdGEgLSBldmVudCBkYXRhLlxuICovXG5BbGxkYXlSZXNpemVHdWlkZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZHJhZ1N0YXJ0RXZlbnREYXRhKSB7XG4gICAgdmFyIGFsbGRheVZpZXdDb250YWluZXIgPSB0aGlzLmFsbGRheVJlc2l6ZS5hbGxkYXlWaWV3LmNvbnRhaW5lcixcbiAgICAgICAgZ3VpZGVFbGVtZW50ID0gdGhpcy5ndWlkZUVsZW1lbnQgPSBkcmFnU3RhcnRFdmVudERhdGEuZXZlbnRCbG9ja0VsZW1lbnQuY2xvbmVOb2RlKHRydWUpLFxuICAgICAgICBldmVudENvbnRhaW5lcjtcblxuICAgIGlmICghdXRpbC5icm93c2VyLm1zaWUpIHtcbiAgICAgICAgZG9tdXRpbC5hZGRDbGFzcyhnbG9iYWwuZG9jdW1lbnQuYm9keSwgY29uZmlnLmNsYXNzbmFtZSgncmVzaXppbmcteCcpKTtcbiAgICB9XG5cbiAgICBldmVudENvbnRhaW5lciA9IGRvbXV0aWwuZmluZCgnLicgKyBjb25maWcuY2xhc3NuYW1lKCdtb250aHdlZWstZXZlbnRzJyksIGFsbGRheVZpZXdDb250YWluZXIpO1xuICAgIGRvbXV0aWwuYWRkQ2xhc3MoZ3VpZGVFbGVtZW50LCBjb25maWcuY2xhc3NuYW1lKCdhbGxkYXktZ3VpZGUtbW92ZScpKTtcbiAgICBldmVudENvbnRhaW5lci5hcHBlbmRDaGlsZChndWlkZUVsZW1lbnQpO1xuXG4gICAgdGhpcy5nZXRFdmVudERhdGFGdW5jID0gdGhpcy5nZXRHdWlkZUVsZW1lbnRXaWR0aEZ1bmMoZHJhZ1N0YXJ0RXZlbnREYXRhKTtcbn07XG5cbi8qKlxuICogRHJhZyBldmVudCBoYW5kbGVyLlxuICogQHBhcmFtIHtvYmplY3R9IGRyYWdFdmVudERhdGEgLSBldmVudCBkYXRhLlxuICovXG5BbGxkYXlSZXNpemVHdWlkZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uKGRyYWdFdmVudERhdGEpIHtcbiAgICB2YXIgZnVuYyA9IHRoaXMuZ2V0RXZlbnREYXRhRnVuYztcblxuICAgIGlmICghZnVuYykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZWZyZXNoR3VpZGVFbGVtZW50KGZ1bmMoZHJhZ0V2ZW50RGF0YS54SW5kZXgpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWxsZGF5UmVzaXplR3VpZGU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBEcmFnIGhhbmRsZXIgZm9yIGNhbGVuZGFyLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwudHVpLnV0aWw7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgZG9tZXZlbnQgPSByZXF1aXJlKCcuLi9jb21tb24vZG9tZXZlbnQnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBtaXhlcyBDdXN0b21FdmVudHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgZHJhZyBoYW5kbGVyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGlzdGFuY2U9MTBdIC0gZGlzdGFuY2UgaW4gcGl4ZWxzIGFmdGVyIG1vdXNlIG11c3QgbW92ZSBiZWZvcmUgZHJhZ2dpbmcgc2hvdWxkIHN0YXJ0XG4gKiBAcGFyYW0ge0xheW91dFZpZXd9IGxheW91dFZpZXcgTGF5b3V0IHZpZXcgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIERyYWcob3B0aW9ucywgbGF5b3V0Vmlldykge1xuICAgIHZhciBjb250YWluZXIgPSBsYXlvdXRWaWV3LmNvbnRhaW5lcjtcblxuICAgIGRvbWV2ZW50Lm9uKGNvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgZGlzdGFuY2U6IDEwXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9pc01vdmVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBkcmFnZ2luZyBkaXN0YW5jZSBpbiBwaXhlbCBiZXR3ZWVuIG1vdXNlZG93biBhbmQgZmlyaW5nIGRyYWdTdGFydCBldmVudHNcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX2Rpc3RhbmNlID0gMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuX2RyYWdTdGFydEZpcmVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuX2RyYWdTdGFydEV2ZW50RGF0YSA9IG51bGw7XG59XG5cbi8qKlxuICogRGVzdHJveSBtZXRob2QuXG4gKi9cbkRyYWcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICBkb21ldmVudC5vZmYodGhpcy5jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG4gICAgdGhpcy5faXNNb3ZlZCA9IG51bGw7XG4gICAgdGhpcy5jb250YWluZXIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBUb2dnbGUgZXZlbnRzIGZvciBtb3VzZSBkcmFnZ2luZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdG9CaW5kIC0gYmluZCBldmVudHMgcmVsYXRlZCB3aXRoIGRyYWdnaW5nIHdoZW4gc3VwcGxpZWQgXCJ0cnVlXCJcbiAqL1xuRHJhZy5wcm90b3R5cGUuX3RvZ2dsZURyYWdFdmVudCA9IGZ1bmN0aW9uKHRvQmluZCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgZG9tTWV0aG9kLFxuICAgICAgICBtZXRob2Q7XG5cbiAgICBpZiAodG9CaW5kKSB7XG4gICAgICAgIGRvbU1ldGhvZCA9ICdvbic7XG4gICAgICAgIG1ldGhvZCA9ICdkaXNhYmxlJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBkb21NZXRob2QgPSAnb2ZmJztcbiAgICAgICAgbWV0aG9kID0gJ2VuYWJsZSc7XG4gICAgfVxuXG4gICAgZG9tdXRpbFttZXRob2QgKyAnVGV4dFNlbGVjdGlvbiddKGNvbnRhaW5lcik7XG4gICAgZG9tdXRpbFttZXRob2QgKyAnSW1hZ2VEcmFnJ10oY29udGFpbmVyKTtcbiAgICBkb21ldmVudFtkb21NZXRob2RdKGdsb2JhbCwge1xuICAgICAgICBtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuICAgICAgICBtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXBcbiAgICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gbW91c2VFdmVudCAtIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAqIEByZXR1cm5zIHtvYmplY3R9IG5vcm1hbGl6ZWQgbW91c2UgZXZlbnQgZGF0YS5cbiAqL1xuRHJhZy5wcm90b3R5cGUuX2dldEV2ZW50RGF0YSA9IGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IG1vdXNlRXZlbnQudGFyZ2V0IHx8IG1vdXNlRXZlbnQuc3JjRWxlbWVudCxcbiAgICAgICAgb3JpZ2luRXZlbnQ6IG1vdXNlRXZlbnRcbiAgICB9O1xufTtcblxuLyoqXG4gKiBNb3VzZURvd24gRE9NIGV2ZW50IGhhbmRsZXIuXG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IG1vdXNlRG93bkV2ZW50IE1vdXNlRG93biBldmVudCBvYmplY3QuXG4gKi9cbkRyYWcucHJvdG90eXBlLl9vbk1vdXNlRG93biA9IGZ1bmN0aW9uKG1vdXNlRG93bkV2ZW50KSB7XG4gICAgLy8gb25seSBwcmltYXJ5IGJ1dHRvbiBjYW4gc3RhcnQgZHJhZy5cbiAgICBpZiAoZG9tZXZlbnQuZ2V0TW91c2VCdXR0b24obW91c2VEb3duRXZlbnQpICE9PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9kaXN0YW5jZSA9IDA7XG4gICAgdGhpcy5fZHJhZ1N0YXJ0RmlyZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kcmFnU3RhcnRFdmVudERhdGEgPSB0aGlzLl9nZXRFdmVudERhdGEobW91c2VEb3duRXZlbnQpO1xuXG4gICAgdGhpcy5fdG9nZ2xlRHJhZ0V2ZW50KHRydWUpO1xufTtcblxuLyoqXG4gKiBNb3VzZU1vdmUgRE9NIGV2ZW50IGhhbmRsZXIuXG4gKiBAZW1pdHMgRHJhZyNkcmFnXG4gKiBAZW1pdHMgRHJhZyNkcmFnU3RhcnRcbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gbW91c2VNb3ZlRXZlbnQgTW91c2VNb3ZlIGV2ZW50IG9iamVjdC5cbiAqL1xuRHJhZy5wcm90b3R5cGUuX29uTW91c2VNb3ZlID0gZnVuY3Rpb24obW91c2VNb3ZlRXZlbnQpIHtcbiAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLm9wdGlvbnMuZGlzdGFuY2U7XG4gICAgLy8gcHJldmVudCBhdXRvbWF0aWMgc2Nyb2xsaW5nLlxuICAgIGRvbWV2ZW50LnByZXZlbnREZWZhdWx0KG1vdXNlTW92ZUV2ZW50KTtcblxuICAgIHRoaXMuX2lzTW92ZWQgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuX2Rpc3RhbmNlIDwgZGlzdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UgKz0gMTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZHJhZ1N0YXJ0RmlyZWQpIHtcbiAgICAgICAgdGhpcy5fZHJhZ1N0YXJ0RmlyZWQgPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEcmFnIHN0YXJ0cyBldmVudHMuIGNhbmNlbGFibGUuXG4gICAgICAgICAqIEBldmVudCBEcmFnI2RyYWdTdGFydFxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSB0YXJnZXQgLSB0YXJnZXQgZWxlbWVudCBpbiB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkge01vdXNlRXZlbnR9IG9yaWdpbkV2ZW50IC0gb3JpZ2luYWwgbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCF0aGlzLmludm9rZSgnZHJhZ1N0YXJ0JywgdGhpcy5fZHJhZ1N0YXJ0RXZlbnREYXRhKSkge1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRHJhZ0V2ZW50KGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbEV2ZW50cyB3aGlsZSBkcmFnZ2luZy5cbiAgICAgKiBAZXZlbnQgRHJhZyNkcmFnXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSB0YXJnZXQgLSB0YXJnZXQgZWxlbWVudCBpbiB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7TW91c2VFdmVudH0gb3JpZ2luRXZlbnQgLSBvcmlnaW5hbCBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICovXG4gICAgdGhpcy5maXJlKCdkcmFnJywgdGhpcy5fZ2V0RXZlbnREYXRhKG1vdXNlTW92ZUV2ZW50KSk7XG59O1xuXG4vKipcbiAqIE1vdXNlVXAgRE9NIGV2ZW50IGhhbmRsZXIuXG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IG1vdXNlVXBFdmVudCBNb3VzZVVwIGV2ZW50IG9iamVjdC5cbiAqIEBlbWl0cyBEcmFnI2RyYWdFbmRcbiAqIEBlbWl0cyBEcmFnI2NsaWNrXG4gKi9cbkRyYWcucHJvdG90eXBlLl9vbk1vdXNlVXAgPSBmdW5jdGlvbihtb3VzZVVwRXZlbnQpIHtcbiAgICB0aGlzLl90b2dnbGVEcmFnRXZlbnQoZmFsc2UpO1xuXG4gICAgLy8gZW1pdCBcImNsaWNrXCIgZXZlbnQgd2hlbiBub3QgZW1pdHRlZCBkcmFnIGV2ZW50IGJldHdlZW4gbW91c2Vkb3duIGFuZCBtb3VzZXVwLlxuICAgIGlmICh0aGlzLl9pc01vdmVkKSB7XG4gICAgICAgIHRoaXMuX2lzTW92ZWQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRHJhZyBlbmQgZXZlbnRzLlxuICAgICAgICAgKiBAZXZlbnQgRHJhZyNkcmFnRW5kXG4gICAgICAgICAqIEB0eXBlIHtNb3VzZUV2ZW50fVxuICAgICAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSB0YXJnZXQgLSB0YXJnZXQgZWxlbWVudCBpbiB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkge01vdXNlRXZlbnR9IG9yaWdpbkV2ZW50IC0gb3JpZ2luYWwgbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maXJlKCdkcmFnRW5kJywgdGhpcy5fZ2V0RXZlbnREYXRhKG1vdXNlVXBFdmVudCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xpY2sgZXZlbnRzLlxuICAgICAqIEBldmVudCBEcmFnI2NsaWNrXG4gICAgICogQHR5cGUge01vdXNlRXZlbnR9XG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gdGFyZ2V0IGVsZW1lbnQgaW4gdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge01vdXNlRXZlbnR9IG9yaWdpbkV2ZW50IC0gb3JpZ2luYWwgbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqL1xuICAgIHRoaXMuZmlyZSgnY2xpY2snLCB0aGlzLl9nZXRFdmVudERhdGEobW91c2VVcEV2ZW50KSk7XG59O1xuXG51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihEcmFnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcmFnO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQWxsZGF5IGV2ZW50IGNsaWNrIGV2ZW50IGhhbmRlciBtb2R1bGVcbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLnR1aS51dGlsO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL2NvbmZpZycpO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge0hhbmRsZXJ9XG4gKiBAbWl4ZXMgdXRpbC5DdXN0b21FdmVudHNcbiAqIEBwYXJhbSB7RHJhZ30gW2RyYWdIYW5kbGVyXSAtIERyYWcgaGFuZGxlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7VGltZUdyaWR9IFt0aW1lR3JpZFZpZXddIC0gVGltZUdyaWQgdmlldyBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7QmFzZX0gW2Jhc2VDb250cm9sbGVyXSAtIEJhc2UgY29udHJvbGxlciBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gVGltZUNsaWNrKGRyYWdIYW5kbGVyLCB0aW1lR3JpZFZpZXcsIGJhc2VDb250cm9sbGVyKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0RyYWd9XG4gICAgICovXG4gICAgdGhpcy5kcmFnSGFuZGxlciA9IGRyYWdIYW5kbGVyO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1RpbWVHcmlkfVxuICAgICAqL1xuICAgIHRoaXMudGltZUdyaWRWaWV3ID0gdGltZUdyaWRWaWV3O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Jhc2V9XG4gICAgICovXG4gICAgdGhpcy5iYXNlQ29udHJvbGxlciA9IGJhc2VDb250cm9sbGVyO1xuXG4gICAgZHJhZ0hhbmRsZXIub24oe1xuICAgICAgICAnY2xpY2snOiB0aGlzLl9vbkNsaWNrXG4gICAgfSwgdGhpcyk7XG59XG5cbi8qKlxuICogRGVzdHJveSBtZXRob2RcbiAqL1xuVGltZUNsaWNrLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kcmFnSGFuZGxlci5vZmYodGhpcyk7XG4gICAgdGhpcy50aW1lR3JpZFZpZXcgPSB0aGlzLmJhc2VDb250cm9sbGVyID0gdGhpcy5kcmFnSGFuZGxlciA9IG51bGw7XG59O1xuXG4vKipcbiAqIENoZWNrIHRhcmdldCBlbGVtZW50IGlzIGV4cGVjdGVkIGNvbmRpdGlvbiBmb3IgYWN0aXZhdGUgdGhpcyBwbHVnaW5zLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gVGhlIGVsZW1lbnQgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gbW9kZWwgaWRcbiAqL1xuVGltZUNsaWNrLnByb3RvdHlwZS5jaGVja0V4cGVjdENvbmRpdGlvbiA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgIHZhciBjb250YWluZXIsXG4gICAgICAgIG1hdGNoZXM7XG5cbiAgICBjb250YWluZXIgPSBkb211dGlsLmNsb3Nlc3QodGFyZ2V0LCAnLicgKyBjb25maWcuY2xhc3NuYW1lKCd0aW1lLWRhdGUnKSk7XG5cbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbWF0Y2hlcyA9IGRvbXV0aWwuZ2V0Q2xhc3MoY29udGFpbmVyKS5tYXRjaChjb25maWcudGltZS5nZXRWaWV3SURSZWdFeHApO1xuXG4gICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWwucGljayh0aGlzLnRpbWVHcmlkVmlldy5jaGlsZHMuaXRlbXMsICttYXRjaGVzWzFdKTtcbn07XG5cbi8qKlxuICogQ2xpY2sgZXZlbnQgaGFuZGVyXG4gKiBAcGFyYW0ge29iamVjdH0gY2xpY2tFdmVudCAtIGNsaWNrIGV2ZW50IGZyb20ge0BsaW5rIERyYWd9XG4gKiBAZW1pdHMgVGltZUNsaWNrI2NsaWNrRXZlbnRcbiAqL1xuVGltZUNsaWNrLnByb3RvdHlwZS5fb25DbGljayA9IGZ1bmN0aW9uKGNsaWNrRXZlbnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gY2xpY2tFdmVudC50YXJnZXQsXG4gICAgICAgIHRpbWVWaWV3ID0gdGhpcy5jaGVja0V4cGVjdENvbmRpdGlvbih0YXJnZXQpLFxuICAgICAgICBibG9ja0VsZW1lbnQgPSBkb211dGlsLmNsb3Nlc3QodGFyZ2V0LCAnLicgKyBjb25maWcuY2xhc3NuYW1lKCd0aW1lLWRhdGUtZXZlbnQtYmxvY2snKSksXG4gICAgICAgIGV2ZW50Q29sbGVjdGlvbiA9IHRoaXMuYmFzZUNvbnRyb2xsZXIuZXZlbnRzO1xuXG4gICAgaWYgKCF0aW1lVmlldyB8fCAhYmxvY2tFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudENvbGxlY3Rpb24uZG9XaGVuSGFzKGRvbXV0aWwuZ2V0RGF0YShibG9ja0VsZW1lbnQsICdpZCcpLCBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGV2ZW50cyBUaW1lQ2xpY2sjY2xpY2tFdmVudFxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJvcGVydHkge0NhbEV2ZW50fSBtb2RlbCAtIG1vZGVsIGluc3RhbmNlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TW91c2VFdmVudH0ganNFdmVudCAtIE1vdXNlRXZlbnQgb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpcmUoJ2NsaWNrRXZlbnQnLCB7XG4gICAgICAgICAgICBtb2RlbDogIG1vZGVsLFxuICAgICAgICAgICAganNFdmVudDogY2xpY2tFdmVudC5vcmlnaW5FdmVudFxuICAgICAgICB9KTtcbiAgICB9LCB0aGlzKTtcbn07XG5cbnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKFRpbWVDbGljayk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZUNsaWNrO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29yZSBtZXRob2RzIGZvciBkcmFnZ2luZyBhY3Rpb25zXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC50dWkudXRpbDtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi8uLi9jb21tb24vY29tbW9uJyk7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBkb21ldmVudCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb21ldmVudCcpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL3BvaW50Jyk7XG5cbi8qKlxuICogQG1peGluIFRpbWUuQ29yZVxuICovXG52YXIgdGltZUNvcmUgPSB7XG4gICAgLyoqXG4gICAgICogR2V0IFkgaW5kZXggcmF0aW8oaG91cikgaW4gdGltZSBncmlkcyBieSBzdXBwbGllZCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlTWlsIC0gYmFzZSBtaWxsaXNlY29uZHMgbnVtYmVyIGZvciBzdXBwbGllZCBoZWlnaHQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIGNvbnRhaW5lciBlbGVtZW50IGhlaWdodC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFkgY29vcmRpbmF0ZSB0byBjYWxjdWxhdGUgaG91ciByYXRpby5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBob3VyIGluZGV4IHJhdGlvIHZhbHVlLlxuICAgICAqL1xuICAgIF9jYWxjR3JpZFlJbmRleDogZnVuY3Rpb24oYmFzZU1pbCwgaGVpZ2h0LCB5KSB7XG4gICAgICAgIC8vIGdldCByYXRpbyBmcm9tIHJpZ2h0IGV4cHJlc3Npb24gPiBwb2ludC55IDogeCA9IHNlc3Npb24uaGVpZ2h0IDogYmFzZU1pbFxuICAgICAgICAvLyBhbmQgY29udmVydCBtaWxsaXNlY29uZHMgdmFsdWUgdG8gaG91cnMuXG4gICAgICAgIHZhciByZXN1bHQgPSBkYXRldGltZS5taWxsaXNlY29uZHNUbygnaG91cicsICh5ICogYmFzZU1pbCkgLyBoZWlnaHQpLFxuICAgICAgICAgICAgZmxvb3JlZCA9IHJlc3VsdCB8IDAsXG4gICAgICAgICAgICBuZWFyZXN0ID0gY29tbW9uLm5lYXJlc3QocmVzdWx0IC0gZmxvb3JlZCwgWzAsIDFdKTtcblxuICAgICAgICByZXR1cm4gZmxvb3JlZCArIChuZWFyZXN0ID8gMC41IDogMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBmdW5jdGlvbiB0byBtYWtlcyBldmVudCBkYXRhIGZyb20gVGltZSBhbmQgbW91c2VFdmVudFxuICAgICAqIEBwYXJhbSB7VGltZX0gdGltZVZpZXcgLSBJbnN0YW5jZSBvZiB0aW1lIHZpZXcuXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9ufSAtIEZ1bmN0aW9uIHRoYXQgcmV0dXJuIGV2ZW50IGRhdGEgZnJvbSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBfcmV0cml2ZUV2ZW50RGF0YTogZnVuY3Rpb24odGltZVZpZXcpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRpbWVWaWV3LmNvbnRhaW5lcixcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0aW1lVmlldy5vcHRpb25zLFxuICAgICAgICAgICAgdmlld0hlaWdodCA9IHRpbWVWaWV3LmdldFZpZXdCb3VuZCgpLmhlaWdodCxcbiAgICAgICAgICAgIHZpZXdUaW1lID0gK3RpbWVWaWV3LmdldERhdGUoKSxcbiAgICAgICAgICAgIGhvdXJMZW5ndGggPSBvcHRpb25zLmhvdXJFbmQgLSBvcHRpb25zLmhvdXJTdGFydCxcbiAgICAgICAgICAgIGJhc2VNaWwgPSBkYXRldGltZS5taWxsaXNlY29uZHNGcm9tKCdob3VyJywgaG91ckxlbmd0aCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gbW91c2VFdmVudCAtIG1vdXNlIGV2ZW50IG9iamVjdCB0byBnZXQgY29tbW9uIGV2ZW50IGRhdGEuXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZXh0ZW5kXSAtIG9iamVjdCB0byBleHRlbmQgZXZlbnQgZGF0YSBiZWZvcmUgcmV0dXJuLlxuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAtIGNvbW1vbiBldmVudCBkYXRhIGZvciB0aW1lLipcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiB1dGlsLmJpbmQoZnVuY3Rpb24obW91c2VFdmVudCwgZXh0ZW5kKSB7XG4gICAgICAgICAgICB2YXIgbW91c2VZID0gUG9pbnQubihkb21ldmVudC5nZXRNb3VzZVBvc2l0aW9uKG1vdXNlRXZlbnQsIGNvbnRhaW5lcikpLnksXG4gICAgICAgICAgICAgICAgZ3JpZFkgPSBjb21tb24ucmF0aW8odmlld0hlaWdodCwgaG91ckxlbmd0aCwgbW91c2VZKSxcbiAgICAgICAgICAgICAgICB0aW1lWSA9IHZpZXdUaW1lICsgZGF0ZXRpbWUubWlsbGlzZWNvbmRzRnJvbSgnaG91cicsIGdyaWRZKSxcbiAgICAgICAgICAgICAgICBuZWFyZXN0R3JpZFkgPSB0aGlzLl9jYWxjR3JpZFlJbmRleChiYXNlTWlsLCB2aWV3SGVpZ2h0LCBtb3VzZVkpLFxuICAgICAgICAgICAgICAgIG5lYXJlc3RHcmlkVGltZVkgPSB2aWV3VGltZSArIGRhdGV0aW1lLm1pbGxpc2Vjb25kc0Zyb20oJ2hvdXInLCBuZWFyZXN0R3JpZFkgKyBvcHRpb25zLmhvdXJTdGFydCk7XG5cbiAgICAgICAgICAgIHJldHVybiB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBtb3VzZUV2ZW50LnRhcmdldCB8fCBtb3VzZUV2ZW50LnNyY0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgcmVsYXRlZFZpZXc6IHRpbWVWaWV3LFxuICAgICAgICAgICAgICAgIG9yaWdpbkV2ZW50OiBtb3VzZUV2ZW50LFxuICAgICAgICAgICAgICAgIG1vdXNlWTogbW91c2VZLFxuICAgICAgICAgICAgICAgIGdyaWRZOiBncmlkWSxcbiAgICAgICAgICAgICAgICB0aW1lWTogdGltZVksXG4gICAgICAgICAgICAgICAgbmVhcmVzdEdyaWRZOiBuZWFyZXN0R3JpZFksXG4gICAgICAgICAgICAgICAgbmVhcmVzdEdyaWRUaW1lWTogbmVhcmVzdEdyaWRUaW1lWVxuICAgICAgICAgICAgfSwgZXh0ZW5kKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1peGluIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0geyhUaW1lQ3JlYXRpb258VGltZU1vdmUpfSBvYmogLSBDb25zdHJ1Y3RvciBmdW5jdGlvbnNcbiAgICAgKi9cbiAgICBtaXhpbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciBwcm90byA9IG9iai5wcm90b3R5cGU7XG4gICAgICAgIHV0aWwuZm9yRWFjaCh0aW1lQ29yZSwgZnVuY3Rpb24obWV0aG9kLCBtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ21peGluJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvdG9bbWV0aG9kTmFtZV0gPSBtZXRob2Q7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdGltZUNvcmU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBIYW5kbGluZyBjcmVhdGlvbiBldmVudHMgZnJvbSBkcmFnIGhhbmRsZXIgYW5kIHRpbWUgZ3JpZCB2aWV3XG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC50dWkudXRpbDtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi8uLi9jb25maWcnKTtcbnZhciBhcnJheSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9hcnJheScpO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgVGltZUNyZWF0aW9uR3VpZGUgPSByZXF1aXJlKCcuL2NyZWF0aW9uR3VpZGUnKTtcbnZhciB0aW1lQ29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge0hhbmRsZXJ9XG4gKiBAbWl4ZXMgdGltZUNvcmVcbiAqIEBtaXhlcyBDdXN0b21FdmVudHNcbiAqIEBwYXJhbSB7RHJhZ30gW2RyYWdIYW5kbGVyXSAtIERyYWcgaGFuZGxlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7VGltZUdyaWR9IFt0aW1lR3JpZFZpZXddIC0gVGltZUdyaWQgdmlldyBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7QmFzZX0gW2Jhc2VDb250cm9sbGVyXSAtIEJhc2UgY29udHJvbGxlciBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gVGltZUNyZWF0aW9uKGRyYWdIYW5kbGVyLCB0aW1lR3JpZFZpZXcsIGJhc2VDb250cm9sbGVyKSB7XG4gICAgLyoqXG4gICAgICogRHJhZyBoYW5kbGVyIGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtEcmFnfVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGltZUdyaWQgdmlldyBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7VGltZUdyaWR9XG4gICAgICovXG4gICAgdGhpcy50aW1lR3JpZFZpZXcgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQmFzZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtCYXNlfVxuICAgICAqL1xuICAgIHRoaXMuYmFzZUNvbnRyb2xsZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1RpbWVDcmVhdGlvbkd1aWRlfVxuICAgICAqL1xuICAgIHRoaXMuZ3VpZGUgPSBuZXcgVGltZUNyZWF0aW9uR3VpZGUodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUZW1wb3JhcnkgZnVuY3Rpb24gZm9yIHNpbmdsZSBkcmFnIHNlc3Npb24ncyBjYWxjLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLl9nZXRFdmVudERhdGFGdW5jID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRlbXBvcmFyeSBmdW5jdGlvbiBmb3IgZHJhZyBzdGFydCBkYXRhIGNhY2hlLlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5fZHJhZ1N0YXJ0ID0gbnVsbDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEZXN0cm95IG1ldGhvZFxuICovXG5UaW1lQ3JlYXRpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmd1aWRlLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9mZih0aGlzKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gdGhpcy50aW1lR3JpZFZpZXcgPSB0aGlzLmJhc2VDb250cm9sbGVyID1cbiAgICAgICAgdGhpcy5fZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX2RyYWdTdGFydCA9IHRoaXMuZ3VpZGUgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDb25uZWN0IGhhbmRsZXIsIHZpZXcsIGNvbnRyb2xsZXJzIGZvciBldmVudCBjcmVhdGlvbnMuXG4gKiBAcGFyYW0ge0RyYWd9IFtkcmFnSGFuZGxlcl0gLSBEcmFnIGhhbmRsZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge1RpbWVHcmlkfSBbdGltZUdyaWRWaWV3XSAtIFRpbWVHcmlkIHZpZXcgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0Jhc2V9IFtiYXNlQ29udHJvbGxlcl0gLSBCYXNlIGNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gKi9cblRpbWVDcmVhdGlvbi5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKGRyYWdIYW5kbGVyLCB0aW1lR3JpZFZpZXcsIGJhc2VDb250cm9sbGVyKSB7XG4gICAgdGhpcy5kcmFnSGFuZGxlciA9IGRyYWdIYW5kbGVyO1xuICAgIHRoaXMudGltZUdyaWRWaWV3ID0gdGltZUdyaWRWaWV3O1xuICAgIHRoaXMuYmFzZUNvbnRyb2xsZXIgPSBiYXNlQ29udHJvbGxlcjtcblxuICAgIGRyYWdIYW5kbGVyLm9uKHtcbiAgICAgICAgZHJhZ1N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydFxuICAgIH0sIHRoaXMpO1xufTtcblxuLyoqXG4gKiBDaGVjayB0YXJnZXQgZWxlbWVudCBpcyBleHBlY3RlZCBjb25kaXRpb24gZm9yIGFjdGl2YXRlIHRoaXMgcGx1Z2lucy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIFRoZSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7KGJvb2xlYW58VGltZSl9IC0gcmV0dXJuIFRpbWUgdmlldyBpbnN0YW5jZSB3aGVuIHNhdGlhdGUgY29uZGl0aW9uLlxuICovXG5UaW1lQ3JlYXRpb24ucHJvdG90eXBlLmNoZWNrRXhwZWN0ZWRDb25kaXRpb24gPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICB2YXIgY3NzQ2xhc3MgPSBkb211dGlsLmdldENsYXNzKHRhcmdldCksXG4gICAgICAgIG1hdGNoZXM7XG5cbiAgICBpZiAoY3NzQ2xhc3MgPT09IGNvbmZpZy5jbGFzc25hbWUoJ3RpbWUtZGF0ZS1ldmVudC1ibG9jaycpKSB7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICBjc3NDbGFzcyA9IGRvbXV0aWwuZ2V0Q2xhc3ModGFyZ2V0KTtcbiAgICB9XG5cbiAgICBtYXRjaGVzID0gY3NzQ2xhc3MubWF0Y2goY29uZmlnLnRpbWUuZ2V0Vmlld0lEUmVnRXhwKTtcblxuICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlsLnBpY2sodGhpcy50aW1lR3JpZFZpZXcuY2hpbGRzLml0ZW1zLCBtYXRjaGVzWzFdKTtcbn07XG5cbi8qKlxuICogRHJhZyNkcmFnU3RhcnQgZXZlbnQgaGFuZGxlci5cbiAqIEBlbWl0cyBUaW1lQ3JlYXRpb24jdGltZV9jcmVhdGlvbl9kcmFnc3RhcnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnU3RhcnRFdmVudERhdGEgLSBEcmFnI2RyYWdTdGFydCBldmVudCBkYXRhLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvdmVycmlkZUV2ZW50TmFtZV0gLSBvdmVycmlkZSBlbWl0dGVkIGV2ZW50IG5hbWUgd2hlbiBzdXBwbGllZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtyZXZpc2VdIC0gc3VwcGx5IGZ1bmN0aW9uIGZvciByZXZpc2UgZXZlbnQgZGF0YSBiZWZvcmUgZW1pdC5cbiAqL1xuVGltZUNyZWF0aW9uLnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbihkcmFnU3RhcnRFdmVudERhdGEsIG92ZXJyaWRlRXZlbnROYW1lLCByZXZpc2UpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZHJhZ1N0YXJ0RXZlbnREYXRhLnRhcmdldCxcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5jaGVja0V4cGVjdGVkQ29uZGl0aW9uKHRhcmdldCksXG4gICAgICAgIGdldEV2ZW50RGF0YUZ1bmMsXG4gICAgICAgIGV2ZW50RGF0YTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBnZXRFdmVudERhdGFGdW5jID0gdGhpcy5fZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX3JldHJpdmVFdmVudERhdGEocmVzdWx0KTtcbiAgICBldmVudERhdGEgPSB0aGlzLl9kcmFnU3RhcnQgPSBnZXRFdmVudERhdGFGdW5jKGRyYWdTdGFydEV2ZW50RGF0YS5vcmlnaW5FdmVudCk7XG5cbiAgICBpZiAocmV2aXNlKSB7XG4gICAgICAgIHJldmlzZShldmVudERhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuZHJhZ0hhbmRsZXIub24oe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBUaW1lQ3JlYXRpb24jdGltZV9jcmVhdGlvbl9kcmFnc3RhcnRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7VGltZX0gcmVsYXRlZFZpZXcgLSB0aW1lIHZpZXcgaW5zdGFuY2UgcmVsYXRlZCB3aXRoIG1vdXNlIHBvc2l0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7TW91c2VFdmVudH0gb3JpZ2luRXZlbnQgLSBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1vdXNlWSAtIG1vdXNlIFkgcHggbW91c2UgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGdyaWRZIC0gZ3JpZCBZIGluZGV4IHZhbHVlIHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVZIC0gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIG1vdXNlWSBwb2ludHMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkWSAtIG5lYXJlc3QgZ3JpZCBpbmRleCByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFRpbWVZIC0gdGltZSB2YWx1ZSBmb3IgbmVhcmVzdEdyaWRZLlxuICAgICAqL1xuICAgIHRoaXMuZmlyZShvdmVycmlkZUV2ZW50TmFtZSB8fCAndGltZV9jcmVhdGlvbl9kcmFnc3RhcnQnLCBldmVudERhdGEpO1xufTtcblxuLyoqXG4gKiBEcmFnI2RyYWcgZXZlbnQgaGFuZGxlclxuICogQGVtaXRzIFRpbWVDcmVhdGlvbiN0aW1lX2NyZWF0aW9uX2RyYWdcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnRXZlbnREYXRhIC0gZXZlbnQgZGF0YSBmcm9tIERyYWcjZHJhZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3ZlcnJpZGVFdmVudE5hbWVdIC0gb3ZlcnJpZGUgZW1pdHRlZCBldmVudCBuYW1lIHdoZW4gc3VwcGxpZWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcmV2aXNlXSAtIHN1cHBseSBmdW5jdGlvbiBmb3IgcmV2aXNlIGV2ZW50IGRhdGEgYmVmb3JlIGVtaXQuXG4gKi9cblRpbWVDcmVhdGlvbi5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uKGRyYWdFdmVudERhdGEsIG92ZXJyaWRlRXZlbnROYW1lLCByZXZpc2UpIHtcbiAgICB2YXIgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX2dldEV2ZW50RGF0YUZ1bmMsXG4gICAgICAgIGV2ZW50RGF0YTtcblxuICAgIGlmICghZ2V0RXZlbnREYXRhRnVuYykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnREYXRhID0gZ2V0RXZlbnREYXRhRnVuYyhkcmFnRXZlbnREYXRhLm9yaWdpbkV2ZW50KTtcblxuICAgIGlmIChyZXZpc2UpIHtcbiAgICAgICAgcmV2aXNlKGV2ZW50RGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFRpbWVDcmVhdGlvbiN0aW1lX2NyZWF0aW9uX2RyYWdcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7VGltZX0gcmVsYXRlZFZpZXcgLSB0aW1lIHZpZXcgaW5zdGFuY2UgcmVsYXRlZCB3aXRoIG1vdXNlIHBvc2l0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7TW91c2VFdmVudH0gb3JpZ2luRXZlbnQgLSBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1vdXNlWSAtIG1vdXNlIFkgcHggbW91c2UgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGdyaWRZIC0gZ3JpZCBZIGluZGV4IHZhbHVlIHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVZIC0gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIG1vdXNlWSBwb2ludHMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkWSAtIG5lYXJlc3QgZ3JpZCBpbmRleCByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFRpbWVZIC0gdGltZSB2YWx1ZSBmb3IgbmVhcmVzdEdyaWRZLlxuICAgICAqL1xuICAgIHRoaXMuZmlyZShvdmVycmlkZUV2ZW50TmFtZSB8fCAndGltZV9jcmVhdGlvbl9kcmFnJywgZXZlbnREYXRhKTtcbn07XG5cbi8qKlxuICogQGZpcmVzIFRpbWVDcmVhdGlvbiNiZWZvcmVDcmVhdGVFdmVudFxuICogQHBhcmFtIHtvYmplY3R9IGV2ZW50RGF0YSAtIGV2ZW50IGRhdGEgb2JqZWN0IGZyb20gVGltZUNyZWF0aW9uI3RpbWVfY3JlYXRpb25fZHJhZ2VuZFxuICogb3IgVGltZUNyZWF0aW9uI3RpbWVfY3JlYXRpb25fY2xpY2tcbiAqL1xuVGltZUNyZWF0aW9uLnByb3RvdHlwZS5fY3JlYXRlRXZlbnQgPSBmdW5jdGlvbihldmVudERhdGEpIHtcbiAgICB2YXIgcmVsYXRlZFZpZXcgPSBldmVudERhdGEucmVsYXRlZFZpZXcsXG4gICAgICAgIGNyZWF0ZVJhbmdlID0gZXZlbnREYXRhLmNyZWF0ZVJhbmdlLFxuICAgICAgICBuZWFyZXN0R3JpZFRpbWVZID0gZXZlbnREYXRhLm5lYXJlc3RHcmlkVGltZVksXG4gICAgICAgIGJhc2VEYXRlLFxuICAgICAgICBkYXRlU3RhcnQsXG4gICAgICAgIGRhdGVFbmQsXG4gICAgICAgIHN0YXJ0cyxcbiAgICAgICAgZW5kcztcblxuICAgIGlmICghY3JlYXRlUmFuZ2UpIHtcbiAgICAgICAgY3JlYXRlUmFuZ2UgPSBbXG4gICAgICAgICAgICBuZWFyZXN0R3JpZFRpbWVZLFxuICAgICAgICAgICAgbmVhcmVzdEdyaWRUaW1lWSArIGRhdGV0aW1lLm1pbGxpc2Vjb25kc0Zyb20oJ21pbnV0ZXMnLCAzMClcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBiYXNlRGF0ZSA9IG5ldyBEYXRlKHJlbGF0ZWRWaWV3LmdldERhdGUoKSk7XG4gICAgZGF0ZVN0YXJ0ID0gZGF0ZXRpbWUuc3RhcnQoYmFzZURhdGUpO1xuICAgIGRhdGVFbmQgPSBkYXRldGltZS5lbmQoYmFzZURhdGUpO1xuICAgIHN0YXJ0cyA9IE1hdGgubWF4KGRhdGVTdGFydC5nZXRUaW1lKCksIGNyZWF0ZVJhbmdlWzBdKTtcbiAgICBlbmRzID0gTWF0aC5taW4oZGF0ZUVuZC5nZXRUaW1lKCksIGNyZWF0ZVJhbmdlWzFdKTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBUaW1lQ3JlYXRpb24jYmVmb3JlQ3JlYXRlRXZlbnRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNBbGxEYXkgLSB3aGV0aGVyIGV2ZW50IGlzIGZpcmVkIGluIGFsbGRheSB2aWV3IGFyZWE/XG4gICAgICogQHByb3BlcnR5IHtEYXRlfSBzdGFydHMgLSBzZWxlY3Qgc3RhcnQgdGltZVxuICAgICAqIEBwcm9wZXJ0eSB7RGF0ZV0gZW5kcyAtIHNlbGVjdCBlbmQgdGltZVxuICAgICAqL1xuICAgIHRoaXMuZmlyZSgnYmVmb3JlQ3JlYXRlRXZlbnQnLCB7XG4gICAgICAgIGlzQWxsRGF5OiBmYWxzZSxcbiAgICAgICAgc3RhcnRzOiBuZXcgRGF0ZShzdGFydHMpLFxuICAgICAgICBlbmRzOiBuZXcgRGF0ZShlbmRzKVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBEcmFnI2RyYWdFbmQgZXZlbnQgaGFuZGxlclxuICogQGVtaXRzIFRpbWVDcmVhdGlvbiN0aW1lX2NyZWF0aW9uX2RyYWdlbmRcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnRW5kRXZlbnREYXRhIC0gZXZlbnQgZGF0YSBmcm9tIERyYWcjZHJhZ2VuZFxuICovXG5UaW1lQ3JlYXRpb24ucHJvdG90eXBlLl9vbkRyYWdFbmQgPSBmdW5jdGlvbihkcmFnRW5kRXZlbnREYXRhKSB7XG4gICAgdmFyIGRyYWdTdGFydCA9IHRoaXMuX2RyYWdTdGFydDtcblxuICAgIHRoaXMuZHJhZ0hhbmRsZXIub2ZmKHtcbiAgICAgICAgZHJhZzogdGhpcy5fb25EcmFnLFxuICAgICAgICBkcmFnRW5kOiB0aGlzLl9vbkRyYWdFbmQsXG4gICAgICAgIGNsaWNrOiB0aGlzLl9vbkNsaWNrXG4gICAgfSwgdGhpcyk7XG5cbiAgICBmdW5jdGlvbiByZXZpc2VGdW5jKGV2ZW50RGF0YSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBbXG4gICAgICAgICAgICBkcmFnU3RhcnQubmVhcmVzdEdyaWRUaW1lWSxcbiAgICAgICAgICAgIGV2ZW50RGF0YS5uZWFyZXN0R3JpZFRpbWVZXG4gICAgICAgIF0uc29ydChhcnJheS5jb21wYXJlLm51bS5hc2MpO1xuICAgICAgICByYW5nZVsxXSArPSBkYXRldGltZS5taWxsaXNlY29uZHNGcm9tKCdob3VyJywgMC41KTtcblxuICAgICAgICBldmVudERhdGEuY3JlYXRlUmFuZ2UgPSByYW5nZTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVFdmVudChldmVudERhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBldmVudCBUaW1lQ3JlYXRpb24jdGltZV9jcmVhdGlvbl9kcmFnZW5kXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge1RpbWV9IHJlbGF0ZWRWaWV3IC0gdGltZSB2aWV3IGluc3RhbmNlIHJlbGF0ZWQgd2l0aCBtb3VzZSBwb3NpdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge01vdXNlRXZlbnR9IG9yaWdpbkV2ZW50IC0gbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb3VzZVkgLSBtb3VzZSBZIHB4IG1vdXNlIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBncmlkWSAtIGdyaWQgWSBpbmRleCB2YWx1ZSByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lWSAtIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiBtb3VzZVkgcG9pbnRzLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFkgLSBuZWFyZXN0IGdyaWQgaW5kZXggcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRUaW1lWSAtIHRpbWUgdmFsdWUgZm9yIG5lYXJlc3RHcmlkWS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcltdfSBjcmVhdGVSYW5nZSAtIG1pbGxpc2Vjb25kcyByYW5nZSBiZXR3ZWVuIGRyYWcgc3RhcnQgYW5kIGVuZCB0byBjcmVhdGUuXG4gICAgICovXG4gICAgdGhpcy5fb25EcmFnKGRyYWdFbmRFdmVudERhdGEsICd0aW1lX2NyZWF0aW9uX2RyYWdlbmQnLCB1dGlsLmJpbmQocmV2aXNlRnVuYywgdGhpcykpO1xuXG4gICAgdGhpcy5fZHJhZ1N0YXJ0ID0gdGhpcy5fZ2V0RXZlbnREYXRhRnVuYyA9IG51bGw7XG59O1xuXG4vKipcbiAqIERyYWcjY2xpY2sgZXZlbnQgaGFuZGxlclxuICogQGVtaXRzIFRpbWVDcmVhdGlvbiN0aW1lX2NyZWF0aW9uX2NsaWNrXG4gKiBAcGFyYW0ge29iamVjdH0gY2xpY2tFdmVudERhdGEgLSBldmVudCBkYXRhIGZyb20gRHJhZyNjbGljay5cbiAqL1xuVGltZUNyZWF0aW9uLnByb3RvdHlwZS5fb25DbGljayA9IGZ1bmN0aW9uKGNsaWNrRXZlbnREYXRhKSB7XG4gICAgdGhpcy5kcmFnSGFuZGxlci5vZmYoe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIGZ1bmN0aW9uIHJldmlzZUZ1bmMoZXZlbnREYXRhKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUV2ZW50KGV2ZW50RGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFRpbWVDcmVhdGlvbiN0aW1lX2NyZWF0aW9uX2NsaWNrXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge1RpbWV9IHJlbGF0ZWRWaWV3IC0gdGltZSB2aWV3IGluc3RhbmNlIHJlbGF0ZWQgd2l0aCBtb3VzZSBwb3NpdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge01vdXNlRXZlbnR9IG9yaWdpbkV2ZW50IC0gbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb3VzZVkgLSBtb3VzZSBZIHB4IG1vdXNlIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBncmlkWSAtIGdyaWQgWSBpbmRleCB2YWx1ZSByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lWSAtIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiBtb3VzZVkgcG9pbnRzLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFkgLSBuZWFyZXN0IGdyaWQgaW5kZXggcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRUaW1lWSAtIHRpbWUgdmFsdWUgZm9yIG5lYXJlc3RHcmlkWS5cbiAgICAgKi9cbiAgICB0aGlzLl9vbkRyYWcoY2xpY2tFdmVudERhdGEsICd0aW1lX2NyZWF0aW9uX2NsaWNrJywgdXRpbC5iaW5kKHJldmlzZUZ1bmMsIHRoaXMpKTtcblxuICAgIHRoaXMuX2RyYWdTdGFydCA9IHRoaXMuX2dldEV2ZW50RGF0YUZ1bmMgPSBudWxsO1xufTtcblxudGltZUNvcmUubWl4aW4oVGltZUNyZWF0aW9uKTtcbnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKFRpbWVDcmVhdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZUNyZWF0aW9uO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTW9kdWxlIGZvciBUaW1lLkNyZWF0aW9uIGVmZmVjdCB3aGlsZSBkcmFnZ2luZy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi8uLi9jb21tb24vY29tbW9uJyk7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi8uLi9jb25maWcnKTtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciByZXFBbmltRnJhbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vcmVxQW5pbUZyYW1lJyk7XG52YXIgcmF0aW8gPSByZXF1aXJlKCcuLi8uLi9jb21tb24vY29tbW9uJykucmF0aW87XG52YXIgTUlOMzAgPSAoZGF0ZXRpbWUuTUlMTElTRUNPTkRTX1BFUl9NSU5VVEVTICogMzApXG5cbi8qKlxuICogQ2xhc3MgZm9yIFRpbWUuQ3JlYXRpb24gZHJhZ2dpbmcgZWZmZWN0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1RpbWVDcmVhdGlvbn0gdGltZUNyZWF0aW9uIC0gaW5zdGFuY2Ugb2YgVGltZUNyZWF0aW9uLlxuICovXG5mdW5jdGlvbiBUaW1lQ3JlYXRpb25HdWlkZSh0aW1lQ3JlYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBHdWlkZSBlbGVtZW50IGZvciBjcmVhdGlvbiBlZmZlY3QuXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZ3VpZGVFbGVtZW50ID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0hUTUxEaXZFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZ3VpZGVUaW1lRWxlbWVudCA9IGRvbXV0aWwuYXBwZW5kSFRNTEVsZW1lbnQoXG4gICAgICAgICdzcGFuJywgXG4gICAgICAgIHRoaXMuZ3VpZGVFbGVtZW50LCBcbiAgICAgICAgY29uZmlnLmNsYXNzbmFtZSgndGltZS1ndWlkZS1jcmVhdGlvbi1sYWJlbCcpXG4gICAgKTtcblxuICAgIGRvbXV0aWwuYWRkQ2xhc3ModGhpcy5ndWlkZUVsZW1lbnQsIGNvbmZpZy5jbGFzc25hbWUoJ3RpbWUtZ3VpZGUtY3JlYXRpb24nKSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VGltZUNyZWF0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudGltZUNyZWF0aW9uID0gdGltZUNyZWF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuX3N0eWxlVW5pdCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7YXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5fc3R5bGVTdGFydCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5fc3R5bGVGdW5jID0gbnVsbDtcblxuICAgIHRpbWVDcmVhdGlvbi5vbih7XG4gICAgICAgICd0aW1lX2NyZWF0aW9uX2RyYWdzdGFydCc6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuICAgICAgICAndGltZV9jcmVhdGlvbl9kcmFnJzogdGhpcy5fb25EcmFnLFxuICAgICAgICAndGltZV9jcmVhdGlvbl9jbGljayc6IHRoaXMuY2xlYXJHdWlkZUVsZW1lbnRcbiAgICB9LCB0aGlzKTtcbn1cblxuLyoqXG4gKiBEZXN0cm95IG1ldGhvZC5cbiAqL1xuVGltZUNyZWF0aW9uR3VpZGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyR3VpZGVFbGVtZW50KCk7XG4gICAgdGhpcy50aW1lQ3JlYXRpb24ub2ZmKHRoaXMpO1xuICAgIHRoaXMudGltZUNyZWF0aW9uID0gdGhpcy5fc3R5bGVVbml0ID0gdGhpcy5fc3R5bGVTdGFydCA9XG4gICAgICAgIHRoaXMuX3N0eWxlRnVuYyA9IHRoaXMuZ3VpZGVFbGVtZW50ID0gdGhpcy5ndWlkZVRpbWVFbGVtZW50ID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xlYXIgZ3VpZGUgZWxlbWVudC5cbiAqL1xuVGltZUNyZWF0aW9uR3VpZGUucHJvdG90eXBlLmNsZWFyR3VpZGVFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGd1aWRlRWxlbWVudCA9IHRoaXMuZ3VpZGVFbGVtZW50LFxuICAgICAgICB0aW1lRWxlbWVudCA9IHRoaXMuZ3VpZGVUaW1lRWxlbWVudDtcblxuICAgIGRvbXV0aWwucmVtb3ZlKGd1aWRlRWxlbWVudCk7XG5cbiAgICByZXFBbmltRnJhbWUucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgZ3VpZGVFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGd1aWRlRWxlbWVudC5zdHlsZS50b3AgPSAnJztcbiAgICAgICAgZ3VpZGVFbGVtZW50LnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgICB0aW1lRWxlbWVudC5pbm5lckhUTUwgPSAnJztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmVmcmVzaCBndWlkZSBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIC0gVGhlIG51bWJlciBvZiBndWlkZSBlbGVtZW50J3Mgc3R5bGUgdG9wXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIG51bWJlciBvZiBndWlkZSBlbGVtZW50J3Mgc3R5bGUgaGVpZ2h0XG4gKiBAcGFyYW0ge0RhdGV9IHN0YXJ0IC0gc3RhcnQgdGltZSBvZiBldmVudCB0byBjcmVhdGVcbiAqIEBwYXJhbSB7RGF0ZX0gZW5kIC0gZW5kIHRpbWUgb2YgZXZlbnQgdG8gY3JlYXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJvdHRvbUxhYmVsIC0gaXMgbGFiZWwgbmVlZCB0byByZW5kZXIgYm90dG9tIG9mIGd1aWRlIGVsZW1lbnQ/XG4gKi9cblRpbWVDcmVhdGlvbkd1aWRlLnByb3RvdHlwZS5fcmVmcmVzaEd1aWRlRWxlbWVudCA9IGZ1bmN0aW9uKHRvcCwgaGVpZ2h0LCBzdGFydCwgZW5kLCBib3R0b21MYWJlbCkge1xuICAgIHZhciBndWlkZUVsZW1lbnQgPSB0aGlzLmd1aWRlRWxlbWVudCxcbiAgICAgICAgdGltZUVsZW1lbnQgPSB0aGlzLmd1aWRlVGltZUVsZW1lbnQ7XG5cbiAgICByZXFBbmltRnJhbWUucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgZ3VpZGVFbGVtZW50LnN0eWxlLnRvcCA9IHRvcCArICdweCc7XG4gICAgICAgIGd1aWRlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICBndWlkZUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgICAgdGltZUVsZW1lbnQuaW5uZXJIVE1MID0gZGF0ZXRpbWUuZm9ybWF0KG5ldyBEYXRlKHN0YXJ0KSwgJ0hIOm1tJykgKyBcbiAgICAgICAgICAgICcgfiAnICsgZGF0ZXRpbWUuZm9ybWF0KG5ldyBEYXRlKGVuZCksICdISDptbScpO1xuXG4gICAgICAgIGlmICghIWJvdHRvbUxhYmVsKSB7XG4gICAgICAgICAgICBkb211dGlsLnJlbW92ZUNsYXNzKHRpbWVFbGVtZW50LCBjb25maWcuY2xhc3NuYW1lKCd0aW1lLWd1aWRlLWJvdHRvbScpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbXV0aWwuYWRkQ2xhc3ModGltZUVsZW1lbnQsIGNvbmZpZy5jbGFzc25hbWUoJ3RpbWUtZ3VpZGUtYm90dG9tJykpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEdldCB1bml0IGRhdGEgb2YgY2FsY3VsYXRpbmcgbmV3IHN0eWxlIG9mIGd1aWRlIGVsZW1lbnQgYnkgdXNlciBpbnRlcmFjdGlvblxuICogQHBhcmFtIHtUaW1lfSByZWxhdGVkVmlldyAtIHRpbWUgdmlldyBpbnN0YW5jZSByZWxhdGVkIHdpdGggZXZlbnRcbiAqIEByZXR1cm5zIHthcnJheX0gdW5pdCBkYXRhLlxuICovXG5UaW1lQ3JlYXRpb25HdWlkZS5wcm90b3R5cGUuX2dldFVuaXREYXRhID0gZnVuY3Rpb24ocmVsYXRlZFZpZXcpIHtcbiAgICB2YXIgdmlld09wdCA9IHJlbGF0ZWRWaWV3Lm9wdGlvbnMsXG4gICAgICAgIHZpZXdIZWlnaHQgPSByZWxhdGVkVmlldy5nZXRWaWV3Qm91bmQoKS5oZWlnaHQsXG4gICAgICAgIGhvdXJMZW5ndGggPSB2aWV3T3B0LmhvdXJFbmQgLSB2aWV3T3B0LmhvdXJTdGFydCxcbiAgICAgICAgdG9kYXlTdGFydCA9IGRhdGV0aW1lLnBhcnNlKHZpZXdPcHQueW1kKSxcbiAgICAgICAgdG9kYXlFbmQgPSBkYXRldGltZS5lbmQodG9kYXlTdGFydCk7XG5cbiAgICB0b2RheVN0YXJ0LnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgIHRvZGF5U3RhcnQuc2V0SG91cnModmlld09wdC5ob3VyU3RhcnQpO1xuXG4gICAgLy8gWzBdIGhlaWdodCBvZiB2aWV3XG4gICAgLy8gWzFdIGhvdXIgbGVuZ3RoIG9mIHZpZXdcbiAgICAvLyBbMl0gc3RhcnQgdGltZSBvZiB2aWV3XG4gICAgLy8gWzNdIGVuZCB0aW1lIG9mIHZpZXdcbiAgICAvLyBbNF0gaGVpZ2h0IG9mIHZpZXcgZm9yIG9uZSBob3VyXG4gICAgcmV0dXJuIFt2aWV3SGVpZ2h0LCBob3VyTGVuZ3RoLCArdG9kYXlTdGFydCwgK3RvZGF5RW5kLCB2aWV3SGVpZ2h0IC8gaG91ckxlbmd0aF07XG59O1xuXG4vKipcbiAqIEFwcGx5aW5nIGxpbWl0YXRpb24gdG8gc3VwcGxpZWQgZGF0YSBhbmQgcmV0dXJuIGl0LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCAtIHRvcCBwaXhlbCBvZiBndWlkZSBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gaGVpZ2h0IHBpeGVsIG9mIGd1aWRlIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHJlbGF0aXZlIHRpbWUgdmFsdWUgb2YgZHJhZ3N0YXJ0IHBvaW50XG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIC0gcmVsYXRpdmUgdGltZSB2YWx1ZSBvZiBkcmFnZW5kIHBvaW50XG4gKiBAcmV0dXJucyB7YXJyYXl9IGxpbWl0ZWQgc3R5bGUgZGF0YVxuICovXG5UaW1lQ3JlYXRpb25HdWlkZS5wcm90b3R5cGUuX2xpbWl0U3R5bGVEYXRhID0gZnVuY3Rpb24odG9wLCBoZWlnaHQsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgdW5pdERhdGEgPSB0aGlzLl9zdHlsZVVuaXQ7XG5cbiAgICB0b3AgPSBjb21tb24ubGltaXQodG9wLCBbMF0sIFt1bml0RGF0YVswXV0pO1xuICAgIGhlaWdodCA9IGNvbW1vbi5saW1pdCh0b3AgKyBoZWlnaHQsIFswXSwgW3VuaXREYXRhWzBdXSkgLSB0b3A7XG4gICAgc3RhcnQgPSBjb21tb24ubGltaXQoc3RhcnQsIFt1bml0RGF0YVsyXV0sIFt1bml0RGF0YVszXV0pO1xuICAgIGVuZCA9IGNvbW1vbi5saW1pdChlbmQsIFt1bml0RGF0YVsyXV0sIFt1bml0RGF0YVszXV0pO1xuXG4gICAgcmV0dXJuIFt0b3AsIGhlaWdodCwgc3RhcnQsIGVuZF07XG59O1xuXG4vKipcbiAqIEdldCBmdW5jdGlvbiB0byBjYWxjdWxhdGUgZ3VpZGUgZWxlbWVudCBVSSBkYXRhIGZyb20gc3VwcGxpZWQgdW5pdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSB2aWV3SGVpZ2h0IC0gdG90YWwgaGVpZ2h0IG9mIHZpZXcncyBjb250YWluZXIgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IGhvdXJMZW5ndGggLSBob3VyIGxlbmd0aCB0aGF0IHJlbmRlcmVkIGluIHRpbWUgdmlld1xuICogQHBhcmFtIHtudW1iZXJ9IHRvZGF5U3RhcnQgLSB0aW1lIGZvciB2aWV3J3Mgc3RhcnQgZGF0ZVxuICogQHJldHVybnMge2Z1bmN0aW9ufSBVSSBkYXRhIGNhbGN1bGF0b3IgZnVuY3Rpb25cbiAqL1xuVGltZUNyZWF0aW9uR3VpZGUucHJvdG90eXBlLl9nZXRTdHlsZURhdGFGdW5jID0gZnVuY3Rpb24odmlld0hlaWdodCwgaG91ckxlbmd0aCwgdG9kYXlTdGFydCkge1xuICAgIHZhciB0b2RheUVuZCA9ICtkYXRldGltZS5lbmQobmV3IERhdGUoK3RvZGF5U3RhcnQpKTtcblxuICAgIGZ1bmN0aW9uIGdldFN0eWxlRGF0YShldmVudERhdGEpIHtcbiAgICAgICAgdmFyIGdyaWRZID0gZXZlbnREYXRhLm5lYXJlc3RHcmlkWSxcbiAgICAgICAgICAgIGdyaWRUaW1lWSA9IGV2ZW50RGF0YS5uZWFyZXN0R3JpZFRpbWVZLFxuICAgICAgICAgICAgdG9wLCB0aW1lO1xuXG4gICAgICAgIHRvcCA9IGNvbW1vbi5saW1pdChyYXRpbyhob3VyTGVuZ3RoLCB2aWV3SGVpZ2h0LCBncmlkWSksIFswXSwgW3ZpZXdIZWlnaHRdKTtcbiAgICAgICAgdGltZSA9IGNvbW1vbi5saW1pdChncmlkVGltZVksIFt0b2RheVN0YXJ0XSwgW3RvZGF5RW5kXSk7XG5cbiAgICAgICAgcmV0dXJuIFt0b3AsIHRpbWVdO1xuICAgIH1cbiAgICAgICAgXG4gICAgcmV0dXJuIGdldFN0eWxlRGF0YTtcbn07XG5cbi8qKlxuICogRHJhZ1N0YXJ0IGV2ZW50IGhhbmRsZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnU3RhcnRFdmVudERhdGEgLSBkcmFnU3RhcnQgZXZlbnQgZGF0YS5cbiAqL1xuVGltZUNyZWF0aW9uR3VpZGUucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGRyYWdTdGFydEV2ZW50RGF0YSkge1xuICAgIHZhciByZWxhdGVkVmlldyA9IGRyYWdTdGFydEV2ZW50RGF0YS5yZWxhdGVkVmlldyxcbiAgICAgICAgdW5pdERhdGEsIHN0eWxlRnVuYywgc3R5bGVEYXRhLCByZXN1bHQ7XG5cbiAgICB1bml0RGF0YSA9IHRoaXMuX3N0eWxlVW5pdCA9IHRoaXMuX2dldFVuaXREYXRhKHJlbGF0ZWRWaWV3KTtcbiAgICBzdHlsZUZ1bmMgPSB0aGlzLl9zdHlsZUZ1bmMgPSB0aGlzLl9nZXRTdHlsZURhdGFGdW5jLmFwcGx5KHRoaXMsIHVuaXREYXRhKTtcbiAgICBzdHlsZURhdGEgPSB0aGlzLl9zdHlsZVN0YXJ0ID0gc3R5bGVGdW5jKGRyYWdTdGFydEV2ZW50RGF0YSk7XG5cbiAgICByZXN1bHQgPSB0aGlzLl9saW1pdFN0eWxlRGF0YShcbiAgICAgICAgc3R5bGVEYXRhWzBdLFxuICAgICAgICAodW5pdERhdGFbNF0gLyAyKSxcbiAgICAgICAgc3R5bGVEYXRhWzFdLFxuICAgICAgICAoc3R5bGVEYXRhWzFdICsgTUlOMzApXG4gICAgKTtcblxuICAgIHRoaXMuX3JlZnJlc2hHdWlkZUVsZW1lbnQuYXBwbHkodGhpcywgcmVzdWx0KTtcblxuICAgIHJlbGF0ZWRWaWV3LmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmd1aWRlRWxlbWVudCk7XG59O1xuXG4vKipcbiAqIERyYWcgZXZlbnQgaGFuZGxlclxuICogQHBhcmFtIHtvYmplY3R9IGRyYWdFdmVudERhdGEgLSBkcmFnIGV2ZW50IGRhdGEuXG4gKi9cblRpbWVDcmVhdGlvbkd1aWRlLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24oZHJhZ0V2ZW50RGF0YSkge1xuICAgIHZhciBzdHlsZUZ1bmMgPSB0aGlzLl9zdHlsZUZ1bmMsXG4gICAgICAgIHVuaXREYXRhID0gdGhpcy5fc3R5bGVVbml0LFxuICAgICAgICBzdGFydFN0eWxlID0gdGhpcy5fc3R5bGVTdGFydCxcbiAgICAgICAgaGVpZ2h0T2ZIYWxmSG91cixcbiAgICAgICAgZW5kU3R5bGUsXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmICghc3R5bGVGdW5jIHx8ICF1bml0RGF0YSB8fCAhc3RhcnRTdHlsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGVpZ2h0T2ZIYWxmSG91ciA9ICh1bml0RGF0YVs0XSAvIDIpO1xuICAgIGVuZFN0eWxlID0gc3R5bGVGdW5jKGRyYWdFdmVudERhdGEpO1xuXG4gICAgaWYgKGVuZFN0eWxlWzBdID4gc3RhcnRTdHlsZVswXSkge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9saW1pdFN0eWxlRGF0YShcbiAgICAgICAgICAgIHN0YXJ0U3R5bGVbMF0sXG4gICAgICAgICAgICAoZW5kU3R5bGVbMF0gLSBzdGFydFN0eWxlWzBdKSArIGhlaWdodE9mSGFsZkhvdXIsXG4gICAgICAgICAgICBzdGFydFN0eWxlWzFdLFxuICAgICAgICAgICAgKGVuZFN0eWxlWzFdICsgTUlOMzApXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5fcmVmcmVzaEd1aWRlRWxlbWVudC5hcHBseSh0aGlzLCByZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2xpbWl0U3R5bGVEYXRhKFxuICAgICAgICAgICAgZW5kU3R5bGVbMF0sXG4gICAgICAgICAgICAoc3RhcnRTdHlsZVswXSAtIGVuZFN0eWxlWzBdKSArIGhlaWdodE9mSGFsZkhvdXIsXG4gICAgICAgICAgICBlbmRTdHlsZVsxXSxcbiAgICAgICAgICAgIChzdGFydFN0eWxlWzFdICsgTUlOMzApXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5fcmVmcmVzaEd1aWRlRWxlbWVudC5hcHBseSh0aGlzLCByZXN1bHQuY29uY2F0KFt0cnVlXSkpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZUNyZWF0aW9uR3VpZGU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBIYW5kbGluZyBtb3ZlIGV2ZW50cyBmcm9tIGRyYWcgaGFuZGxlciBhbmQgdGltZSBncmlkIHZpZXdcbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLnR1aS51dGlsO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL2NvbmZpZycpO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgdGltZUNvcmUgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBUaW1lTW92ZUd1aWRlID0gcmVxdWlyZSgnLi9tb3ZlR3VpZGUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtIYW5kbGVyfVxuICogQG1peGVzIHRpbWVDb3JlXG4gKiBAbWl4ZXMgdXRpbC5DdXN0b21FdmVudHNcbiAqIEBwYXJhbSB7RHJhZ30gW2RyYWdIYW5kbGVyXSAtIERyYWcgaGFuZGxlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7VGltZUdyaWR9IFt0aW1lR3JpZFZpZXddIC0gVGltZUdyaWQgdmlldyBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7QmFzZX0gW2Jhc2VDb250cm9sbGVyXSAtIEJhc2UgY29udHJvbGxlciBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gVGltZU1vdmUoZHJhZ0hhbmRsZXIsIHRpbWVHcmlkVmlldywgYmFzZUNvbnRyb2xsZXIpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RHJhZ31cbiAgICAgKi9cbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtUaW1lR3JpZH1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWVHcmlkVmlldyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QmFzZX1cbiAgICAgKi9cbiAgICB0aGlzLmJhc2VDb250cm9sbGVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLl9nZXRFdmVudERhdGFGdW5jID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5fZHJhZ1N0YXJ0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtUaW1lTW92ZUd1aWRlfVxuICAgICAqL1xuICAgIHRoaXMuX2d1aWRlID0gbmV3IFRpbWVNb3ZlR3VpZGUodGhpcyk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmNvbm5lY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG59XG5cbi8qKlxuICogRGVzdHJveSBtZXRob2QuXG4gKi9cblRpbWVNb3ZlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZ3VpZGUuZGVzdHJveSgpO1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIub2ZmKHRoaXMpO1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSB0aGlzLnRpbWVHcmlkVmlldyA9IHRoaXMuYmFzZUNvbnRyb2xsZXIgPVxuICAgICAgICB0aGlzLl9nZXRFdmVudERhdGFGdW5jID0gdGhpcy5fZHJhZ1N0YXJ0ID0gdGhpcy5fZ3VpZGUgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDb25uZWN0IGhhbmRsZXIsIHZpZXcsIGNvbnRyb2xsZXJzIGZvciBldmVudCBjcmVhdGlvbnMuXG4gKiBAcGFyYW0ge0RyYWd9IFtkcmFnSGFuZGxlcl0gLSBEcmFnIGhhbmRsZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge1RpbWVHcmlkfSBbdGltZUdyaWRWaWV3XSAtIFRpbWVHcmlkIHZpZXcgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0Jhc2V9IFtiYXNlQ29udHJvbGxlcl0gLSBCYXNlIGNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gKi9cblRpbWVNb3ZlLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oZHJhZ0hhbmRsZXIsIHRpbWVHcmlkVmlldywgYmFzZUNvbnRyb2xsZXIpIHtcbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gZHJhZ0hhbmRsZXI7XG4gICAgdGhpcy50aW1lR3JpZFZpZXcgPSB0aW1lR3JpZFZpZXc7XG4gICAgdGhpcy5iYXNlQ29udHJvbGxlciA9IGJhc2VDb250cm9sbGVyO1xuXG4gICAgZHJhZ0hhbmRsZXIub24oe1xuICAgICAgICBkcmFnU3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0XG4gICAgfSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIENoZWNrIHRhcmdldCBlbGVtZW50IGlzIGV4cGVjdGVkIGNvbmRpdGlvbiBmb3IgYWN0aXZhdGUgdGhpcyBwbHVnaW5zLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gVGhlIGVsZW1lbnQgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufG9iamVjdH0gLSByZXR1cm4gb2JqZWN0IHdoZW4gc2F0aWF0ZSBjb25kaXRpb24uXG4gKi9cblRpbWVNb3ZlLnByb3RvdHlwZS5jaGVja0V4cGVjdENvbmRpdGlvbiA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgIGlmIChkb211dGlsLmdldENsYXNzKHRhcmdldCkgIT09IGNvbmZpZy5jbGFzc25hbWUoJ3RpbWUtZXZlbnQnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2dldFRpbWVWaWV3KHRhcmdldCk7XG59O1xuXG4vKipcbiAqIEdldCBUaW1lIHZpZXcgY29udGFpbmVyIGZyb20gc3VwcGxpZWQgZWxlbWVudC5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIGVsZW1lbnQgdG8gZmluZCB0aW1lIHZpZXcgY29udGFpbmVyLlxuICogQHJldHVybnMge29iamVjdHxib29sZWFufSAtIHJldHVybiB0aW1lIHZpZXcgaW5zdGFuY2Ugd2hlbiBmaW5kZWQuXG4gKi9cblRpbWVNb3ZlLnByb3RvdHlwZS5fZ2V0VGltZVZpZXcgPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9tdXRpbC5jbG9zZXN0KHRhcmdldCwgJy4nICsgY29uZmlnLmNsYXNzbmFtZSgndGltZS1kYXRlJykpLFxuICAgICAgICBtYXRjaGVzO1xuXG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG1hdGNoZXMgPSBkb211dGlsLmdldENsYXNzKGNvbnRhaW5lcikubWF0Y2goY29uZmlnLnRpbWUuZ2V0Vmlld0lEUmVnRXhwKTtcblxuICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlsLnBpY2sodGhpcy50aW1lR3JpZFZpZXcuY2hpbGRzLml0ZW1zLCArbWF0Y2hlc1sxXSk7XG59O1xuXG4vKipcbiAqIEBlbWl0cyBUaW1lTW92ZSN0aW1lX21vdmVfZHJhZ3N0YXJ0XG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ1N0YXJ0RXZlbnREYXRhIC0gRHJhZyNkcmFnU3RhcnQgZXZlbnQgZGF0YS5cbiAqL1xuVGltZU1vdmUucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGRyYWdTdGFydEV2ZW50RGF0YSkge1xuICAgIHZhciB0YXJnZXQgPSBkcmFnU3RhcnRFdmVudERhdGEudGFyZ2V0LFxuICAgICAgICB0aW1lVmlldyA9IHRoaXMuY2hlY2tFeHBlY3RDb25kaXRpb24odGFyZ2V0KSxcbiAgICAgICAgYmxvY2tFbGVtZW50ID0gZG9tdXRpbC5jbG9zZXN0KHRhcmdldCwgJy4nICsgY29uZmlnLmNsYXNzbmFtZSgndGltZS1kYXRlLWV2ZW50LWJsb2NrJykpLFxuICAgICAgICBnZXRFdmVudERhdGFGdW5jLFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICBpZiAoIXRpbWVWaWV3IHx8ICFibG9ja0VsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9nZXRFdmVudERhdGFGdW5jID0gdGhpcy5fcmV0cml2ZUV2ZW50RGF0YSh0aW1lVmlldyk7XG4gICAgZXZlbnREYXRhID0gdGhpcy5fZHJhZ1N0YXJ0ID0gZ2V0RXZlbnREYXRhRnVuYyhcbiAgICAgICAgZHJhZ1N0YXJ0RXZlbnREYXRhLm9yaWdpbkV2ZW50LCB7XG4gICAgICAgICAgICB0YXJnZXRNb2RlbElEOiBkb211dGlsLmdldERhdGEoYmxvY2tFbGVtZW50LCAnaWQnKVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIHRoaXMuZHJhZ0hhbmRsZXIub24oe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBUaW1lTW92ZSN0aW1lX21vdmVfZHJhZ3N0YXJ0XG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBjdXJyZW50IHRhcmdldCBpbiBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtUaW1lfSByZWxhdGVkVmlldyAtIHRpbWUgdmlldyBpbnN0YW5jZSByZWxhdGVkIHdpdGggbW91c2UgcG9zaXRpb24uXG4gICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBvcmlnaW5FdmVudCAtIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW91c2VZIC0gbW91c2UgWSBweCBtb3VzZSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZ3JpZFkgLSBncmlkIFkgaW5kZXggdmFsdWUgcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZVkgLSBtaWxsaXNlY29uZHMgdmFsdWUgb2YgbW91c2VZIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRZIC0gbmVhcmVzdCBncmlkIGluZGV4IHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkVGltZVkgLSB0aW1lIHZhbHVlIGZvciBuZWFyZXN0R3JpZFkuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHRhcmdldE1vZGVsSUQgLSBUaGUgbW9kZWwgdW5pcXVlIGlkIGVtaXR0ZWQgbW92ZSBldmVudC5cbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ3RpbWVfbW92ZV9kcmFnc3RhcnQnLCBldmVudERhdGEpO1xufTtcblxuLyoqXG4gKiBAZW1pdHMgVGltZU1vdmUjdGltZV9tb3ZlX2RyYWdcbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gZHJhZ0V2ZW50RGF0YSAtIG1vdXNlbW92ZSBldmVudCBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3ZlcnJpZGVFdmVudE5hbWVdIC0gbmFtZSBvZiBlbWl0dGluZyBldmVudCB0byBvdmVycmlkZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtyZXZpc2VdIC0gc3VwcGx5IGZ1bmN0aW9uIGZvciByZXZpc2UgZXZlbnQgZGF0YSBiZWZvcmUgZW1pdC5cbiAqL1xuVGltZU1vdmUucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbihkcmFnRXZlbnREYXRhLCBvdmVycmlkZUV2ZW50TmFtZSwgcmV2aXNlKSB7XG4gICAgdmFyIGdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9nZXRFdmVudERhdGFGdW5jLFxuICAgICAgICB0aW1lVmlldyA9IHRoaXMuX2dldFRpbWVWaWV3KGRyYWdFdmVudERhdGEudGFyZ2V0KSxcbiAgICAgICAgZHJhZ1N0YXJ0ID0gdGhpcy5fZHJhZ1N0YXJ0LFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICBpZiAoIXRpbWVWaWV3IHx8ICFnZXRFdmVudERhdGFGdW5jIHx8ICFkcmFnU3RhcnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50RGF0YSA9IGdldEV2ZW50RGF0YUZ1bmMoZHJhZ0V2ZW50RGF0YS5vcmlnaW5FdmVudCwge1xuICAgICAgICBjdXJyZW50VmlldzogdGltZVZpZXcsXG4gICAgICAgIHRhcmdldE1vZGVsSUQ6IGRyYWdTdGFydC50YXJnZXRNb2RlbElEXG4gICAgfSk7XG5cbiAgICBpZiAocmV2aXNlKSB7XG4gICAgICAgIHJldmlzZShldmVudERhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBldmVudCBUaW1lTW92ZSN0aW1lX21vdmVfZHJhZ1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gY3VycmVudCB0YXJnZXQgaW4gbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqIEBwcm9wZXJ0eSB7VGltZX0gcmVsYXRlZFZpZXcgLSB0aW1lIHZpZXcgaW5zdGFuY2UgcmVsYXRlZCB3aXRoIGRyYWcgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBvcmlnaW5FdmVudCAtIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW91c2VZIC0gbW91c2UgWSBweCBtb3VzZSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZ3JpZFkgLSBncmlkIFkgaW5kZXggdmFsdWUgcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZVkgLSBtaWxsaXNlY29uZHMgdmFsdWUgb2YgbW91c2VZIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRZIC0gbmVhcmVzdCBncmlkIGluZGV4IHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkVGltZVkgLSB0aW1lIHZhbHVlIGZvciBuZWFyZXN0R3JpZFkuXG4gICAgICogQHByb3BlcnR5IHtUaW1lfSBjdXJyZW50VmlldyAtIHRpbWUgdmlldyBpbnN0YW5jZSByZWxhdGVkIHdpdGggY3VycmVudCBtb3VzZSBwb3NpdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdGFyZ2V0TW9kZWxJRCAtIFRoZSBtb2RlbCB1bmlxdWUgaWQgZW1pdHRlZCBtb3ZlIGV2ZW50LlxuICAgICAqL1xuICAgIHRoaXMuZmlyZShvdmVycmlkZUV2ZW50TmFtZSB8fCAndGltZV9tb3ZlX2RyYWcnLCBldmVudERhdGEpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgbW9kZWwgaW5zdGFuY2UgYnkgZHJhZ2VuZCBldmVudCByZXN1bHRzLlxuICogQGZpcmVzIFRpbWVNb3ZlI2JlZm9yZVVwZGF0ZUV2ZW50XG4gKiBAcGFyYW0ge29iamVjdH0gZXZlbnREYXRhIC0gZXZlbnQgZGF0YSBmcm9tIFRpbWVNb3ZlI3RpbWVfbW92ZV9kcmFnZW5kXG4gKi9cblRpbWVNb3ZlLnByb3RvdHlwZS5fdXBkYXRlRXZlbnQgPSBmdW5jdGlvbihldmVudERhdGEpIHtcbiAgICB2YXIgY3RybCA9IHRoaXMuYmFzZUNvbnRyb2xsZXIsXG4gICAgICAgIG1vZGVsSUQgPSBldmVudERhdGEudGFyZ2V0TW9kZWxJRCxcbiAgICAgICAgcmFuZ2UgPSBldmVudERhdGEubmVhcmVzdFJhbmdlLFxuICAgICAgICB0aW1lRGlmZiA9IHJhbmdlWzFdIC0gcmFuZ2VbMF0sXG4gICAgICAgIGRhdGVEaWZmID0gMCxcbiAgICAgICAgbW9kZWwgPSBjdHJsLmV2ZW50cy5pdGVtc1ttb2RlbElEXSxcbiAgICAgICAgcmVsYXRlZFZpZXcgPSBldmVudERhdGEucmVsYXRlZFZpZXcsXG4gICAgICAgIGN1cnJlbnRWaWV3ID0gZXZlbnREYXRhLmN1cnJlbnRWaWV3LFxuICAgICAgICBldmVudER1cmF0aW9uLFxuICAgICAgICBkYXRlU3RhcnQsXG4gICAgICAgIGRhdGVFbmQsXG4gICAgICAgIG5ld1N0YXJ0cyxcbiAgICAgICAgbmV3RW5kcyxcbiAgICAgICAgYmFzZURhdGU7XG5cbiAgICBpZiAoIW1vZGVsIHx8ICFjdXJyZW50Vmlldykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGltZURpZmYgLT0gZGF0ZXRpbWUubWlsbGlzZWNvbmRzRnJvbSgnbWludXRlcycsIDMwKTtcbiAgICBiYXNlRGF0ZSA9IG5ldyBEYXRlKHJlbGF0ZWRWaWV3LmdldERhdGUoKSk7XG4gICAgZGF0ZVN0YXJ0ID0gZGF0ZXRpbWUuc3RhcnQoYmFzZURhdGUpO1xuICAgIGRhdGVFbmQgPSBkYXRldGltZS5lbmQoYmFzZURhdGUpO1xuICAgIG5ld1N0YXJ0cyA9IG5ldyBEYXRlKG1vZGVsLmdldFN0YXJ0cygpLmdldFRpbWUoKSArIHRpbWVEaWZmKTtcbiAgICBuZXdFbmRzID0gbmV3IERhdGUobW9kZWwuZ2V0RW5kcygpLmdldFRpbWUoKSArIHRpbWVEaWZmKTtcbiAgICBldmVudER1cmF0aW9uID0gbW9kZWwuZHVyYXRpb24oKTtcblxuICAgIGlmIChjdXJyZW50Vmlldykge1xuICAgICAgICBkYXRlRGlmZiA9IGN1cnJlbnRWaWV3LmdldERhdGUoKSAtIHJlbGF0ZWRWaWV3LmdldERhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAobmV3U3RhcnRzIDwgZGF0ZVN0YXJ0KSB7XG4gICAgICAgIG5ld1N0YXJ0cyA9IG5ldyBEYXRlKGRhdGVTdGFydC5nZXRUaW1lKCkpO1xuICAgICAgICBuZXdFbmRzID0gbmV3IERhdGUobmV3U3RhcnRzLmdldFRpbWUoKSArIGV2ZW50RHVyYXRpb24uZ2V0VGltZSgpKTtcbiAgICB9IGVsc2UgaWYgKG5ld0VuZHMgPiBkYXRlRW5kKSB7XG4gICAgICAgIG5ld0VuZHMgPSBuZXcgRGF0ZShkYXRlRW5kLmdldFRpbWUoKSk7XG4gICAgICAgIG5ld1N0YXJ0cyA9IG5ldyBEYXRlKG5ld0VuZHMuZ2V0VGltZSgpIC0gZXZlbnREdXJhdGlvbi5nZXRUaW1lKCkpO1xuICAgIH1cblxuICAgIG5ld1N0YXJ0cyA9IG5ldyBEYXRlKG5ld1N0YXJ0cy5nZXRUaW1lKCkgKyBkYXRlRGlmZik7XG4gICAgbmV3RW5kcyA9IG5ldyBEYXRlKG5ld0VuZHMuZ2V0VGltZSgpICsgZGF0ZURpZmYpO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFRpbWVNb3ZlI2JlZm9yZVVwZGF0ZUV2ZW50XG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0NhbEV2ZW50fSBtb2RlbCAtIG1vZGVsIGluc3RhbmNlIHRvIHVwZGF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7ZGF0ZX0gc3RhcnRzIC0gc3RhcnQgdGltZSB0byB1cGRhdGVcbiAgICAgKiBAcHJvcGVydHkge2RhdGV9IGVuZHMgLSBlbmQgdGltZSB0byB1cGRhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ2JlZm9yZVVwZGF0ZUV2ZW50Jywge1xuICAgICAgICBtb2RlbDogbW9kZWwsXG4gICAgICAgIHN0YXJ0czogbmV3U3RhcnRzLFxuICAgICAgICBlbmRzOiBuZXdFbmRzXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBlbWl0cyBUaW1lTW92ZSN0aW1lX21vdmVfZHJhZ2VuZFxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBkcmFnRW5kRXZlbnREYXRhIC0gbW91c2V1cCBtb3VzZSBldmVudCBvYmplY3QuXG4gKi9cblRpbWVNb3ZlLnByb3RvdHlwZS5fb25EcmFnRW5kID0gZnVuY3Rpb24oZHJhZ0VuZEV2ZW50RGF0YSkge1xuICAgIHZhciBnZXRFdmVudERhdGFGdW5jID0gdGhpcy5fZ2V0RXZlbnREYXRhRnVuYyxcbiAgICAgICAgY3VycmVudFZpZXcgPSB0aGlzLl9nZXRUaW1lVmlldyhkcmFnRW5kRXZlbnREYXRhLnRhcmdldCksXG4gICAgICAgIGRyYWdTdGFydCA9IHRoaXMuX2RyYWdTdGFydCxcbiAgICAgICAgZXZlbnREYXRhO1xuXG4gICAgdGhpcy5kcmFnSGFuZGxlci5vZmYoe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIGlmICghZ2V0RXZlbnREYXRhRnVuYyB8fCAhZHJhZ1N0YXJ0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudERhdGEgPSBnZXRFdmVudERhdGFGdW5jKGRyYWdFbmRFdmVudERhdGEub3JpZ2luRXZlbnQsIHtcbiAgICAgICAgY3VycmVudFZpZXc6IGN1cnJlbnRWaWV3LFxuICAgICAgICB0YXJnZXRNb2RlbElEOiBkcmFnU3RhcnQudGFyZ2V0TW9kZWxJRFxuICAgIH0pO1xuXG4gICAgZXZlbnREYXRhLnJhbmdlID0gW1xuICAgICAgICBkcmFnU3RhcnQudGltZVksXG4gICAgICAgIGV2ZW50RGF0YS50aW1lWSArIGRhdGV0aW1lLm1pbGxpc2Vjb25kc0Zyb20oJ2hvdXInLCAwLjUpXG4gICAgXTtcblxuICAgIGV2ZW50RGF0YS5uZWFyZXN0UmFuZ2UgPSBbXG4gICAgICAgIGRyYWdTdGFydC5uZWFyZXN0R3JpZFRpbWVZLFxuICAgICAgICBldmVudERhdGEubmVhcmVzdEdyaWRUaW1lWSArIGRhdGV0aW1lLm1pbGxpc2Vjb25kc0Zyb20oJ2hvdXInLCAwLjUpXG4gICAgXTtcblxuICAgIHRoaXMuX3VwZGF0ZUV2ZW50KGV2ZW50RGF0YSk7XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgVGltZU1vdmUjdGltZV9tb3ZlX2RyYWdlbmRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIGN1cnJlbnQgdGFyZ2V0IGluIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge1RpbWV9IHJlbGF0ZWRWaWV3IC0gdGltZSB2aWV3IGluc3RhbmNlIHJlbGF0ZWQgd2l0aCBkcmFnIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7VGltZX0gY3VycmVudFZpZXcgLSB0aW1lIHZpZXcgaW5zdGFuY2UgcmVsYXRlZCB3aXRoIGN1cnJlbnQgbW91c2UgcG9zaXRpb24uXG4gICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBvcmlnaW5FdmVudCAtIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW91c2VZIC0gbW91c2UgWSBweCBtb3VzZSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZ3JpZFkgLSBncmlkIFkgaW5kZXggdmFsdWUgcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZVkgLSBtaWxsaXNlY29uZHMgdmFsdWUgb2YgbW91c2VZIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRZIC0gbmVhcmVzdCBncmlkIGluZGV4IHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkVGltZVkgLSB0aW1lIHZhbHVlIGZvciBuZWFyZXN0R3JpZFkuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHRhcmdldE1vZGVsSUQgLSBUaGUgbW9kZWwgdW5pcXVlIGlkIGVtaXR0ZWQgbW92ZSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcltdfSByYW5nZSAtIG1pbGxpc2Vjb25kcyByYW5nZSBiZXR3ZWVuIGRyYWcgc3RhcnQgYW5kIGVuZC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcltdfSBuZWFyZXN0UmFuZ2UgLSBtaWxsaXNlY29uZHMgcmFuZ2UgcmVsYXRlZCB3aXRoIG5lYXJlc3RHcmlkWSBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQuXG4gICAgICovXG4gICAgdGhpcy5maXJlKCd0aW1lX21vdmVfZHJhZ2VuZCcsIGV2ZW50RGF0YSk7XG59O1xuXG4vKipcbiAqIEBlbWl0cyBUaW1lTW92ZSN0aW1lX21vdmVfY2xpY2tcbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gY2xpY2tFdmVudERhdGEgLSBjbGljayBtb3VzZSBldmVudCBvYmplY3QuXG4gKi9cblRpbWVNb3ZlLnByb3RvdHlwZS5fb25DbGljayA9IGZ1bmN0aW9uKGNsaWNrRXZlbnREYXRhKSB7XG4gICAgdmFyIGdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9nZXRFdmVudERhdGFGdW5jLFxuICAgICAgICBkcmFnU3RhcnQgPSB0aGlzLl9kcmFnU3RhcnQsXG4gICAgICAgIGV2ZW50RGF0YTtcblxuICAgIHRoaXMuZHJhZ0hhbmRsZXIub2ZmKHtcbiAgICAgICAgZHJhZzogdGhpcy5fb25EcmFnLFxuICAgICAgICBkcmFnRW5kOiB0aGlzLl9vbkRyYWdFbmQsXG4gICAgICAgIGNsaWNrOiB0aGlzLl9vbkNsaWNrXG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoIWdldEV2ZW50RGF0YUZ1bmMgfHwgIWRyYWdTdGFydCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnREYXRhID0gZ2V0RXZlbnREYXRhRnVuYyhjbGlja0V2ZW50RGF0YS5vcmlnaW5FdmVudCwge1xuICAgICAgICB0YXJnZXRNb2RlbElEOiBkcmFnU3RhcnQudGFyZ2V0TW9kZWxJRFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFRpbWVNb3ZlI3RpbWVfbW92ZV9jbGlja1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gY3VycmVudCB0YXJnZXQgaW4gbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqIEBwcm9wZXJ0eSB7VGltZX0gcmVsYXRlZFZpZXcgLSB0aW1lIHZpZXcgaW5zdGFuY2UgcmVsYXRlZCB3aXRoIGRyYWcgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBvcmlnaW5FdmVudCAtIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW91c2VZIC0gbW91c2UgWSBweCBtb3VzZSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZ3JpZFkgLSBncmlkIFkgaW5kZXggdmFsdWUgcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZVkgLSBtaWxsaXNlY29uZHMgdmFsdWUgb2YgbW91c2VZIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRZIC0gbmVhcmVzdCBncmlkIGluZGV4IHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkVGltZVkgLSB0aW1lIHZhbHVlIGZvciBuZWFyZXN0R3JpZFkuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHRhcmdldE1vZGVsSUQgLSBUaGUgbW9kZWwgdW5pcXVlIGlkIGVtaXR0ZWQgbW92ZSBldmVudC5cbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ3RpbWVfbW92ZV9jbGljaycsIGV2ZW50RGF0YSk7XG59O1xuXG50aW1lQ29yZS5taXhpbihUaW1lTW92ZSk7XG51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihUaW1lTW92ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZU1vdmU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBNb2R1bGUgZm9yIFRpbWUuTW92ZSBlZmZlY3Qgd2hpbGUgZHJhZ2dpbmcuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC50dWkudXRpbDtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi8uLi9jb25maWcnKTtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciByZXFBbmltRnJhbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vcmVxQW5pbUZyYW1lJyk7XG52YXIgcmF0aW8gPSByZXF1aXJlKCcuLi8uLi9jb21tb24vY29tbW9uJykucmF0aW87XG5cbi8qKlxuICogQ2xhc3MgZm9yIFRpbWUuTW92ZSBlZmZlY3QuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VGltZU1vdmV9IHRpbWVNb3ZlIC0gVGhlIGluc3RhbmNlIG9mIFRpbWVNb3ZlLlxuICovXG5mdW5jdGlvbiBUaW1lTW92ZUd1aWRlKHRpbWVNb3ZlKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZ3VpZGVFbGVtZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtUaW1lTW92ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWVNb3ZlID0gdGltZU1vdmU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5fY29udGFpbmVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLl9nZXRUb3BGdW5jID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fc3RhcnRHcmlkWSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX3N0YXJ0VG9wUGl4ZWwgPSAwO1xuXG4gICAgdGltZU1vdmUub24oe1xuICAgICAgICAndGltZV9tb3ZlX2RyYWdzdGFydCc6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuICAgICAgICAndGltZV9tb3ZlX2RyYWcnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgICd0aW1lX21vdmVfZHJhZ2VuZCc6IHRoaXMuX2NsZWFyR3VpZGVFbGVtZW50LFxuICAgICAgICAndGltZV9tb3ZlX2NsaWNrJzogdGhpcy5fY2xlYXJHdWlkZUVsZW1lbnRcbiAgICB9LCB0aGlzKTtcbn1cblxuLyoqXG4gKiBEZXN0cm95IG1ldGhvZFxuICovXG5UaW1lTW92ZUd1aWRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2xlYXJHdWlkZUVsZW1lbnQoKTtcbiAgICB0aGlzLnRpbWVNb3ZlLm9mZih0aGlzKTtcbiAgICB0aGlzLmd1aWRlRWxlbWVudCA9IHRoaXMudGltZU1vdmUgPSB0aGlzLl9jb250YWluZXIgPVxuICAgICAgICB0aGlzLl9nZXRUb3BGdW5jID0gdGhpcy5fc3RhcnRHcmlkWSA9IHRoaXMuX3N0YXJ0VG9wUGl4ZWwgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhciBndWlkZSBlbGVtZW50LlxuICovXG5UaW1lTW92ZUd1aWRlLnByb3RvdHlwZS5fY2xlYXJHdWlkZUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ3VpZGVFbGVtZW50ID0gdGhpcy5ndWlkZUVsZW1lbnQ7XG5cbiAgICBpZiAoIXV0aWwuYnJvd3Nlci5tc2llKSB7XG4gICAgICAgIGRvbXV0aWwucmVtb3ZlQ2xhc3MoZ2xvYmFsLmRvY3VtZW50LmJvZHksIGNvbmZpZy5jbGFzc25hbWUoJ2RyYWdnaW5nJykpO1xuICAgIH1cblxuICAgIGRvbXV0aWwucmVtb3ZlKGd1aWRlRWxlbWVudCk7XG5cbiAgICB0aGlzLmd1aWRlRWxlbWVudCA9IHRoaXMuX2dldFRvcEZ1bmMgPVxuICAgICAgICB0aGlzLl9zdGFydEdyaWRZID0gdGhpcy5fc3RhcnRUb3BQaXhlbCA9IG51bGw7XG59O1xuXG4vKipcbiAqIFJlZnJlc2ggZ3VpZGUgZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHRvcCAtIGd1aWRlIGVsZW1lbnQncyBzdHlsZSB0b3AuXG4gKi9cblRpbWVNb3ZlR3VpZGUucHJvdG90eXBlLl9yZWZyZXNoR3VpZGVFbGVtZW50ID0gZnVuY3Rpb24odG9wKSB7XG4gICAgdmFyIGd1aWRlRWxlbWVudCA9IHRoaXMuZ3VpZGVFbGVtZW50O1xuXG4gICAgaWYgKCFndWlkZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlcUFuaW1GcmFtZS5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICBndWlkZUVsZW1lbnQuc3R5bGUudG9wID0gdG9wICsgJ3B4JztcbiAgICAgICAgZ3VpZGVFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBUaW1lTW92ZSN0aW1lX21vdmVfZHJhZ3N0YXJ0IGV2ZW50IGhhbmRsZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnU3RhcnRFdmVudERhdGEgLSBkcmFnc3RhcnQgZXZlbnQgZGF0YVxuICovXG5UaW1lTW92ZUd1aWRlLnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbihkcmFnU3RhcnRFdmVudERhdGEpIHtcbiAgICB2YXIgZ3VpZGVFbGVtZW50ID0gZG9tdXRpbC5jbG9zZXN0KFxuICAgICAgICBkcmFnU3RhcnRFdmVudERhdGEudGFyZ2V0LFxuICAgICAgICAnLicgKyBjb25maWcuY2xhc3NuYW1lKCd0aW1lLWRhdGUtZXZlbnQtYmxvY2snKVxuICAgICk7XG5cbiAgICBpZiAoIWd1aWRlRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ3VpZGVFbGVtZW50ID0gZ3VpZGVFbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgICBkb211dGlsLmFkZENsYXNzKGd1aWRlRWxlbWVudCwgY29uZmlnLmNsYXNzbmFtZSgndGltZS1ndWlkZS1tb3ZlJykpO1xuXG4gICAgdGhpcy5fc3RhcnRUb3BQaXhlbCA9IHBhcnNlRmxvYXQoZ3VpZGVFbGVtZW50LnN0eWxlLnRvcCk7XG4gICAgdGhpcy5fc3RhcnRHcmlkWSA9IGRyYWdTdGFydEV2ZW50RGF0YS5uZWFyZXN0R3JpZFk7XG4gICAgdGhpcy5ndWlkZUVsZW1lbnQgPSBndWlkZUVsZW1lbnQ7XG4gICAgdGhpcy5fY29udGFpbmVyID0gZHJhZ1N0YXJ0RXZlbnREYXRhLnJlbGF0ZWRWaWV3LmNvbnRhaW5lcjtcbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoZ3VpZGVFbGVtZW50KTtcbn07XG5cbi8qKlxuICogVGltZU1vdmUjdGltZV9tb3ZlX2RyYWcgZXZlbnQgaGFuZGxlclxuICogQHBhcmFtIHtvYmplY3R9IGRyYWdFdmVudERhdGEgLSBkcmFnIGV2ZW50IGRhdGFcbiAqL1xuVGltZU1vdmVHdWlkZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uKGRyYWdFdmVudERhdGEpIHtcbiAgICB2YXIgdGltZVZpZXcgPSBkcmFnRXZlbnREYXRhLmN1cnJlbnRWaWV3LFxuICAgICAgICB2aWV3T3B0aW9ucyA9IHRpbWVWaWV3Lm9wdGlvbnMsXG4gICAgICAgIHZpZXdIZWlnaHQgPSB0aW1lVmlldy5nZXRWaWV3Qm91bmQoKS5oZWlnaHQsXG4gICAgICAgIGd1aWRlSGVpZ2h0ID0gcGFyc2VGbG9hdCh0aGlzLmd1aWRlRWxlbWVudC5zdHlsZS5oZWlnaHQpLFxuICAgICAgICBob3VyTGVuZ3RoID0gdmlld09wdGlvbnMuaG91ckVuZCAtIHZpZXdPcHRpb25zLmhvdXJTdGFydCxcbiAgICAgICAgZ3JpZFlPZmZzZXQgPSBkcmFnRXZlbnREYXRhLm5lYXJlc3RHcmlkWSAtIHRoaXMuX3N0YXJ0R3JpZFksXG4gICAgICAgIGdyaWRZT2Zmc2V0UGl4ZWwgPSByYXRpbyhob3VyTGVuZ3RoLCB2aWV3SGVpZ2h0LCBncmlkWU9mZnNldCksXG4gICAgICAgIGJvdHRvbUxpbWl0LFxuICAgICAgICB0b3A7XG5cbiAgICBpZiAoIXV0aWwuYnJvd3Nlci5tc2llKSB7XG4gICAgICAgIGRvbXV0aWwuYWRkQ2xhc3MoZ2xvYmFsLmRvY3VtZW50LmJvZHksIGNvbmZpZy5jbGFzc25hbWUoJ2RyYWdnaW5nJykpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb250YWluZXIgIT09IHRpbWVWaWV3LmNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSB0aW1lVmlldy5jb250YWluZXI7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmd1aWRlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgdG9wID0gdGhpcy5fc3RhcnRUb3BQaXhlbCArIGdyaWRZT2Zmc2V0UGl4ZWw7XG4gICAgYm90dG9tTGltaXQgPSB2aWV3SGVpZ2h0IC0gZ3VpZGVIZWlnaHQ7XG5cbiAgICB0b3AgPSBNYXRoLm1heCh0b3AsIDApO1xuICAgIHRvcCA9IE1hdGgubWluKHRvcCwgYm90dG9tTGltaXQpO1xuXG4gICAgdGhpcy5fcmVmcmVzaEd1aWRlRWxlbWVudCh0b3ApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lTW92ZUd1aWRlO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgSGFuZGxpbmcgcmVzaXplIGV2ZW50cyBmcm9tIGRyYWcgaGFuZGxlciBhbmQgdGltZSBncmlkIHZpZXdcbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgdXRpbCA9IGdsb2JhbC50dWkudXRpbDtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi8uLi9jb25maWcnKTtcbnZhciBkYXRldGltZSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kYXRldGltZScpO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIHRpbWVDb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG52YXIgVGltZVJlc2l6ZUd1aWRlID0gcmVxdWlyZSgnLi9yZXNpemVHdWlkZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge0hhbmRsZXJ9XG4gKiBAbWl4ZXMgdGltZUNvcmVcbiAqIEBtaXhlcyB1dGlsLkN1c3RvbUV2ZW50c1xuICogQHBhcmFtIHtEcmFnfSBbZHJhZ0hhbmRsZXJdIC0gRHJhZyBoYW5kbGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHtUaW1lR3JpZH0gW3RpbWVHcmlkVmlld10gLSBUaW1lR3JpZCB2aWV3IGluc3RhbmNlLlxuICogQHBhcmFtIHtCYXNlfSBbYmFzZUNvbnRyb2xsZXJdIC0gQmFzZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBUaW1lUmVzaXplKGRyYWdIYW5kbGVyLCB0aW1lR3JpZFZpZXcsIGJhc2VDb250cm9sbGVyKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0RyYWd9XG4gICAgICovXG4gICAgdGhpcy5kcmFnSGFuZGxlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VGltZUdyaWR9XG4gICAgICovXG4gICAgdGhpcy50aW1lR3JpZFZpZXcgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Jhc2V9XG4gICAgICovXG4gICAgdGhpcy5iYXNlQ29udHJvbGxlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5fZ2V0RXZlbnREYXRhRnVuYyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuX2RyYWdTdGFydCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VGltZVJlc2l6ZUd1aWRlfVxuICAgICAqL1xuICAgIHRoaXMuX2d1aWRlID0gbmV3IFRpbWVSZXNpemVHdWlkZSh0aGlzKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEZXN0cm95IG1ldGhvZFxuICovXG5UaW1lUmVzaXplLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZ3VpZGUuZGVzdHJveSgpO1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIub2ZmKHRoaXMpO1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSB0aGlzLnRpbWVHcmlkVmlldyA9IHRoaXMuYmFzZUNvbnRyb2xsZXIgPVxuICAgICAgICB0aGlzLl9nZXRFdmVudERhdGFGdW5jID0gdGhpcy5fZHJhZ1N0YXJ0ID0gdGhpcy5fZ3VpZGUgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDb25uZWN0IGhhbmRsZXIsIHZpZXcsIGNvbnRyb2xsZXJzIGZvciBldmVudCBjcmVhdGlvbnMuXG4gKiBAcGFyYW0ge0RyYWd9IFtkcmFnSGFuZGxlcl0gLSBEcmFnIGhhbmRsZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge1RpbWVHcmlkfSBbdGltZUdyaWRWaWV3XSAtIFRpbWVHcmlkIHZpZXcgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0Jhc2V9IFtiYXNlQ29udHJvbGxlcl0gLSBCYXNlIGNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gKi9cblRpbWVSZXNpemUucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihkcmFnSGFuZGxlciwgdGltZUdyaWRWaWV3LCBiYXNlQ29udHJvbGxlcikge1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBkcmFnSGFuZGxlcjtcbiAgICB0aGlzLnRpbWVHcmlkVmlldyA9IHRpbWVHcmlkVmlldztcbiAgICB0aGlzLmJhc2VDb250cm9sbGVyID0gYmFzZUNvbnRyb2xsZXI7XG5cbiAgICBkcmFnSGFuZGxlci5vbih7XG4gICAgICAgIGRyYWdTdGFydDogdGhpcy5fb25EcmFnU3RhcnRcbiAgICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gZWxlbWVudCB0byBjaGVjayBjb25kaXRpb24uXG4gKiBAcmV0dXJucyB7b2JqZWN0fGJvb2xlYW59IC0gcmV0dXJuIHRpbWUgdmlldyBpbnN0YW5jZSBvciBmYWxzZVxuICovXG5UaW1lUmVzaXplLnByb3RvdHlwZS5jaGVja0V4cGVjdENvbmRpdGlvbiA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgIHZhciBjb250YWluZXIsXG4gICAgICAgIG1hdGNoZXM7XG5cbiAgICBpZiAoIWRvbXV0aWwuaGFzQ2xhc3ModGFyZ2V0LCBjb25maWcuY2xhc3NuYW1lKCd0aW1lLXJlc2l6ZS1oYW5kbGUnKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnRhaW5lciA9IGRvbXV0aWwuY2xvc2VzdCh0YXJnZXQsICcuJyArIGNvbmZpZy5jbGFzc25hbWUoJ3RpbWUtZGF0ZScpKTtcblxuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBtYXRjaGVzID0gZG9tdXRpbC5nZXRDbGFzcyhjb250YWluZXIpLm1hdGNoKGNvbmZpZy50aW1lLmdldFZpZXdJRFJlZ0V4cCk7XG5cbiAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbC5waWNrKHRoaXMudGltZUdyaWRWaWV3LmNoaWxkcy5pdGVtcywgK21hdGNoZXNbMV0pO1xufTtcblxuLyoqXG4gKiBAZW1pdHMgVGltZVJlc2l6ZSN0aW1lX3Jlc2l6ZV9kcmFnc3RhcnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnU3RhcnRFdmVudERhdGEgLSBldmVudCBkYXRhIG9mIERyYWcjZHJhZ3N0YXJ0XG4gKi9cblRpbWVSZXNpemUucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGRyYWdTdGFydEV2ZW50RGF0YSkge1xuICAgIHZhciB0YXJnZXQgPSBkcmFnU3RhcnRFdmVudERhdGEudGFyZ2V0LFxuICAgICAgICB0aW1lVmlldyA9IHRoaXMuY2hlY2tFeHBlY3RDb25kaXRpb24odGFyZ2V0KSxcbiAgICAgICAgYmxvY2tFbGVtZW50ID0gZG9tdXRpbC5jbG9zZXN0KHRhcmdldCwgJy4nICsgY29uZmlnLmNsYXNzbmFtZSgndGltZS1kYXRlLWV2ZW50LWJsb2NrJykpLFxuICAgICAgICBnZXRFdmVudERhdGFGdW5jLFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICBpZiAoIXRpbWVWaWV3IHx8ICFibG9ja0VsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9nZXRFdmVudERhdGFGdW5jID0gdGhpcy5fcmV0cml2ZUV2ZW50RGF0YSh0aW1lVmlldyk7XG4gICAgZXZlbnREYXRhID0gdGhpcy5fZHJhZ1N0YXJ0ID0gZ2V0RXZlbnREYXRhRnVuYyhcbiAgICAgICAgZHJhZ1N0YXJ0RXZlbnREYXRhLm9yaWdpbkV2ZW50LCB7XG4gICAgICAgICAgICB0YXJnZXRNb2RlbElEOiBkb211dGlsLmdldERhdGEoYmxvY2tFbGVtZW50LCAnaWQnKVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIHRoaXMuZHJhZ0hhbmRsZXIub24oe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBUaW1lUmVzaXplI3RpbWVfcmVzaXplX2RyYWdzdGFydFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gY3VycmVudCB0YXJnZXQgaW4gbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqIEBwcm9wZXJ0eSB7VGltZX0gcmVsYXRlZFZpZXcgLSB0aW1lIHZpZXcgaW5zdGFuY2UgcmVsYXRlZCB3aXRoIG1vdXNlIHBvc2l0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7TW91c2VFdmVudH0gb3JpZ2luRXZlbnQgLSBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1vdXNlWSAtIG1vdXNlIFkgcHggbW91c2UgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGdyaWRZIC0gZ3JpZCBZIGluZGV4IHZhbHVlIHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVZIC0gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIG1vdXNlWSBwb2ludHMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkWSAtIG5lYXJlc3QgZ3JpZCBpbmRleCByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFRpbWVZIC0gdGltZSB2YWx1ZSBmb3IgbmVhcmVzdEdyaWRZLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0YXJnZXRNb2RlbElEIC0gVGhlIG1vZGVsIHVuaXF1ZSBpZCBlbWl0dGVkIG1vdmUgZXZlbnQuXG4gICAgICovXG4gICAgdGhpcy5maXJlKCd0aW1lX3Jlc2l6ZV9kcmFnc3RhcnQnLCBldmVudERhdGEpO1xufTtcblxuLyoqXG4gKiBEcmFnI2RyYWcgZXZlbnQgaGFuZGxlclxuICogQGVtaXRzIFRpbWVSZXNpemUjdGltZV9yZXNpemVfZHJhZ1xuICogQHBhcmFtIHtvYmplY3R9IGRyYWdFdmVudERhdGEgLSBldmVudCBkYXRhIG9mIERyYWcjZHJhZyBjdXN0b20gZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW292ZXJyaWRlRXZlbnROYW1lXSAtIG92ZXJyaWRlIGVtaXR0ZWQgZXZlbnQgbmFtZSB3aGVuIHN1cHBsaWVkLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3JldmlzZV0gLSBzdXBwbHkgZnVuY3Rpb24gZm9yIHJldmlzZSBldmVudCBkYXRhIGJlZm9yZSBlbWl0LlxuICovXG5UaW1lUmVzaXplLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24oZHJhZ0V2ZW50RGF0YSwgb3ZlcnJpZGVFdmVudE5hbWUsIHJldmlzZSkge1xuICAgIHZhciBnZXRFdmVudERhdGFGdW5jID0gdGhpcy5fZ2V0RXZlbnREYXRhRnVuYyxcbiAgICAgICAgc3RhcnRFdmVudERhdGEgPSB0aGlzLl9kcmFnU3RhcnQsXG4gICAgICAgIGV2ZW50RGF0YTtcblxuICAgIGlmICghZ2V0RXZlbnREYXRhRnVuYyB8fCAhc3RhcnRFdmVudERhdGEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50RGF0YSA9IGdldEV2ZW50RGF0YUZ1bmMoZHJhZ0V2ZW50RGF0YS5vcmlnaW5FdmVudCwge1xuICAgICAgICB0YXJnZXRNb2RlbElEOiBzdGFydEV2ZW50RGF0YS50YXJnZXRNb2RlbElEXG4gICAgfSk7XG5cbiAgICBpZiAocmV2aXNlKSB7XG4gICAgICAgIHJldmlzZShldmVudERhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBldmVudCBUaW1lUmVzaXplI3RpbWVfcmVzaXplX2RyYWdcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIGN1cnJlbnQgdGFyZ2V0IGluIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge1RpbWV9IHJlbGF0ZWRWaWV3IC0gdGltZSB2aWV3IGluc3RhbmNlIHJlbGF0ZWQgd2l0aCBkcmFnIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7TW91c2VFdmVudH0gb3JpZ2luRXZlbnQgLSBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1vdXNlWSAtIG1vdXNlIFkgcHggbW91c2UgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGdyaWRZIC0gZ3JpZCBZIGluZGV4IHZhbHVlIHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVZIC0gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIG1vdXNlWSBwb2ludHMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkWSAtIG5lYXJlc3QgZ3JpZCBpbmRleCByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFRpbWVZIC0gdGltZSB2YWx1ZSBmb3IgbmVhcmVzdEdyaWRZLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0YXJnZXRNb2RlbElEIC0gVGhlIG1vZGVsIHVuaXF1ZSBpZCBlbWl0dGVkIG1vdmUgZXZlbnQuXG4gICAgICovXG4gICAgdGhpcy5maXJlKG92ZXJyaWRlRXZlbnROYW1lIHx8ICd0aW1lX3Jlc2l6ZV9kcmFnJywgZXZlbnREYXRhKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIG1vZGVsIGluc3RhbmNlIGJ5IGRyYWdlbmQgZXZlbnQgcmVzdWx0cy5cbiAqIEBmaXJlcyBUaW1lUmVzaXplI2JlZm9yZVVwZGF0ZUV2ZW50XG4gKiBAcGFyYW0ge29iamVjdH0gZXZlbnREYXRhIC0gZXZlbnQgZGF0YSBmcm9tIFRpbWVSZXNpemUjdGltZV9yZXNpemVfZHJhZ2VuZFxuICovXG5UaW1lUmVzaXplLnByb3RvdHlwZS5fdXBkYXRlRXZlbnQgPSBmdW5jdGlvbihldmVudERhdGEpIHtcbiAgICB2YXIgY3RybCA9IHRoaXMuYmFzZUNvbnRyb2xsZXIsXG4gICAgICAgIG1vZGVsSUQgPSBldmVudERhdGEudGFyZ2V0TW9kZWxJRCxcbiAgICAgICAgcmFuZ2UgPSBldmVudERhdGEubmVhcmVzdFJhbmdlLFxuICAgICAgICB0aW1lRGlmZiA9IHJhbmdlWzFdIC0gcmFuZ2VbMF0sXG4gICAgICAgIG1vZGVsID0gY3RybC5ldmVudHMuaXRlbXNbbW9kZWxJRF0sXG4gICAgICAgIHJlbGF0ZWRWaWV3ID0gZXZlbnREYXRhLnJlbGF0ZWRWaWV3LFxuICAgICAgICBkYXRlRW5kLFxuICAgICAgICBuZXdFbmRzLFxuICAgICAgICBiYXNlRGF0ZTtcblxuICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRpbWVEaWZmIC09IGRhdGV0aW1lLm1pbGxpc2Vjb25kc0Zyb20oJ21pbnV0ZXMnLCAzMCk7XG5cbiAgICBiYXNlRGF0ZSA9IG5ldyBEYXRlKHJlbGF0ZWRWaWV3LmdldERhdGUoKSk7XG4gICAgZGF0ZUVuZCA9IGRhdGV0aW1lLmVuZChiYXNlRGF0ZSk7XG4gICAgbmV3RW5kcyA9IG5ldyBEYXRlKG1vZGVsLmdldEVuZHMoKS5nZXRUaW1lKCkgKyB0aW1lRGlmZik7XG5cbiAgICBpZiAobmV3RW5kcyA+IGRhdGVFbmQpIHtcbiAgICAgICAgbmV3RW5kcyA9IG5ldyBEYXRlKGRhdGVFbmQuZ2V0VGltZSgpKTtcbiAgICB9XG5cbiAgICBpZiAobmV3RW5kcy5nZXRUaW1lKCkgLSBtb2RlbC5nZXRTdGFydHMoKS5nZXRUaW1lKCkgPCBkYXRldGltZS5taWxsaXNlY29uZHNGcm9tKCdtaW51dGVzJywgMzApKSB7XG4gICAgICAgIG5ld0VuZHMgPSBuZXcgRGF0ZShtb2RlbC5nZXRTdGFydHMoKS5nZXRUaW1lKCkgKyBkYXRldGltZS5taWxsaXNlY29uZHNGcm9tKCdtaW51dGVzJywgMzApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgVGltZVJlc2l6ZSNiZWZvcmVVcGRhdGVFdmVudFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtDYWxFdmVudH0gbW9kZWwgLSBtb2RlbCBpbnN0YW5jZSB0byB1cGRhdGVcbiAgICAgKiBAcHJvcGVydHkge2RhdGV9IHN0YXJ0cyAtIHN0YXJ0IHRpbWUgdG8gdXBkYXRlXG4gICAgICogQHByb3BlcnR5IHtkYXRlfSBlbmRzIC0gZW5kIHRpbWUgdG8gdXBkYXRlXG4gICAgICovXG4gICAgdGhpcy5maXJlKCdiZWZvcmVVcGRhdGVFdmVudCcsIHtcbiAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICBzdGFydHM6IG1vZGVsLmdldFN0YXJ0cygpLFxuICAgICAgICBlbmRzOiBuZXdFbmRzXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIERyYWcjZHJhZ0VuZCBldmVudCBoYW5kbGVyXG4gKiBAZW1pdHMgVGltZVJlc2l6ZSN0aW1lX3Jlc2l6ZV9kcmFnZW5kXG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IGRyYWdFbmRFdmVudERhdGEgLSBNb3VzZSBldmVudCBvZiBEcmFnI2RyYWdFbmQgY3VzdG9tIGV2ZW50LlxuICovXG5UaW1lUmVzaXplLnByb3RvdHlwZS5fb25EcmFnRW5kID0gZnVuY3Rpb24oZHJhZ0VuZEV2ZW50RGF0YSkge1xuICAgIHZhciBnZXRFdmVudERhdGFGdW5jID0gdGhpcy5fZ2V0RXZlbnREYXRhRnVuYyxcbiAgICAgICAgZHJhZ1N0YXJ0ID0gdGhpcy5fZHJhZ1N0YXJ0LFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9mZih7XG4gICAgICAgIGRyYWc6IHRoaXMuX29uRHJhZyxcbiAgICAgICAgZHJhZ0VuZDogdGhpcy5fb25EcmFnRW5kLFxuICAgICAgICBjbGljazogdGhpcy5fb25DbGlja1xuICAgIH0sIHRoaXMpO1xuXG4gICAgaWYgKCFnZXRFdmVudERhdGFGdW5jIHx8ICFkcmFnU3RhcnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50RGF0YSA9IGdldEV2ZW50RGF0YUZ1bmMoZHJhZ0VuZEV2ZW50RGF0YS5vcmlnaW5FdmVudCwge1xuICAgICAgICB0YXJnZXRNb2RlbElEOiBkcmFnU3RhcnQudGFyZ2V0TW9kZWxJRFxuICAgIH0pO1xuXG4gICAgZXZlbnREYXRhLnJhbmdlID0gW1xuICAgICAgICBkcmFnU3RhcnQudGltZVksXG4gICAgICAgIGV2ZW50RGF0YS50aW1lWSArIGRhdGV0aW1lLm1pbGxpc2Vjb25kc0Zyb20oJ2hvdXInLCAwLjUpXG4gICAgXTtcblxuICAgIGV2ZW50RGF0YS5uZWFyZXN0UmFuZ2UgPSBbXG4gICAgICAgIGRyYWdTdGFydC5uZWFyZXN0R3JpZFRpbWVZLFxuICAgICAgICBldmVudERhdGEubmVhcmVzdEdyaWRUaW1lWSArIGRhdGV0aW1lLm1pbGxpc2Vjb25kc0Zyb20oJ2hvdXInLCAwLjUpXG4gICAgXTtcblxuICAgIHRoaXMuX3VwZGF0ZUV2ZW50KGV2ZW50RGF0YSk7XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgVGltZVJlc2l6ZSN0aW1lX3Jlc2l6ZV9kcmFnZW5kXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBjdXJyZW50IHRhcmdldCBpbiBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtUaW1lfSByZWxhdGVkVmlldyAtIHRpbWUgdmlldyBpbnN0YW5jZSByZWxhdGVkIHdpdGggZHJhZyBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge01vdXNlRXZlbnR9IG9yaWdpbkV2ZW50IC0gbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb3VzZVkgLSBtb3VzZSBZIHB4IG1vdXNlIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBncmlkWSAtIGdyaWQgWSBpbmRleCB2YWx1ZSByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lWSAtIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiBtb3VzZVkgcG9pbnRzLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFkgLSBuZWFyZXN0IGdyaWQgaW5kZXggcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRUaW1lWSAtIHRpbWUgdmFsdWUgZm9yIG5lYXJlc3RHcmlkWS5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdGFyZ2V0TW9kZWxJRCAtIFRoZSBtb2RlbCB1bmlxdWUgaWQgZW1pdHRlZCBtb3ZlIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IHJhbmdlIC0gbWlsbGlzZWNvbmRzIHJhbmdlIGJldHdlZW4gZHJhZyBzdGFydCBhbmQgZW5kLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IG5lYXJlc3RSYW5nZSAtIG1pbGxpc2Vjb25kcyByYW5nZSByZWxhdGVkIHdpdGggbmVhcmVzdEdyaWRZIGJldHdlZW4gc3RhcnQgYW5kIGVuZC5cbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ3RpbWVfcmVzaXplX2RyYWdlbmQnLCBldmVudERhdGEpO1xuXG4gICAgdGhpcy5fZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX2RyYWdTdGFydCA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBlbWl0cyBUaW1lUmVzaXplI3RpbWVfcmVzaXplX2NsaWNrXG4gKi9cblRpbWVSZXNpemUucHJvdG90eXBlLl9vbkNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kcmFnSGFuZGxlci5vZmYoe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBUaW1lUmVzaXplI3RpbWVfcmVzaXplX2NsaWNrXG4gICAgICovXG4gICAgdGhpcy5maXJlKCd0aW1lX3Jlc2l6ZV9jbGljaycpO1xufTtcblxudGltZUNvcmUubWl4aW4oVGltZVJlc2l6ZSk7XG51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihUaW1lUmVzaXplKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lUmVzaXplO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTW9kdWxlIGZvciBUaW1lLlJlc2l6ZSBlZmZlY3Qgd2hpbGUgZHJhZ2dpbmcuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWwgPSBnbG9iYWwudHVpLnV0aWw7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vY29uZmlnJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgcmVxQW5pbUZyYW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL3JlcUFuaW1GcmFtZScpO1xudmFyIHJhdGlvID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2NvbW1vbicpLnJhdGlvO1xuXG4vKipcbiAqIENsYXNzIGZvciBUaW1lLlJlc2l6ZSBlZmZlY3QuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VGltZVJlc2l6ZX0gdGltZVJlc2l6ZSAtIHRoZSBpbnN0YW5jZSBvZiBUaW1lUmVzaXplIGhhbmRsZXIuXG4gKi9cbmZ1bmN0aW9uIFRpbWVSZXNpemVHdWlkZSh0aW1lUmVzaXplKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZ3VpZGVFbGVtZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtUaW1lUmVzaXplfVxuICAgICAqL1xuICAgIHRoaXMudGltZVJlc2l6ZSA9IHRpbWVSZXNpemU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5fZ2V0VG9wRnVuYyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5fb3JpZ2luRXZlbnRFbGVtZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fc3RhcnRUb3BQaXhlbCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX3N0YXJ0SGVpZ2h0UGl4ZWwgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9zdGFydEdyaWRZID0gMDtcblxuICAgIHRpbWVSZXNpemUub24oe1xuICAgICAgICAndGltZV9yZXNpemVfZHJhZ3N0YXJ0JzogdGhpcy5fb25EcmFnU3RhcnQsXG4gICAgICAgICd0aW1lX3Jlc2l6ZV9kcmFnJzogdGhpcy5fb25EcmFnLFxuICAgICAgICAndGltZV9yZXNpemVfZHJhZ2VuZCc6IHRoaXMuX2NsZWFyR3VpZGVFbGVtZW50LFxuICAgICAgICAndGltZV9yZXNpemVfY2xpY2snOiB0aGlzLl9jbGVhckd1aWRlRWxlbWVudFxuICAgIH0sIHRoaXMpO1xufVxuXG4vKipcbiAqIERlc3Ryb3kgbWV0aG9kXG4gKi9cblRpbWVSZXNpemVHdWlkZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NsZWFyR3VpZGVFbGVtZW50KCk7XG4gICAgdGhpcy50aW1lUmVzaXplLm9mZih0aGlzKTtcbiAgICB0aGlzLmd1aWRlRWxlbWVudCA9IHRoaXMudGltZVJlc2l6ZSA9IHRoaXMuX2dldFRvcEZ1bmMgPVxuICAgICAgICB0aGlzLl9vcmlnaW5FdmVudEVsZW1lbnQgPSB0aGlzLl9zdGFydEhlaWdodFBpeGVsID1cbiAgICAgICAgdGhpcy5fc3RhcnRHcmlkWSA9IHRoaXMuX3N0YXJ0VG9wUGl4ZWwgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhciBndWlkZSBlbGVtZW50LlxuICovXG5UaW1lUmVzaXplR3VpZGUucHJvdG90eXBlLl9jbGVhckd1aWRlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBndWlkZUVsZW1lbnQgPSB0aGlzLmd1aWRlRWxlbWVudCxcbiAgICAgICAgb3JpZ2luRWxlbWVudCA9IHRoaXMuX29yaWdpbkV2ZW50RWxlbWVudDtcblxuICAgIGlmICghdXRpbC5icm93c2VyLm1zaWUpIHtcbiAgICAgICAgZG9tdXRpbC5yZW1vdmVDbGFzcyhnbG9iYWwuZG9jdW1lbnQuYm9keSwgY29uZmlnLmNsYXNzbmFtZSgncmVzaXppbmcnKSk7XG4gICAgfVxuXG4gICAgaWYgKG9yaWdpbkVsZW1lbnQpIHtcbiAgICAgICAgb3JpZ2luRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB9XG5cbiAgICBkb211dGlsLnJlbW92ZShndWlkZUVsZW1lbnQpO1xuXG4gICAgdGhpcy5ndWlkZUVsZW1lbnQgPSB0aGlzLl9nZXRUb3BGdW5jID0gdGhpcy5fb3JpZ2luRXZlbnRFbGVtZW50ID1cbiAgICAgICAgdGhpcy5fc3RhcnRIZWlnaHRQaXhlbCA9IHRoaXMuX3N0YXJ0R3JpZFkgPSB0aGlzLl9zdGFydFRvcFBpeGVsID0gbnVsbDtcbn07XG5cbi8qKlxuICogUmVmcmVzaCBndWlkZSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gaGVpZ2h0IC0gZ3VpZGUgZWxlbWVudCdzIHN0eWxlIGhlaWdodC5cbiAqL1xuVGltZVJlc2l6ZUd1aWRlLnByb3RvdHlwZS5fcmVmcmVzaEd1aWRlRWxlbWVudCA9IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgIHZhciBndWlkZUVsZW1lbnQgPSB0aGlzLmd1aWRlRWxlbWVudDtcblxuICAgIGlmICghZ3VpZGVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXFBbmltRnJhbWUucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgZ3VpZGVFbGVtZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgIGd1aWRlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB9KTtcbn07XG5cblxuLyoqXG4gKiBUaW1lTW92ZSN0aW1lX21vdmVfZHJhZ3N0YXJ0IGV2ZW50IGhhbmRsZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnU3RhcnRFdmVudERhdGEgLSBkcmFnc3RhcnQgZXZlbnQgZGF0YVxuICovXG5UaW1lUmVzaXplR3VpZGUucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGRyYWdTdGFydEV2ZW50RGF0YSkge1xuICAgIHZhciBvcmlnaW5FbGVtZW50ID0gZG9tdXRpbC5jbG9zZXN0KFxuICAgICAgICAgICAgZHJhZ1N0YXJ0RXZlbnREYXRhLnRhcmdldCxcbiAgICAgICAgICAgICcuJyArIGNvbmZpZy5jbGFzc25hbWUoJ3RpbWUtZGF0ZS1ldmVudC1ibG9jaycpXG4gICAgICAgICksXG4gICAgICAgIGd1aWRlRWxlbWVudDtcblxuICAgIGlmICghdXRpbC5icm93c2VyLm1zaWUpIHtcbiAgICAgICAgZG9tdXRpbC5hZGRDbGFzcyhnbG9iYWwuZG9jdW1lbnQuYm9keSwgY29uZmlnLmNsYXNzbmFtZSgncmVzaXppbmcnKSk7XG4gICAgfVxuXG4gICAgaWYgKCFvcmlnaW5FbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGFydEdyaWRZID0gZHJhZ1N0YXJ0RXZlbnREYXRhLm5lYXJlc3RHcmlkWTtcbiAgICB0aGlzLl9zdGFydEhlaWdodFBpeGVsID0gcGFyc2VGbG9hdChvcmlnaW5FbGVtZW50LnN0eWxlLmhlaWdodCk7XG4gICAgdGhpcy5fc3RhcnRUb3BQaXhlbCA9IHBhcnNlRmxvYXQob3JpZ2luRWxlbWVudC5zdHlsZS50b3ApO1xuXG4gICAgdGhpcy5fb3JpZ2luRXZlbnRFbGVtZW50ID0gb3JpZ2luRWxlbWVudDtcbiAgICBndWlkZUVsZW1lbnQgPSB0aGlzLmd1aWRlRWxlbWVudCA9IG9yaWdpbkVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xuICAgIGRvbXV0aWwuYWRkQ2xhc3MoZ3VpZGVFbGVtZW50LCBjb25maWcuY2xhc3NuYW1lKCd0aW1lLWd1aWRlLXJlc2l6ZScpKTtcblxuICAgIG9yaWdpbkVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBkcmFnU3RhcnRFdmVudERhdGEucmVsYXRlZFZpZXcuY29udGFpbmVyLmFwcGVuZENoaWxkKGd1aWRlRWxlbWVudCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnRXZlbnREYXRhIC0gZXZlbnQgZGF0YSBmcm9tIERyYWcjZHJhZy5cbiAqL1xuVGltZVJlc2l6ZUd1aWRlLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24oZHJhZ0V2ZW50RGF0YSkge1xuICAgIHZhciB0aW1lVmlldyA9IGRyYWdFdmVudERhdGEucmVsYXRlZFZpZXcsXG4gICAgICAgIHZpZXdPcHRpb25zID0gdGltZVZpZXcub3B0aW9ucyxcbiAgICAgICAgdmlld0hlaWdodCA9IHRpbWVWaWV3LmdldFZpZXdCb3VuZCgpLmhlaWdodCxcbiAgICAgICAgaG91ckxlbmd0aCA9IHZpZXdPcHRpb25zLmhvdXJFbmQgLSB2aWV3T3B0aW9ucy5ob3VyU3RhcnQsXG4gICAgICAgIGd1aWRlRWxlbWVudCA9IHRoaXMuZ3VpZGVFbGVtZW50LFxuICAgICAgICBndWlkZVRvcCA9IHBhcnNlRmxvYXQoZ3VpZGVFbGVtZW50LnN0eWxlLnRvcCksXG4gICAgICAgIGdyaWRZT2Zmc2V0ID0gZHJhZ0V2ZW50RGF0YS5uZWFyZXN0R3JpZFkgLSB0aGlzLl9zdGFydEdyaWRZLFxuICAgICAgICAvLyBob3VyTGVuZ3RoIDogdmlld0hlaWdodCA9IGdyaWRZT2Zmc2V0IDogWDtcbiAgICAgICAgZ3JpZFlPZmZzZXRQaXhlbCA9IHJhdGlvKGhvdXJMZW5ndGgsIHZpZXdIZWlnaHQsIGdyaWRZT2Zmc2V0KSxcbiAgICAgICAgbWluSGVpZ2h0LFxuICAgICAgICBtYXhIZWlnaHQsXG4gICAgICAgIGhlaWdodDtcblxuICAgIGhlaWdodCA9ICh0aGlzLl9zdGFydEhlaWdodFBpeGVsICsgZ3JpZFlPZmZzZXRQaXhlbCk7XG4gICAgLy8gYXQgbGVhc3QgbGFyZ2UgdGhhbiAzMG1pbiBmcm9tIGV2ZW50IHN0YXJ0IHRpbWUuXG4gICAgbWluSGVpZ2h0ID0gZ3VpZGVUb3AgKyByYXRpbyhob3VyTGVuZ3RoLCB2aWV3SGVpZ2h0LCAwLjUpO1xuICAgIG1pbkhlaWdodCAtPSB0aGlzLl9zdGFydFRvcFBpeGVsO1xuICAgIC8vIHNtYWxsZXIgdGhhbiAyNGhcbiAgICBtYXhIZWlnaHQgPSB2aWV3SGVpZ2h0IC0gZ3VpZGVUb3A7XG5cbiAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIG1pbkhlaWdodCk7XG4gICAgaGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0LCBtYXhIZWlnaHQpO1xuXG4gICAgdGhpcy5fcmVmcmVzaEd1aWRlRWxlbWVudChoZWlnaHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lUmVzaXplR3VpZGU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBNb2RlbCBvZiBldmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLnR1aS51dGlsO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgZGlydHkgPSByZXF1aXJlKCcuLi9jb21tb24vZGlydHknKTtcbnZhciBtb2RlbCA9IHJlcXVpcmUoJy4uL2NvbW1vbi9tb2RlbCcpO1xuXG4vKipcbiAqIFRoZSBtb2RlbCBvZiBjYWxlbmRhciBldmVudHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBtaXhlcyBkaXJ0eVxuICogQG1peGVzIG1vZGVsXG4gKi9cbmZ1bmN0aW9uIENhbEV2ZW50KCkge1xuICAgIC8qKlxuICAgICAqIGBPcHRpb25hbGAgdW5pcXVlIGlkIGZvciB2YXJpb3VzIHVzZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSAnJztcblxuICAgIC8qKlxuICAgICAqIHRpdGxlIGZvciBldmVudC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudGl0bGUgPSAnJztcblxuICAgIC8qKlxuICAgICAqIGlzIGV2ZW50IGlzIGFsbCBkYXkgZXZlbnQ/XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc0FsbERheSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogZXZlbnQgc3RhcnRzXG4gICAgICogQHR5cGUge0RhdGV9XG4gICAgICovXG4gICAgdGhpcy5zdGFydHMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogZXZlbnQgZW5kc1xuICAgICAqIEB0eXBlIHtEYXRlfVxuICAgICAqL1xuICAgIHRoaXMuZW5kcyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBldmVudCB0ZXh0IGNvbG9yXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNvbG9yID0gJyMwMDAnO1xuXG4gICAgLyoqXG4gICAgICogZXZlbnQgYmFja2dyb3VuZCBjb2xvclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5iZ0NvbG9yID0gJyNhMWI1NmMnO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBtb2RlbCBpZFxuICAgIHV0aWwuc3RhbXAodGhpcyk7XG59XG5cbi8qKioqKioqKioqXG4gKiBzdGF0aWMgcHJvcHNcbiAqKioqKioqKioqL1xuXG5DYWxFdmVudC5zY2hlbWEgPSB7XG4gICAgcmVxdWlyZWQ6IFsndGl0bGUnXSxcbiAgICBkYXRlUmFuZ2U6IFsnc3RhcnRzJywgJ2VuZHMnXVxufTtcblxuLyoqXG4gKiBjcmVhdGUgZXZlbnQgbW9kZWwgZnJvbSBqc29uKG9iamVjdCkgZGF0YS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIG9iamVjdCBmb3IgbW9kZWwuXG4gKiBAcmV0dXJucyB7Q2FsRXZlbnR9IENhbEV2ZW50IG1vZGVsIGluc3RhbmNlLlxuICovXG5DYWxFdmVudC5jcmVhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIGluc3QgPSBuZXcgQ2FsRXZlbnQoKTtcbiAgICBpbnN0LmluaXQoZGF0YSk7XG5cbiAgICByZXR1cm4gaW5zdDtcbn07XG5cbi8qKioqKioqKioqXG4gKiBwcm90b3R5cGUgcHJvcHNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIEluaXRpYWxpemUgZXZlbnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBvcHRpb25zLlxuICovXG5DYWxFdmVudC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkIHx8ICcnO1xuICAgIHRoaXMudGl0bGUgPSBvcHRpb25zLnRpdGxlIHx8ICcnO1xuICAgIHRoaXMuaXNBbGxEYXkgPSB1dGlsLmlzRXhpc3R5KG9wdGlvbnMuaXNBbGxEYXkpID8gb3B0aW9ucy5pc0FsbERheSA6IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnRzKSB7XG4gICAgICAgIHRoaXMuc3RhcnRzID0gbmV3IERhdGUob3B0aW9ucy5zdGFydHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnRzID0gbmV3IERhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5lbmRzKSB7XG4gICAgICAgIHRoaXMuZW5kcyA9IG5ldyBEYXRlKG9wdGlvbnMuZW5kcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbmRzID0gbmV3IERhdGUodGhpcy5zdGFydHMuZ2V0VGltZSgpKTtcbiAgICAgICAgdGhpcy5lbmRzLnNldE1pbnV0ZXModGhpcy5lbmRzLmdldE1pbnV0ZXMoKSArIDMwKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbG9yID0gb3B0aW9ucy5jb2xvciB8fCB0aGlzLmNvbG9yO1xuICAgIHRoaXMuYmdDb2xvciA9IG9wdGlvbnMuYmdDb2xvciB8fCB0aGlzLmJnQ29sb3I7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtEYXRlfSByZW5kZXIgc3RhcnQgZGF0ZS5cbiAqL1xuQ2FsRXZlbnQucHJvdG90eXBlLmdldFN0YXJ0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0cztcbn07XG5cbi8qKlxuICogQHJldHVybnMge0RhdGV9IHJlbmRlciBlbmQgZGF0ZS5cbiAqL1xuQ2FsRXZlbnQucHJvdG90eXBlLmdldEVuZHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lbmRzO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBpbnN0YW5jZSB1bmlxdWUgaWQuXG4gKi9cbkNhbEV2ZW50LnByb3RvdHlwZS5jaWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdXRpbC5zdGFtcCh0aGlzKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdHdvIGV2ZW50IGFyZSBlcXVhbHMgKG1lYW5zIHRpdGxlLCBpc0FsbERheSwgc3RhcnRzLCBlbmRzIGFyZSBzYW1lKVxuICogQHBhcmFtIHtDYWxFdmVudH0gZXZlbnQgQ2FsRXZlbnQgbW9kZWwgaW5zdGFuY2UgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm4gZmFsc2Ugd2hlbiBub3Qgc2FtZS5cbiAqL1xuQ2FsRXZlbnQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuaWQgIT09IGV2ZW50LmlkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50aXRsZSAhPT0gZXZlbnQudGl0bGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzQWxsRGF5ICE9PSBldmVudC5pc0FsbERheSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGRhdGV0aW1lLmNvbXBhcmUodGhpcy5nZXRTdGFydHMoKSwgZXZlbnQuZ2V0U3RhcnRzKCkpICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0ZXRpbWUuY29tcGFyZSh0aGlzLmdldEVuZHMoKSwgZXZlbnQuZ2V0RW5kcygpKSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29sb3IgIT09IGV2ZW50LmNvbG9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iZ0NvbG9yICE9PSBldmVudC5iZ0NvbG9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogcmV0dXJuIGR1cmF0aW9uIGJldHdlZW4gc3RhcnRzIGFuZCBlbmRzLlxuICogQHJldHVybnMge0RhdGV9IGR1cmF0aW9uIChVVEMpXG4gKi9cbkNhbEV2ZW50LnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFydHMgPSB0aGlzLmdldFN0YXJ0cygpLFxuICAgICAgICBlbmRzID0gdGhpcy5nZXRFbmRzKCksXG4gICAgICAgIGR1cmF0aW9uO1xuXG4gICAgaWYgKHRoaXMuaXNBbGxEYXkpIHtcbiAgICAgICAgZHVyYXRpb24gPSBuZXcgRGF0ZShkYXRldGltZS5lbmQoZW5kcykgLSBkYXRldGltZS5zdGFydChzdGFydHMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkdXJhdGlvbiA9IG5ldyBEYXRlKGVuZHMgLSBzdGFydHMpO1xuICAgIH1cblxuICAgIHJldHVybiBkdXJhdGlvbjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBDYWxFdmVudCBjb2luY2lkZXMgd2l0aCB0aGUgc2FtZSB0aW1lIGFzIHRoZVxuICogY2FsbGluZyBDYWxFdmVudC5cbiAqIEBwYXJhbSB7Q2FsRXZlbnR9IGV2ZW50IFRoZSBvdGhlciBldmVudCB0byBjb21wYXJlIHdpdGggdGhpcyBDYWxFdmVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBJZiB0aGUgb3RoZXIgZXZlbnQgb2NjdXJzIHdpdGhpbiB0aGUgc2FtZSB0aW1lIGFzIHRoZSBmaXJzdCBvYmplY3QuXG4gKi9cbkNhbEV2ZW50LnByb3RvdHlwZS5jb2xsaWRlc1dpdGggPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBvd25TdGFydHMgPSB0aGlzLmdldFN0YXJ0cygpLFxuICAgICAgICBvd25FbmRzID0gdGhpcy5nZXRFbmRzKCksXG4gICAgICAgIHN0YXJ0cyA9IGV2ZW50LmdldFN0YXJ0cygpLFxuICAgICAgICBlbmRzID0gZXZlbnQuZ2V0RW5kcygpO1xuXG4gICAgaWYgKChzdGFydHMgPiBvd25TdGFydHMgJiYgc3RhcnRzIDwgb3duRW5kcykgfHxcbiAgICAgICAgKGVuZHMgPiBvd25TdGFydHMgJiYgZW5kcyA8IG93bkVuZHMpIHx8XG4gICAgICAgIChzdGFydHMgPD0gb3duU3RhcnRzICYmIGVuZHMgPj0gb3duRW5kcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbm1vZGVsLm1peGluKENhbEV2ZW50LnByb3RvdHlwZSk7XG5kaXJ0eS5taXhpbihDYWxFdmVudC5wcm90b3R5cGUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbEV2ZW50O1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTW9kZWwgZm9yIHZpZXdzXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC50dWkudXRpbDtcblxuLyoqXG4gKiBDYWxFdmVudCBWaWV3TW9kZWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtDYWxFdmVudH0gZXZlbnQgQ2FsRXZlbnQgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIENhbEV2ZW50Vmlld01vZGVsKGV2ZW50KSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGVsIG9mIGV2ZW50LlxuICAgICAqIEB0eXBlIHtDYWxFdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLm1vZGVsID0gZXZlbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudG9wID0gMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZWZ0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudCBldmVudCBoYXMgY29sbGlkZSB3aXRoIG90aGVyIGV2ZW50cyB3aGVuIHJlbmRlcmluZy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmhhc0NvbGxpZGUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEV4dHJhIHNwYWNlIGF0IHJpZ3RoIHNpZGUgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZXh0cmFTcGFjZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiByZXByZXNlbnQgdGhpcyBldmVudCBibG9jayBpcyBub3QgdmlzaWJsZSBhZnRlciByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIGluIG1vbnRoIHZpZXcsIHNvbWUgdmlld21vZGVsIGluIGRhdGUgbmVlZCB0byBoaWRlIHdoZW4gYWxyZWFkeSByZW5kZXJlZCBiZWZvcmUgZGF0ZXMuXG4gICAgICpcbiAgICAgKiBzZXQgdHJ1ZSB0aGVuIGl0IGp1c3Qgc2hvd3MgZW1wdHkgc3BhY2UuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIHJlcHJlc2VudCByZW5kZXIgc3RhcnQgZGF0ZSB1c2VkIGF0IHJlbmRlcmluZy5cbiAgICAgKlxuICAgICAqIGlmIHNldCBudWxsIHRoZW4gdXNlIG1vZGVsJ3MgJ3N0YXJ0cycgcHJvcGVydHkuXG4gICAgICogQHR5cGUge0RhdGV9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJTdGFydHMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogcmVwcmVzZW50IHJlbmRlciBlbmQgZGF0ZSB1c2VkIGF0IHJlbmRlcmluZy5cbiAgICAgKlxuICAgICAqIGlmIHNldCBudWxsIHRoZW4gdXNlIG1vZGVsJ3MgJ2VuZHMnIHByb3BlcnR5LlxuICAgICAqIEB0eXBlIHtEYXRlfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyRW5kcyA9IG51bGw7XG59XG5cbi8qKioqKioqKioqXG4gKiBzdGF0aWMgcHJvcHNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIENhbEV2ZW50Vmlld01vZGVsIGZhY3RvcnkgbWV0aG9kLlxuICogQHBhcmFtIHtDYWxFdmVudH0gZXZlbnQgQ2FsRXZlbnQgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7Q2FsRXZlbnRWaWV3TW9kZWx9IENhbEV2ZW50Vmlld01vZGVsIGluc3RhbmNlLlxuICovXG5DYWxFdmVudFZpZXdNb2RlbC5jcmVhdGUgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiBuZXcgQ2FsRXZlbnRWaWV3TW9kZWwoZXZlbnQpO1xufTtcblxuXG4vKioqKioqKioqKlxuICogcHJvdG90eXBlIHByb3BzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiByZXR1cm4gcmVuZGVyU3RhcnRzIHByb3BlcnR5IHRvIHJlbmRlciBwcm9wZXJseSB3aGVuIHNwZWNpZmljIGV2ZW50IHRoYXQgZXhjZWVkIHJlbmRlcmluZyBkYXRlIHJhbmdlLlxuICpcbiAqIGlmIHJlbmRlclN0YXJ0cyBpcyBub3Qgc2V0LiByZXR1cm4gbW9kZWwncyBzdGFydHMgcHJvcGVydHkuXG4gKiBAb3ZlcnJpZGVcbiAqIEByZXR1cm5zIHtEYXRlfSByZW5kZXIgc3RhcnQgZGF0ZS5cbiAqL1xuQ2FsRXZlbnRWaWV3TW9kZWwucHJvdG90eXBlLmdldFN0YXJ0cyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnJlbmRlclN0YXJ0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJTdGFydHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubW9kZWwuc3RhcnRzO1xufTtcblxuLyoqXG4gKiByZXR1cm4gcmVuZGVyU3RhcnRzIHByb3BlcnR5IHRvIHJlbmRlciBwcm9wZXJseSB3aGVuIHNwZWNpZmljIGV2ZW50IHRoYXQgZXhjZWVkIHJlbmRlcmluZyBkYXRlIHJhbmdlLlxuICpcbiAqIGlmIHJlbmRlckVuZHMgaXMgbm90IHNldC4gcmV0dXJuIG1vZGVsJ3MgZW5kcyBwcm9wZXJ0eS5cbiAqIEBvdmVycmlkZVxuICogQHJldHVybnMge0RhdGV9IHJlbmRlciBlbmQgZGF0ZS5cbiAqL1xuQ2FsRXZlbnRWaWV3TW9kZWwucHJvdG90eXBlLmdldEVuZHMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJFbmRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckVuZHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubW9kZWwuZW5kcztcbn07XG5cbi8qKlxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlIG51bWJlciBmb3IgbW9kZWwuXG4gKi9cbkNhbEV2ZW50Vmlld01vZGVsLnByb3RvdHlwZS5jaWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdXRpbC5zdGFtcCh0aGlzLm1vZGVsKTtcbn07XG5cbi8qKlxuICogU2hhZG93aW5nIHZhbHVlT2YgbWV0aG9kIGZvciBldmVudCBzb3J0aW5nLlxuICogQHJldHVybnMge0NhbEV2ZW50fSBUaGUgbW9kZWwgb2YgZXZlbnQuXG4gKi9cbkNhbEV2ZW50Vmlld01vZGVsLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZWw7XG59O1xuXG4vKipcbiAqIExpbmsgZHVyYXRpb24gbWV0aG9kXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBDYWxFdmVudCNkdXJhdGlvbiByZXN1bHQuXG4gKi9cbkNhbEV2ZW50Vmlld01vZGVsLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1vZGVsLmR1cmF0aW9uKCk7XG59O1xuXG4vKipcbiAqIExpbmsgY29sbGlkZXNXaXRoIG1ldGhvZFxuICogQHBhcmFtIHtDYWxFdmVudHxDYWxFdmVudFZpZXdNb2RlbH0gdmlld01vZGVsIC0gTW9kZWwgb3Igdmlld21vZGVsIGluc3RhbmNlIG9mIENhbEV2ZW50cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBDYWxFdmVudCNjb2xsaWRlc1dpdGggcmVzdWx0LlxuICovXG5DYWxFdmVudFZpZXdNb2RlbC5wcm90b3R5cGUuY29sbGlkZXNXaXRoID0gZnVuY3Rpb24odmlld01vZGVsKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZWwuY29sbGlkZXNXaXRoKHZpZXdNb2RlbC52YWx1ZU9mKCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYWxFdmVudFZpZXdNb2RlbDtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IExheW91dCB2aWV3LiB3cmFwIGFsbCB2aWV3IGNvbnRhaW5lcnMgYXQgb3V0c2lkZS5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLnR1aS51dGlsO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9jb21tb24vY29sbGVjdGlvbicpO1xudmFyIFZpZXcgPSByZXF1aXJlKCcuL3ZpZXcnKTtcblxuLyoqXG4gKiBMYXlvdXQgdmlldyBmb3IgdG9nZ2xlIGVhY2ggY2hpbGQgdmlldy4gSXQgd2lsbCBjb250cm9sbGVkIHZpYSBuYXZpZ2F0aW9uIFVJLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7Vmlld31cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBDb250YWluZXIgZWxlbWVudCB0byB1c2UgbGF5b3V0IHZpZXcuXG4gKi9cbmZ1bmN0aW9uIExheW91dChjb250YWluZXIpIHtcbiAgICBjb250YWluZXIgPSBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KCdkaXYnLCBjb250YWluZXIsIGNvbmZpZy5jbGFzc25hbWUoJ2xheW91dCcpKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICAgIC8qZXNsaW50LWRpc2FibGUqL1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9ufSBDaGlsZCB2aWV3IGNvbGxlY3Rpb24uXG4gICAgICovXG4gICAgdGhpcy5jaGlsZHMgPSBuZXcgQ29sbGVjdGlvbihmdW5jdGlvbihjaGlsZFZpZXcpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkVmlldy52aWV3TmFtZTtcbiAgICB9KTtcbiAgICAvKmVzbGludC1lbmFibGUqL1xufVxuXG51dGlsLmluaGVyaXQoTGF5b3V0LCBWaWV3KTtcblxuLyoqXG4gKiBDbGVhciBjaGlsZCB2aWV3cy5cbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2hpbGRzLmVhY2goZnVuY3Rpb24oY2hpbGRWaWV3KSB7XG4gICAgICAgIGNoaWxkVmlldy5kZXN0cm95KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmNoaWxkcy5jbGVhcigpO1xuICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgY2hpbGQgdmlldy5cbiAqIEBvdmVycmlkZVxuICogQHBhcmFtIHsoc3RyaW5nfFZpZXcpfSB2aWV3TmFtZSAtIG5hbWUgb2YgdmlldyBvciBpbnN0YW5jZS5cbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uKHZpZXdOYW1lKSB7XG4gICAgdGhpcy5jaGlsZHMucmVtb3ZlKHZpZXdOYW1lKTtcbn07XG5cbi8qKlxuICogVG9nZ2xlIGNoaWxkIHZpZXdzLlxuICogQHBhcmFtIHtzdHJpbmd9IHZpZXdOYW1lIC0gTmFtZSBvZiB2aWV3LlxuICovXG5MYXlvdXQucHJvdG90eXBlLnRvZ2dsZUNoaWxkVmlldyA9IGZ1bmN0aW9uKHZpZXdOYW1lKSB7XG4gICAgdmFyIGNvbnRhaW5lcixcbiAgICAgICAgcHJlZml4ID0gWydhZGQnLCAncmVtb3ZlJ10sXG4gICAgICAgIGZsYWc7XG5cbiAgICB0aGlzLmNoaWxkcy5lYWNoKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICBjb250YWluZXIgPSBjaGlsZFZpZXcuY29udGFpbmVyO1xuICAgICAgICBmbGFnID0gKyhjaGlsZFZpZXcudmlld05hbWUgPT09IHZpZXdOYW1lKTtcbiAgICAgICAgZG9tdXRpbFtwcmVmaXhbZmxhZ10gKyAnQ2xhc3MnXShjb250YWluZXIsIGNvbmZpZy5jbGFzc25hbWUoJ2hpZGRlbicpKTtcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGF5b3V0O1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVmlldyBvZiB3ZWVrIGV2ZW50IGNvbnRhaW5lciBpbnNpZGUgb2YgV2VlayB2aWV3LlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwudHVpLnV0aWw7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBWaWV3ID0gcmVxdWlyZSgnLi92aWV3Jyk7XG52YXIgdG1wbCA9IHJlcXVpcmUoJy4vdGVtcGxhdGUvbW9udGh3ZWVrLmhicycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge1ZpZXd9XG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIHZpZXcgb3B0aW9ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb250YWluZXJIZWlnaHQ9NDBdIC0gbWluaW11bSBoZWlnaHQgb2YgZXZlbnQgY29udGFpbmVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29udGFpbmVyQnV0dG9uR3V0dGVyPThdIC0gZnJlZSBzcGFjZSBhdCBib3R0b20gdG8gbWFrZSBjcmVhdGUgZWFzeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5ldmVudEhlaWdodD0xOF0gLSBoZWlnaHQgb2YgZWFjaCBldmVudCBibG9jay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5ldmVudEd1dHRlcj0yXSAtIGd1dHRlciBoZWlnaHQgb2YgZWFjaCBldmVudCBibG9jay5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLl9nZXRWaWV3TW9kZWxGdW5jXSAtIGZ1bmN0aW9uIGZvciBleHRyYWN0IHBhcnRpYWwgdmlldyBtb2RlbCBkYXRhIGZyb20gd2hvbGUgdmlldyBtb2RlbHMuXG4gKiBAcGFyYW0ge0hUTUxESVZFbGVtZW50fSBjb250YWluZXIgLSBET00gZWxlbWVudCB0byB1c2UgY29udGFpbmVyIGZvciB0aGlzIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIE1vbnRoV2VlayhvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICBjb250YWluZXIgPSBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBjb25maWcuY2xhc3NuYW1lKCdhbGxkYXktbW9udGh3ZWVrJylcbiAgICApO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICBjb250YWluZXJIZWlnaHQ6IDQwLFxuICAgICAgICBjb250YWluZXJCb3R0b21HdXR0ZXI6IDgsXG4gICAgICAgIGV2ZW50SGVpZ2h0OiAxOCxcbiAgICAgICAgZXZlbnRHdXR0ZXI6IDJcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIG9wdGlvbnMubWluSGVpZ2h0ID0gb3B0aW9ucy5jb250YWluZXJIZWlnaHQgKyBvcHRpb25zLmNvbnRhaW5lckJvdHRvbUd1dHRlcjtcblxuICAgIFZpZXcuY2FsbCh0aGlzLCBjb250YWluZXIpO1xufVxuXG51dGlsLmluaGVyaXQoTW9udGhXZWVrLCBWaWV3KTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gdmlld01vZGVsIC0gdmlld01vZGVsIGZyb20gcGFyZW50IHZpZXdzLlxuICogQHJldHVybnMge29iamVjdH0gdmlld01vZGVsIHRvIHJlbmRlcmluZy5cbiAqL1xuTW9udGhXZWVrLnByb3RvdHlwZS5fZ2V0QmFzZVZpZXdNb2RlbCA9IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICByYW5nZSA9IGRhdGV0aW1lLnJhbmdlKFxuICAgICAgICAgICAgdmlld01vZGVsLnJlbmRlclN0YXJ0RGF0ZSxcbiAgICAgICAgICAgIHZpZXdNb2RlbC5yZW5kZXJFbmREYXRlLFxuICAgICAgICAgICAgZGF0ZXRpbWUuTUlMTElTRUNPTkRTX1BFUl9EQVlcbiAgICAgICAgKSxcbiAgICAgICAgbWF0cmljZXMgPSBvcHRpb25zLl9nZXRWaWV3TW9kZWxGdW5jKHZpZXdNb2RlbCksXG4gICAgICAgIHdpZHRoUGVyY2VudCA9IDEwMCAvIHJhbmdlLmxlbmd0aDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB3aWR0aFBlcmNlbnQsXG4gICAgICAgIGhlaWdodDogb3B0aW9ucy5jb250YWluZXJIZWlnaHQsXG4gICAgICAgIGV2ZW50QmxvY2tIZWlnaHQ6IG9wdGlvbnMuZXZlbnRIZWlnaHQgKyBvcHRpb25zLmV2ZW50R3V0dGVyLFxuICAgICAgICBldmVudEJsb2NrR3V0dGVyOiBvcHRpb25zLmV2ZW50R3V0dGVyLFxuICAgICAgICBldmVudEhlaWdodDogb3B0aW9ucy5ldmVudEhlaWdodCxcbiAgICAgICAgZXZlbnRHcmlkOiB1dGlsLm1hcChyYW5nZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gd2lkdGhQZXJjZW50O1xuICAgICAgICB9KSxcbiAgICAgICAgbWF0cmljZXM6IG1hdHJpY2VzXG4gICAgfTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKiBAcGFyYW0ge29iamVjdH0gdmlld01vZGVsIC0gdmlld01vZGVsIGZyb20gcGFyZW50IHZpZXdzLlxuICovXG5Nb250aFdlZWsucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgIHZhciBiYXNlVmlld01vZGVsID0gdGhpcy5fZ2V0QmFzZVZpZXdNb2RlbCh2aWV3TW9kZWwpLFxuICAgICAgICBtYXhFdmVudEluRGF5ID0gMDtcblxuICAgIG1heEV2ZW50SW5EYXkgPSBNYXRoLm1heC5hcHBseShudWxsLCB1dGlsLm1hcChiYXNlVmlld01vZGVsLm1hdHJpY2VzLCBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIHV0aWwubWFwKG1hdHJpeCwgZnVuY3Rpb24ocm93KSB7XG4gICAgICAgICAgICByZXR1cm4gcm93Lmxlbmd0aDtcbiAgICAgICAgfSkpO1xuICAgIH0pKTtcblxuICAgIHRoaXMucmVzaXplKG1heEV2ZW50SW5EYXkpO1xuXG4gICAgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gdG1wbChiYXNlVmlld01vZGVsKTtcbn07XG5cbi8qKlxuICogUmVzaXplIE1vbnRoV2VlayBjb250YWluZXIgYW5kIHNlbmQgaW5mb3JtYXRpb24gdG8gcGFyZW50IHZpZXdzLlxuICogQG92ZXJyaWRlXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RXZlbnRJbkRheSAtIGhvdyBsYXJnZXN0IGV2ZW50IGJsb2NrIGluIG9uZSBkYXk/XG4gKi9cbk1vbnRoV2Vlay5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24obWF4RXZlbnRJbkRheSkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBuZXdIZWlnaHQgPSAobWF4RXZlbnRJbkRheSAqIChvcHRpb25zLmV2ZW50SGVpZ2h0ICsgb3B0aW9ucy5ldmVudEd1dHRlcikpICsgb3B0aW9ucy5jb250YWluZXJCb3R0b21HdXR0ZXI7XG5cbiAgICBuZXdIZWlnaHQgPSBNYXRoLm1heChuZXdIZWlnaHQsIG9wdGlvbnMubWluSGVpZ2h0KTtcbiAgICBcbiAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBuZXdIZWlnaHQgKyAncHgnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb250aFdlZWs7XG5cbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZSh7XCJjb21waWxlclwiOls3LFwiPj0gNC4wLjBcIl0sXCJtYWluXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgaGVscGVyLCBhbGlhczE9ZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSwgYWxpYXMyPWhlbHBlcnMuaGVscGVyTWlzc2luZywgYWxpYXMzPVwiZnVuY3Rpb25cIiwgYWxpYXM0PWNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uO1xuXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcInNjcm9sbC15IFwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcImRheW5hbWUtbGF5b3V0XFxcIj48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJzY3JvbGwteSBcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJhbGxkYXktbGF5b3V0XFxcIj48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJ0aW1lZ3JpZC1sYXlvdXRcXFwiPjwvZGl2PlxcblwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgSGVscGVycyBmb3IgaGFuZGxlYmFyIHRlbXBsYXRlcy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLnR1aS51dGlsO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9jb21tb24nKTtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi8uLi9jb25maWcnKTtcblxuZnVuY3Rpb24gZ2V0RWxTaXplKHZhbHVlLCBwb3N0Zml4LCBwcmVmaXgpIHtcbiAgICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG4gICAgaWYgKHV0aWwuaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnOicgKyB2YWx1ZSArIHBvc3RmaXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZpeCArICc6YXV0byc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdzdGFtcCc6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gdXRpbC5zdGFtcChvYmopO1xuICAgIH0sXG5cbiAgICAnZXF1YWwnOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhID09PSBiO1xuICAgIH0sXG5cbiAgICAnb3InOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIHx8IGI7XG4gICAgfSxcblxuICAgICdmaSc6IGZ1bmN0aW9uKGEsIG9wZXIsIGIsIG9wdGlvbnMpIHtcbiAgICAgICAgc3dpdGNoIChvcGVyKSB7XG4gICAgICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhID09IGIpID8gb3B0aW9ucy5mbih0aGlzKSA6IG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICAgICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICAoYSA9PT0gYikgPyBvcHRpb25zLmZuKHRoaXMpIDogb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnY29tbW9uLXdpZHRoJzogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIGdldEVsU2l6ZSh3aWR0aCwgJyUnLCAnd2lkdGgnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXNlIGluIHRpbWUuaGJzXG4gICAgICogQHBhcmFtIHtDYWxFdmVudFZpZXdNb2RlbH0gZXZlbnRWaWV3TW9kZWwgdmlld01vZGVsXG4gICAgICogQHJldHVybnMge3N0cmluZ30gZWxlbWVudCBzaXplIGNzcyBjbGFzc1xuICAgICAqL1xuICAgICd0aW1lLWV2ZW50QmxvY2snOiBmdW5jdGlvbihldmVudFZpZXdNb2RlbCkge1xuICAgICAgICB2YXIgdG9wID0gZ2V0RWxTaXplKGV2ZW50Vmlld01vZGVsLnRvcCwgJ3B4JywgJ3RvcCcpLFxuICAgICAgICAgICAgbGVmdCA9IGdldEVsU2l6ZShldmVudFZpZXdNb2RlbC5sZWZ0LCAnJScsICdsZWZ0JyksXG4gICAgICAgICAgICB3aWR0aCA9IGdldEVsU2l6ZShldmVudFZpZXdNb2RlbC53aWR0aCwgJyUnLCAnd2lkdGgnKSxcbiAgICAgICAgICAgIGhlaWdodCA9IGdldEVsU2l6ZShldmVudFZpZXdNb2RlbC5oZWlnaHQsICdweCcsICdoZWlnaHQnKTtcblxuICAgICAgICByZXR1cm4gW3RvcCwgbGVmdCwgd2lkdGgsIGhlaWdodF0uam9pbignOycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2UgaW4gZGF5bmFtZS5oYnNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjc3MgY2xhc3NcbiAgICAgKi9cbiAgICAnZGF5bmFtZS1pc0hvbGxpZGF5JzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRheSA9PT0gMCB8fCB0aGlzLmRheSA9PT0gNikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5jbGFzc25hbWUoJ2RheW5hbWUnKSArICcgJyArIGNvbmZpZy5jbGFzc25hbWUoJ2hvbGxpZGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnLmNsYXNzbmFtZSgnZGF5bmFtZScpO1xuICAgIH0sXG5cbiAgICAnbXVsdGlwbHknOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhICogYjtcbiAgICB9LFxuXG4gICAgJ0NTU19QUkVGSVgnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5jc3NQcmVmaXg7XG4gICAgfSxcblxuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiBEZWZhdWx0IGV2ZW50IHRlbXBsYXRlXG4gICAgICoqKioqKioqKiovXG5cbiAgICAnbWlsZXN0b25lLXRtcGwnOiBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwiJyArIGNvbmZpZy5jbGFzc25hbWUoJ2RvdCcpICsgJ1wiIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonICsgbW9kZWwuYmdDb2xvciArICdcIj48L3NwYW4+ICcgKyBjb21tb24uc3RyaXBUYWdzKG1vZGVsLnRpdGxlKTtcbiAgICB9LFxuXG4gICAgJ3Rhc2stdG1wbCc6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCInICsgY29uZmlnLmNsYXNzbmFtZSgnZG90JykgKyAnXCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicgKyBtb2RlbC5iZ0NvbG9yICsgJ1wiPjwvc3Bhbj4gJyArIGNvbW1vbi5zdHJpcFRhZ3MobW9kZWwudGl0bGUpO1xuICAgIH0sXG5cbiAgICAnYWxsZGF5LXRtcGwnOiBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICByZXR1cm4gY29tbW9uLnN0cmlwVGFncyhtb2RlbC50aXRsZSk7XG4gICAgfSxcblxuICAgICd0aW1lLXRtcGwnOiBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICByZXR1cm4gY29tbW9uLnN0cmlwVGFncyhtb2RlbC50aXRsZSk7XG4gICAgfVxufTtcblxuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcIjFcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBoZWxwZXIsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LCBhbGlhczI9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBhbGlhczM9Y29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwiXCJcbiAgICArIGFsaWFzMygoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gXCJmdW5jdGlvblwiID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwibW9udGh3ZWVrLWdyaWQtbGluZVxcXCIgc3R5bGU9XFxcIndpZHRoOlwiXG4gICAgKyBhbGlhczMoY29udGFpbmVyLmxhbWJkYShkZXB0aDAsIGRlcHRoMCkpXG4gICAgKyBcIiU7bGVmdDpcIlxuICAgICsgYWxpYXMzKChoZWxwZXJzLm11bHRpcGx5IHx8IChkZXB0aDAgJiYgZGVwdGgwLm11bHRpcGx5KSB8fCBhbGlhczIpLmNhbGwoYWxpYXMxLGRlcHRoMCwoZGF0YSAmJiBkYXRhLmluZGV4KSx7XCJuYW1lXCI6XCJtdWx0aXBseVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSlcbiAgICArIFwiJTtcXFwiPiZuYnNwOzwvZGl2PlxcblwiO1xufSxcIjNcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazE7XG5cbiAgcmV0dXJuICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSxkZXB0aDAse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSg0LCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKTtcbn0sXCI0XCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxO1xuXG4gIHJldHVybiBcIiBcXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LGRlcHRoMCx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDUsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpO1xufSxcIjVcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazE7XG5cbiAgcmV0dXJuIFwiIFxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sZGVwdGgwLHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDYsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpO1xufSxcIjZcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sIGFsaWFzMj1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGFsaWFzMz1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbiwgYWxpYXM0PVwiZnVuY3Rpb25cIiwgYWxpYXM1PWNvbnRhaW5lci5sYW1iZGE7XG5cbiAgcmV0dXJuIFwiIFxcbjxkaXYgZGF0YS1pZD1cXFwiXCJcbiAgICArIGFsaWFzMygoaGVscGVycy5zdGFtcCB8fCAoZGVwdGgwICYmIGRlcHRoMC5zdGFtcCkgfHwgYWxpYXMyKS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubW9kZWwgOiBkZXB0aDApLHtcIm5hbWVcIjpcInN0YW1wXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKVxuICAgICsgXCJcXFwiIFxcbiAgICBjbGFzcz1cXFwiXCJcbiAgICArIGFsaWFzMygoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXM0ID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiYWxsZGF5LWV2ZW50LWJsb2NrIFwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAucmVuZGVyU3RhcnRzIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSg3LCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzW1wiaWZcIl0uY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnJlbmRlckVuZHMgOiBkZXB0aDApLHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDksIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIlxcXCJcXG4gICAgc3R5bGU9XFxcInRvcDpcIlxuICAgICsgYWxpYXMzKChoZWxwZXJzLm11bHRpcGx5IHx8IChkZXB0aDAgJiYgZGVwdGgwLm11bHRpcGx5KSB8fCBhbGlhczIpLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50b3AgOiBkZXB0aDApLCgoc3RhY2sxID0gKGRhdGEgJiYgZGF0YS5yb290KSkgJiYgc3RhY2sxLmV2ZW50QmxvY2tIZWlnaHQpLHtcIm5hbWVcIjpcIm11bHRpcGx5XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKVxuICAgICsgXCJweDtsZWZ0OlwiXG4gICAgKyBhbGlhczMoKGhlbHBlcnMubXVsdGlwbHkgfHwgKGRlcHRoMCAmJiBkZXB0aDAubXVsdGlwbHkpIHx8IGFsaWFzMikuY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmxlZnQgOiBkZXB0aDApLCgoc3RhY2sxID0gKGRhdGEgJiYgZGF0YS5yb290KSkgJiYgc3RhY2sxLndpZHRoKSx7XCJuYW1lXCI6XCJtdWx0aXBseVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSlcbiAgICArIFwiJTt3aWR0aDpcIlxuICAgICsgYWxpYXMzKChoZWxwZXJzLm11bHRpcGx5IHx8IChkZXB0aDAgJiYgZGVwdGgwLm11bHRpcGx5KSB8fCBhbGlhczIpLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC53aWR0aCA6IGRlcHRoMCksKChzdGFjazEgPSAoZGF0YSAmJiBkYXRhLnJvb3QpKSAmJiBzdGFjazEud2lkdGgpLHtcIm5hbWVcIjpcIm11bHRpcGx5XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKVxuICAgICsgXCIlO2hlaWdodDpcIlxuICAgICsgYWxpYXMzKGFsaWFzNSgoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS5ldmVudEJsb2NrSGVpZ2h0KSwgZGVwdGgwKSlcbiAgICArIFwicHg7bWFyZ2luLXRvcDpcIlxuICAgICsgYWxpYXMzKGFsaWFzNSgoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS5ldmVudEJsb2NrR3V0dGVyKSwgZGVwdGgwKSlcbiAgICArIFwicHhcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXMzKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczQgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJhbGxkYXktZXZlbnRcXFwiIHN0eWxlPVxcXCJoZWlnaHQ6XCJcbiAgICArIGFsaWFzMyhhbGlhczUoKChzdGFjazEgPSAoZGF0YSAmJiBkYXRhLnJvb3QpKSAmJiBzdGFjazEuZXZlbnRIZWlnaHQpLCBkZXB0aDApKVxuICAgICsgXCJweDtjb2xvcjpcIlxuICAgICsgYWxpYXMzKGFsaWFzNSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tb2RlbCA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuY29sb3IgOiBzdGFjazEpLCBkZXB0aDApKVxuICAgICsgXCI7YmFja2dyb3VuZC1jb2xvcjpcIlxuICAgICsgYWxpYXMzKGFsaWFzNSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tb2RlbCA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuYmdDb2xvciA6IHN0YWNrMSksIGRlcHRoMCkpXG4gICAgKyBcIlxcXCI+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiXCJcbiAgICArIGFsaWFzMygoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXM0ID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiYWxsZGF5LWV2ZW50LXRpdGxlXFxcIj5cIlxuICAgICsgKChzdGFjazEgPSAoaGVscGVyc1tcImFsbGRheS10bXBsXCJdIHx8IChkZXB0aDAgJiYgZGVwdGgwW1wiYWxsZGF5LXRtcGxcIl0pIHx8IGFsaWFzMikuY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1vZGVsIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJhbGxkYXktdG1wbFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIjwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXMzKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczQgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJhbGxkYXktcmVzaXplLWhhbmRsZSBoYW5kbGUteVxcXCI+Jm5ic3A7PC9zcGFuPlxcbiAgICA8L2Rpdj4gXFxuPC9kaXY+XFxuXCI7XG59LFwiN1wiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIGhlbHBlcjtcblxuICByZXR1cm4gXCIgXCJcbiAgICArIGNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJzLmhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBcImZ1bmN0aW9uXCIgPyBoZWxwZXIuY2FsbChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiYWxsZGF5LWV4Y2VlZC1sZWZ0XCI7XG59LFwiOVwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIGhlbHBlcjtcblxuICByZXR1cm4gXCIgXCJcbiAgICArIGNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJzLmhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBcImZ1bmN0aW9uXCIgPyBoZWxwZXIuY2FsbChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiYWxsZGF5LWV4Y2VlZC1yaWdodFwiO1xufSxcImNvbXBpbGVyXCI6WzcsXCI+PSA0LjAuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sIGFsaWFzMj1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGFsaWFzMz1cImZ1bmN0aW9uXCIsIGFsaWFzND1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbjtcblxuICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJtb250aHdlZWstZ3JpZFxcXCI+XFxuXCJcbiAgICArICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5ldmVudEdyaWQgOiBkZXB0aDApLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMSwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwibW9udGh3ZWVrLWV2ZW50c1xcXCI+XFxuXCJcbiAgICArICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tYXRyaWNlcyA6IGRlcHRoMCkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgzLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L2Rpdj5cXG5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJlZ2lzdGVyIGRldmVsb3BlZCBjdXN0b20gaGFuZGxlYmFycyBoZWxwZXIuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC50dWkudXRpbDtcbnZhciBoZWxwZXIgPSByZXF1aXJlKCcuL2hlbHBlcicpO1xudmFyIEhhbmRsZWJhcnMgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5cbnV0aWwuZm9yRWFjaChoZWxwZXIsIGZ1bmN0aW9uKGhlbHBlciwgbmFtZSkge1xuICAgIEhhbmRsZWJhcnMucmVnaXN0ZXJIZWxwZXIobmFtZSwgaGVscGVyKTtcbn0sIHRoaXMpO1xuXG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoe1wiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sIGFsaWFzMj1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGFsaWFzMz1cImZ1bmN0aW9uXCIsIGFsaWFzND1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbjtcblxuICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJhbGxkYXktbGVmdFxcXCI+XFxuICAgIDxzcGFuPlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy50aXRsZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudGl0bGUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcInRpdGxlXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIjwvc3Bhbj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJhbGxkYXktcmlnaHRcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJhbGxkYXktbW9udGh3ZWVrLWNvbnRhaW5lclxcXCI+PC9kaXY+XFxuPC9kaXY+XFxuXCI7XG59LFwidXNlRGF0YVwiOnRydWV9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZSh7XCIxXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgaGVscGVyLCBhbGlhczE9ZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSwgYWxpYXMyPWhlbHBlcnMuaGVscGVyTWlzc2luZywgYWxpYXMzPVwiZnVuY3Rpb25cIiwgYWxpYXM0PWNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uO1xuXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVyc1tcImRheW5hbWUtaXNIb2xsaWRheVwiXSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDBbXCJkYXluYW1lLWlzSG9sbGlkYXlcIl0gOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcImRheW5hbWUtaXNIb2xsaWRheVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJcXFwiIHN0eWxlPVxcXCJcIlxuICAgICsgYWxpYXM0KChoZWxwZXJzW1wiY29tbW9uLXdpZHRoXCJdIHx8IChkZXB0aDAgJiYgZGVwdGgwW1wiY29tbW9uLXdpZHRoXCJdKSB8fCBhbGlhczIpLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC53aWR0aCA6IGRlcHRoMCkse1wibmFtZVwiOlwiY29tbW9uLXdpZHRoXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKVxuICAgICsgXCJcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJkYXluYW1lLWxhYmVsXFxcIj5cIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuZGF5TmFtZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZGF5TmFtZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiZGF5TmFtZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCI8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiZGF5bmFtZS1kYXRlXFxcIj5cIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuZGF0ZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZGF0ZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiZGF0ZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCI8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbn0sXCJjb21waWxlclwiOls3LFwiPj0gNC4wLjBcIl0sXCJtYWluXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxO1xuXG4gIHJldHVybiAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sZGVwdGgwLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMSwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIik7XG59LFwidXNlRGF0YVwiOnRydWV9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZSh7XCIxXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxO1xuXG4gIHJldHVybiAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sZGVwdGgwLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMiwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIik7XG59LFwiMlwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMTtcblxuICByZXR1cm4gKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LGRlcHRoMCx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDMsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpO1xufSxcIjNcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazE7XG5cbiAgcmV0dXJuICgoc3RhY2sxID0gaGVscGVyc1tcImlmXCJdLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSxkZXB0aDAse1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oNCwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIik7XG59LFwiNFwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMSwgaGVscGVyLCBhbGlhczE9ZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSwgYWxpYXMyPWhlbHBlcnMuaGVscGVyTWlzc2luZywgYWxpYXMzPVwiZnVuY3Rpb25cIiwgYWxpYXM0PWNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uLCBhbGlhczU9Y29udGFpbmVyLmxhbWJkYTtcblxuICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJ0aW1lLWRhdGUtZXZlbnQtYmxvY2tcXFwiIGRhdGEtaWQ9XFxcIlwiXG4gICAgKyBhbGlhczQoKGhlbHBlcnMuc3RhbXAgfHwgKGRlcHRoMCAmJiBkZXB0aDAuc3RhbXApIHx8IGFsaWFzMikuY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1vZGVsIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJzdGFtcFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSlcbiAgICArIFwiXFxcIiBzdHlsZT1cXFwiXCJcbiAgICArIGFsaWFzNCgoaGVscGVyc1tcInRpbWUtZXZlbnRCbG9ja1wiXSB8fCAoZGVwdGgwICYmIGRlcHRoMFtcInRpbWUtZXZlbnRCbG9ja1wiXSkgfHwgYWxpYXMyKS5jYWxsKGFsaWFzMSxkZXB0aDAse1wibmFtZVwiOlwidGltZS1ldmVudEJsb2NrXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKVxuICAgICsgXCJcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcInRpbWUtZXZlbnRcXFwiIHN0eWxlPVxcXCJjb2xvcjpcIlxuICAgICsgYWxpYXM0KGFsaWFzNSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tb2RlbCA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuY29sb3IgOiBzdGFjazEpLCBkZXB0aDApKVxuICAgICsgXCI7YmFja2dyb3VuZC1jb2xvcjpcIlxuICAgICsgYWxpYXM0KGFsaWFzNSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tb2RlbCA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuYmdDb2xvciA6IHN0YWNrMSksIGRlcHRoMCkpXG4gICAgKyBcIlxcXCI+XCJcbiAgICArICgoc3RhY2sxID0gKGhlbHBlcnNbXCJ0aW1lLXRtcGxcIl0gfHwgKGRlcHRoMCAmJiBkZXB0aDBbXCJ0aW1lLXRtcGxcIl0pIHx8IGFsaWFzMikuY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1vZGVsIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJ0aW1lLXRtcGxcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJ0aW1lLXJlc2l6ZS1oYW5kbGUgaGFuZGxlLXhcXFwiPiZuYnNwOzwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuXCI7XG59LFwiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMTtcblxuICByZXR1cm4gKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tYXRyaWNlcyA6IGRlcHRoMCkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgxLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKTtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pO1xuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcIjFcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBoZWxwZXIsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LCBhbGlhczI9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBhbGlhczM9XCJmdW5jdGlvblwiLCBhbGlhczQ9Y29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgcmV0dXJuIFwiPGxpIGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJ0aW1lZ3JpZC1ob3VyLVwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5ob3VyIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5ob3VyIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJob3VyXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIlxcXCI+PHNwYW4+XCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLmhvdXIgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmhvdXIgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcImhvdXJcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiPC9zcGFuPjwvbGk+XCI7XG59LFwiM1wiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIGhlbHBlcjtcblxuICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJcIlxuICAgICsgY29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlcnMuaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IFwiZnVuY3Rpb25cIiA/IGhlbHBlci5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30se1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJ0aW1lZ3JpZC1ncmlkXFxcIj48L2Rpdj5cIjtcbn0sXCJjb21waWxlclwiOls3LFwiPj0gNC4wLjBcIl0sXCJtYWluXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxLCBoZWxwZXIsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LCBhbGlhczI9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBhbGlhczM9XCJmdW5jdGlvblwiLCBhbGlhczQ9Y29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwidGltZWdyaWRcXFwiPlxcbiAgICA8dWwgY2xhc3M9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcInRpbWVncmlkLWxlZnRcXFwiPlxcbiAgICAgICAgXCJcbiAgICArICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5ob3VycyA6IGRlcHRoMCkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgxLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCJcXG4gICAgPC91bD5cXG4gICAgPGRpdiBjbGFzcz1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwidGltZWdyaWQtcmlnaHRcXFwiPlxcbiAgICAgICAgXCJcbiAgICArICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5ob3VycyA6IGRlcHRoMCkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgzLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCJcXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcInRpbWVncmlkLWV2ZW50c1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJ0aW1lZ3JpZC1ldmVudHMtY29udGFpbmVyXFxcIj48L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcInRpbWVncmlkLWhvdXJtYXJrZXJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5DU1NfUFJFRklYIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5DU1NfUFJFRklYIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJDU1NfUFJFRklYXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcInRpbWVncmlkLWhvdXJtYXJrZXItd3JhcFxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwidGltZWdyaWQtaG91cm1hcmtlci1saW5lXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuQ1NTX1BSRUZJWCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuQ1NTX1BSRUZJWCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiQ1NTX1BSRUZJWFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJ0aW1lZ3JpZC1ob3VybWFya2VyLXRpbWVcXFwiPjAwOjAwPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLkNTU19QUkVGSVggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLkNTU19QUkVGSVggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIkNTU19QUkVGSVhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwidGltZWdyaWQtdG9kYXltYXJrZXJcXFwiPnRvZGF5PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG59LFwidXNlRGF0YVwiOnRydWV9KTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBUaGUgYmFzZSBjbGFzcyBvZiB2aWV3cy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLnR1aS51dGlsO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9jb21tb24vY29sbGVjdGlvbicpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3Mgb2Ygdmlld3MuXG4gKlxuICogQWxsIHZpZXdzIGNyZWF0ZSBvd24gY29udGFpbmVyIGVsZW1lbnQgaW5zaWRlIHN1cHBsaWVkIGNvbnRhaW5lciBlbGVtZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgRGVmYXVsdCBjb250YWluZXIgZWxlbWVudCBmb3Igdmlldy4geW91IGNhbiB1c2UgdGhpcyBlbGVtZW50IGZvciB0aGlzLmNvbnRhaW5lciBzeW50YXguXG4gKi9cbmZ1bmN0aW9uIFZpZXcoY29udGFpbmVyKSB7XG4gICAgdmFyIGlkID0gdXRpbC5zdGFtcCh0aGlzKTtcblxuICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGNvbnRhaW5lcikpIHtcbiAgICAgICAgY29udGFpbmVyID0gZG9tdXRpbC5hcHBlbmRIVE1MRWxlbWVudCgnZGl2Jyk7XG4gICAgfVxuXG4gICAgZG9tdXRpbC5hZGRDbGFzcyhjb250YWluZXIsIHRoaXMuY3NzcHJlZml4KGlkKSk7XG5cbiAgICAvKipcbiAgICAgKiB1bmlxdWUgaWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBpZDtcblxuICAgIC8qKlxuICAgICAqIGJhc2UgZWxlbWVudCBvZiB2aWV3LlxuICAgICAqIEB0eXBlIHtIVE1MRElWRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICAgIC8qZXNsaW50LWRpc2FibGUqL1xuICAgIC8qKlxuICAgICAqIGNoaWxkIHZpZXdzLlxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY2hpbGRzID0gbmV3IENvbGxlY3Rpb24oZnVuY3Rpb24odmlldykge1xuICAgICAgICByZXR1cm4gdXRpbC5zdGFtcCh2aWV3KTtcbiAgICB9KTtcbiAgICAvKmVzbGludC1lbmFibGUqL1xuXG4gICAgLyoqXG4gICAgICogcGFyZW50IHZpZXcgaW5zdGFuY2UuXG4gICAgICogQHR5cGUge1ZpZXd9XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xufVxuXG4vKipcbiAqIENTUyBjbGFzc25hbWUgcHJlZml4XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5WaWV3LnByb3RvdHlwZS5jc3NQcmVmaXggPSAndHVpLXZpZXctJztcblxuLyoqXG4gKiBBZGQgY2hpbGQgdmlld3MuXG4gKiBAcGFyYW0ge1ZpZXd9IHZpZXcgVGhlIHZpZXcgaW5zdGFuY2UgdG8gYWRkLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZuXSBGdW5jdGlvbiBmb3IgaW52b2tlIGJlZm9yZSBhZGQuIHBhcmVudCB2aWV3IGNsYXNzIGlzIHN1cHBsaWVkIGZpcnN0IGFyZ3VtZW50cy5cbiAqL1xuVmlldy5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbih2aWV3LCBmbikge1xuICAgIGlmIChmbikge1xuICAgICAgICBmbi5jYWxsKHZpZXcsIHRoaXMpO1xuICAgIH1cbiAgICAvLyBhZGQgcGFyZW50IHZpZXdcbiAgICB2aWV3LnBhcmVudCA9IHRoaXM7XG5cbiAgICB0aGlzLmNoaWxkcy5hZGQodmlldyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhZGRlZCBjaGlsZCB2aWV3LlxuICogQHBhcmFtIHsobnVtYmVyfFZpZXcpfSBpZCBWaWV3IGlkIG9yIGluc3RhbmNlIGl0c2VsZiB0byByZW1vdmUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZm5dIEZ1bmN0aW9uIGZvciBpbnZva2UgYmVmb3JlIHJlbW92ZS4gcGFyZW50IHZpZXcgY2xhc3MgaXMgc3VwcGxpZWQgZmlyc3QgYXJndW1lbnRzLlxuICovXG5WaWV3LnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uKGlkLCBmbikge1xuICAgIHZhciB2aWV3ID0gdXRpbC5pc051bWJlcihpZCkgPyB0aGlzLmNoaWxkcy5pdGVtc1tpZF0gOiBpZDtcblxuICAgIGlkID0gdXRpbC5zdGFtcCh2aWV3KTtcblxuICAgIGlmIChmbikge1xuICAgICAgICBmbi5jYWxsKHZpZXcsIHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGRzLnJlbW92ZShpZCk7XG59O1xuXG4vKipcbiAqIFJlbmRlciB2aWV3IHJlY3Vyc2l2ZWx5LlxuICovXG5WaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNoaWxkcy5lYWNoKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICBjaGlsZFZpZXcucmVuZGVyKCk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEludm9rZSBmdW5jdGlvbiByZWN1cnNpdmVseS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gZnVuY3Rpb24gdG8gaW52b2tlIGNoaWxkIHZpZXcgcmVjdXJzaXZlbHlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBUaGlzPWZhbHNlXSAtIHNldCB0cnVlIHRoZW4gc2tpcCBpbnZva2Ugd2l0aCB0aGlzKHJvb3QpIHZpZXcuXG4gKi9cblZpZXcucHJvdG90eXBlLnJlY3Vyc2l2ZSA9IGZ1bmN0aW9uKGZuLCBza2lwVGhpcykge1xuICAgIGlmICghdXRpbC5pc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFza2lwVGhpcykge1xuICAgICAgICBmbih0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLmNoaWxkcy5lYWNoKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICBjaGlsZFZpZXcucmVjdXJzaXZlKGZuKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmVzaXplIHZpZXcgcmVjdXJzaXZlbHkgdG8gcGFyZW50LlxuICovXG5WaWV3LnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKHBhcmVudC5fb25SZXNpemUpKSB7XG4gICAgICAgICAgICBwYXJlbnQuX29uUmVzaXplLmFwcGx5KHBhcmVudCwgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbn07XG5cbi8qKlxuICogSW52b2tpbmcgbWV0aG9kIGJlZm9yZSBkZXN0cm95aW5nLlxuICovXG5WaWV3LnByb3RvdHlwZS5fYmVmb3JlRGVzdHJveSA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogQ2xlYXIgcHJvcGVydGllc1xuICovXG5WaWV3LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JlZm9yZURlc3Ryb3koKTtcbiAgICB0aGlzLmNoaWxkcy5jbGVhcigpO1xuICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuXG4gICAgdGhpcy5pZCA9IHRoaXMucGFyZW50ID0gdGhpcy5jaGlsZHMgPSB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG59O1xuXG4vKmVzbGludC1kaXNhYmxlKi9cbi8qKlxuICogRGVzdHJveSBjaGlsZCB2aWV3IHJlY3Vyc2l2ZWx5LlxuICovXG5WaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oaXNDaGlsZFZpZXcpIHtcbiAgICB0aGlzLmNoaWxkcy5lYWNoKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICBjaGlsZFZpZXcuZGVzdHJveSh0cnVlKTtcbiAgICAgICAgY2hpbGRWaWV3Ll9kZXN0cm95KCk7XG4gICAgfSk7XG5cbiAgICBpZiAoaXNDaGlsZFZpZXcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2Rlc3Ryb3koKTtcbn07XG4vKmVzbGludC1lbmFibGUqL1xuXG4vKipcbiAqIENhbGN1bGF0ZSB2aWV3J3MgY29udGFpbmVyIGVsZW1lbnQgYm91bmQuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgYm91bmQgb2YgY29udGFpbmVyIGVsZW1lbnQuXG4gKi9cblZpZXcucHJvdG90eXBlLmdldFZpZXdCb3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgcG9zaXRpb24gPSBkb211dGlsLmdldFBvc2l0aW9uKGNvbnRhaW5lciksXG4gICAgICAgIHNpemUgPSBkb211dGlsLmdldFNpemUoY29udGFpbmVyKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBvc2l0aW9uWzBdLFxuICAgICAgICB5OiBwb3NpdGlvblsxXSxcbiAgICAgICAgd2lkdGg6IHNpemVbMF0sXG4gICAgICAgIGhlaWdodDogc2l6ZVsxXVxuICAgIH07XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIHZpZXcgZGVmYXVsdCBDU1MgcHJlZml4XG4gKiBAcGFyYW0ge3N0cmluZ30gW2NsYXNzTmFtZV0gLSBpZiBzdXBwbGllZCB0aGVuIHJldHVybiBwcmVmaXggYWRkZWQgY2xhc3MgbmFtZVxuICogQHJldHVybnMge3N0cmluZ30gQ1NTIHByZWZpeCB2YWx1ZVxuICovXG5WaWV3LnByb3RvdHlwZS5jc3NwcmVmaXggPSBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jc3NQcmVmaXggKyAoY2xhc3NOYW1lIHx8ICcnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlldztcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFZpZXcgb2YgYWxsZGF5IGV2ZW50IGNvbnRhaW5lciBpbnNpZGUgb2YgV2VlayB2aWV3LlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwudHVpLnV0aWw7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vY29uZmlnJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXcnKTtcbnZhciBNb250aFdlZWsgPSByZXF1aXJlKCcuLi9tb250aHdlZWsnKTtcbnZhciBtYWluVG1wbCA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlL3dlZWsvYWxsZGF5LmhicycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge1ZpZXd9XG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBUaGUgb2JqZWN0IGZvciB2aWV3IGN1c3RvbWl6YXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yZW5kZXJTdGFydERhdGUgLSBzdGFydCBkYXRlIG9mIGFsbGRheSB2aWV3J3MgcmVuZGVyIGRhdGUuIFlZWVktTU0tRERcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJlbmRlckVuZERhdGUgLSBlbmQgZGF0ZSBvZiBhbGxkYXkgdmlldydzIHJlbmRlciBkYXRlLiBZWVlZLU1NLUREXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaGVpZ2h0PTYwXSAtIG1pbmltdW0gaGVpZ2h0IG9mIGV2ZW50IGNvbnRhaW5lciBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmV2ZW50QmxvY2tIZWlnaHQ9MThdIC0gaGVpZ2h0IG9mIGVhY2ggZXZlbnQgYmxvY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZXZlbnRCbG9ja0d1dHRlcj0yXSAtIGd1dHRlciBoZWlnaHQgb2YgZWFjaCBldmVudCBibG9jay5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLl9nZXRWaWV3TW9kZWxGdW5jXSAtIGZ1bmN0aW9uIGZvciBleHRyYWN0IHBhcnRpYWwgdmlldyBtb2RlbCBkYXRhIGZyb20gd2hvbGUgdmlldyBtb2RlbHMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgQ29udGFpbmVyIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIEFsbGRheShvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICBjb250YWluZXIgPSBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBjb25maWcuY2xhc3NuYW1lKCdhbGxkYXktY29udGFpbmVyJylcbiAgICApO1xuXG4gICAgLyoqXG4gICAgICogcmVuZGVyaW5nIG9wdGlvbnMuXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgIHRpdGxlOiAn7KKF7J287J287KCVJyxcbiAgICAgICAgcmVuZGVyU3RhcnREYXRlOiAnJyxcbiAgICAgICAgcmVuZGVyRW5kRGF0ZTogJycsXG4gICAgICAgIGNvbnRhaW5lckhlaWdodDogNDAsXG4gICAgICAgIGNvbnRhaW5lckJvdHRvbUd1dHRlcjogOCxcbiAgICAgICAgZXZlbnRIZWlnaHQ6IDE4LFxuICAgICAgICBldmVudEd1dHRlcjogMixcbiAgICAgICAgX2dldFZpZXdNb2RlbEZ1bmM6IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdNb2RlbC5ldmVudHNJbkRhdGVSYW5nZS5hbGxkYXk7XG4gICAgICAgIH1cbiAgICB9LCBvcHRpb25zKTtcblxuICAgIFZpZXcuY2FsbCh0aGlzLCBjb250YWluZXIpO1xufVxuXG51dGlsLmluaGVyaXQoQWxsZGF5LCBWaWV3KTtcblxuLyoqXG4gKiBjcmVhdGUgbW9udGggd2VlayB2aWV3IG1vZGVsIGZvciByZW5kZXIgYWxsZGF5IGV2ZW50cyBpbiB0b3Agb2Ygd2VlayB2aWV3cy5cbiAqIEBvdmVycmlkZVxuICogQHBhcmFtIHtvYmplY3R9IHZpZXdNb2RlbCAtIHZpZXdNb2RlbCBmcm9tIHBhcmVudCB2aWV3cy5cbiAqL1xuQWxsZGF5LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbih2aWV3TW9kZWwpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIsXG4gICAgICAgIG1vbnRoV2Vla0luc3Q7XG5cbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gbWFpblRtcGwodGhpcy5vcHRpb25zKTtcblxuICAgIHRoaXMuY2hpbGRzLmNsZWFyKCk7XG5cbiAgICBtb250aFdlZWtJbnN0ID0gbmV3IE1vbnRoV2VlayhcbiAgICAgICAgdGhpcy5vcHRpb25zLCBcbiAgICAgICAgZG9tdXRpbC5maW5kKCcuJyArIGNvbmZpZy5jbGFzc25hbWUoJ2FsbGRheS1tb250aHdlZWstY29udGFpbmVyJyksIGNvbnRhaW5lcilcbiAgICApO1xuXG4gICAgdGhpcy5hZGRDaGlsZChtb250aFdlZWtJbnN0KTtcblxuICAgIHRoaXMuY2hpbGRzLmVhY2goZnVuY3Rpb24oY2hpbGRWaWV3KSB7XG4gICAgICAgIGNoaWxkVmlldy5yZW5kZXIodmlld01vZGVsKTtcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWxsZGF5O1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVmlldyBmb3IgcmVuZGVyaW5nIGRheW5hbWVzXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC50dWkudXRpbDtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi8uLi9jb25maWcnKTtcbnZhciBkYXRldGltZSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kYXRldGltZScpO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIFZpZXcgPSByZXF1aXJlKCcuLi92aWV3Jyk7XG52YXIgZGF5bmFtZVRtcGwgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZS93ZWVrL2RheW5hbWVzLmhicycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGZvciBkYXluYW1lIHZpZXdcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBDb250YWluZXIgZWxlbWVudCB0byB1c2UuXG4gKiBAZXh0ZW5kcyB7Vmlld31cbiAqL1xuZnVuY3Rpb24gRGF5TmFtZShvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICBjb250YWluZXIgPSBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBjb25maWcuY2xhc3NuYW1lKCdkYXluYW1lLWNvbnRhaW5lcicpXG4gICAgKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgZGF5bmFtZXM6IFsn7J28JywgJ+yblCcsICftmZQnLCAn7IiYJywgJ+uqqScsICfquIgnLCAn7YagJ11cbiAgICB9LCBvcHRpb25zKTtcblxuICAgIFZpZXcuY2FsbCh0aGlzLCBjb250YWluZXIpO1xufVxuXG51dGlsLmluaGVyaXQoRGF5TmFtZSwgVmlldyk7XG5cbi8qKlxuICogR2V0IGRlZmF1bHQgdmlld21vZGVscy5cbiAqIEBwYXJhbSB7RGF0ZX0gc3RhcnQgVGhlIGRhdGUgb2Ygc3RhcnQgcmVuZGVyXG4gKiBAcGFyYW0ge0RhdGV9IGVuZCBUaGUgZW5kIG9mIGVuZCByZW5kZXJcbiAqIEByZXR1cm5zIHthcnJheX0gdmlld21vZGVsLlxuICovXG5EYXlOYW1lLnByb3RvdHlwZS5fZ2V0QmFzZVZpZXdNb2RlbCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgZGF5bmFtZXMgPSB0aGlzLm9wdGlvbnMuZGF5bmFtZXMsXG4gICAgICAgIHZpZXdNb2RlbDtcblxuICAgIHZpZXdNb2RlbCA9IHV0aWwubWFwKGRhdGV0aW1lLnJhbmdlKFxuICAgICAgICBkYXRldGltZS5zdGFydChzdGFydCksXG4gICAgICAgIGRhdGV0aW1lLnN0YXJ0KGVuZCksXG4gICAgICAgIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZXG4gICAgKSwgZnVuY3Rpb24oZCwgaSwgYXJyKSB7XG4gICAgICAgIHZhciBkYXkgPSBkLmdldERheSgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXk6IGRheSxcbiAgICAgICAgICAgIGRheU5hbWU6IGRheW5hbWVzW2RheV0sXG4gICAgICAgICAgICBkYXRlOiBkLmdldERhdGUoKSxcbiAgICAgICAgICAgIHdpZHRoOiAxMDAgLyBhcnIubGVuZ3RoXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdmlld01vZGVsO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2aWV3TW9kZWwgVmlldyBtb2RlbCBmcm9tIHBhcmVudCAoV2Vla1ZpZXcpXG4gKi9cbkRheU5hbWUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgIHZhciBfdmlld01vZGVsID0gdGhpcy5fZ2V0QmFzZVZpZXdNb2RlbChcbiAgICAgICAgdmlld01vZGVsLnJlbmRlclN0YXJ0RGF0ZSxcbiAgICAgICAgdmlld01vZGVsLnJlbmRlckVuZERhdGVcbiAgICApO1xuXG4gICAgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gZGF5bmFtZVRtcGwoX3ZpZXdNb2RlbCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERheU5hbWU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBWaWV3IG9mIHRpbWUuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC50dWkudXRpbDtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi8uLi9jb25maWcnKTtcbnZhciBkYXRldGltZSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kYXRldGltZScpO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIFZpZXcgPSByZXF1aXJlKCcuLi92aWV3Jyk7XG52YXIgdGltZVRtcGwgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZS93ZWVrL3RpbWUuaGJzJyk7XG52YXIgZm9yRWFjaEFyciA9IHV0aWwuZm9yRWFjaEFycmF5O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge1ZpZXd9XG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggRGF0ZSBlbGVtZW50IHdpZHRoIChwZXJjZW50KVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgT3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueW1kIFlZWU1NREQgc3RyaW5nIGZvciB0aGlzIHZpZXdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5pc1RvZGF5IHdoZW4gc2V0IHRydWUgdGhlbiBhc3NpZ24gdG9kYXkgZGVzaWduIGNsYXNzIHRvIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmhvdXJTdGFydCBDYW4gbGltaXQgb2YgcmVuZGVyIGhvdXIgc3RhcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5ob3VyRW5kIENhbiBsaW1pdCBvZiByZW5kZXIgaG91ciBlbmQuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgRWxlbWVudCB0byB1c2UgY29udGFpbmVyIGZvciB0aGlzIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIFRpbWUod2lkdGgsIG9wdGlvbnMsIGNvbnRhaW5lcikge1xuICAgIFZpZXcuY2FsbCh0aGlzLCBjb250YWluZXIpO1xuXG4gICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gd2lkdGggKyAnJSc7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgIHltZDogJycsXG4gICAgICAgIGlzVG9kYXk6IGZhbHNlLFxuICAgICAgICBob3VyU3RhcnQ6IDAsXG4gICAgICAgIGhvdXJFbmQ6IDI0XG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmlzVG9kYXkpIHtcbiAgICAgICAgZG9tdXRpbC5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lciwgY29uZmlnLmNsYXNzbmFtZSgndGltZS1kYXRlLXRvZGF5JykpO1xuICAgIH1cbn1cblxudXRpbC5pbmhlcml0KFRpbWUsIFZpZXcpO1xuXG4vKipcbiAqIENvbnZlcnQgWVlZWU1NREQgZm9ybWF0dGVkIHN0cmluZyBkYXRlIHRvIERhdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIGZvcm1hdHRlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyB7RGF0ZX0gc3RhcnQgb2YgZGF0ZS5cbiAqL1xuVGltZS5wcm90b3R5cGUuX3BhcnNlRGF0ZUdyb3VwID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIHkgPSBwYXJzZUludChzdHIuc3Vic3RyKDAsIDQpLCAxMCksXG4gICAgICAgIG0gPSBwYXJzZUludChzdHIuc3Vic3RyKDQsIDIpLCAxMCksXG4gICAgICAgIGQgPSBwYXJzZUludChzdHIuc3Vic3RyKDYsIDIpLCAxMCk7XG5cbiAgICByZXR1cm4gbmV3IERhdGUoeSwgbSAtIDEsIGQpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0NhbEV2ZW50Vmlld01vZGVsfSB2aWV3TW9kZWwgLSB2aWV3IG1vZGVsIGluc3RhbmNlIHRvIGNhbGN1bGF0ZSBib3VuZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgY2FsY3VsYXRpbmcgZXZlbnQgZWxlbWVudCdzIGJvdW5kLlxuICogQHBhcmFtIHtEYXRlfSBvcHRpb25zLnRvZGF5U3RhcnQgLSBkYXRlIG9iamVjdCByZXByZXNlbnQgZXZlbnQgZGF0ZSdzIHN0YXJ0ICgwMDowMDowMClcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmJhc2VNUyAtIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHJlbmRlciBldmVudCBibG9ja3MuXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5iYXNlSGVpZ2h0IC0gcGl4ZWwgdmFsdWUgcmVsYXRlZCB3aXRoIGJhc2VNUyBvcHRpb25zLlxuICogQHBhcmFtIHtudW1iZXJbXX0gb3B0aW9ucy5iYXNlTGVmdCAtIGxlZnQgcG9zaXRpb24gcGVyY2VudHMgZm9yIGVhY2ggY29sdW1ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmJhc2VXaWR0aCAtIHRoZSB1bml0IG9mIGV2ZW50IGJsb2NrcyB3aWR0aCBwZXJjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY29sdW1uSW5kZXggLSB0aGUgbnVtYmVyIGluZGV4IG9mIGV2ZW50IGJsb2Nrcy5cbiAqIGl0IHJlcHJlc2VudCByZW5kZXJpbmcgaW5kZXggZnJvbSBsZWZ0IHNpZGVzIGluIHZpZXcuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBib3VuZCBvYmplY3QgZm9yIHN1cHBsaWVkIHZpZXcgbW9kZWwuXG4gKi9cblRpbWUucHJvdG90eXBlLmdldEV2ZW50Vmlld0JvdW5kID0gZnVuY3Rpb24odmlld01vZGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIGJhc2VNUyA9IG9wdGlvbnMuYmFzZU1TLFxuICAgICAgICBiYXNlSGVpZ2h0ID0gb3B0aW9ucy5iYXNlSGVpZ2h0LFxuICAgICAgICBvZmZzZXRTdGFydCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdG9wO1xuXG4gICAgb2Zmc2V0U3RhcnQgPSB2aWV3TW9kZWwudmFsdWVPZigpLnN0YXJ0cyAtIG9wdGlvbnMudG9kYXlTdGFydDtcblxuICAgIC8vIGNvbnRhaW5lckhlaWdodCA6IG1pbGxpc2Vjb25kcyBpbiBkYXkgPSB4IDogZXZlbnQncyBtaWxsaXNlY29uZHNcbiAgICB0b3AgPSAoYmFzZUhlaWdodCAqIG9mZnNldFN0YXJ0KSAvIGJhc2VNUztcbiAgICBoZWlnaHQgPSAoYmFzZUhlaWdodCAqIHZpZXdNb2RlbC5kdXJhdGlvbigpKSAvIGJhc2VNUztcbiAgICB3aWR0aCA9IG9wdGlvbnMuYmFzZVdpZHRoICogKHZpZXdNb2RlbC5leHRyYVNwYWNlICsgMSk7XG5cbiAgICAvLyBzZXQgd2lkdGggYXV0byB3aGVuIGhhcyBubyBjb2xsaXNpb25zLlxuICAgIGlmICghdmlld01vZGVsLmhhc0NvbGxpZGUpIHtcbiAgICAgICAgd2lkdGggPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICBsZWZ0OiBvcHRpb25zLmJhc2VMZWZ0W29wdGlvbnMuY29sdW1uSW5kZXhdLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfTtcbn07XG5cbi8qKlxuICogU2V0IHZpZXdtb2RlbHMgZm9yIHJlbmRlcmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB5bWQgVGhlIGRhdGUgb2YgZXZlbnRzLiBZWVlZTU1ERCBmb3JtYXQuXG4gKiBAcGFyYW0ge2FycmF5fSBtYXRyaWNlcyBUaGUgbWF0cmljZXMgZm9yIGV2ZW50IHBsYWNpbmcuXG4gKi9cblRpbWUucHJvdG90eXBlLl9nZXRCYXNlVmlld01vZGVsID0gZnVuY3Rpb24oeW1kLCBtYXRyaWNlcykge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBob3VyU3RhcnQgPSBvcHRpb25zLmhvdXJTdGFydCxcbiAgICAgICAgaG91ckVuZCA9IG9wdGlvbnMuaG91ckVuZCxcbiAgICAgICAgY29udGFpbmVySGVpZ2h0LFxuICAgICAgICB0b2RheVN0YXJ0LFxuICAgICAgICBiYXNlTVM7XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgZWFjaCBldmVudCBlbGVtZW50IGJvdW5kcyByZWxhdGl2ZSB3aXRoIHJlbmRlcmVkIGhvdXIgbWlsbGlzZWNvbmRzIGFuZFxuICAgICAqIHdyYXAgZWFjaCBldmVudCBtb2RlbCB0byB2aWV3bW9kZWxzLlxuICAgICAqL1xuICAgIGNvbnRhaW5lckhlaWdodCA9IHRoaXMuZ2V0Vmlld0JvdW5kKCkuaGVpZ2h0O1xuICAgIHRvZGF5U3RhcnQgPSB0aGlzLl9wYXJzZURhdGVHcm91cCh5bWQpO1xuICAgIHRvZGF5U3RhcnQuc2V0SG91cnMoaG91clN0YXJ0KTtcbiAgICBiYXNlTVMgPSBkYXRldGltZS5taWxsaXNlY29uZHNGcm9tKCdob3VyJywgKGhvdXJFbmQgLSBob3VyU3RhcnQpKTtcblxuICAgIGZvckVhY2hBcnIobWF0cmljZXMsIGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgICAgICB2YXIgbWF4Um93TGVuZ3RoLFxuICAgICAgICAgICAgd2lkdGhQZXJjZW50LFxuICAgICAgICAgICAgbGVmdFBlcmNlbnRzLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBtYXhSb3dMZW5ndGggPSBNYXRoLm1heC5hcHBseShudWxsLCB1dGlsLm1hcChtYXRyaXgsIGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgcmV0dXJuIHJvdy5sZW5ndGg7XG4gICAgICAgIH0pKTtcblxuICAgICAgICB3aWR0aFBlcmNlbnQgPSAxMDAgLyBtYXhSb3dMZW5ndGg7XG5cbiAgICAgICAgbGVmdFBlcmNlbnRzID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXhSb3dMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgbGVmdFBlcmNlbnRzW2ldID0gd2lkdGhQZXJjZW50ICogaTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvckVhY2hBcnIobWF0cml4LCBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgIGZvckVhY2hBcnIocm93LCBmdW5jdGlvbih2aWV3TW9kZWwsIGNvbCkge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3Qm91bmQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXZpZXdNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmlld0JvdW5kID0gdGhpcy5nZXRFdmVudFZpZXdCb3VuZCh2aWV3TW9kZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgdG9kYXlTdGFydDogdG9kYXlTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgYmFzZU1TOiBiYXNlTVMsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VMZWZ0OiBsZWZ0UGVyY2VudHMsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VXaWR0aDogd2lkdGhQZXJjZW50LFxuICAgICAgICAgICAgICAgICAgICBiYXNlSGVpZ2h0OiBjb250YWluZXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4OiBjb2xcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHV0aWwuZXh0ZW5kKHZpZXdNb2RlbCwgdmlld0JvdW5kKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge0RhdGV9IC0gRGF0ZSBvZiB0aGlzIHZpZXcuXG4gKi9cblRpbWUucHJvdG90eXBlLmdldERhdGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VEYXRlR3JvdXAodGhpcy5vcHRpb25zLnltZCk7XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKiBAcGFyYW0ge3N0cmluZ30geW1kIFRoZSBkYXRlIG9mIGV2ZW50cy4gWVlZWU1NREQgZm9ybWF0XG4gKiBAcGFyYW0ge2FycmF5fSBtYXRyaWNlcyBNYXRyaWNlcyBmb3IgcGxhY2luZyBldmVudHNcbiAqL1xuVGltZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oeW1kLCBtYXRyaWNlcykge1xuICAgIHRoaXMuX2dldEJhc2VWaWV3TW9kZWwoeW1kLCBtYXRyaWNlcyk7XG4gICAgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gdGltZVRtcGwoe1xuICAgICAgICBtYXRyaWNlczogbWF0cmljZXNcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZTtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFZpZXcgZm9yIHJlbmRlcmVkIGV2ZW50cyBieSB0aW1lcy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLnR1aS51dGlsO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL2NvbmZpZycpO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgcmVxQW5pbUZyYW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL3JlcUFuaW1GcmFtZScpO1xudmFyIFZpZXcgPSByZXF1aXJlKCcuLi92aWV3Jyk7XG52YXIgVGltZSA9IHJlcXVpcmUoJy4vdGltZScpO1xudmFyIEF1dG9TY3JvbGwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vYXV0b1Njcm9sbCcpO1xudmFyIG1haW5UbXBsID0gcmVxdWlyZSgnLi4vdGVtcGxhdGUvd2Vlay90aW1lR3JpZC5oYnMnKTtcblxudmFyIFBJWEVMX1JFTkRFUl9FUlJPUiA9IDAuNTtcbnZhciBIT1VSTUFSS0VSX1JFRlJFU0hfSU5URVJWQUwgPSAxMDAwICogMTA7XG52YXIgSU5JVElBTF9BVVRPU0NST0xMX0RFTEFZID0gdXRpbC5icm93c2VyLm1zaWUgPyAxMDAgOiA1MDtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtWaWV3fVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgVGhlIG9iamVjdCBmb3IgdmlldyBjdXN0b21pemF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhvdXJTdGFydD0wXSBZb3UgY2FuIGNoYW5nZSB2aWV3J3Mgc3RhcnQgaG91cnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaG91ckVuZD0wXSBZb3UgY2FuIGNoYW5nZSB2aWV3J3MgZW5kIGhvdXJzLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIENvbnRhaW5lciBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBUaW1lR3JpZChvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICBjb250YWluZXIgPSBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBjb25maWcuY2xhc3NuYW1lKCd0aW1lZ3JpZC1jb250YWluZXInKVxuICAgICk7XG5cbiAgICBWaWV3LmNhbGwodGhpcywgY29udGFpbmVyKTtcblxuICAgIGlmICghdXRpbC5icm93c2VyLnNhZmFyaSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0F1dG9TY3JvbGx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9hdXRvU2Nyb2xsID0gbmV3IEF1dG9TY3JvbGwoY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaW1lIHZpZXcgb3B0aW9ucy5cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgaG91clN0YXJ0OiAwLFxuICAgICAgICBob3VyRW5kOiAyNFxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJ2YWwgaWQgZm9yIGhvdXJtYXJrZXIgYW5pbWF0aW9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbnRlcnZhbElEID0gMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuX3Njcm9sbGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLmF0dGFjaEV2ZW50KCk7XG59XG5cbnV0aWwuaW5oZXJpdChUaW1lR3JpZCwgVmlldyk7XG5cbi8qKioqKioqKioqXG4gKiBQcm90b3R5cGUgcHJvcHNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cblRpbWVHcmlkLnByb3RvdHlwZS52aWV3TmFtZSA9ICd0aW1lZ3JpZCc7XG5cbi8qKlxuICogRGVzdHJveSB2aWV3LlxuICogQG92ZXJyaWRlXG4gKi9cblRpbWVHcmlkLnByb3RvdHlwZS5fYmVmb3JlRGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJRCk7XG5cbiAgICBpZiAodGhpcy5fYXV0b1Njcm9sbCkge1xuICAgICAgICB0aGlzLl9hdXRvU2Nyb2xsLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9hdXRvU2Nyb2xsID0gdGhpcy5ob3VybWFya2VyID0gbnVsbDtcbn07XG5cbi8qKlxuICogR2V0IGJhc2Ugdmlld01vZGVsLlxuICogQHJldHVybnMge29iamVjdH0gVmlld01vZGVsXG4gKi9cblRpbWVHcmlkLnByb3RvdHlwZS5fZ2V0QmFzZVZpZXdNb2RlbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBlbmQgPSBvcHRpb25zLmhvdXJFbmQsXG4gICAgICAgIGkgPSBvcHRpb25zLmhvdXJTdGFydCxcbiAgICAgICAgaG91cnMgPSBbXTtcblxuICAgIGZvciAoOyBpIDwgZW5kOyBpICs9IDEpIHtcbiAgICAgICAgaG91cnMucHVzaCh7aG91cjogaX0pO1xuICAgIH1cblxuICAgIHJldHVybiB7aG91cnM6IGhvdXJzfTtcbn07XG5cbi8qKlxuICogUmVjb25jaWxhdGlvbiBjaGlsZCB2aWV3cyBhbmQgcmVuZGVyLlxuICogQHBhcmFtIHtvYmplY3R9IHZpZXdNb2RlbHMgVmlld21vZGVsXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggVGhlIHdpZHRoIHBlcmNlbnQgb2YgZWFjaCB0aW1lIHZpZXcuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgQ29udGFpbmVyIGVsZW1lbnQgZm9yIGVhY2ggdGltZSB2aWV3LlxuICovXG5UaW1lR3JpZC5wcm90b3R5cGUuX3JlbmRlckNoaWxkcyA9IGZ1bmN0aW9uKHZpZXdNb2RlbHMsIHdpZHRoLCBjb250YWluZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgY2hpbGRPcHRpb24sXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBpc1RvZGF5LFxuICAgICAgICB0b2RheSA9IGRhdGV0aW1lLmZvcm1hdChuZXcgRGF0ZSgpLCAnWVlZWU1NREQnKTtcblxuICAgIC8vIGNsZWFyIGNvbnRlbnRzXG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgIHRoaXMuY2hpbGRzLmNsZWFyKCk7XG4gICAgdGhpcy50b2RheW1hcmtlckxlZnQgPSBudWxsO1xuXG4gICAgLy8gcmVjb25jaWxhdGlvbiBvZiBjaGlsZCB2aWV3c1xuICAgIHV0aWwuZm9yRWFjaCh2aWV3TW9kZWxzLCBmdW5jdGlvbihldmVudHMsIHltZCkge1xuICAgICAgICBpc1RvZGF5ID0geW1kID09PSB0b2RheTtcblxuICAgICAgICBpZiAoaXNUb2RheSkge1xuICAgICAgICAgICAgdGhpcy50b2RheW1hcmtlckxlZnQgPSB3aWR0aCAqIHRoaXMuY2hpbGRzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkT3B0aW9uID0ge1xuICAgICAgICAgICAgeW1kOiB5bWQsXG4gICAgICAgICAgICBpc1RvZGF5OiBpc1RvZGF5LFxuICAgICAgICAgICAgaG91clN0YXJ0OiBvcHRpb25zLmhvdXJTdGFydCxcbiAgICAgICAgICAgIGhvdXJFbmQ6IG9wdGlvbnMuaG91ckVuZFxuICAgICAgICB9O1xuXG4gICAgICAgIGNoaWxkID0gbmV3IFRpbWUoXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGNoaWxkT3B0aW9uLFxuICAgICAgICAgICAgZG9tdXRpbC5hcHBlbmRIVE1MRWxlbWVudCgnZGl2JywgY29udGFpbmVyLCBjb25maWcuY2xhc3NuYW1lKCd0aW1lLWRhdGUnKSlcbiAgICAgICAgKTtcbiAgICAgICAgY2hpbGQucmVuZGVyKHltZCwgZXZlbnRzKTtcblxuICAgICAgICB0aGlzLmFkZENoaWxkKGNoaWxkKTtcbiAgICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKiBAcGFyYW0ge29iamVjdH0gdmlld01vZGVsIFZpZXdNb2RlbCBsaXN0IGZyb20gV2VlayB2aWV3LlxuICovXG5UaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24odmlld01vZGVsKSB7XG4gICAgdmFyIHRpbWVWaWV3TW9kZWwgPSB2aWV3TW9kZWwuZXZlbnRzSW5EYXRlUmFuZ2UudGltZSxcbiAgICAgICAgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIsXG4gICAgICAgIGJhc2VWaWV3TW9kZWwgPSB0aGlzLl9nZXRCYXNlVmlld01vZGVsKCksXG4gICAgICAgIGV2ZW50TGVuID0gdXRpbC5rZXlzKHRpbWVWaWV3TW9kZWwpLmxlbmd0aDtcblxuICAgIGlmICghZXZlbnRMZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBtYWluVG1wbChiYXNlVmlld01vZGVsKTtcblxuICAgIC8qKioqKioqKioqXG4gICAgICogUmVuZGVyIGNoaWxkc1xuICAgICAqKioqKioqKioqL1xuICAgIHRoaXMuX3JlbmRlckNoaWxkcyhcbiAgICAgICAgdGltZVZpZXdNb2RlbCxcbiAgICAgICAgMTAwIC8gZXZlbnRMZW4sXG4gICAgICAgIGRvbXV0aWwuZmluZCgnLicgKyBjb25maWcuY2xhc3NuYW1lKCd0aW1lZ3JpZC1ldmVudHMtY29udGFpbmVyJyksIGNvbnRhaW5lcilcbiAgICApO1xuXG4gICAgdGhpcy5faG91ckxhYmVscyA9IGRvbXV0aWwuZmluZCgndWwnLCBjb250YWluZXIpO1xuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiBSZW5kZXIgaG91cm1hcmtlclxuICAgICAqKioqKioqKioqL1xuICAgIHRoaXMuaG91cm1hcmtlciA9IGRvbXV0aWwuZmluZCgnLicgKyBjb25maWcuY2xhc3NuYW1lKCd0aW1lZ3JpZC1ob3VybWFya2VyJyksIGNvbnRhaW5lcik7XG4gICAgdGhpcy5yZWZyZXNoSG91cm1hcmtlcigpO1xuXG4gICAgaWYgKCF0aGlzLl9zY3JvbGxlZCkge1xuICAgICAgICB0aGlzLl9zY3JvbGxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9Ob3coKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlZnJlc2ggaG91cm1hcmtlciBlbGVtZW50LlxuICovXG5UaW1lR3JpZC5wcm90b3R5cGUucmVmcmVzaEhvdXJtYXJrZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaG91ckxhYmVscyA9IHRoaXMuX2hvdXJMYWJlbHMsXG4gICAgICAgIGhvdXJtYXJrZXIgPSB0aGlzLmhvdXJtYXJrZXIsXG5cbiAgICAgICAgdmlld01vZGVsID0gdGhpcy5fZ2V0SG91cm1hcmtlclZpZXdNb2RlbCgpLFxuICAgICAgICB0b2RheW1hcmtlckxlZnQgPSB0aGlzLnRvZGF5bWFya2VyTGVmdCxcbiAgICAgICAgdG9kYXltYXJrZXIsXG4gICAgICAgIHRleHQsXG4gICAgICAgIGxhYmVsVG9WaXNpYmxlLFxuICAgICAgICBsYWJlbFRvSW52aXNpYmxlO1xuXG4gICAgaWYgKCFob3VybWFya2VyIHx8ICF2aWV3TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRvZGF5bWFya2VyID0gZG9tdXRpbC5maW5kKCcuJyArIGNvbmZpZy5jbGFzc25hbWUoJ3RpbWVncmlkLXRvZGF5bWFya2VyJyksIGhvdXJtYXJrZXIpO1xuICAgIHRleHQgPSBkb211dGlsLmZpbmQoJy4nICsgY29uZmlnLmNsYXNzbmFtZSgndGltZWdyaWQtaG91cm1hcmtlci10aW1lJyksIGhvdXJtYXJrZXIpO1xuICAgIGxhYmVsVG9WaXNpYmxlID0gZG9tdXRpbC5maW5kKCcuJyArIGNvbmZpZy5jbGFzc25hbWUoJ2ludmlzaWJsZScpLCBob3VyTGFiZWxzKTtcbiAgICBsYWJlbFRvSW52aXNpYmxlID0gZG9tdXRpbC5maW5kKCcuJyArIGNvbmZpZy5jbGFzc25hbWUoJ3RpbWVncmlkLWhvdXItJykgKyB2aWV3TW9kZWwuaG91ciwgaG91ckxhYmVscyk7XG5cbiAgICByZXFBbmltRnJhbWUucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGxhYmVsVG9WaXNpYmxlICE9PSBsYWJlbFRvSW52aXNpYmxlKSB7XG4gICAgICAgICAgICBpZiAobGFiZWxUb1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBkb211dGlsLnJlbW92ZUNsYXNzKGxhYmVsVG9WaXNpYmxlLCBjb25maWcuY2xhc3NuYW1lKCdpbnZpc2libGUnKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsYWJlbFRvSW52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgZG9tdXRpbC5hZGRDbGFzcyhsYWJlbFRvSW52aXNpYmxlLCBjb25maWcuY2xhc3NuYW1lKCdpbnZpc2libGUnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBob3VybWFya2VyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICBob3VybWFya2VyLnN0eWxlLnRvcCA9ICh2aWV3TW9kZWwudG9wIC0gUElYRUxfUkVOREVSX0VSUk9SKSArICdweCc7XG5cbiAgICAgICAgaWYgKCF1dGlsLmlzTnVsbCh0b2RheW1hcmtlckxlZnQpKSB7XG4gICAgICAgICAgICB0b2RheW1hcmtlci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIHRvZGF5bWFya2VyLnN0eWxlLmxlZnQgPSB0b2RheW1hcmtlckxlZnQgKyAnJSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2RheW1hcmtlci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dC5pbm5lckhUTUwgPSB2aWV3TW9kZWwudGV4dDtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGdyaWQgc2l6ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gVGhlIHNpemUgb2YgZ3JpZCBlbGVtZW50LlxuICovXG5UaW1lR3JpZC5wcm90b3R5cGUuX2dldEdyaWRTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHRoaXMuY29udGFpbmVyLmNoaWxkTm9kZXNbMF07XG5cbiAgICBpZiAoIWNoaWxkTm9kZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbXV0aWwuZ2V0U2l6ZShjaGlsZE5vZGUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RhdGV9IFt0aW1lXSAtIGRhdGUgb2JqZWN0IHRvIGNvbnZlcnQgcGl4ZWwgaW4gZ3JpZHMuXG4gKiB1c2UgKipEYXRlLm5vdygpKiogd2hlbiBub3Qgc3VwcGxpZWQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcGl4ZWwgdmFsdWUgcmVwcmVzZW50IGN1cnJlbnQgdGltZSBpbiBncmlkcy5cbiAqL1xuVGltZUdyaWQucHJvdG90eXBlLl9nZXRUb3BCeVRpbWUgPSBmdW5jdGlvbih0aW1lKSB7XG4gICAgdmFyIG5vdyA9IHV0aWwuaXNEYXRlKHRpbWUpID8gbmV3IERhdGUodGltZS5nZXRUaW1lKCkpIDogbmV3IERhdGUoKSxcbiAgICAgICAgc3RhcnQgPSBkYXRldGltZS5zdGFydChub3cpLFxuICAgICAgICBob3VyU3RhcnQgPSB0aGlzLm9wdGlvbnMuaG91clN0YXJ0LFxuICAgICAgICBncmlkU2l6ZSA9IHRoaXMuX2dldEdyaWRTaXplKCksXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgdG9wO1xuXG4gICAgaWYgKCFncmlkU2l6ZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBvZmZzZXQgPSArbm93IC0gK3N0YXJ0O1xuICAgIGlmIChob3VyU3RhcnQpIHtcbiAgICAgICAgb2Zmc2V0IC09IGRhdGV0aW1lLm1pbGxpc2Vjb25kc0Zyb20oJ2hvdXInLCBob3VyU3RhcnQpO1xuICAgIH1cblxuICAgIHRvcCA9IChvZmZzZXQgKiBncmlkU2l6ZVsxXSkgLyAoZGF0ZXRpbWUubWlsbGlzZWNvbmRzRnJvbSgnaG91cicsIHRoaXMuX2dldEJhc2VWaWV3TW9kZWwoKS5ob3Vycy5sZW5ndGgpKTtcblxuICAgIHJldHVybiB0b3A7XG59O1xuXG4vKipcbiAqIEdldCBIb3VybWFya2VyIHZpZXdtb2RlbC5cbiAqIEByZXR1cm5zIHtvYmplY3R9IFZpZXdNb2RlbCBvZiBob3VybWFya2VyLlxuICovXG5UaW1lR3JpZC5wcm90b3R5cGUuX2dldEhvdXJtYXJrZXJWaWV3TW9kZWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdGhpcy5fZ2V0VG9wQnlUaW1lKCksXG4gICAgICAgIGhvdXI6IG5vdy5nZXRIb3VycygpLFxuICAgICAgICB0ZXh0OiBkYXRldGltZS5mb3JtYXQobm93LCAnSEg6bW0nKVxuICAgIH07XG59O1xuXG4vKipcbiAqIEF0dGFjaCBldmVudHNcbiAqL1xuVGltZUdyaWQucHJvdG90eXBlLmF0dGFjaEV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElEKTtcbiAgICB0aGlzLmludGVydmFsSUQgPSB3aW5kb3cuc2V0SW50ZXJ2YWwodXRpbC5iaW5kKHRoaXMub25UaWNrLCB0aGlzKSwgSE9VUk1BUktFUl9SRUZSRVNIX0lOVEVSVkFMKTtcbn07XG5cbi8qKlxuICogU2Nyb2xsIHRpbWUgZ3JpZCB0byBjdXJyZW50IGhvdXJtYXJrZXIuXG4gKi9cblRpbWVHcmlkLnByb3RvdHlwZS5zY3JvbGxUb05vdyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdXJyZW50SG91clRvcCA9IHRoaXMuX2dldFRvcEJ5VGltZSgpLFxuICAgICAgICB2aWV3Qm91bmQgPSB0aGlzLmdldFZpZXdCb3VuZCgpLFxuICAgICAgICBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcblxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBjb250YWluZXIuc2Nyb2xsVG9wID0gKGN1cnJlbnRIb3VyVG9wIC0gKHZpZXdCb3VuZC5oZWlnaHQgLyAyKSk7XG4gICAgfSwgSU5JVElBTF9BVVRPU0NST0xMX0RFTEFZKTtcbn07XG5cbi8qKioqKioqKioqXG4gKiBDYWxFdmVudCBoYW5kbGVyc1xuICoqKioqKioqKiovXG5cbi8qKlxuICogSW50ZXJ2YWwgdGljayBoYW5kbGVyXG4gKi9cblRpbWVHcmlkLnByb3RvdHlwZS5vblRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlZnJlc2hIb3VybWFya2VyKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVHcmlkO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVmlldyBvZiBkYXlzIFVJLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwudHVpLnV0aWw7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vY29uZmlnJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBWaWV3ID0gcmVxdWlyZSgnLi4vdmlldycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCYXNlLldlZWt9IGNvbnRyb2xsZXIgVGhlIGNvbnRyb2xsZXIgbWl4aW4gcGFydC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFZpZXcgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlbmRlclN0YXJ0RGF0ZV0gU3RhcnQgZGF0ZSBvZiByZW5kZXIuIGlmIG5vdCBzdXBwbGllZCB0aGVuIHVzZSAtM2QgZnJvbSB0b2RheS4gWVlZWS1NTS1ERCBmb3JtYXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucmVuZGVyRW5kRGF0ZV0gRW5kIGRhdGUgb2YgcmVuZGVyLiBpZiBub3Qgc3VwcGxpZWQgdGhlbiB1c2UgKzNkIGZyb20gdG9kYXkuIFlZWVktTU0tREQgZm9ybWF0LlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNzc1ByZWZpeF0gLSBDU1MgY2xhc3NuYW1lIHByZWZpeFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIFRoZSBlbGVtZW50IHRvIHVzZSBjb250YWluZXIgZm9yIHRoaXMgdmlldy5cbiAqIEBleHRlbmRzIHtWaWV3fVxuICovXG5mdW5jdGlvbiBXZWVrKGNvbnRyb2xsZXIsIG9wdGlvbnMsIGNvbnRhaW5lcikge1xuICAgIHZhciByYW5nZTtcblxuICAgIGNvbnRhaW5lciA9IGRvbXV0aWwuYXBwZW5kSFRNTEVsZW1lbnQoJ2RpdicsIGNvbnRhaW5lcik7XG5cbiAgICBWaWV3LmNhbGwodGhpcywgY29udGFpbmVyKTtcblxuICAgIGRvbXV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCBjb25maWcuY2xhc3NuYW1lKCd3ZWVrLWNvbnRhaW5lcicpKTtcblxuICAgIHJhbmdlID0gdGhpcy5fZ2V0UmVuZGVyRGF0ZVJhbmdlKG5ldyBEYXRlKCkpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge29iamVjdH0gT3B0aW9ucyBmb3Igdmlldy5cbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgIHJlbmRlclN0YXJ0RGF0ZTogZGF0ZXRpbWUuZm9ybWF0KHJhbmdlLnN0YXJ0LCAnWVlZWS1NTS1ERCcpLFxuICAgICAgICByZW5kZXJFbmREYXRlOiBkYXRldGltZS5mb3JtYXQocmFuZ2UuZW5kLCAnWVlZWS1NTS1ERCcpXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBXZWVrIGNvbnRyb2xsZXIgbWl4aW4uXG4gICAgICogQHR5cGUge0Jhc2UuV2Vla31cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xufVxuXG51dGlsLmluaGVyaXQoV2VlaywgVmlldyk7XG5cbi8qKioqKioqKioqXG4gKiBPdmVycmlkZSBwcm9wc1xuICoqKioqKioqKiovXG5cbi8qKlxuICogUmVuZGVyIGVhY2ggY2hpbGQgdmlldyB3aXRoIGV2ZW50cyBpbiByYW5nZXMuXG4gKiBAZmlyZXMgV2VlayNhZnRlclJlbmRlclxuICogQG92ZXJyaWRlXG4gKi9cbldlZWsucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICByZW5kZXJTdGFydERhdGUgPSBkYXRldGltZS5wYXJzZShvcHRpb25zLnJlbmRlclN0YXJ0RGF0ZSksXG4gICAgICAgIHJlbmRlckVuZERhdGUgPSBkYXRldGltZS5wYXJzZShvcHRpb25zLnJlbmRlckVuZERhdGUpLFxuICAgICAgICBldmVudHNJbkRhdGVSYW5nZSA9IHRoaXMuY29udHJvbGxlci5maW5kQnlEYXRlUmFuZ2UoXG4gICAgICAgICAgICBkYXRldGltZS5zdGFydChyZW5kZXJTdGFydERhdGUpLFxuICAgICAgICAgICAgZGF0ZXRpbWUuZW5kKHJlbmRlckVuZERhdGUpXG4gICAgICAgICksXG4gICAgICAgIHZpZXdNb2RlbCA9IHtcbiAgICAgICAgICAgIGV2ZW50c0luRGF0ZVJhbmdlOiBldmVudHNJbkRhdGVSYW5nZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXJ0RGF0ZTogcmVuZGVyU3RhcnREYXRlLFxuICAgICAgICAgICAgcmVuZGVyRW5kRGF0ZTogcmVuZGVyRW5kRGF0ZVxuICAgICAgICB9O1xuXG4gICAgdGhpcy5jaGlsZHMuZWFjaChmdW5jdGlvbihjaGlsZFZpZXcpIHtcbiAgICAgICAgY2hpbGRWaWV3LnJlbmRlcih2aWV3TW9kZWwpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFdlZWsjYWZ0ZXJSZW5kZXJcbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ2FmdGVyUmVuZGVyJyk7XG59O1xuXG4vKioqKioqKioqKlxuICogUHJvdG90eXBlIHByb3BzXG4gKioqKioqKioqKi9cblxuV2Vlay5wcm90b3R5cGUudmlld05hbWUgPSAnd2Vlayc7XG5cbi8qKlxuICogQ2FsY3VsYXRlIGRlZmF1bHQgcmVuZGVyIGRhdGUgcmFuZ2UgZnJvbSBzdXBwbGllZCBkYXRlLlxuICogQHBhcmFtIHtEYXRlfSBiYXNlRGF0ZSBiYXNlIGRhdGUuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBkYXRlIHJhbmdlLlxuICovXG5XZWVrLnByb3RvdHlwZS5fZ2V0UmVuZGVyRGF0ZVJhbmdlID0gZnVuY3Rpb24oYmFzZURhdGUpIHtcbiAgICB2YXIgYmFzZSA9IGRhdGV0aW1lLnN0YXJ0KGJhc2VEYXRlKSxcbiAgICAgICAgc3RhcnQgPSBuZXcgRGF0ZSgrYmFzZSksXG4gICAgICAgIGVuZCA9IG5ldyBEYXRlKCtiYXNlKTtcblxuICAgIHN0YXJ0LnNldERhdGUoc3RhcnQuZ2V0RGF0ZSgpIC0gMyk7XG4gICAgZW5kLnNldERhdGUoZW5kLmdldERhdGUoKSArIDMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZFxuICAgIH07XG59O1xuXG51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihXZWVrKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWVrO1xuXG4iXX0=
