(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
/**
 * ██████╗   ██████╗   ██████╗  ██████╗   █████╗  ██╗   ██╗ ██╗
 * ██╔══██╗ ██╔═══██╗ ██╔═══██╗ ██╔══██╗ ██╔══██╗ ╚██╗ ██╔╝ ██║
 * ██║  ██║ ██║   ██║ ██║   ██║ ██████╔╝ ███████║  ╚████╔╝  ██║
 * ██║  ██║ ██║   ██║ ██║   ██║ ██╔══██╗ ██╔══██║   ╚██╔╝   ╚═╝
 * ██████╔╝ ╚██████╔╝ ╚██████╔╝ ██║  ██║ ██║  ██║    ██║    ██╗
 * ╚═════╝   ╚═════╝   ╚═════╝  ╚═╝  ╚═╝ ╚═╝  ╚═╝    ╚═╝    ╚═╝
 *
 *  ██████╗  █████╗  ██╗      ███████╗ ███╗   ██╗ ██████╗   █████╗  ██████╗
 * ██╔════╝ ██╔══██╗ ██║      ██╔════╝ ████╗  ██║ ██╔══██╗ ██╔══██╗ ██╔══██╗
 * ██║      ███████║ ██║      █████╗   ██╔██╗ ██║ ██║  ██║ ███████║ ██████╔╝
 * ██║      ██╔══██║ ██║      ██╔══╝   ██║╚██╗██║ ██║  ██║ ██╔══██║ ██╔══██╗
 * ╚██████╗ ██║  ██║ ███████╗ ███████╗ ██║ ╚████║ ██████╔╝ ██║  ██║ ██║  ██║
 *  ╚═════╝ ╚═╝  ╚═╝ ╚══════╝ ╚══════╝ ╚═╝  ╚═══╝ ╚═════╝  ╚═╝  ╚═╝ ╚═╝  ╚═╝
 * @version 0.1.6
 */
/* eslint vars-on-top:0, strict:0 */

/**********
 * Common
 **********/
require('code-snippet');
require('./src/js/view/template/registerHelpers');
var dirty = require('./src/js/common/dirty');
var datetime = require('./src/js/common/datetime');
var array = require('./src/js/common/array');
var domevent = require('./src/js/common/domevent');
var domutil = require('./src/js/common/domutil');
var Colleciton = require('./src/js/common/collection');
var model = require('./src/js/common/model');
var common = require('./src/js/common/common');
var reqAnimFrame = require('./src/js/common/reqAnimFrame');
var AJAX = require('./src/js/common/ajax');

/**********
 * Models
 **********/
var Point = require('./src/js/common/point');
var Event = require('./src/js/model/event');

/**********
 * Views
 **********/
var View = require('./src/js/view/view');
var MonthWeek = require('./src/js/view/monthweek');

var Week = require('./src/js/view/week/week');
var DayName = require('./src/js/view/week/dayname');
var TimeGrid = require('./src/js/view/week/timeGrid');
var Time = require('./src/js/view/week/time');


/**********
 * View Models
 **********/
var EventViewModel = require('./src/js/model/viewModel/event');

/**********
 * Handlers
 **********/
var Drag = require('./src/js/handler/drag');
var TimeCore = require('./src/js/handler/time/core');
var TimeClick = require('./src/js/handler/time/click');
var TimeCreation = require('./src/js/handler/time/creation');
var TimeCreationGuide = require('./src/js/handler/time/creationGuide');
var TimeMove = require('./src/js/handler/time/move');
var TimeMoveGuide = require('./src/js/handler/time/moveGuide');
var TimeResize = require('./src/js/handler/time/resize');
var TimeResizeGuide = require('./src/js/handler/time/resizeGuide');

var AlldayCore = require('./src/js/handler/allday/core');
var AlldayClick = require('./src/js/handler/allday/click');
var AlldayCreation = require('./src/js/handler/allday/creation');
var AlldayCreationGuide = require('./src/js/handler/allday/creationGuide');
var AlldayMove = require('./src/js/handler/allday/move');
var AlldayMoveGuide = require('./src/js/handler/allday/moveGuide');
var AlldayResize = require('./src/js/handler/allday/resize');
var AlldayResizeGuide = require('./src/js/handler/allday/resizeGuide');

/**********
 * Factory
 **********/
var controllerFactory = require('./src/js/factory/controller');

/**********
 * SERVICE MODULE
 **********/
var MiniCalendar = require('./src/js/dooray/view/minicalendar');
var DoorayEvent = require('./src/js/dooray/model/event');
var DoorayController = require('./src/js/dooray/controller/base');
var TaskView = require('./src/js/dooray/view/taskview');
var MilestoneClick = require('./src/js/dooray/handler/milestoneClick');
var TaskClick = require('./src/js/dooray/handler/taskClick');

/** @namespace ne.dooray.calendar */

global.ne.util.defineNamespace('ne.dooray.calendar', {
    // common
    dirty: dirty,
    datetime: datetime,
    array: array,
    domevent: domevent,
    domutil: domutil,
    Collection: Colleciton,
    model: model,
    common: common,
    reqAnimFrame: reqAnimFrame,
    AJAX: AJAX,
    Point: Point, 

    // model
    Event: Event,
    EventViewModel: EventViewModel,

    // view
    View: View,
    Week: Week,
    DayName: DayName,
    TimeGrid: TimeGrid,
    Time: Time,
    MonthWeek: MonthWeek,

    // handler, guide
    Drag: Drag,

    TimeCore: TimeCore,
    TimeClick: TimeClick,
    TimeCreation: TimeCreation,
    TimeCreationGuide: TimeCreationGuide,
    TimeMove: TimeMove,
    TimeMoveGuide: TimeMoveGuide,
    TimeResize: TimeResize,
    TimeResizeGuide: TimeResizeGuide,

    AlldayCore: AlldayCore,
    AlldayClick: AlldayClick,
    AlldayCreation: AlldayCreation,
    AlldayCreationGuide: AlldayCreationGuide,
    AlldayMove: AlldayMove,
    AlldayMoveGuide: AlldayMoveGuide,
    AlldayResize: AlldayResize,
    AlldayResizeGuide: AlldayResizeGuide,

    // only for test
    ControllerFactory: controllerFactory,

    // service modules
    DoorayEvent: DoorayEvent,
    DoorayController: DoorayController,
    MiniCalendar: MiniCalendar,
    TaskView: TaskView,
    MilestoneClick: MilestoneClick,
    TaskClick: TaskClick
});

/**********
 * Calendar Factory
 **********/

var Calendar = require('./src/js/factory/calendar');
var ServiceCalendar = require('./src/js/dooray/factory/calendar');

global.ne.dooray.calendar.OriginCalendar = function (options, container) {
    return new Calendar(options, container);
};

global.ne.dooray.calendar.Calendar = function(options, container) {
    return new ServiceCalendar(options, container);
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./src/js/common/ajax":23,"./src/js/common/array":24,"./src/js/common/collection":26,"./src/js/common/common":27,"./src/js/common/datetime":28,"./src/js/common/dirty":29,"./src/js/common/domevent":30,"./src/js/common/domutil":31,"./src/js/common/model":32,"./src/js/common/point":33,"./src/js/common/reqAnimFrame":34,"./src/js/dooray/controller/base":37,"./src/js/dooray/factory/calendar":38,"./src/js/dooray/handler/milestoneClick":40,"./src/js/dooray/handler/taskClick":41,"./src/js/dooray/model/event":42,"./src/js/dooray/view/minicalendar":46,"./src/js/dooray/view/taskview":48,"./src/js/factory/calendar":50,"./src/js/factory/controller":51,"./src/js/handler/allday/click":53,"./src/js/handler/allday/core":54,"./src/js/handler/allday/creation":55,"./src/js/handler/allday/creationGuide":56,"./src/js/handler/allday/move":57,"./src/js/handler/allday/moveGuide":58,"./src/js/handler/allday/resize":59,"./src/js/handler/allday/resizeGuide":60,"./src/js/handler/drag":61,"./src/js/handler/time/click":62,"./src/js/handler/time/core":63,"./src/js/handler/time/creation":64,"./src/js/handler/time/creationGuide":65,"./src/js/handler/time/move":66,"./src/js/handler/time/moveGuide":67,"./src/js/handler/time/resize":68,"./src/js/handler/time/resizeGuide":69,"./src/js/model/event":70,"./src/js/model/viewModel/event":71,"./src/js/view/monthweek":73,"./src/js/view/template/registerHelpers":77,"./src/js/view/view":82,"./src/js/view/week/dayname":84,"./src/js/view/week/time":85,"./src/js/view/week/timeGrid":86,"./src/js/view/week/week":87,"code-snippet":2}],2:[function(require,module,exports){
/*!code-snippet v1.0.4 | NHN Entertainment*/
/**********
 * array.js
 **********/

/**
 * @fileoverview This module has some functions for handling array.
 * @author NHN Ent.
 *         FE Development Team <jiung.kang@nhnent.com>
 * @dependency type.js
 */

(function(ne) {
    'use strict';
    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    var aps = Array.prototype.slice;

    /**
     * Generate an integer Array containing an arithmetic progression.
     * @param {number} start
     * @param {number} stop
     * @param {number} step
     * @memberof ne.util
     * @returns {Array}
     * @example
     *
     *   var arr = ne.util.range(5);
     *   console.log(arr); // [0,1,2,3,4]
     *
     *   arr = ne.util.range(1, 5);
     *   console.log(arr); // [1,2,3,4]
     *
     *   arr = ne.util.range(2, 10, 2);
     *   console.log(arr); // [2,4,6,8]
     *
     *   arr = ne.util.range(10, 2, -2);
     *   console.log(arr); // [10,8,6,4]
     */
    var range = function(start, stop, step) {
        var arr = [],
            flag;

        if (ne.util.isUndefined(stop)) {
            stop = start || 0;
            start = 0;
        }

        step = step || 1;
        flag = step < 0 ? -1 : 1;
        stop *= flag;

        for(; start * flag < stop; start += step) {
            arr.push(start);
        }

        return arr;
    };

    /**
     * Zip together multiple lists into a single array
     * @param {...Array}
     * @memberof ne.util
     * @returns {Array}
     * @example
     *
     *   var result = ne.util.zip([1, 2, 3], ['a', 'b','c'], [true, false, true]);
     *
     *   console.log(result[0]); // [1, 'a', true]
     *   console.log(result[1]); // [2, 'b', false]
     *   console.log(result[2]); // [3, 'c', true]
     */
    var zip = function() {
        var arr2d = aps.call(arguments),
            result = [];

        ne.util.forEach(arr2d, function(arr) {
            ne.util.forEach(arr, function(value, index) {
                if (!result[index]) {
                    result[index] = [];
                }
                result[index].push(value);
            });
        });

        return result;
    };

    ne.util.range = range;
    ne.util.zip = zip;
})(window.ne);
/**********
 * browser.js
 **********/

/**
 * @fileoverview This module detects the kind of well-known browser and version.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @namespace ne.util
 */

(function(ne) {
    'use strict';
    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    /* istanbul ignore if */
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * This object has an information that indicate the kind of browser.<br>
     * The list below is a detectable browser list.
     *  - ie7 ~ ie11
     *  - chrome
     *  - firefox
     *  - safari
     * @memberof ne.util
     * @example
     *  ne.util.browser.chrome === true;    // chrome
     *  ne.util.browser.firefox === true;    // firefox
     *  ne.util.browser.safari === true;    // safari
     *  ne.util.browser.msie === true;    // IE
     *  ne.util.browser.other === true;    // other browser
     *  ne.util.browser.version;    // browser version
     */
    var browser = {
        chrome: false,
        firefox: false,
        safari: false,
        msie: false,
        others: false,
        version: 0
    };

    var nav = window.navigator,
        appName = nav.appName.replace(/\s/g, '_'),
        userAgent = nav.userAgent;

    var rIE = /MSIE\s([0-9]+[.0-9]*)/,
        rIE11 = /Trident.*rv:11\./,
        versionRegex = {
            'firefox': /Firefox\/(\d+)\./,
            'chrome': /Chrome\/(\d+)\./,
            'safari': /Version\/([\d\.]+)\sSafari\/(\d+)/
        };

    var key, tmp;

    var detector = {
        'Microsoft_Internet_Explorer': function() {
            // ie8 ~ ie10
            browser.msie = true;
            browser.version = parseFloat(userAgent.match(rIE)[1]);
        },
        'Netscape': function() {
            var detected = false;

            if (rIE11.exec(userAgent)) {
                browser.msie = true;
                browser.version = 11;
            } else {
                for (key in versionRegex) {
                    if (versionRegex.hasOwnProperty(key)) {
                        tmp = userAgent.match(versionRegex[key]);
                        if (tmp && tmp.length > 1) {
                            browser[key] = detected = true;
                            browser.version = parseFloat(tmp[1] || 0);
                            break;
                        }
                    }
                }
            }
            if (!detected) {
                browser.others = true;
            }
        }
    };

    detector[appName]();
    ne.util.browser = browser;
})(window.ne);

/**********
 * collection.js
 **********/

/**
 * @fileoverview This module has some functions for handling object as collection.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency type.js, object.js
 */

(function(ne) {
    'use strict';
    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * This variable saves whether the 'indexOf' method is in Array.prototype or not.<br>
     * And it will be checked only once when the page is loaded.
     * @type {boolean}
     */
    var hasIndexOf = !!Array.prototype.indexOf;

    /**
     * Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.<br>
     * If the callback function returns false, the loop will be stopped.<br>
     * Callback function(iteratee) is invoked with three arguments:
     *  - The value of the element
     *  - The index of the element
     *  - The array(or Array-like object) being traversed
     * @param {Array} arr The array(or Array-like object) that will be traversed
     * @param {function} iteratee Callback function
     * @param {Object} [context] Context(this) of callback function
     * @memberof ne.util
     * @example
     *  var sum = 0;
     *
     *  forEachArray([1,2,3], function(value){
     *      sum += value;
     *   });
     *  alert(sum); // 6
     */
    function forEachArray(arr, iteratee, context) {
        var index = 0,
            len = arr.length;

        context = context || null;

        for (; index < len; index++) {
            if (iteratee.call(context, arr[index], index, arr) === false) {
                break;
            }
        }
    }


    /**
     * Execute the provided callback once for each property of object which actually exist.<br>
     * If the callback function returns false, the loop will be stopped.<br>
     * Callback function(iteratee) is invoked with three arguments:
     *  - The value of the property
     *  - The name of the property
     *  - The object being traversed
     * @param {Object} obj The object that will be traversed
     * @param {function} iteratee  Callback function
     * @param {Object} [context] Context(this) of callback function
     * @memberof ne.util
     * @example
     *  var sum = 0;
     *
     *  forEachOwnProperties({a:1,b:2,c:3}, function(value){
     *      sum += value;
     *  });
     *  alert(sum); // 6
     **/
    function forEachOwnProperties(obj, iteratee, context) {
        var key;

        context = context || null;

        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (iteratee.call(context, obj[key], key, obj) === false) {
                    break;
                }
            }
        }
    }

    /**
     * Execute the provided callback once for each property of object(or element of array) which actually exist.<br>
     * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).<br>
     * If the callback function returns false, the loop will be stopped.<br>
     * Callback function(iteratee) is invoked with three arguments:
     *  - The value of the property(or The value of the element)
     *  - The name of the property(or The index of the element)
     *  - The object being traversed
     * @param {Object} obj The object that will be traversed
     * @param {function} iteratee Callback function
     * @param {Object} [context] Context(this) of callback function
     * @memberof ne.util
     * @example
     *  //ex1
     *  var sum = 0;
     *
     *  forEach([1,2,3], function(value){
     *      sum += value;
     *  });
     *  alert(sum); // 6
     *
     *  //ex2 - In case of Array-like object
     *  function sum(){
     *      var factors = Array.prototype.slice.call(arguments);
     *      forEach(factors, function(value){
     *           //......
     *      });
     *  }
     */
    function forEach(obj, iteratee, context) {
        if (ne.util.isArray(obj)) {
            ne.util.forEachArray(obj, iteratee, context);
        } else {
            ne.util.forEachOwnProperties(obj, iteratee, context);
        }
    }

    /**
     * Execute the provided callback function once for each element in an array, in order, and constructs a new array from the results.<br>
     * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of forEach example)<br>
     * Callback function(iteratee) is invoked with three arguments:
     *  - The value of the property(or The value of the element)
     *  - The name of the property(or The index of the element)
     *  - The object being traversed
     * @param {Object} obj The object that will be traversed
     * @param {function} iteratee Callback function
     * @param {Object} [context] Context(this) of callback function
     * @returns {Array} A new array composed of returned values from callback function
     * @memberof ne.util
     * @example
     *  var result = map([0,1,2,3], function(value) {
     *      return value + 1;
     *  });
     *
     *  alert(result);  // 1,2,3,4
     */
    function map(obj, iteratee, context) {
        var resultArray = [];

        context = context || null;

        ne.util.forEach(obj, function() {
            resultArray.push(iteratee.apply(context, arguments));
        });

        return resultArray;
    }

    /**
     * Execute the callback function once for each element present in the array(or Array-like object or plain object).<br>
     * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of forEach example)<br>
     * Callback function(iteratee) is invoked with four arguments:
     *  - The previousValue
     *  - The currentValue
     *  - The index
     *  - The object being traversed
     * @param {Object} obj The object that will be traversed
     * @param {function} iteratee Callback function
     * @param {Object} [context] Context(this) of callback function
     * @returns {*} The result value
     * @memberof ne.util
     * @example
     *  var result = reduce([0,1,2,3], function(stored, value) {
     *      return stored + value;
     *  });
     *
     *  alert(result); // 6
     */
    function reduce(obj, iteratee, context) {
        var keys,
            index = 0,
            length,
            store;

        context = context || null;

        if (!ne.util.isArray(obj)) {
            keys = ne.util.keys(obj);
        }

        length = keys ? keys.length : obj.length;

        store = obj[keys ? keys[index++] : index++];

        for (; index < length; index++) {
            store = iteratee.call(context, store, obj[keys ? keys[index] : index]);
        }

        return store;
    }
    /**
     * Transform the Array-like object to Array.<br>
     * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.
     * @param {*} arrayLike Array-like object
     * @return {Array} Array
     * @memberof ne.util
     * @example
     *  var arrayLike = {
     *      0: 'one',
     *      1: 'two',
     *      2: 'three',
     *      3: 'four',
     *      length: 4
     *  };
     *  var result = toArray(arrayLike);
     *
     *  alert(result instanceof Array); // true
     *  alert(result); // one,two,three,four
     */
    function toArray(arrayLike) {
        var arr;
        try {
            arr = Array.prototype.slice.call(arrayLike);
        } catch (e) {
            arr = [];
            forEachArray(arrayLike, function(value) {
                arr.push(value);
            });
        }
        return arr;
    }

    /**
     * Create a new array or plain object with all elements(or properties) that pass the test implemented by the provided function.<br>
     * Callback function(iteratee) is invoked with three arguments:
     *  - The value of the property(or The value of the element)
     *  - The name of the property(or The index of the element)
     *  - The object being traversed
     * @param {Object} obj Object(plain object or Array) that will be traversed
     * @param {function} iteratee Callback function
     * @param {Object} [context] Context(this) of callback function
     * @returns {Object} plain object or Array
     * @memberof ne.util
     * @example
     *  var result1 = filter([0,1,2,3], function(value) {
     *      return (value % 2 === 0);
     *  });
     *  alert(result1); // 0,2
     *
     *  var result2 = filter({a : 1, b: 2, c: 3}, function(value) {
     *      return (value % 2 !== 0);
     *  });
     *  alert(result2.a); // 1
     *  alert(result2.b); // undefined
     *  alert(result2.c); // 3
     */
    var filter = function(obj, iteratee, context) {
        var result,
            add;

        context = context || null;

        if (!ne.util.isObject(obj) || !ne.util.isFunction(iteratee)) {
            throw new Error('wrong parameter');
        }

        if (ne.util.isArray(obj)) {
            result = [];
            add = function(result, args) {
                result.push(args[0]);
            };
        } else {
            result = {};
            add = function(result, args) {
                result[args[1]] = args[0];
            };
        }

        ne.util.forEach(obj, function() {
            if (iteratee.apply(context, arguments)) {
                add(result, arguments);
            }
        }, context);

        return result;
    };

    /**
     * Returns the first index at which a given element can be found in the array from start index(default 0), or -1 if it is not present.<br>
     * It compares searchElement to elements of the Array using strict equality (the same method used by the ===, or triple-equals, operator).
     * @param {*} searchElement Element to locate in the array
     * @param {Array} array Array that will be traversed.
     * @param {number} startIndex Start index in array for searching (default 0)
     * @memberof ne.util
     * @return {number} the First index at which a given element, or -1 if it is not present
     * @example
     *
     *   var arr = ['one', 'two', 'three', 'four'],
     *       idx1,
     *       idx2;
     *
     *   idx1 = ne.util.inArray('one', arr, 3);
     *   alert(idx1); // -1
     *
     *   idx2 = ne.util.inArray('one', arr);
     *   alert(idx2); // 0
     */
    var inArray = function(searchElement, array, startIndex) {
        if (!ne.util.isArray(array)) {
            return -1;
        }

        if (hasIndexOf) {
            return Array.prototype.indexOf.call(array, searchElement, startIndex);
        }

        var i,
            length = array.length;

        // set startIndex
        if (ne.util.isUndefined(startIndex)) {
            startIndex = 0;
        } else if (startIndex >= length || startIndex < 0) {
            return -1;
        }

        // search
        for (i = startIndex; i < length; i++) {
            if (array[i] === searchElement) {
                return i;
            }
        }

        return -1;
    };

    /**
     * fetching a property
     * @param {Array} arr target collection
     * @param {String|Number} property property name
     * @memberof ne.util
     * @returns {Array}
     * @example
     *   var objArr = [
     *         {'abc': 1, 'def': 2, 'ghi': 3},
     *         {'abc': 4, 'def': 5, 'ghi': 6},
     *         {'abc': 7, 'def': 8, 'ghi': 9}
     *       ],
     *       arr2d = [
     *         [1, 2, 3],
     *         [4, 5, 6],
     *         [7, 8, 9]
     *       ],
     *       result;
     *
     *   result = ne.util.pluck(objArr, 'abc');
     *   console.log(result) // [1, 4, 7]
     *
     *   result = ne.util.pluck(arr2d, 2);
     *   console.log(result) // [3, 6, 9]
     */
    var pluck = function(arr, property) {
        var result = ne.util.map(arr, function(item) {
            return item[property];
        });
        return result;
    };

    ne.util.forEachOwnProperties = forEachOwnProperties;
    ne.util.forEachArray = forEachArray;
    ne.util.forEach = forEach;
    ne.util.toArray = toArray;
    ne.util.map = map;
    ne.util.reduce = reduce;
    ne.util.filter = filter;
    ne.util.inArray = inArray;
    ne.util.pluck = pluck;

})(window.ne);

/**********
 * customEvent.js
 **********/

/**
 * @fileoverview
 *  This module provides some functions for custom events.<br>
 *  And it is implemented in the observer design pattern.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency type.js, collection.js object.js
 */

(function(ne) {
    'use strict';
    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }

    /* istanbul ignore if */
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * A unit of event handler item.
     * @ignore
     * @typedef {Object} handlerItem
     * @property {function} fn - event handler
     * @property {*} ctx - context of event handler
     */

    /**
     * A data structure for storing handlerItems bound with a specific context
     *  and is a unit item of ctxEvents.<br>
     * Handlers in this item, will be executed with same event.
     * @ignore
     * @typedef {Object.<string, handlerItem>} ctxEventsItem
     * @example
     *  ctxEventsItem = {
     *      1_1: {
     *          fn: function(){...},
     *          ctx: context1
     *      },
     *      2_1: {
     *          fn: function(){...},
     *          ctx: context1
     *      }
     *  }
     */

    /**
     * A data structure for storing ctxEventsItem and length for each event(or event name).
     * @ignore
     * @typedef {Object.<string, (ctxEventsItem|number)>} ctxEvents
     * @example
     *  ctxEvents = {
     *      eventName1_idx: {
     *          1_1: {
     *              fn: function(){...},
     *              ctx: context1
     *          },
     *          2_1: {
     *              fn: function(){...},
     *              ctx: context1
     *          }
     *      },
     *      eventName1_len: 2,
     *      eventName2_idx: {
     *          3_2: {
     *              fn: function(){...},
     *              ctx: context2
     *          },
     *          4_2: {
     *              fn: function(){...},
     *              ctx: context2
     *          }
     *      },
     *      eventName2_len: 2
     *  };
     */


    /**
     * @constructor
     * @memberof ne.util
     */
    function CustomEvents() {
        /**
         * Caching a data structure that has normal event handlers which are not bound with a specific context.
         * @type {object.<string, handlerItem[]>}
         * @private
         */
        this._events = null;

        /**
         * Caching a {ctxEvents}
         * @type {ctxEvents}
         * @private
         */
        this._ctxEvents = null;
    }


    /**********
     * static
     **********/

    /**
     * Use for making a constructor to be able to do CustomEvent's functions.
     * @param {function} func - Constructor
     * @example
     *  function Model() {
     *      this.name = '';
     *  }
     *  ne.util.CustomEvents.mixin(Model);
     *
     *  var model = new Model();
     *  model.on('change', function() { this.name = 'model'; }, this);
     *  model.fire('change');
     *  alert(model.name); // 'model';
     */
    CustomEvents.mixin = function(func) {
        ne.util.extend(func.prototype, CustomEvents.prototype);
    };

    /**********
     * private
     **********/

    /**
     * Work similarly to Array.prototype.forEach(),
     *  however does Array.prototype.splice() additionally.<br>
     * Callback(iteratee) function is invoked with four arguments:
     *  - The value of the element
     *  - The index of the element
     *  - The array being traversed
     *  - A special callback function that decreases the length of array
     * @param {Array} arr - Array that will be traversed
     * @param {function} iteratee - Callback function
     */
    CustomEvents.prototype._forEachArraySplice = function(arr, iteratee) {
        var i,
            len,
            item,
            decrease = function() {
                arr.splice(i, 1);
                len -= 1;
                i -= 1;
            };

        if (!ne.util.isExisty(arr) || !ne.util.isArray(arr)) {
            return;
        }

        for (i = 0, len = arr.length; i < len; i++) {
            item = arr[i];

            if (iteratee(item, i, arr, decrease) === false) {
                return;
            }
        }
    };

    /**********
     * context event handler
     **********/

    /**
     * Execute the callback once for each ctxEventsItem.<br>
     * Callback function(iteratee) is invoked with three arguments:
     *  - {ctxEventsItem} A unit item of ctxEvents
     *  - {string} A key (ex - 'eventName_idx' or 'eventName_len')
     *  - {ctxEvents} A ctxEvents being traversed
     * @param {function} iteratee - Callback function
     * @private
     */
    CustomEvents.prototype._eachCtxEvents = function(iteratee) {
        var events = this._ctxEvents;
        ne.util.forEachOwnProperties(events, iteratee);
    };

    /**
     * Execute the callback once
     *  for each handler item that is value of the key including a specific string(=id, arguments[1]).<br>
     * Callback function(iteratee) is invoked with two arguments:
     *  - handlerItem
     *  - handlerItemId
     * @param {ctxEventsItem} ctxEventsItem - A data structure storing handlerItems.
     * @param {string} id - An id of handler for searching
     * @param {function} iteratee - Callback function
     * @private
     */
    CustomEvents.prototype._eachCtxHandlerItemByContainId = function(ctxEventsItem, id, iteratee) {
        ne.util.forEachOwnProperties(ctxEventsItem, function(handlerItem, handlerItemId) {
            if (handlerItemId.indexOf(id) > -1) {
                iteratee(handlerItem, handlerItemId);
            }
        });
    };

    /**
     * Execute the callback once
     *  for each case of when the provided handler(arguments[0]) is equal to a handler in ctxEventsItem.<br>
     * Callback function(iteratee) is invoked with four arguments:
     *  - handlerItem
     *  - handlerItemId
     *  - ctxEventsItem
     *  - eventKey, A Name of custom event (ex - 'eventName_idx')
     * @param {function} handler - Event handler
     * @param {function} iteratee - Callback function
     * @private
     */
    CustomEvents.prototype._eachCtxEventByHandler = function(handler, iteratee) {
        var handlerId = ne.util.stamp(handler),
            eachById = this._eachCtxHandlerItemByContainId;

        this._eachCtxEvents(function(ctxEventsItem, eventKey) {
            eachById(ctxEventsItem, handlerId, function(handlerItem, handlerItemId) {
                iteratee(handlerItem, handlerItemId, ctxEventsItem, eventKey);
            });
        });
    };

    /**
     * Execute the callback once
     *  for each case of when the provided context(arguments[0]) is equal to a context in ctxEventsItem.<br>
     * Callback function(iteratee) is invoked with four arguments:
     *  - handlerItem
     *  - handlerItemId
     *  - ctxEventsItem
     *  - eventKey, A Name of custom event with postfix (ex - 'eventName_idx')
     * @param {*} context - Context for searching
     * @param {function} iteratee - Callback function
     * @private
     */
    CustomEvents.prototype._eachCtxEventByContext = function(context, iteratee) {
        var contextId = ne.util.stamp(context),
            eachById = this._eachCtxHandlerItemByContainId;

        this._eachCtxEvents(function(ctxEventsItem, eventKey) {
            eachById(ctxEventsItem, contextId, function(handlerItem, handlerItemId) {
                iteratee(handlerItem, handlerItemId, ctxEventsItem, eventKey);
            });
        });
    };

    /**
     * Execute the callback once for each handler of ctxEventsItem of the provided eventName(arguments[0]).<br>
     * Callback function(iteratee) is invoked with four arguments:
     *  - handlerItem
     *  - handlerItemId
     *  - ctxEventsItem
     *  - eventKey, A Name of custom event with postfix (ex - 'eventName_idx')
     * @param {string} eventName - Custom event name
     * @param {function} iteratee - Callback function
     * @private
     */
    CustomEvents.prototype._eachCtxEventByEventName = function(eventName, iteratee) {
        if (!this._ctxEvents) {
            return;
        }

        var key = this._getCtxKey(eventName),
            ctxEventsItem = this._ctxEvents[key],
            args;

        ne.util.forEachOwnProperties(ctxEventsItem, function() {
            args = Array.prototype.slice.call(arguments);
            args.push(key);
            iteratee.apply(null, args);
        });
    };

    /**********
     * normal event handler
     **********/

    /**
     * Execute the callback once
     *  for each handler in instance equal to the provided handler(arguments[0]).<br>
     * Callback function(iteratee) is invoked with five arguments:
     *  - handlerItem
     *  - index of handlerItem array
     *  - eventList by handler
     *  - eventKey, A Name of custom event with postfix (ex - 'eventName_idx')
     *  - decrease, A special callback function that decreases the length of array.
     * @param {function} handler - A handler for searching
     * @param {function} iteratee - Callback function
     * @private
     */
    CustomEvents.prototype._eachEventByHandler = function(handler, iteratee) {
        var events = this._events,
            forEachArrayDecrease = this._forEachArraySplice,
            idx = 0;

        ne.util.forEachOwnProperties(events, function(eventList, eventKey) {
            forEachArrayDecrease(eventList, function(handlerItem, index, eventList, decrease) {
                if (handlerItem.fn === handler) {
                    iteratee(handlerItem, idx, eventList, eventKey, decrease);
                    idx += 1;
                }
            });
        });
    };

    /**
     * Execute the callback once for each handler of normal events of the provided eventName.<br>
     * Callback function(iteratee) is invoked with four arguments:
     *  - handler
     *  - index of handler-list
     *  - handler-list
     *  - decrease, A special callback function that decreases the length of array
     * @param {string} eventName - Custom event name
     * @param {function} iteratee - Callback function
     * @private
     */
    CustomEvents.prototype._eachEventByEventName = function(eventName, iteratee) {
        var events;

        if (!this._events) {
            return;
        }

        events = this._events[eventName];
        if (!ne.util.isExisty(events)) {
            return;
        }

        this._forEachArraySplice(events, iteratee);
    };

    /**
     * Return a new key for saving a handler with a context in event name.
     * @param {string} eventName A event name
     * @returns {string} Key
     * @private
     */
    CustomEvents.prototype._getCtxKey = function(eventName) {
        return eventName + '_idx';
    };

    /**
     * Return a new key for saving length of handlers in event name.
     * @param {string} eventName A event name
     * @returns {string} Key
     * @private
     */
    CustomEvents.prototype._getCtxLenKey = function(eventName) {
        return eventName + '_len';
    };

    /**
     * Return a new key for storing to ctxEventsItem.
     * @param {function} func A event handler
     * @param {*} ctx A context in handler
     * @returns {string} Key
     * @private
     */
    CustomEvents.prototype._getHandlerKey = function(func, ctx) {
        return ne.util.stamp(func) + '_' + ne.util.stamp(ctx);
    };


    /**
     * Set the length of handlers in ctxEventsItem.
     * @param {string} lenKey - A key for saving the length of handlers in `this._ctxEvents`
     * @param {number} change - A variation value of length
     * @private
     */
    CustomEvents.prototype._setCtxLen = function(lenKey, change) {
        var events = this._ctxEvents;

        if (!ne.util.isExisty(events[lenKey])) {
            events[lenKey] = 0;
        }

        events[lenKey] += change;
    };


    /**
     * Store a {handlerItem} to instance.
     * @param {string} eventName - Custom event name
     * @param {*} context - Context for binding
     * @param {function} handler - Handler function
     * @private
     */
    CustomEvents.prototype._addCtxEvent = function(eventName, context, handler) {
        var events = this._ctxEvents,
            key = this._getCtxKey(eventName),
            event;

        if (!ne.util.isExisty(events)) {
            events = this._ctxEvents = {};
        }

        event = events[key];
        if (!ne.util.isExisty(event)) {
            event = events[key] = {};
        }

        var lenKey = this._getCtxLenKey(eventName),
            handlerItemId = this._getHandlerKey(handler, context);

        event[handlerItemId] = {
            fn: handler,
            ctx: context
        };

        this._setCtxLen(lenKey, +1);
    };

    /**
     * Store a event handler without context to instance.
     * @param {string} eventName - Custom event name
     * @param {function} handler - Handler function
     * @private
     */
    CustomEvents.prototype._addNormalEvent = function(eventName, handler) {
        var events = this._events,
            event;

        if (!ne.util.isExisty(events)) {
            events = this._events = {};
        }

        event = events[eventName];
        if (!ne.util.isExisty(event)) {
            event = events[eventName] = [];
        }

        event.push({ fn: handler });
    };


    /**
     * Take the event handler off by handler(arguments[0])
     * @param {function} handler - Handler for offing
     * @private
     */
    CustomEvents.prototype._offByHandler = function(handler) {
        var ctxEvents = this._ctxEvents,
            lenKey;

        this._eachCtxEventByHandler(handler, function(handlerItem, hanId, ctxItems, eventKey) {
            lenKey = eventKey.replace('_idx', '_len');
            delete ctxItems[hanId];
            ctxEvents[lenKey] -= 1;
        });

        this._eachEventByHandler(handler, function(handlerItem, index, items, eventKey, decrease) {
            items.splice(index, 1);
            decrease();
        });
    };

    /**
     * Take the event handler off by context with event name
     * @param {*} context - Context
     * @param {(string|function)} [eventName] - Custom event name
     * @private
     */
    CustomEvents.prototype._offByContext = function(context, eventName) {
        var ctxEvents = this._ctxEvents,
            hasArgs = ne.util.isExisty(eventName),
            matchEventName,
            matchHandler,
            lenKey;

        this._eachCtxEventByContext(context, function(handlerItem, hanId, ctxItems, eventKey) {
            lenKey = eventKey.replace('_idx', '_len');

            matchEventName = hasArgs && ne.util.isString(eventName) && eventKey.indexOf(eventName) > -1;
            matchHandler = hasArgs && ne.util.isFunction(eventName) && handlerItem.fn === eventName;

            if (!hasArgs || (matchEventName || matchHandler)) {
                delete ctxItems[hanId];
                ctxEvents[lenKey] -= 1;
            }
        });
    };

    /**
     * Take the event handler off by event name with handler
     * @param {string} eventName - Custom event name
     * @param {function} [handler] - Event handler
     * @private
     */
    CustomEvents.prototype._offByEventName = function(eventName, handler) {
        var ctxEvents = this._ctxEvents,
            hasHandler = ne.util.isExisty(handler),
            lenKey;

        this._eachCtxEventByEventName(eventName, function(handlerItem, hanId, ctxItems, eventKey) {
            lenKey = eventKey.replace('_idx', '_len');
            if (!hasHandler || (hasHandler && handlerItem.fn === handler)) {
                delete ctxItems[hanId];
                ctxEvents[lenKey] -= 1;
            }
        });

        this._eachEventByEventName(eventName, function(handlerItem, index, items, decrease) {
            if (!hasHandler || (hasHandler && handlerItem.fn === handler)) {
                items.splice(index, 1);
                decrease();
            }
        });

    };

    /**********
     * public
     **********/

    /**
     * Attach the event handler with event name and context.
     * @param {(string|{name:string, handler:function})} eventName - Custom event name or an object {eventName: handler}
     * @param {(function|*)} [handler] - Handler function or context
     * @param {*} [context] - Context for binding
     * @example
     *  // 1. Basic
     *  customEvent.on('onload', handler);
     *
     *  // 2. With context
     *  customEvent.on('onload', handler, myObj);
     *
     *  // 3. Attach with an object
     *  customEvent.on({
     *    'play': handler,
     *    'pause': handler2
     *  });
     *
     *  // 4. Attach with an object with context
     *  customEvent.on({
     *    'play': handler
     *  }, myObj);
     */
    CustomEvents.prototype.on = function(eventName, handler, context) {
        var eventNameList;

        if (ne.util.isObject(eventName)) {
            // {eventName: handler}
            context = handler;
            ne.util.forEachOwnProperties(eventName, function(handler, name) {
                 this.on(name, handler, context);
            }, this);
            return;
        } else if (ne.util.isString(eventName) && eventName.indexOf(' ') > -1) {
            // processing of multiple events by split event name
            eventNameList = eventName.split(' ');
            ne.util.forEachArray(eventNameList, function(name) {
                this.on(name, handler, context);
            }, this);
            return;
        }

        var ctxId;

        if (ne.util.isExisty(context)) {
            ctxId = ne.util.stamp(context);
        }

        if (ne.util.isExisty(ctxId)) {
            this._addCtxEvent(eventName, context, handler);
        } else {
            this._addNormalEvent(eventName, handler);
        }
    };

    /**
     * Detach the event handler.
     * @param {(string|{name:string, handler:function})} eventName - Custom event name or an object {eventName: handler}
     * @param {function} [handler] Handler function
     * @example
     * // 1. off by context
     * customEvent.off(myObj);
     *
     * // 2. off by event name
     * customEvent.off('onload');
     *
     * // 3. off by handler
     * customEvent.off(handler);
     *
     * // 4. off by event name and handler
     * customEvent.off('play', handler);
     *
     * // 5. off by context and handler
     * customEvent.off(myObj, handler);
     *
     * // 6. off by context and event name
     * customEvent.off(myObj, 'onload');
     *
     * // 7. off by an Object.<string, function> that is {eventName: handler}
     * customEvent.off({
     *   'play': handler,
     *   'pause': handler2
     * });
     *
     * // 8. off the all events
     * customEvent.off();
     */
    CustomEvents.prototype.off = function(eventName, handler) {
        if (!arguments.length) {
            // 8. off the all events
            this._events = null;
            this._ctxEvents = null;
            return;
        }

        if (ne.util.isFunction(eventName)) {
            // 3. off by handler
            this._offByHandler(eventName);

        } else if (ne.util.isObject(eventName)) {
            if (ne.util.hasStamp(eventName)) {
                // 1, 5, 6 off by context
                this._offByContext(eventName, handler);
            } else {
                // 4. off by an Object.<string, function>
                ne.util.forEachOwnProperties(eventName, function(handler, name) {
                    this.off(name, handler);
                }, this);
            }

        } else {
            // 2, 4 off by event name
            this._offByEventName(eventName, handler);

        }
    };

    /**
     * Return a count of events registered.
     * @param {string} eventName - Custom event name
     * @returns {*}
     */
    CustomEvents.prototype.getListenerLength = function(eventName) {
        var ctxEvents = this._ctxEvents,
            events = this._events,
            existy = ne.util.isExisty,
            lenKey = this._getCtxLenKey(eventName);

        var normal = (existy(events) && ne.util.isArray(events[eventName])) ? events[eventName].length : 0,
            ctx = (existy(ctxEvents) && existy(ctxEvents[lenKey])) ? ctxEvents[lenKey] : 0;

        return normal + ctx;
    };

    /**
     * Return whether at least one of the handlers is registered in the given event name.
     * @param {string} eventName - Custom event name
     * @returns {boolean} Is there at least one handler in event name?
     */
    CustomEvents.prototype.hasListener = function(eventName) {
        return this.getListenerLength(eventName) > 0;
    };



    /**
     * Fire a event and returns the result of operation 'boolean AND' with all listener's results.<br>
     * So, It is different from {@link CustomEvents#fire}.<br>
     * In service code,
     *  use this as a before event in component level usually for notifying that the event is cancelable.
     * @param {string} eventName - Custom event name
     * @param {...*} data - Data for event
     * @returns {boolean} The result of operation 'boolean AND'
     * @example
     *  if (this.invoke('beforeZoom')) {    // check the result of 'beforeZoom'
     *      // if true,
     *      // doSomething
     *  }
     *
     *  // In service code,
     *  map.on({
     *      'beforeZoom': function() {
     *          if (that.disabled && this.getState()) {    // It should cancel the 'zoom' event by some conditions.
     *              return false;
     *          }
     *          return true;
     *      }
     *  });
     */
    CustomEvents.prototype.invoke = function(eventName, data) {
        if (!this.hasListener(eventName)) {
            return true;
        }

        var args = Array.prototype.slice.call(arguments, 1),
            self = this,
            result = true,
            existy = ne.util.isExisty;

        this._eachEventByEventName(eventName, function(item) {
            if (existy(item) && item.fn.apply(self, args) === false) {
                result = false;
            }
        });

        this._eachCtxEventByEventName(eventName, function(item) {
            if (existy(item) && item.fn.apply(item.ctx, args) === false) {
                result = false;
            }
        });

        return result;
    };

    /**
     * Fire a event by event name with data.
     * @param {string} eventName - Custom event name
     * @param {...*} data - Data for event
     * @return {Object} this
     * @example
     *  instance.on('move', function(direction) {
     *      var direction = direction;
     *  });
     *  instance.fire('move', 'left');
     */
    CustomEvents.prototype.fire = function(eventName, data) {
        this.invoke.apply(this, arguments);
        return this;
    };

    /**
     * Attach a one-shot event.
     * @param {(object|string)} eventName - Custom event name or an object {eventName: handler}
     * @param {function} fn - Handler function
     * @param {*} [context] - Context for binding
     */
    CustomEvents.prototype.once = function(eventName, fn, context) {
        var that = this;

        if (ne.util.isObject(eventName)) {
            ne.util.forEachOwnProperties(eventName, function(handler, eventName) {
                this.once(eventName, handler, fn);
            }, this);

            return;
        }

        function onceHandler() {
            fn.apply(context, arguments);
            that.off(eventName, onceHandler, context);
        }

        this.on(eventName, onceHandler, context);
    };

    ne.util.CustomEvents = CustomEvents;

})(window.ne);

/**********
 * defineClass.js
 **********/

/**
 * @fileoverview
 *  This module provides a function to make a constructor that can inherit from the other constructors like the CLASS easily.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency inheritance.js, object.js
 */

(function(ne) {
    'use strict';
    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    /* istanbul ignore if */
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * Help a constructor to be defined and to inherit from the other constructors
     * @param {*} [parent] Parent constructor
     * @param {Object} props Members of constructor
     *  @param {Function} props.init Initialization method
     *  @param {Object} [props.static] Static members of constructor
     * @returns {*} Constructor
     * @memberof ne.util
     * @example
     *  var Parent = defineClass({
     *      init: function() {
     *          this.name = 'made by def';
     *      },
     *      method: function() {
     *          //..can do something with this
     *      },
     *      static: {
     *          staticMethod: function() {
     *               //..do something
     *          }
     *      }
     *  });
     *
     *  var Child = defineClass(Parent, {
     *      method2: function() {}
     *  });
     *
     *  Parent.staticMethod();
     *
     *  var parentInstance = new Parent();
     *  console.log(parentInstance.name); //made by def
     *  parentInstance.staticMethod(); // Error
     *
     *  var childInstance = new Child();
     *  childInstance.method();
     *  childInstance.method2();
     */
    ne.util.defineClass = function(parent, props) {
        var obj;

        if (!props) {
            props = parent;
            parent = null;
        }

        obj = props.init || function(){};

        if(parent) {
            ne.util.inherit(obj, parent);
        }

        if (props.hasOwnProperty('static')) {
            ne.util.extend(obj, props.static);
            delete props.static;
        }

        ne.util.extend(obj.prototype, props);

        return obj;
    };

})(window.ne);

/**********
 * defineModule.js
 **********/

/**
 * @fileoverview Define module
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency type.js, defineNamespace.js
 */
(function(ne) {
    'use strict';
    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    /* istanbul ignore if */
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    var util = ne.util,
        INITIALIZATION_METHOD_NAME = 'initialize';

    /**
     * Define module
     * @param {string} namespace - Namespace of module
     * @param {Object} moduleDefinition - Object literal for module
     * @returns {Object} Defined module
     * @memberof ne.util
     * @example
     *     var myModule = ne.util.defineModule('modules.myModule', {
     *          name: 'john',
     *          message: '',
     *          initialize: function() {
     *              this.message = 'hello world';
     *          },
     *          getMessage: function() {
     *              return this.name + ': ' + this.message
     *          }
     *     });
     *
     *     console.log(myModule.getMessage());  // 'john: hello world';
     *     console.log(window.modules.myModule.getMessage());   // 'john: hello world';
     */
    function defineModule(namespace, moduleDefinition) {
        var base = moduleDefinition || {};

        if (util.isFunction(base[INITIALIZATION_METHOD_NAME])) {
            base[INITIALIZATION_METHOD_NAME]();
            delete base[INITIALIZATION_METHOD_NAME];
        }

        return util.defineNamespace(namespace, base, true);
    }
    ne.util.defineModule = defineModule;
})(window.ne);

/**********
 * defineNamespace.js
 **********/

/**
 * @fileoverview Define namespace
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency inheritance.js, object.js, collection.js
 */
(function(ne) {

    'use strict';
    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    /* istanbul ignore if */
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * Define namespace
     * @param {string} name - Module name
     * @param {(object|function)} props - A set of modules or one module
     * @param {boolean} isOverride flag - What if module already define, override or not
     * @returns {(object|function)} Defined namespace
     * @memberof ne.util
     * @example
     * var neComp = defineNamespace('ne.component');
     * neComp.listMenu = ne.util.defineClass({
     *      init: function() {
     *          // code
     *      }
     * });
     */
    var defineNamespace = function(name, props, isOverride) {
        var namespace,
            lastspace,
            result,
            module = getNamespace(name);

        if (!isOverride && isValidType(module)) {
            return module;
        }

        namespace = name.split('.');
        lastspace = namespace.pop();
        namespace.unshift(window);

        result = ne.util.reduce(namespace, function(obj, name) {
            obj[name] = obj[name] || {};
            return obj[name];
        });

        result[lastspace] = isValidType(props) ? props : {};

        return result[lastspace];

    };

    /**
     * Get namespace
     * @param {string} name - namespace
     * @returns {*}
     */
    var getNamespace = function(name) {
        var namespace,
            result;

        namespace = name.split('.');
        namespace.unshift(window);

        result = ne.util.reduce(namespace, function(obj, name) {
            return obj && obj[name];
        });
        return result;
    };

    /**
     * Check valid type
     * @param {*} module
     * @returns {boolean}
     */
    var isValidType = function(module) {
        return (ne.util.isObject(module) || ne.util.isFunction(module));
    };

    ne.util.defineNamespace = defineNamespace;

})(window.ne);
/**********
 * enum.js
 **********/

/**
 * @fileoverview This module provides a Enum Constructor.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency type, collection.js
 */

(function(ne) {

'use strict';

/* istanbul ignore if */
if (!ne) {
    ne = window.ne = {};
}
if (!ne.util) {
    ne.util = window.ne.util = {};
}

/**
 * Check whether the defineProperty() method is supported.
 * @type {boolean}
 */
var isSupportDefinedProperty = (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) {
        return false;
    }
}());

/**
 * A unique value of a constant.
 * @type {number}
 */
var enumValue = 0;

/**
 * Make a constant-list that has unique values.<br>
 * In modern browsers (except IE8 and lower),<br>
 *  a value defined once can not be changed.
 *
 * @param {...string | string[]} itemList Constant-list (An array of string is available)
 * @exports Enum
 * @constructor
 * @class
 * @memberof ne.util
 * @examples
 *  //create
 *  var MYENUM = new Enum('TYPE1', 'TYPE2');
 *  var MYENUM2 = new Enum(['TYPE1', 'TYPE2']);
 *
 *  //usage
 *  if (value === MYENUM.TYPE1) {
 *       ....
 *  }
 *
 *  //add (If a duplicate name is inputted, will be disregarded.)
 *  MYENUM.set('TYPE3', 'TYPE4');
 *
 *  //get name of a constant by a value
 *  MYENUM.getName(MYENUM.TYPE1); // 'TYPE1'이 리턴된다.
 *
 *  // In modern browsers (except IE8 and lower), a value can not be changed in constants.
 *  var originalValue = MYENUM.TYPE1;
 *  MYENUM.TYPE1 = 1234; // maybe TypeError
 *  MYENUM.TYPE1 === originalValue; // true
 *
 **/
function Enum(itemList) {
    if (itemList) {
        this.set.apply(this, arguments);
    }
}

/**
 * Define a constants-list
 * @param {...string| string[]} itemList Constant-list (An array of string is available)
 */
Enum.prototype.set = function(itemList) {
    var self = this;

    if (!ne.util.isArray(itemList)) {
        itemList = ne.util.toArray(arguments);
    }

    ne.util.forEach(itemList, function itemListIteratee(item) {
        self._addItem(item);
    });
};

/**
 * Return a key of the constant.
 * @param {number} value A value of the constant.
 * @returns {string|undefined} Key of the constant.
 */
Enum.prototype.getName = function(value) {
    var foundedKey,
        self = this;

    ne.util.forEach(this, function(itemValue, key) {
        if (self._isEnumItem(key) && value === itemValue) {
            foundedKey = key;
            return false;
        }
    });

    return foundedKey;
};

/**
 * Create a constant.
 * @private
 * @param {string} name Constant name. (It will be a key of a constant)
 */
Enum.prototype._addItem = function(name) {
    var value;

    if (!this.hasOwnProperty(name)) {
        value = this._makeEnumValue();

        if (isSupportDefinedProperty) {
            Object.defineProperty(this, name, {
                enumerable: true,
                configurable: false,
                writable: false,
                value: value
            });
        } else {
            this[name] = value;
        }
    }
};

/**
 * Return a unique value for assigning to a constant.
 * @private
 * @returns {number} A unique value
 */
Enum.prototype._makeEnumValue = function() {
    var value;

    value = enumValue;
    enumValue += 1;

    return value;
};

/**
 * Return whether a constant from the given key is in instance or not.
 * @param {string} key - A constant key
 * @returns {boolean} Result
 * @private
 */
Enum.prototype._isEnumItem = function(key) {
    return ne.util.isNumber(this[key]);
};

ne.util.Enum = Enum;

})(window.ne);

/**********
 * exMap.js
 **********/

/**
 * @fileoverview
 *  Implements the ExMap (Extended Map) object.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency Map.js, collection.js
 */

(function(ne) {
    'use strict';

    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    // Caching ne.util for performance enhancing
    var util = ne.util,
        mapAPIsForRead = ['get', 'has', 'forEach', 'keys', 'values', 'entries'],
        mapAPIsForDelete = ['delete', 'clear'];

    /**
     * The ExMap object is Extended Version of the ne.util.Map object.<br>
     * and added some useful feature to make it easy to manage the Map object.
     * @constructor
     * @param {Array} initData - Array of key-value pairs (2-element Arrays).
     *      Each key-value pair will be added to the new Map
     * @memberof ne.util
     */
    function ExMap(initData) {
        this._map = new util.Map(initData);
        this.size = this._map.size;
    }

    util.forEachArray(mapAPIsForRead, function(name) {
        ExMap.prototype[name] = function() {
            return this._map[name].apply(this._map, arguments);
        };
    });

    util.forEachArray(mapAPIsForDelete, function(name) {
        ExMap.prototype[name] = function() {
            var result = this._map[name].apply(this._map, arguments);
            this.size = this._map.size;
            return result;
        };
    });

    ExMap.prototype.set = function() {
        this._map.set.apply(this._map, arguments);
        this.size = this._map.size;
        return this;
    };

    /**
     * Sets all of the key-value pairs in the specified object to the Map object.
     * @param  {Object} object - Plain object that has a key-value pair
     */
    ExMap.prototype.setObject = function(object) {
        util.forEachOwnProperties(object, function(value, key) {
            this.set(key, value);
        }, this);
    };

    /**
     * Removes the elements associated with keys in the specified array.
     * @param  {Array} keys - Array that contains keys of the element to remove
     */
    ExMap.prototype.deleteByKeys = function(keys) {
        util.forEachArray(keys, function(key) {
            this['delete'](key);
        }, this);
    };

    /**
     * Sets all of the key-value pairs in the specified Map object to this Map object.
     * @param  {Map} map - Map object to be merged into this Map object
     */
    ExMap.prototype.merge = function(map) {
        map.forEach(function(value, key) {
            this.set(key, value);
        }, this);
    };

    /**
     * Looks through each key-value pair in the map and returns the new ExMap object of
     * all key-value pairs that pass a truth test implemented by the provided function.
     * @param  {function} predicate - Function to test each key-value pair of the Map object.<br>
     *      Invoked with arguments (value, key). Return true to keep the element, false otherwise.
     * @return {ExMap} A new ExMap object
     */
    ExMap.prototype.filter = function(predicate) {
        var filtered = new ExMap();

        this.forEach(function(value, key) {
            if (predicate(value, key)) {
                filtered.set(key, value);
            }
        });

        return filtered;
    };

    util.ExMap = ExMap;
})(window.ne);

/**********
 * formatDate.js
 **********/

/**
 * @fileoverview This module has a function for date format.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency type.js
 */

(function(ne) {
    'use strict';

    var tokens = /[\\]*YYYY|[\\]*YY|[\\]*MMMM|[\\]*MMM|[\\]*MM|[\\]*M|[\\]*DD|[\\]*D|[\\]*HH|[\\]*H|[\\]*A/gi,
        MONTH_STR = ["Invalid month", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        MONTH_DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        replaceMap = {
            M: function(date) {
                return Number(date.month);
            },
            MM: function(date) {
                var month = date.month;
                return (Number(month) < 10) ? '0' + month : month;
            },
            MMM: function(date) {
                return MONTH_STR[Number(date.month)].substr(0, 3);
            },
            MMMM: function(date) {
                return MONTH_STR[Number(date.month)];
            },
            D: function(date) {
                return Number(date.date);
            },
            d: function(date) {
                return replaceMap.D(date);
            },
            DD: function(date) {
                var dayInMonth = date.date;
                return (Number(dayInMonth) < 10) ? '0' + dayInMonth : dayInMonth;
            },
            dd: function(date) {
                return replaceMap.DD(date);
            },
            YY: function(date) {
                return Number(date.year) % 100;
            },
            yy: function(date) {
                return replaceMap.YY(date);
            },
            YYYY: function(date) {
                var prefix = '20',
                    year = date.year;
                if (year > 69 && year < 100) {
                    prefix = '19';
                }
                return (Number(year) < 100) ? prefix + String(year) : year;
            },
            yyyy: function(date) {
                return replaceMap.YYYY(date);
            },
            A: function(date) {
                return date.meridian;
            },
            a: function(date) {
                return date.meridian.toLowerCase();
            },
            hh: function(date) {
                var hour = date.hour;
                return (Number(hour) < 10) ? '0' + hour : hour;
            },
            HH: function(date) {
                return replaceMap.hh(date);
            },
            h: function(date) {
                return String(Number(date.hour));
            },
            H: function(date) {
                return replaceMap.h(date);
            },
            m: function(date) {
                return String(Number(date.minute));
            },
            mm: function(date) {
                var minute = date.minute;
                return (Number(minute) < 10) ? '0' + minute : minute;
            }
        };

    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    /* istanbul ignore if */
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * Check whether the given variables are valid date or not.
     * @param {number} year - Year
     * @param {number} month - Month
     * @param {number} date - Day in month.
     * @returns {boolean} Is valid?
     */
    function isValidDate(year, month, date) {
        var isValidYear,
            isValidMonth,
            isValid,
            lastDayInMonth;

        year = Number(year);
        month = Number(month);
        date = Number(date);

        isValidYear = (year > -1 && year < 100) || (year > 1969) && (year < 2070);
        isValidMonth = (month > 0) && (month < 13);

        if (!isValidYear || !isValidMonth) {
            return false;
        }

        lastDayInMonth = MONTH_DAYS[month];
        if (month === 2 && year % 4 === 0) {
            if (year % 100 !== 0 || year % 400 === 0) {
                lastDayInMonth = 29;
            }
        }

        isValid = (date > 0) && (date <= lastDayInMonth);
        return isValid;
    }

    /**
     * Return a string that transformed from the given form and date.
     * @param {string} form - Date form
     * @param {Date|Object} date - Date object
     * @returns {boolean|string} A transformed string or false.
     * @memberOf ne.util
     * @example
     *  // key         | Shorthand
     *  // ------------|-----------------------
     *  // years       | YY / YYYY / yy / yyyy
     *  // months(n)   | M / MM
     *  // months(str) | MMM / MMMM
     *  // days        | D / DD / d / dd
     *  // hours       | H / HH / h / hh
     *  // minutes     | m / mm
     *  // AM/PM       | A / a
     *
     *  var dateStr1 = formatDate('yyyy-MM-dd', {
     *      year: 2014,
     *      month: 12,
     *      date: 12
     *  });
     *  alert(dateStr1); // '2014-12-12'
     *
     *  var dateStr2 = formatDate('MMM DD YYYY HH:mm', {
     *      year: 1999,
     *      month: 9,
     *      date: 9,
     *      hour: 0,
     *      minute: 2
     *  })
     *  alert(dateStr2); // 'Sep 09 1999 00:02'
     *
     *  var dt = new Date(2010, 2, 13),
     *      dateStr3 = formatDate('yyyy년 M월 dd일', dt);
     *
     *  alert(dateStr3); // '2010년 3월 13일'
     */
    function formatDate(form, date) {
        var meridian,
            nDate,
            resultStr;

        if (ne.util.isDate(date)) {
            nDate = {
                year: date.getFullYear(),
                month: date.getMonth() + 1,
                date: date.getDate(),
                hour: date.getHours(),
                minute: date.getMinutes()
            };
        } else {
            nDate = {
                year: date.year,
                month: date.month,
                date: date.date,
                hour: date.hour,
                minute: date.minute
            };
        }

        if (!isValidDate(nDate.year, nDate.month, nDate.date)) {
            return false;
        }

        nDate.meridian = '';
        if (/[^\\][aA]\b/g.test(form)) {
            meridian = (nDate.hour > 12) ? 'PM' : 'AM';
            nDate.hour %= 12;
            nDate.meridian = meridian;
        }

        resultStr = form.replace(tokens, function(key) {
            if (key.indexOf('\\') > -1) {
                return key.replace(/\\/g, '');
            } else {
                return replaceMap[key](nDate) || '';
            }
        });
        return resultStr;
    }

    ne.util.formatDate = formatDate;
})(window.ne);


/**********
 * func.js
 **********/

/**
 * @fileoverview This module provides a bind() function for context binding.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 */

(function(ne) {
    'use strict';

    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * Create a new function that, when called, has its this keyword set to the provided value.
     * @param {function} fn A original function before binding
     * @param {*} obj context of function in arguments[0]
     * @return {function()} A new bound function with context that is in arguments[1]
     * @memberof ne.util
     */
    function bind(fn, obj) {
        var slice = Array.prototype.slice;

        if (fn.bind) {
            return fn.bind.apply(fn, slice.call(arguments, 1));
        }

        /* istanbul ignore next */
        var args = slice.call(arguments, 2);

        /* istanbul ignore next */
        return function() {
            /* istanbul ignore next */
            return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
        };
    }

    ne.util.bind = bind;

})(window.ne);

/**********
 * hashMap.js
 **********/

/**
 * @fileoverview This module provides the HashMap constructor.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency type, collection.js
 */

(function(ne) {
    'use strict';

    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * All the data in hashMap begin with _MAPDATAPREFIX;
     * @type {string}
     * @private
     */
    var _MAPDATAPREFIX = 'å';

    /**
     * HashMap can handle the key-value pairs.<br>
     * Caution:<br>
     *  HashMap instance has a length property but is not an instance of Array.
     * @param {Object} [obj] A initial data for creation.
     * @constructor
     * @memberof ne.util
     * @example
     *  var hm = new ne.util.HashMap({
     *      'mydata': {
     *           'hello': 'imfine'
     *       },
     *      'what': 'time'
     *  });
     */
    function HashMap(obj) {
        /**
         * size
         * @type {number}
         */
        this.length = 0;

        if (obj) {
            this.setObject(obj);
        }
    }

    /**
     * Set a data from the given key with value or the given object.
     * @param {string|Object} key A string or object for key
     * @param {*} [value] A data
     * @example
     *  var hm = new HashMap();
     *
     *  hm.set('key', 'value');
     *  hm.set({
     *      'key1': 'data1',
     *      'key2': 'data2'
     *  });
     */
    HashMap.prototype.set = function(key, value) {
        if(arguments.length === 2) {
            this.setKeyValue(key, value);
        } else {
            this.setObject(key);
        }
    };

    /**
     * Set a data from the given key with value.
     * @param {string} key A string for key
     * @param {*} value A data
     * @example
     *  var hm = new HashMap();
     *  hm.setKeyValue('key', 'value');
     */
    HashMap.prototype.setKeyValue = function(key, value) {
        if (!this.has(key)) {
            this.length += 1;
        }
        this[this.encodeKey(key)] = value;
    };

    /**
     * Set a data from the given object.
     * @param {Object} obj A object for data
     * @example
     *  var hm = new HashMap();
     *
     *  hm.setObject({
     *      'key1': 'data1',
     *      'key2': 'data2'
     *  });
     */
    HashMap.prototype.setObject = function(obj) {
        var self = this;

        ne.util.forEachOwnProperties(obj, function(value, key) {
            self.setKeyValue(key, value);
        });
    };

    /**
     * Merge with the given another hashMap.
     * @param {HashMap} hashMap Another hashMap instance
     */
    HashMap.prototype.merge = function(hashMap) {
        var self = this;

        hashMap.each(function(value, key) {
            self.setKeyValue(key, value);
        });
    };

    /**
     * Encode the given key for hashMap.
     * @param {string} key A string for key
     * @returns {string} A encoded key
     * @private
     */
    HashMap.prototype.encodeKey = function(key) {
        return _MAPDATAPREFIX + key;
    };

    /**
     * Decode the given key in hashMap.
     * @param {string} key A string for key
     * @returns {string} A decoded key
     * @private
     */
    HashMap.prototype.decodeKey = function(key) {
        var decodedKey = key.split(_MAPDATAPREFIX);
        return decodedKey[decodedKey.length-1];
    };

    /**
     * Return the value from the given key.
     * @param {string} key A string for key
     * @returns {*} The value from a key
     * @example
     *  var hm = new HashMap();
     *  hm.set('key', 'value');
     *
     *  hm.get('key') // value
     */
    HashMap.prototype.get = function(key) {
        return this[this.encodeKey(key)];
    };

    /**
     * Check the existence of a value from the key.
     * @param {string} key A string for key
     * @returns {boolean} Indicating whether a value exists or not.
     * @example
     *  var hm = new HashMap();
     *  hm.set('key', 'value');
     *
     *  hm.has('key') // true
     */
    HashMap.prototype.has = function(key) {
        return this.hasOwnProperty(this.encodeKey(key));
    };

    /**
     * Remove a data(key-value pairs) from the given key or the given key-list.
     * @param {...string|string[]} key A string for key
     * @returns {string|string[]} A removed data
     * @example
     *  var hm = new HashMap();
     *  hm.set('key', 'value');
     *  hm.set('key2', 'value');
     *
     *  //ex1
     *  hm.remove('key');
     *
     *  //ex2
     *  hm.remove('key', 'key2');
     *
     *  //ex3
     *  hm.remove(['key', 'key2']);
     */
    HashMap.prototype.remove = function(key) {
        if (arguments.length > 1) {
            key = ne.util.toArray(arguments);
        }

        return ne.util.isArray(key) ? this.removeByKeyArray(key) : this.removeByKey(key);
    };

    /**
     * Remove data(key-value pair) from the given key.
     * @param {string} key A string for key
     * @returns {*|null} A removed data
     * @example
     *  var hm = new HashMap();
     *  hm.set('key', 'value');
     *
     *  hm.removeByKey('key')
     */
    HashMap.prototype.removeByKey = function(key) {
        var data = this.has(key) ? this.get(key) : null;

        if (data !== null) {
            delete this[this.encodeKey(key)];
            this.length -= 1;
        }

        return data;
    };

    /**
     * Remove a data(key-value pairs) from the given key-list.
     * @param {string[]} keyArray An array of keys
     * @returns {string[]} A removed data
     * @example
     *  var hm = new HashMap();
     *  hm.set('key', 'value');
     *  hm.set('key2', 'value');
     *
     *  hm.removeByKeyArray(['key', 'key2']);
     */
    HashMap.prototype.removeByKeyArray = function(keyArray) {
        var data = [],
            self = this;

        ne.util.forEach(keyArray, function(key) {
            data.push(self.removeByKey(key));
        });

        return data;
    };

    /**
     * Remove all the data
     */
    HashMap.prototype.removeAll = function() {
        var self = this;

        this.each(function(value, key) {
            self.remove(key);
        });
    };

    /**
     * Execute the provided callback once for each all the data.
     * @param {Function} iteratee Callback function
     * @example
     *  var hm = new HashMap();
     *  hm.set('key', 'value');
     *  hm.set('key2', 'value');
     *
     *  hm.each(function(value, key) {
     *      //do something...
     *  });
     */
    HashMap.prototype.each = function(iteratee) {
        var self = this,
            flag;

        ne.util.forEachOwnProperties(this, function(value, key) {
            if (key.charAt(0) === _MAPDATAPREFIX) {
                flag = iteratee(value, self.decodeKey(key));
            }

            if (flag === false) {
                return flag;
            }
        });
    };

    /**
     * Return the key-list stored.
     * @returns {Array} A key-list
     * @example
     *  var hm = new HashMap();
     *  hm.set('key', 'value');
     *  hm.set('key2', 'value');
     *
     *  hm.keys();  //['key', 'key2');
     */
    HashMap.prototype.keys = function() {
        var keys = [],
            self = this;

        this.each(function(value, key) {
            keys.push(self.decodeKey(key));
        });

        return keys;
    };

    /**
     * Work similarly to Array.prototype.map().<br>
     * It executes the provided callback that checks conditions once for each element of hashMap,<br>
     *  and returns a new array having elements satisfying the conditions
     * @param {Function} condition A function that checks conditions
     * @returns {Array} A new array having elements satisfying the conditions
     * @example
     *  //ex1
     *  var hm = new HashMap();
     *  hm.set('key', 'value');
     *  hm.set('key2', 'value');
     *
     *  hm.find(function(value, key) {
     *      return key === 'key2';
     *  }); // ['value']
     *
     *  //ex2
     *  var hm = new HashMap({
     *      'myobj1': {
     *           visible: true
     *       },
     *      'mybobj2': {
     *           visible: false
     *       }
     *  });
     *
     *  hm.find(function(obj, key) {
     *      return obj.visible === true;
     *  }); // [{visible: true}];
     */
    HashMap.prototype.find = function(condition) {
        var founds = [];

        this.each(function(value, key) {
            if (condition(value, key)) {
                founds.push(value);
            }
        });

        return founds;
    };

    /**
     * Return a new Array having all values.
     * @returns {Array} A new array having all values
     */
    HashMap.prototype.toArray = function() {
        var result = [];

        this.each(function(v) {
            result.push(v);
        });

        return result;
    };

    ne.util.HashMap = HashMap;

})(window.ne);

/**********
 * inheritance.js
 **********/

/**
 * @fileoverview This module provides some simple function for inheritance.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 */

(function(ne) {
    'use strict';
    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    /* istanbul ignore if */
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }



    /**
     * Create a new object with the specified prototype object and properties.
     * @param {Object} obj This object will be a prototype of the newly-created object.
     * @return {Object}
     * @memberof ne.util
     */
    function createObject() {
        function F() {}

        return function(obj) {
            F.prototype = obj;
            return new F();
        };
    }

    /**
     * Provide a simple inheritance in prototype-oriented.
     * Caution :
     *  Don't overwrite the prototype of child constructor.
     *
     * @param {function} subType Child constructor
     * @param {function} superType Parent constructor
     * @memberof ne.util
     * @example
     *  // Parent constructor
     *  function Animal(leg) {
     *      this.leg = leg;
     *  }
     *
     *  Animal.prototype.growl = function() {
     *      // ...
     *  };
     *
     *  // Child constructor
     *  function Person(name) {
     *      this.name = name;
     *  }
     *
     *  // Inheritance
     *  core.inherit(Person, Animal);
     *
     *  // After this inheritance, please use only the extending of property.
     *  // Do not overwrite prototype.
     *  Person.prototype.walk = function(direction) {
     *      // ...
     *  };
     */
    function inherit(subType, superType) {
        var prototype = ne.util.createObject(superType.prototype);
        prototype.constructor = subType;
        subType.prototype = prototype;
    }

    ne.util.createObject = createObject();
    ne.util.inherit = inherit;

})(window.ne);

/**********
 * map.js
 **********/

/**
 * @fileoverview
 *  Implements the Map object.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency type.js, collection.js
 */

(function(ne) {
    'use strict';

    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }


    // Caching ne.util for performance enhancing
    var util = ne.util,

    /**
     * Using undefined for a key can be ambiguous if there's deleted item in the array,<br>
     * which is also undefined when accessed by index.<br>
     * So use this unique object as an undefined key to distinguish it from deleted keys.
     * @private
     * @constant
     */
    _KEY_FOR_UNDEFINED = {},

    /**
     * For using NaN as a key, use this unique object as a NaN key.<br>
     * This makes it easier and faster to compare an object with each keys in the array<br>
     * through no exceptional comapring for NaN.
     */
    _KEY_FOR_NAN = {};

    /**
     * Constructor of MapIterator<br>
     * Creates iterator object with new keyword.
     * @constructor
     * @param  {Array} keys - The array of keys in the map
     * @param  {function} valueGetter - Function that returns certain value,
     *      taking key and keyIndex as arguments.
     */
    function MapIterator(keys, valueGetter) {
        this._keys = keys;
        this._valueGetter = valueGetter;
        this._length = this._keys.length;
        this._index = -1;
        this._done = false;
    }

    /**
     * Implementation of Iterator protocol.
     * @return {{done: boolean, value: *}} Object that contains done(boolean) and value.
     */
    MapIterator.prototype.next = function() {
        var data = {};
        do {
           this._index += 1;
       } while (util.isUndefined(this._keys[this._index]) && this._index < this._length);

        if (this._index >= this._length) {
            data.done = true;
        } else {
            data.done = false;
            data.value = this._valueGetter(this._keys[this._index], this._index);
        }
        return data;
    };

    /**
     * The Map object implements the ES6 Map specification as closely as possible.<br>
     * For using objects and primitive values as keys, this object uses array internally.<br>
     * So if the key is not a string, get(), set(), has(), delete() will operates in O(n),<br>
     * and it can cause performance issues with a large dataset.
     *
     * Features listed below are not supported. (can't be implented without native support)
     * - Map object is iterable<br>
     * - Iterable object can be used as an argument of constructor
     *
     * If the browser supports full implementation of ES6 Map specification, native Map obejct
     * will be used internally.
     * @constructor
     * @param  {Array} initData - Array of key-value pairs (2-element Arrays).
     *      Each key-value pair will be added to the new Map
     * @memberof ne.util
     */
    function Map(initData) {
        this._valuesForString = {};
        this._valuesForIndex = {};
        this._keys = [];

        if (initData) {
            this._setInitData(initData);
        }

        this.size = 0;
    }

    /**
     * Add all elements in the initData to the Map object.
     * @private
     * @param  {Array} initData - Array of key-value pairs to add to the Map object
     */
    Map.prototype._setInitData = function(initData) {
        if (!util.isArray(initData)) {
            throw new Error('Only Array is supported.');
        }
        util.forEachArray(initData, function(pair) {
            this.set(pair[0], pair[1]);
        }, this);
    };

    /**
     * Returns true if the specified value is NaN.<br>
     * For unsing NaN as a key, use this method to test equality of NaN<br>
     * because === operator doesn't work for NaN.
     * @private
     * @param {*} value - Any object to be tested
     * @return {boolean} True if value is NaN, false otherwise.
     */
    Map.prototype._isNaN = function(value) {
        return typeof value === 'number' && value !== value;
    };

    /**
     * Returns the index of the specified key.
     * @private
     * @param  {*} key - The key object to search for.
     * @return {number} The index of the specified key
     */
    Map.prototype._getKeyIndex = function(key) {
        var result = -1,
            value;

        if (util.isString(key)) {
            value = this._valuesForString[key];
            if (value) {
                result = value.keyIndex;
            }
        } else {
            result = util.inArray(key, this._keys);
        }
        return result;
    };

    /**
     * Returns the original key of the specified key.
     * @private
     * @param  {*} key - key
     * @return {*} Original key
     */
    Map.prototype._getOriginKey = function(key) {
        var originKey = key;
        if (key === _KEY_FOR_UNDEFINED) {
            originKey = undefined;
        } else if (key === _KEY_FOR_NAN) {
            originKey = NaN;
        }
        return originKey;
    };

    /**
     * Returns the unique key of the specified key.
     * @private
     * @param  {*} key - key
     * @return {*} Unique key
     */
    Map.prototype._getUniqueKey = function(key) {
        var uniqueKey = key;
        if (util.isUndefined(key)) {
            uniqueKey = _KEY_FOR_UNDEFINED;
        } else if (this._isNaN(key)) {
            uniqueKey = _KEY_FOR_NAN;
        }
        return uniqueKey;
    };

    /**
     * Returns the value object of the specified key.
     * @private
     * @param  {*} key - The key of the value object to be returned
     * @param  {number} keyIndex - The index of the key
     * @return {{keyIndex: number, origin: *}} Value object
     */
    Map.prototype._getValueObject = function(key, keyIndex) {
        if (util.isString(key)) {
            return this._valuesForString[key];
        } else {
            if (util.isUndefined(keyIndex)) {
                keyIndex = this._getKeyIndex(key);
            }
            if (keyIndex >= 0) {
                return this._valuesForIndex[keyIndex];
            }
        }
    };

    /**
     * Returns the original value of the specified key.
     * @private
     * @param  {*} key - The key of the value object to be returned
     * @param  {number} keyIndex - The index of the key
     * @return {*} Original value
     */
    Map.prototype._getOriginValue = function(key, keyIndex) {
        return this._getValueObject(key, keyIndex).origin;
    };

    /**
     * Returns key-value pair of the specified key.
     * @private
     * @param  {*} key - The key of the value object to be returned
     * @param  {number} keyIndex - The index of the key
     * @return {Array} Key-value Pair
     */
    Map.prototype._getKeyValuePair = function(key, keyIndex) {
        return [this._getOriginKey(key), this._getOriginValue(key, keyIndex)];
    };

    /**
     * Creates the wrapper object of original value that contains a key index
     * and returns it.
     * @private
     * @param  {type} origin - Original value
     * @param  {type} keyIndex - Index of the key
     * @return {{keyIndex: number, origin: *}} Value object
     */
    Map.prototype._createValueObject = function(origin, keyIndex) {
        return {
            keyIndex: keyIndex,
            origin: origin
        };
    };

    /**
     * Sets the value for the key in the Map object.
     * @param  {*} key - The key of the element to add to the Map object
     * @param  {*} value - The value of the element to add to the Map object
     * @return {Map} The Map object
     */
    Map.prototype.set = function(key, value) {
        var uniqueKey = this._getUniqueKey(key),
            keyIndex = this._getKeyIndex(uniqueKey),
            valueObject;

        if (keyIndex < 0) {
            keyIndex = this._keys.push(uniqueKey) - 1;
            this.size += 1;
        }
        valueObject = this._createValueObject(value, keyIndex);

        if (util.isString(key)) {
            this._valuesForString[key] = valueObject;
        } else {
            this._valuesForIndex[keyIndex] = valueObject;
        }
        return this;
    };

    /**
     * Returns the value associated to the key, or undefined if there is none.
     * @param  {*} key - The key of the element to return
     * @return {*} Element associated with the specified key
     */
    Map.prototype.get = function(key) {
        var uniqueKey = this._getUniqueKey(key),
            value = this._getValueObject(uniqueKey);

        return value && value.origin;
    };

    /**
     * Returns a new Iterator object that contains the keys for each element
     * in the Map object in insertion order.
     * @return {Iterator} A new Iterator object
     */
    Map.prototype.keys = function() {
        return new MapIterator(this._keys, util.bind(this._getOriginKey, this));
    };

    /**
     * Returns a new Iterator object that contains the values for each element
     * in the Map object in insertion order.
     * @return {Iterator} A new Iterator object
     */
    Map.prototype.values = function() {
        return new MapIterator(this._keys, util.bind(this._getOriginValue, this));
    };

    /**
     * Returns a new Iterator object that contains the [key, value] pairs
     * for each element in the Map object in insertion order.
     * @return {Iterator} A new Iterator object
     */
    Map.prototype.entries = function() {
        return new MapIterator(this._keys, util.bind(this._getKeyValuePair, this));
    };

    /**
     * Returns a boolean asserting whether a value has been associated to the key
     * in the Map object or not.
     * @param  {*} key - The key of the element to test for presence
     * @return {boolean} True if an element with the specified key exists;
     *          Otherwise false
     */
    Map.prototype.has = function(key) {
        return !!this._getValueObject(key);
    };

    /**
     * Removes the specified element from a Map object.
     * @param {*} key - The key of the element to remove
     */
     // cannot use reserved keyword as a property name in IE8 and under.
    Map.prototype['delete'] = function(key) {
        var keyIndex;

        if (util.isString(key)) {
            if (this._valuesForString[key]) {
                keyIndex = this._valuesForString[key].keyIndex;
                delete this._valuesForString[key];
            }
        } else {
            keyIndex = this._getKeyIndex(key);
            if (keyIndex >= 0) {
                delete this._valuesForIndex[keyIndex];
            }
        }

        if (keyIndex >= 0) {
            delete this._keys[keyIndex];
            this.size -= 1;
        }
    };

    /**
     * Executes a provided function once per each key/value pair in the Map object,
     * in insertion order.
     * @param  {function} callback - Function to execute for each element
     * @param  {thisArg} thisArg - Value to use as this when executing callback
     */
    Map.prototype.forEach = function(callback, thisArg) {
        thisArg = thisArg || this;
        util.forEachArray(this._keys, function(key) {
            if (!util.isUndefined(key)) {
                callback.call(thisArg, this._getValueObject(key).origin, key, this);
            }
        }, this);
    };

    /**
     * Removes all elements from a Map object.
     */
    Map.prototype.clear = function() {
        Map.call(this);
    };

    // Use native Map object if exists.
    // But only latest versions of Chrome and Firefox support full implementation.
    (function() {
        var browser = util.browser;
        if (window.Map && (
            (browser.firefox && browser.version >= 37) ||
            (browser.chrome && browser.version >= 42) )) {
            Map = window.Map;
        }
    })();

    util.Map = Map;
})(window.ne);

/**********
 * object.js
 **********/

/**
 * @fileoverview This module has some functions for handling a plain object, json.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency type.js, collection.js
 */

(function(ne) {
    'use strict';
    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * Extend the target object from other objects.
     * @param {object} target - Object that will be extended
     * @param {...object} objects - Objects as sources
     * @return {object} Extended object
     * @memberOf ne.util
     */
    function extend(target, objects) {
        var source,
            prop,
            hasOwnProp = Object.prototype.hasOwnProperty,
            i,
            len;

        for (i = 1, len = arguments.length; i < len; i++) {
            source = arguments[i];
            for (prop in source) {
                if (hasOwnProp.call(source, prop)) {
                    target[prop] = source[prop];
                }
            }
        }
        return target;
    }

    /**
     * The last id of stamp
     * @type {number}
     */
    var lastId = 0;

    /**
     * Assign a unique id to an object
     * @param {object} obj - Object that will be assigned id.
     * @return {number} Stamped id
     * @memberOf ne.util
     */
    function stamp(obj) {
        obj.__fe_id = obj.__fe_id || ++lastId;
        return obj.__fe_id;
    }

    /**
     * Verify whether an object has a stamped id or not.
     * @param {object} obj
     * @returns {boolean}
     * @memberOf ne.util
     */
    function hasStamp(obj) {
        return ne.util.isExisty(ne.util.pick(obj, '__fe_id'));
    }

    /**
     * Reset the last id of stamp
     */
    function resetLastId() {
        lastId = 0;
    }

    /**
     * Return a key-list(array) of a given object
     * @param {object} obj - Object from which a key-list will be extracted
     * @returns {Array} A key-list(array)
     * @memberOf ne.util
     */
    function keys(obj) {
        var keys = [],
            key;

        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                keys.push(key);
            }
        }

        return keys;
    }

    /**
     * Return the equality for multiple objects(jsonObjects).<br>
     *  See {@link http://stackoverflow.com/questions/1068834/object-comparison-in-javascript}
     * @param {...object} object - Multiple objects for comparing.
     * @return {boolean} Equality
     * @example
     *
     *  var jsonObj1 = {name:'milk', price: 1000},
     *      jsonObj2 = {name:'milk', price: 1000},
     *      jsonObj3 = {name:'milk', price: 1000};
     *
     *  ne.util.compareJSON(jsonObj1, jsonObj2, jsonObj3);   // true
     *
     *
     *  var jsonObj4 = {name:'milk', price: 1000},
     *      jsonObj5 = {name:'beer', price: 3000};
     *
     *      ne.util.compareJSON(jsonObj4, jsonObj5); // false

     * @memberOf ne.util
     */
    function compareJSON(object) {
        var leftChain,
            rightChain,
            argsLen = arguments.length,
            i;

        function isSameObject(x, y) {
            var p;

            // remember that NaN === NaN returns false
            // and isNaN(undefined) returns true
            if (isNaN(x) &&
                isNaN(y) &&
                ne.util.isNumber(x) &&
                ne.util.isNumber(y)) {
                return true;
            }

            // Compare primitives and functions.
            // Check if both arguments link to the same object.
            // Especially useful on step when comparing prototypes
            if (x === y) {
                return true;
            }

            // Works in case when functions are created in constructor.
            // Comparing dates is a common scenario. Another built-ins?
            // We can even handle functions passed across iframes
            if ((ne.util.isFunction(x) && ne.util.isFunction(y)) ||
                (x instanceof Date && y instanceof Date) ||
                (x instanceof RegExp && y instanceof RegExp) ||
                (x instanceof String && y instanceof String) ||
                (x instanceof Number && y instanceof Number)) {
                return x.toString() === y.toString();
            }

            // At last checking prototypes as good a we can
            if (!(x instanceof Object && y instanceof Object)) {
                return false;
            }

            if (x.isPrototypeOf(y) ||
                y.isPrototypeOf(x) ||
                x.constructor !== y.constructor ||
                x.prototype !== y.prototype) {
                return false;
            }

            // check for infinitive linking loops
            if (ne.util.inArray(x, leftChain) > -1 ||
                ne.util.inArray(y, rightChain) > -1) {
                return false;
            }

            // Quick checking of one object beeing a subset of another.
            for (p in y) {
                if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                    return false;
                }
                else if (typeof y[p] !== typeof x[p]) {
                    return false;
                }
            }

            //This for loop executes comparing with hasOwnProperty() and typeof for each property in 'x' object,
            //and verifying equality for x[property] and y[property].
            for (p in x) {
                if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                    return false;
                }
                else if (typeof y[p] !== typeof x[p]) {
                    return false;
                }

                if (typeof(x[p]) === 'object' || typeof(x[p]) === 'function') {
                    leftChain.push(x);
                    rightChain.push(y);

                    if (!isSameObject(x[p], y[p])) {
                        return false;
                    }

                    leftChain.pop();
                    rightChain.pop();
                } else if (x[p] !== y[p]) {
                    return false;
                }
            }

            return true;
        }

        if (argsLen < 1) {
            return true;
        }

        for (i = 1; i < argsLen; i++) {
            leftChain = [];
            rightChain = [];

            if (!isSameObject(arguments[0], arguments[i])) {
                return false;
            }
        }

        return true;
    }

    /**
     * Retrieve a nested item from the given object/array
     * @param {object|Array} obj - Object for retrieving
     * @param {...string|number} paths - Paths of property
     * @returns {*} Value
     * @example
     *  var obj = {
     *      'key1': 1,
     *      'nested' : {
     *          'key1': 11,
     *          'nested': {
     *              'key1': 21
     *          }
     *      }
     *  };
     *  ne.util.pick(obj, 'nested', 'nested', 'key1'); // 21
     *  ne.util.pick(obj, 'nested', 'nested', 'key2'); // undefined
     *
     *  var arr = ['a', 'b', 'c'];
     *  ne.util.pick(arr, 1); // 'b'
     */
    function pick(obj, paths) {
        var args = arguments,
            target = args[0],
            length = args.length,
            i;
        try {
            for (i = 1; i < length; i++) {
                target = target[args[i]];
            }
            return target;
        } catch(e) {
            return;
        }
    }

    ne.util.extend = extend;
    ne.util.stamp = stamp;
    ne.util.hasStamp = hasStamp;
    ne.util._resetLastId = resetLastId;
    ne.util.keys = Object.keys || keys;
    ne.util.compareJSON = compareJSON;
    ne.util.pick = pick;
})(window.ne);

/**********
 * string.js
 **********/

/**
 * @fileoverview This module has some functions for handling the string.
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 */

(function(ne) {
    'use strict';

    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * Transform the given HTML Entity string into plain string
     * @param {String} htmlEntity - HTML Entity type string
     * @return {String} Plain string
     * @memberof ne.util
     * @example
     *  var htmlEntityString = "A &#39;quote&#39; is &lt;b&gt;bold&lt;/b&gt;"
     *  var result = decodeHTMLEntity(htmlEntityString); //"A 'quote' is <b>bold</b>"
     */
    function decodeHTMLEntity(htmlEntity) {
        var entities = {'&quot;' : '"', '&amp;' : '&', '&lt;' : '<', '&gt;' : '>', '&#39;' : '\'', '&nbsp;' : ' '};
        return htmlEntity.replace(/&amp;|&lt;|&gt;|&quot;|&#39;|&nbsp;/g, function(m0) {
            return entities[m0] ? entities[m0] : m0;
        });
    }

    /**
     * Transform the given string into HTML Entity string
     * @param {String} html - String for encoding
     * @return {String} HTML Entity
     * @memberof ne.util
     * @example
     *  var htmlEntityString = "<script> alert('test');</script><a href='test'>";
     *  var result = encodeHTMLEntity(htmlEntityString); //"&lt;script&gt; alert(&#39;test&#39;);&lt;/script&gt;&lt;a href=&#39;test&#39;&gt;"
     */
    function encodeHTMLEntity(html) {
        var entities = {'"': 'quot', '&': 'amp', '<': 'lt', '>': 'gt', '\'': '#39'};
        return html.replace(/[<>&"']/g, function(m0) {
            return entities[m0] ? '&' + entities[m0] + ';' : m0;
        });
    }

    /**
     * Return whether the string capable to transform into plain string is in the given string or not.
     * @param {String} string
     * @memberof ne.util
     * @return {boolean}
     */
    function hasEncodableString(string) {
        return /[<>&"']/.test(string);
    }

    /**
     * Return duplicate charters
     * @param {string} operandStr1 The operand string
     * @param {string} operandStr2 The operand string
     * @private
     * @memberof ne.util
     * @returns {string}
     * @example
     * ne.util.getDuplicatedChar('fe dev', 'nhn entertainment');
     * => 'e'
     * ne.util.getDuplicatedChar('fdsa', 'asdf');
     * => 'asdf'
     */
    function getDuplicatedChar(operandStr1, operandStr2) {
        var dupl,
            key,
            i = 0,
            len = operandStr1.length,
            pool = {};

        for (; i < len; i += 1) {
            key = operandStr1.charAt(i);
            pool[key] = 1;
        }

        for (i = 0, len = operandStr2.length; i < len; i += 1) {
            key = operandStr2.charAt(i);
            if(pool[key]) {
                pool[key] += 1;
            }
        }

        pool = ne.util.filter(pool, function(item) {
            return item > 1;
        });

        pool = ne.util.keys(pool).sort();
        dupl = pool.join('');

        return dupl;
    }

    ne.util.decodeHTMLEntity = decodeHTMLEntity;
    ne.util.encodeHTMLEntity = encodeHTMLEntity;
    ne.util.hasEncodableString = hasEncodableString;
    ne.util.getDuplicatedChar = getDuplicatedChar;

})(window.ne);

/**********
 * tricks.js
 **********/

/**
 * @fileoverview collections of some technic methods.
 * @author NHN Ent. FE Development Team <e0242.nhnent.com>
 */

/** @namespace ne */
/** @namespace ne.util */

(function(ne) {
    'use strict';
    var aps = Array.prototype.slice;

    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    /* istanbul ignore if */
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * Creates a debounced function that delays invoking fn until after delay milliseconds has elapsed
     * since the last time the debouced function was invoked.
     * @param {function} fn The function to debounce.
     * @param {number} [delay=0] The number of milliseconds to delay
     * @memberof ne.util
     * @returns {function} debounced function.
     * @example
     *
     * function someMethodToInvokeDebounced() {}
     *
     * var debounced = ne.util.debounce(someMethodToInvokeDebounced, 300);
     *
     * // invoke repeatedly
     * debounced();
     * debounced();
     * debounced();
     * debounced();
     * debounced();
     * debounced();    // last invoke of debounced()
     *
     * // invoke someMethodToInvokeDebounced() after 300 milliseconds.
     */
    function debounce(fn, delay) {
        var timer,
            args;

        /* istanbul ignore next */
        delay = delay || 0;

        function debounced() {
            args = arguments;

            window.clearTimeout(timer);
            timer = window.setTimeout(function() {
                fn.apply(null, args);
            }, delay);
        }

        return debounced;
    }

    /**
     * return timestamp
     * @memberof ne.util
     * @returns {number} The number of milliseconds from Jan. 1970 00:00:00 (GMT)
     */
    function timestamp() {
        return +(new Date());
    }

    /**
     * Creates a throttled function that only invokes fn at most once per every interval milliseconds.
     *
     * You can use this throttle short time repeatedly invoking functions. (e.g MouseMove, Resize ...)
     *
     * if you need reuse throttled method. you must remove slugs (e.g. flag variable) related with throttling.
     * @param {function} fn function to throttle
     * @param {number} [interval=0] the number of milliseconds to throttle invocations to.
     * @memberof ne.util
     * @returns {function} throttled function
     * @example
     *
     * function someMethodToInvokeThrottled() {}
     *
     * var throttled = ne.util.throttle(someMethodToInvokeThrottled, 300);
     *
     * // invoke repeatedly
     * throttled();    // invoke (leading)
     * throttled();
     * throttled();    // invoke (near 300 milliseconds)
     * throttled();
     * throttled();
     * throttled();    // invoke (near 600 milliseconds)
     * // ...
     * // invoke (trailing)
     *
     * // if you need reuse throttled method. then invoke reset()
     * throttled.reset();
     */
    function throttle(fn, interval) {
        var base,
            _timestamp = ne.util.timestamp,
            debounced,
            isLeading = true,
            stamp,
            args,
            tick = function(_args) {
                fn.apply(null, _args);
                base = null;
            };

        /* istanbul ignore next */
        interval = interval || 0;

        debounced = ne.util.debounce(tick, interval);

        function throttled() {
            args = aps.call(arguments);

            if (isLeading) {
                tick(args);
                isLeading = false;
                return;
            }

            stamp = _timestamp();

            base = base || stamp;

            debounced();

            if ((stamp - base) >= interval) {
                tick(args);
            }
        }

        function reset() {
            isLeading = true;
            base = null;
        }

        throttled.reset = reset;
        return throttled;
    }

    ne.util.timestamp = timestamp;
    ne.util.debounce = debounce;
    ne.util.throttle = throttle;
})(window.ne);


/**********
 * type.js
 **********/

/**
 * @fileoverview This module provides some functions to check the type of variable
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency collection.js
 */

(function(ne) {
    'use strict';
    /* istanbul ignore if */
    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    /**
     * Check whether the given variable is existing or not.<br>
     *  If the given variable is not null and not undefined, returns true.
     * @param {*} param - Target for checking
     * @returns {boolean} Is existy?
     * @memberOf ne.util
     * @example
     *  ne.util.isExisty(''); //true
     *  ne.util.isExisty(0); //true
     *  ne.util.isExisty([]); //true
     *  ne.util.isExisty({}); //true
     *  ne.util.isExisty(null); //false
     *  ne.util.isExisty(undefined); //false
    */
    function isExisty(param) {
        return param != null;
    }

    /**
     * Check whether the given variable is undefined or not.<br>
     *  If the given variable is undefined, returns true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is undefined?
     * @memberOf ne.util
     */
    function isUndefined(obj) {
        return obj === undefined;
    }

    /**
     * Check whether the given variable is null or not.<br>
     *  If the given variable(arguments[0]) is null, returns true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is null?
     * @memberOf ne.util
     */
    function isNull(obj) {
        return obj === null;
    }

    /**
     * Check whether the given variable is truthy or not.<br>
     *  If the given variable is not null or not undefined or not false, returns true.<br>
     *  (It regards 0 as true)
     * @param {*} obj - Target for checking
     * @return {boolean} Is truthy?
     * @memberOf ne.util
     */
    function isTruthy(obj) {
        return isExisty(obj) && obj !== false;
    }

    /**
     * Check whether the given variable is falsy or not.<br>
     *  If the given variable is null or undefined or false, returns true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is falsy?
     * @memberOf ne.util
     */
    function isFalsy(obj) {
        return !isTruthy(obj);
    }


    var toString = Object.prototype.toString;

    /**
     * Check whether the given variable is an arguments object or not.<br>
     *  If the given variable is an arguments object, return true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is arguments?
     * @memberOf ne.util
     */
    function isArguments(obj) {
        var result = isExisty(obj) &&
            ((toString.call(obj) === '[object Arguments]') || !!obj.callee);

        return result;
    }

    /**
     * Check whether the given variable is an instance of Array or not.<br>
     *  If the given variable is an instance of Array, return true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is array instance?
     * @memberOf ne.util
     */
    function isArray(obj) {
        return obj instanceof Array;
    }

    /**
     * Check whether the given variable is an object or not.<br>
     *  If the given variable is an object, return true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is object?
     * @memberOf ne.util
     */
    function isObject(obj) {
        return obj === Object(obj);
    }

    /**
     * Check whether the given variable is a function or not.<br>
     *  If the given variable is a function, return true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is function?
     * @memberOf ne.util
     */
    function isFunction(obj) {
        return obj instanceof Function;
    }

    /**
     * Check whether the given variable is a number or not.<br>
     *  If the given variable is a number, return true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is number?
     * @memberOf ne.util
     */
    function isNumber(obj) {
        return typeof obj === 'number' || obj instanceof Number;
    }

    /**
     * Check whether the given variable is a string or not.<br>
     *  If the given variable is a string, return true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is string?
     * @memberOf ne.util
     */
    function isString(obj) {
        return typeof obj === 'string' || obj instanceof String;
    }

    /**
     * Check whether the given variable is a boolean or not.<br>
     *  If the given variable is a boolean, return true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is boolean?
     * @memberOf ne.util
     */
    function isBoolean(obj) {
        return typeof obj === 'boolean' || obj instanceof Boolean;
    }


    /**
     * Check whether the given variable is an instance of Array or not.<br>
     *  If the given variable is an instance of Array, return true.<br>
     *  (It is used for multiple frame environments)
     * @param {*} obj - Target for checking
     * @return {boolean} Is an instance of array?
     * @memberOf ne.util
     */
    function isArraySafe(obj) {
        return toString.call(obj) === '[object Array]';
    }

    /**
     * Check whether the given variable is a function or not.<br>
     *  If the given variable is a function, return true.<br>
     *  (It is used for multiple frame environments)
     * @param {*} obj - Target for checking
     * @return {boolean} Is a function?
     * @memberOf ne.util
     */
    function isFunctionSafe(obj) {
        return toString.call(obj) === '[object Function]';
    }

    /**
     * Check whether the given variable is a number or not.<br>
     *  If the given variable is a number, return true.<br>
     *  (It is used for multiple frame environments)
     * @param {*} obj - Target for checking
     * @return {boolean} Is a number?
     * @memberOf ne.util
     */
    function isNumberSafe(obj) {
        return toString.call(obj) === '[object Number]';
    }

    /**
     * Check whether the given variable is a string or not.<br>
     *  If the given variable is a string, return true.<br>
     *  (It is used for multiple frame environments)
     * @param {*} obj - Target for checking
     * @return {boolean} Is a string?
     * @memberOf ne.util
     */
    function isStringSafe(obj) {
        return toString.call(obj) === '[object String]';
    }

    /**
     * Check whether the given variable is a boolean or not.<br>
     *  If the given variable is a boolean, return true.<br>
     *  (It is used for multiple frame environments)
     * @param {*} obj - Target for checking
     * @return {boolean} Is a boolean?
     * @memberOf ne.util
     */
    function isBooleanSafe(obj) {
        return toString.call(obj) === '[object Boolean]';
    }

    /**
     * Check whether the given variable is a instance of HTMLNode or not.<br>
     *  If the given variables is a instance of HTMLNode, return true.
     * @param {*} html - Target for checking
     * @return {boolean} Is HTMLNode ?
     * @memberOf ne.util
     */
    function isHTMLNode(html) {
        if (typeof(HTMLElement) === 'object') {
            return (html && (html instanceof HTMLElement || !!html.nodeType));
        }
        return !!(html && html.nodeType);
    }

    /**
     * Check whether the given variable is a HTML tag or not.<br>
     *  If the given variables is a HTML tag, return true.
     * @param {*} html - Target for checking
     * @return {Boolean} Is HTML tag?
     * @memberOf ne.util
     */
    function isHTMLTag(html) {
        if (typeof(HTMLElement) === 'object') {
            return (html && (html instanceof HTMLElement));
        }
        return !!(html && html.nodeType && html.nodeType === 1);
    }

    /**
     * Check whether the given variable is empty(null, undefined, or empty array, empty object) or not.<br>
     *  If the given variables is empty, return true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is empty?
     * @memberOf ne.util
     */
    function isEmpty(obj) {
        var hasKey = false;

        if (!isExisty(obj)) {
            return true;
        }

        if (isString(obj) && obj === '') {
            return true;
        }

        if (isArray(obj) || isArguments(obj)) {
            return obj.length === 0;
        }

        if (isObject(obj) && !isFunction(obj)) {
            ne.util.forEachOwnProperties(obj, function() {
                hasKey = true;
                return false;
            });

            return !hasKey;
        }

        return true;

    }

    /**
     * Check whether the given variable is not empty(not null, not undefined, or not empty array, not empty object) or not.<br>
     *  If the given variables is not empty, return true.
     * @param {*} obj - Target for checking
     * @return {boolean} Is not empty?
     * @memberOf ne.util
     */
    function isNotEmpty(obj) {
        return !isEmpty(obj);
    }

    /**
     * Check whether the given variable is an instance of Date or not.<br>
     *  If the given variables is an instance of Date, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is an instance of Date?
     * @memberOf ne.util
     */
    function isDate(obj) {
        return obj instanceof Date;
    }

    /**
     * Check whether the given variable is an instance of Date or not.<br>
     *  If the given variables is an instance of Date, return true.<br>
     *  (It is used for multiple frame environments)
     * @param {*} obj - Target for checking
     * @returns {boolean} Is an instance of Date?
     * @memberOf ne.util
     */
    function isDateSafe(obj) {
        return toString.call(obj) === '[object Date]';
    }


    ne.util.isExisty = isExisty;
    ne.util.isUndefined = isUndefined;
    ne.util.isNull = isNull;
    ne.util.isTruthy = isTruthy;
    ne.util.isFalsy = isFalsy;
    ne.util.isArguments = isArguments;
    ne.util.isArray = Array.isArray || isArray;
    ne.util.isArraySafe = Array.isArray || isArraySafe;
    ne.util.isObject = isObject;
    ne.util.isFunction = isFunction;
    ne.util.isFunctionSafe = isFunctionSafe;
    ne.util.isNumber = isNumber;
    ne.util.isNumberSafe = isNumberSafe;
    ne.util.isDate = isDate;
    ne.util.isDateSafe = isDateSafe;
    ne.util.isString = isString;
    ne.util.isStringSafe = isStringSafe;
    ne.util.isBoolean = isBoolean;
    ne.util.isBooleanSafe = isBooleanSafe;
    ne.util.isHTMLNode = isHTMLNode;
    ne.util.isHTMLTag = isHTMLTag;
    ne.util.isEmpty = isEmpty;
    ne.util.isNotEmpty = isNotEmpty;

})(window.ne);

/**********
 * window.js
 **********/

/**
 * @fileoverview This module has some methods for handling popup-window
 * @author NHN Ent.
 *         FE Development Team <e0242@nhnent.com>
 * @dependency browser.js, type.js, object.js, collection.js, func.js, window.js
 */

(function(ne) {
    'use strict';
    if (!ne) {
        ne = window.ne = {};
    }
    if (!ne.util) {
        ne.util = window.ne.util = {};
    }

    var popup_id = 0;

    /**
     * Popup management class
     * @constructor
     * @memberof ne.util
     */
    function Popup() {

        /**
         * Caching the window-contexts of opened popups
         * @type {Object}
         */
        this.openedPopup = {};

        /**
         * In IE7, an error occurs when the closeWithParent property attaches to window object.<br>
         * So, It is for saving the value of closeWithParent instead of attaching to window object.
         * @type {Object}
         */
        this.closeWithParentPopup = {};

        /**
         * Post data bridge for IE11 popup
         * @type {string}
         */
        this.postDataBridgeUrl = '';
    }

    /**********
     * public methods
     **********/

    /**
     * Returns a popup-list administered by current window.
     * @param {string} [key] The key of popup.
     * @returns {Object} popup window list object
     */
    Popup.prototype.getPopupList = function(key) {
        var target;
        if (ne.util.isExisty(key)) {
            target = this.openedPopup[key];
        } else {
            target = this.openedPopup;
        }
        return target;
    };

    /**
     * Open popup
     * Caution:
     *  In IE11, when transfer data to popup by POST, must set the postDataBridgeUrl.
     *
     * @param {string} url - popup url
     * @param {Object} options
     *     @param {string} [options.popupName] - Key of popup window.<br>
     *      If the key is set, when you try to open by this key, the popup of this key is focused.<br>
     *      Or else a new popup window having this key is opened.
     *
     *     @param {string} [options.popupOptionStr=""] - Option string of popup window<br>
     *      It is same with the third parameter of window.open() method.<br>
     *      See {@link http://www.w3schools.com/jsref/met_win_open.asp}
     *
     *     @param {boolean} [options.closeWithParent=true] - Is closed when parent window closed?
     *
     *     @param {boolean} [options.useReload=false] - This property indicates whether reload the popup or not.<br>
     *      If true, the popup will be reloaded when you try to re-open the popup that has been opened.<br>
     *      When transmit the POST-data, some browsers alert a message for confirming whether retransmit or not.
     *
     *     @param {string} [options.postDataBridgeUrl=''] - Use this url to avoid a certain bug occuring when transmitting POST data to the popup in IE11.<br>
     *      This specific buggy situation is known to happen because IE11 tries to open the requested url not in a new popup window as intended, but in a new tab.<br>
     *      See {@link http://wiki.nhnent.com/pages/viewpage.action?pageId=240562844}
     *
     *     @param {string} [options.method=get] - The method of transmission when the form-data is transmitted to popup-window.
     *
     *     @param {Object} [options.param=null] - Using as parameters for transmission when the form-data is transmitted to popup-window.
     */
    Popup.prototype.openPopup = function(url, options) {
        options = ne.util.extend({
            popupName: 'popup_' + popup_id + '_' + (+new Date()),
            popupOptionStr: '',
            useReload: true,
            closeWithParent: true,
            method: 'get',
            param: {}
        }, options || {});

        options.method = options.method.toUpperCase();

        this.postDataBridgeUrl = options.postDataBridgeUrl || this.postDataBridgeUrl;

        var popup,
            formElement,
            useIEPostBridge = options.method === 'POST' && options.param &&
                ne.util.browser.msie && ne.util.browser.version === 11;

        if (!ne.util.isExisty(url)) {
            throw new Error('Popup#open() 팝업 URL이 입력되지 않았습니다');
        }

        popup_id += 1;

        /*
         * In form-data transmission
         * 1. Create a form before opening a popup.
         * 2. Transmit the form-data.
         * 3. Remove the form after transmission.
         */
        if (options.param) {
            if (options.method === 'GET') {
                url = url + (/\?/.test(url) ? '&' : '?') + this._parameterize(options.param);
            } else if (options.method === 'POST') {
                if (!useIEPostBridge) {
                    formElement = this.createForm(url, options.param, options.method, options.popupName);
                    url = 'about:blank';
                }
            }
        }

        popup = this.openedPopup[options.popupName];

        if (!ne.util.isExisty(popup)) {
            this.openedPopup[options.popupName] = popup = this._open(useIEPostBridge, options.param,
                url, options.popupName, options.popupOptionStr);

        } else {
            if (popup.closed) {
                this.openedPopup[options.popupName] = popup = this._open(useIEPostBridge, options.param,
                    url, options.popupName, options.popupOptionStr);

            } else {
                if (options.useReload) {
                    popup.location.replace(url);
                }
                popup.focus();
            }
        }

        this.closeWithParentPopup[options.popupName] = options.closeWithParent;

        if (!popup || popup.closed || ne.util.isUndefined(popup.closed)) {
            alert('브라우저에 팝업을 막는 기능이 활성화 상태이기 때문에 서비스 이용에 문제가 있을 수 있습니다. 해당 기능을 비활성화 해 주세요');
        }

        if (options.param && options.method === 'POST' && !useIEPostBridge) {
            if (popup) {
                formElement.submit();
            }
            if (formElement.parentNode) {
                formElement.parentNode.removeChild(formElement);
            }
        }

        window.onunload = ne.util.bind(this.closeAllPopup, this);
    };

    /**
     * Close the popup
     * @param {boolean} [skipBeforeUnload] - If true, the 'window.onunload' will be null and skip unload event.
     * @param {Window} [popup] - Window-context of popup for closing. If omit this, current window-context will be closed.
     */
    Popup.prototype.close = function(skipBeforeUnload, popup) {
        skipBeforeUnload = ne.util.isExisty(skipBeforeUnload) ? skipBeforeUnload : false;

        var target = popup || window;

        if (skipBeforeUnload) {
            window.onunload = null;
        }

        if (!target.closed) {
            target.opener = window.location.href;
            target.close();
        }
    };

    /**
     * Close all the popups in current window.
     * @param {boolean} closeWithParent - If true, popups having the closeWithParentPopup property as true will be closed.
     */
    Popup.prototype.closeAllPopup = function(closeWithParent) {
        var hasArg = ne.util.isExisty(closeWithParent);

        ne.util.forEachOwnProperties(this.openedPopup, function(popup, key) {
            if ((hasArg && this.closeWithParentPopup[key]) || !hasArg) {
                this.close(false, popup);
            }
        }, this);
    };

    /**
     * Activate(or focus) the popup of the given name.
     * @param {string} popupName - Name of popup for activation
     */
    Popup.prototype.focus = function(popupName) {
        this.getPopupList(popupName).focus();
    };

    /**
     * Return an object made of parsing the query string.
     * @return {Object} An object having some information of the query string.
     * @private
     */
    Popup.prototype.parseQuery = function() {
        var search,
            pair,
            param = {};

        search = window.location.search.substr(1);
        ne.util.forEachArray(search.split('&'), function(part) {
            pair = part.split('=');
            param[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
        });

        return param;
    };

    /**
     * Create a hidden form from the given arguments and return this form.
     * @param {string} action - URL for form transmission
     * @param {Object} [data] - Data for form transmission
     * @param {string} [method] - Method of transmission
     * @param {string} [target] - Target of transmission
     * @param {HTMLElement} [container] - Container element of form.
     * @returns {HTMLElement} Form element
     */
    Popup.prototype.createForm = function(action, data, method, target, container) {
        var form = document.createElement('form'),
            input;

        container = container || document.body;

        form.method = method || 'POST';
        form.action = action || '';
        form.target = target || '';
        form.style.display = 'none';

        ne.util.forEachOwnProperties(data, function(value, key) {
            input = document.createElement('input');
            input.name = key;
            input.type = 'hidden';
            input.value = value;
            form.appendChild(input);
        });

        container.appendChild(form);

        return form;
    };

    /**********
     * private methods
     **********/

    /**
     * Return an query string made by parsing the given object
     * @param {Object} object - An object that has information for query string
     * @returns {string} - Query string
     * @private
     */
    Popup.prototype._parameterize = function(object) {
        var query = [];

        ne.util.forEachOwnProperties(object, function(value, key) {
            query.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
        });

        return query.join('&');
    };

    /**
     * Open popup
     * @param {boolean} useIEPostBridge - A switch option whether to use alternative of tossing POST data to the popup window in IE11
     * @param {Object} param - A data for tossing to popup
     * @param {string} url - Popup url
     * @param {string} popupName - Popup name
     * @param {string} optionStr - Setting for popup, ex) 'width=640,height=320,scrollbars=yes'
     * @returns {Window} Window context of popup
     * @private
     */
    Popup.prototype._open = function(useIEPostBridge, param, url, popupName, optionStr) {
        var popup;

        if (useIEPostBridge) {
            url = this.postDataBridgeUrl + '?storageKey=' + encodeURIComponent(popupName) +
            '&redirectUrl=' + encodeURIComponent(url);
            if (!window.localStorage) {
                alert('IE11브라우저의 문제로 인해 이 기능은 브라우저의 LocalStorage 기능을 활성화 하셔야 이용하실 수 있습니다');
            } else {
                localStorage.removeItem(popupName);
                localStorage.setItem(popupName, JSON.stringify(param));

                popup = window.open(url, popupName, optionStr);
            }
        } else {
            popup = window.open(url, popupName, optionStr);
        }

        return popup;
    };

    ne.util.popup = new Popup();

})(window.ne);

},{}],3:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _handlebarsBase = require('./handlebars/base');

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)

var base = _interopRequireWildcard(_handlebarsBase);

var _handlebarsSafeString = require('./handlebars/safe-string');

var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

var _handlebarsException = require('./handlebars/exception');

var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

var _handlebarsUtils = require('./handlebars/utils');

var Utils = _interopRequireWildcard(_handlebarsUtils);

var _handlebarsRuntime = require('./handlebars/runtime');

var runtime = _interopRequireWildcard(_handlebarsRuntime);

var _handlebarsNoConflict = require('./handlebars/no-conflict');

// For compatibility and usage outside of module systems, make the Handlebars object a namespace

var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

function create() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = _handlebarsSafeString2['default'];
  hb.Exception = _handlebarsException2['default'];
  hb.Utils = Utils;
  hb.escapeExpression = Utils.escapeExpression;

  hb.VM = runtime;
  hb.template = function (spec) {
    return runtime.template(spec, hb);
  };

  return hb;
}

var inst = create();
inst.create = create;

_handlebarsNoConflict2['default'](inst);

inst['default'] = inst;

exports['default'] = inst;
module.exports = exports['default'];


},{"./handlebars/base":4,"./handlebars/exception":7,"./handlebars/no-conflict":17,"./handlebars/runtime":18,"./handlebars/safe-string":19,"./handlebars/utils":20}],4:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.HandlebarsEnvironment = HandlebarsEnvironment;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _helpers = require('./helpers');

var _decorators = require('./decorators');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var VERSION = '4.0.3';
exports.VERSION = VERSION;
var COMPILER_REVISION = 7;

exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '== 1.x.x',
  5: '== 2.0.0-alpha.x',
  6: '>= 2.0.0-beta.1',
  7: '>= 4.0.0'
};

exports.REVISION_CHANGES = REVISION_CHANGES;
var objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials, decorators) {
  this.helpers = helpers || {};
  this.partials = partials || {};
  this.decorators = decorators || {};

  _helpers.registerDefaultHelpers(this);
  _decorators.registerDefaultDecorators(this);
}

HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: _logger2['default'],
  log: _logger2['default'].log,

  registerHelper: function registerHelper(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple helpers');
      }
      _utils.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn;
    }
  },
  unregisterHelper: function unregisterHelper(name) {
    delete this.helpers[name];
  },

  registerPartial: function registerPartial(name, partial) {
    if (_utils.toString.call(name) === objectType) {
      _utils.extend(this.partials, name);
    } else {
      if (typeof partial === 'undefined') {
        throw new _exception2['default']('Attempting to register a partial as undefined');
      }
      this.partials[name] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name) {
    delete this.partials[name];
  },

  registerDecorator: function registerDecorator(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple decorators');
      }
      _utils.extend(this.decorators, name);
    } else {
      this.decorators[name] = fn;
    }
  },
  unregisterDecorator: function unregisterDecorator(name) {
    delete this.decorators[name];
  }
};

var log = _logger2['default'].log;

exports.log = log;
exports.createFrame = _utils.createFrame;
exports.logger = _logger2['default'];


},{"./decorators":5,"./exception":7,"./helpers":8,"./logger":16,"./utils":20}],5:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultDecorators = registerDefaultDecorators;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _decoratorsInline = require('./decorators/inline');

var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

function registerDefaultDecorators(instance) {
  _decoratorsInline2['default'](instance);
}


},{"./decorators/inline":6}],6:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerDecorator('inline', function (fn, props, container, options) {
    var ret = fn;
    if (!props.partials) {
      props.partials = {};
      ret = function (context, options) {
        // Create a new partials stack frame prior to exec.
        var original = container.partials;
        container.partials = _utils.extend({}, original, props.partials);
        var ret = fn(context, options);
        container.partials = original;
        return ret;
      };
    }

    props.partials[options.args[0]] = options.fn;

    return ret;
  });
};

module.exports = exports['default'];


},{"../utils":20}],7:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var loc = node && node.loc,
      line = undefined,
      column = undefined;
  if (loc) {
    line = loc.start.line;
    column = loc.start.column;

    message += ' - ' + line + ':' + column;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  /* istanbul ignore else */
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, Exception);
  }

  if (loc) {
    this.lineNumber = line;
    this.column = column;
  }
}

Exception.prototype = new Error();

exports['default'] = Exception;
module.exports = exports['default'];


},{}],8:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultHelpers = registerDefaultHelpers;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _helpersBlockHelperMissing = require('./helpers/block-helper-missing');

var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

var _helpersEach = require('./helpers/each');

var _helpersEach2 = _interopRequireDefault(_helpersEach);

var _helpersHelperMissing = require('./helpers/helper-missing');

var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

var _helpersIf = require('./helpers/if');

var _helpersIf2 = _interopRequireDefault(_helpersIf);

var _helpersLog = require('./helpers/log');

var _helpersLog2 = _interopRequireDefault(_helpersLog);

var _helpersLookup = require('./helpers/lookup');

var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

var _helpersWith = require('./helpers/with');

var _helpersWith2 = _interopRequireDefault(_helpersWith);

function registerDefaultHelpers(instance) {
  _helpersBlockHelperMissing2['default'](instance);
  _helpersEach2['default'](instance);
  _helpersHelperMissing2['default'](instance);
  _helpersIf2['default'](instance);
  _helpersLog2['default'](instance);
  _helpersLookup2['default'](instance);
  _helpersWith2['default'](instance);
}


},{"./helpers/block-helper-missing":9,"./helpers/each":10,"./helpers/helper-missing":11,"./helpers/if":12,"./helpers/log":13,"./helpers/lookup":14,"./helpers/with":15}],9:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('blockHelperMissing', function (context, options) {
    var inverse = options.inverse,
        fn = options.fn;

    if (context === true) {
      return fn(this);
    } else if (context === false || context == null) {
      return inverse(this);
    } else if (_utils.isArray(context)) {
      if (context.length > 0) {
        if (options.ids) {
          options.ids = [options.name];
        }

        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      if (options.data && options.ids) {
        var data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
        options = { data: data };
      }

      return fn(context, options);
    }
  });
};

module.exports = exports['default'];


},{"../utils":20}],10:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('../utils');

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('each', function (context, options) {
    if (!options) {
      throw new _exception2['default']('Must pass iterator to #each');
    }

    var fn = options.fn,
        inverse = options.inverse,
        i = 0,
        ret = '',
        data = undefined,
        contextPath = undefined;

    if (options.data && options.ids) {
      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
    }

    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    if (options.data) {
      data = _utils.createFrame(options.data);
    }

    function execIteration(field, index, last) {
      if (data) {
        data.key = field;
        data.index = index;
        data.first = index === 0;
        data.last = !!last;

        if (contextPath) {
          data.contextPath = contextPath + field;
        }
      }

      ret = ret + fn(context[field], {
        data: data,
        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
      });
    }

    if (context && typeof context === 'object') {
      if (_utils.isArray(context)) {
        for (var j = context.length; i < j; i++) {
          if (i in context) {
            execIteration(i, i, i === context.length - 1);
          }
        }
      } else {
        var priorKey = undefined;

        for (var key in context) {
          if (context.hasOwnProperty(key)) {
            // We're running the iterations one step out of sync so we can detect
            // the last iteration without have to scan the object twice and create
            // an itermediate keys array.
            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1);
            }
            priorKey = key;
            i++;
          }
        }
        if (priorKey !== undefined) {
          execIteration(priorKey, i - 1, true);
        }
      }
    }

    if (i === 0) {
      ret = inverse(this);
    }

    return ret;
  });
};

module.exports = exports['default'];


},{"../exception":7,"../utils":20}],11:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('helperMissing', function () /* [args, ]options */{
    if (arguments.length === 1) {
      // A missing field in a {{foo}} construct.
      return undefined;
    } else {
      // Someone is actually trying to call something, blow up.
      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    }
  });
};

module.exports = exports['default'];


},{"../exception":7}],12:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('if', function (conditional, options) {
    if (_utils.isFunction(conditional)) {
      conditional = conditional.call(this);
    }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function (conditional, options) {
    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
  });
};

module.exports = exports['default'];


},{"../utils":20}],13:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('log', function () /* message, options */{
    var args = [undefined],
        options = arguments[arguments.length - 1];
    for (var i = 0; i < arguments.length - 1; i++) {
      args.push(arguments[i]);
    }

    var level = 1;
    if (options.hash.level != null) {
      level = options.hash.level;
    } else if (options.data && options.data.level != null) {
      level = options.data.level;
    }
    args[0] = level;

    instance.log.apply(instance, args);
  });
};

module.exports = exports['default'];


},{}],14:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('lookup', function (obj, field) {
    return obj && obj[field];
  });
};

module.exports = exports['default'];


},{}],15:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('with', function (context, options) {
    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    var fn = options.fn;

    if (!_utils.isEmpty(context)) {
      var data = options.data;
      if (options.data && options.ids) {
        data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
      }

      return fn(context, {
        data: data,
        blockParams: _utils.blockParams([context], [data && data.contextPath])
      });
    } else {
      return options.inverse(this);
    }
  });
};

module.exports = exports['default'];


},{"../utils":20}],16:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('./utils');

var logger = {
  methodMap: ['debug', 'info', 'warn', 'error'],
  level: 'info',

  // Maps a given level value to the `methodMap` indexes above.
  lookupLevel: function lookupLevel(level) {
    if (typeof level === 'string') {
      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
      if (levelMap >= 0) {
        level = levelMap;
      } else {
        level = parseInt(level, 10);
      }
    }

    return level;
  },

  // Can be overridden in the host environment
  log: function log(level) {
    level = logger.lookupLevel(level);

    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
      var method = logger.methodMap[level];
      if (!console[method]) {
        // eslint-disable-line no-console
        method = 'log';
      }

      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        message[_key - 1] = arguments[_key];
      }

      console[method].apply(console, message); // eslint-disable-line no-console
    }
  }
};

exports['default'] = logger;
module.exports = exports['default'];


},{"./utils":20}],17:[function(require,module,exports){
(function (global){
/* global window */
'use strict';

exports.__esModule = true;

exports['default'] = function (Handlebars) {
  /* istanbul ignore next */
  var root = typeof global !== 'undefined' ? global : window,
      $Handlebars = root.Handlebars;
  /* istanbul ignore next */
  Handlebars.noConflict = function () {
    if (root.Handlebars === Handlebars) {
      root.Handlebars = $Handlebars;
    }
  };
};

module.exports = exports['default'];


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],18:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.checkRevision = checkRevision;
exports.template = template;
exports.wrapProgram = wrapProgram;
exports.resolvePartial = resolvePartial;
exports.invokePartial = invokePartial;
exports.noop = noop;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _utils = require('./utils');

var Utils = _interopRequireWildcard(_utils);

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _base = require('./base');

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = _base.COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
    }
  }
}

function template(templateSpec, env) {
  /* istanbul ignore next */
  if (!env) {
    throw new _exception2['default']('No environment passed to template');
  }
  if (!templateSpec || !templateSpec.main) {
    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
  }

  templateSpec.main.decorator = templateSpec.main_d;

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  env.VM.checkRevision(templateSpec.compiler);

  function invokePartialWrapper(partial, context, options) {
    if (options.hash) {
      context = Utils.extend({}, context, options.hash);
      if (options.ids) {
        options.ids[0] = true;
      }
    }

    partial = env.VM.resolvePartial.call(this, partial, context, options);
    var result = env.VM.invokePartial.call(this, partial, context, options);

    if (result == null && env.compile) {
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, options);
    }
    if (result != null) {
      if (options.indent) {
        var lines = result.split('\n');
        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }

          lines[i] = options.indent + lines[i];
        }
        result = lines.join('\n');
      }
      return result;
    } else {
      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    }
  }

  // Just add water
  var container = {
    strict: function strict(obj, name) {
      if (!(name in obj)) {
        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
      }
      return obj[name];
    },
    lookup: function lookup(depths, name) {
      var len = depths.length;
      for (var i = 0; i < len; i++) {
        if (depths[i] && depths[i][name] != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === 'function' ? current.call(context) : current;
    },

    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,

    fn: function fn(i) {
      var ret = templateSpec[i];
      ret.decorator = templateSpec[i + '_d'];
      return ret;
    },

    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams, depths) {
      var programWrapper = this.programs[i],
          fn = this.fn(i);
      if (data || depths || blockParams || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      }
      return programWrapper;
    },

    data: function data(value, depth) {
      while (value && depth--) {
        value = value._parent;
      }
      return value;
    },
    merge: function merge(param, common) {
      var obj = param || common;

      if (param && common && param !== common) {
        obj = Utils.extend({}, common, param);
      }

      return obj;
    },

    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };

  function ret(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var data = options.data;

    ret._setup(options);
    if (!options.partial && templateSpec.useData) {
      data = initData(context, data);
    }
    var depths = undefined,
        blockParams = templateSpec.useBlockParams ? [] : undefined;
    if (templateSpec.useDepths) {
      if (options.depths) {
        depths = context !== options.depths[0] ? [context].concat(options.depths) : options.depths;
      } else {
        depths = [context];
      }
    }

    function main(context /*, options*/) {
      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    }
    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    return main(context, options);
  }
  ret.isTop = true;

  ret._setup = function (options) {
    if (!options.partial) {
      container.helpers = container.merge(options.helpers, env.helpers);

      if (templateSpec.usePartial) {
        container.partials = container.merge(options.partials, env.partials);
      }
      if (templateSpec.usePartial || templateSpec.useDecorators) {
        container.decorators = container.merge(options.decorators, env.decorators);
      }
    } else {
      container.helpers = options.helpers;
      container.partials = options.partials;
      container.decorators = options.decorators;
    }
  };

  ret._child = function (i, data, blockParams, depths) {
    if (templateSpec.useBlockParams && !blockParams) {
      throw new _exception2['default']('must pass block params');
    }
    if (templateSpec.useDepths && !depths) {
      throw new _exception2['default']('must pass parent depths');
    }

    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
  };
  return ret;
}

function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
  function prog(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var currentDepths = depths;
    if (depths && context !== depths[0]) {
      currentDepths = [context].concat(depths);
    }

    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
  }

  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}

function resolvePartial(partial, context, options) {
  if (!partial) {
    if (options.name === '@partial-block') {
      partial = options.data['partial-block'];
    } else {
      partial = options.partials[options.name];
    }
  } else if (!partial.call && !options.name) {
    // This is a dynamic partial that returned a string
    options.name = partial;
    partial = options.partials[partial];
  }
  return partial;
}

function invokePartial(partial, context, options) {
  options.partial = true;
  if (options.ids) {
    options.data.contextPath = options.ids[0] || options.data.contextPath;
  }

  var partialBlock = undefined;
  if (options.fn && options.fn !== noop) {
    options.data = _base.createFrame(options.data);
    partialBlock = options.data['partial-block'] = options.fn;

    if (partialBlock.partials) {
      options.partials = Utils.extend({}, options.partials, partialBlock.partials);
    }
  }

  if (partial === undefined && partialBlock) {
    partial = partialBlock;
  }

  if (partial === undefined) {
    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
  } else if (partial instanceof Function) {
    return partial(context, options);
  }
}

function noop() {
  return '';
}

function initData(context, data) {
  if (!data || !('root' in data)) {
    data = data ? _base.createFrame(data) : {};
    data.root = context;
  }
  return data;
}

function executeDecorators(fn, prog, container, depths, data, blockParams) {
  if (fn.decorator) {
    var props = {};
    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
    Utils.extend(prog, props);
  }
  return prog;
}


},{"./base":4,"./exception":7,"./utils":20}],19:[function(require,module,exports){
// Build out our basic SafeString type
'use strict';

exports.__esModule = true;
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
  return '' + this.string;
};

exports['default'] = SafeString;
module.exports = exports['default'];


},{}],20:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.extend = extend;
exports.indexOf = indexOf;
exports.escapeExpression = escapeExpression;
exports.isEmpty = isEmpty;
exports.createFrame = createFrame;
exports.blockParams = blockParams;
exports.appendContextPath = appendContextPath;
var escape = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;',
  '=': '&#x3D;'
};

var badChars = /[&<>"'`=]/g,
    possible = /[&<>"'`=]/;

function escapeChar(chr) {
  return escape[chr];
}

function extend(obj /* , ...source */) {
  for (var i = 1; i < arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }

  return obj;
}

var toString = Object.prototype.toString;

// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
/* eslint-disable func-style */
exports.toString = toString;
var isFunction = function isFunction(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
/* istanbul ignore next */
if (isFunction(/x/)) {
  exports.isFunction = isFunction = function (value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
exports.isFunction = isFunction;

/* eslint-enable func-style */

/* istanbul ignore next */
var isArray = Array.isArray || function (value) {
  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
};

// Older IE versions do not directly support indexOf so we must implement our own, sadly.
exports.isArray = isArray;

function indexOf(array, value) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
}

function escapeExpression(string) {
  if (typeof string !== 'string') {
    // don't escape SafeStrings, since they're already safe
    if (string && string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return '';
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = '' + string;
  }

  if (!possible.test(string)) {
    return string;
  }
  return string.replace(badChars, escapeChar);
}

function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

function createFrame(object) {
  var frame = extend({}, object);
  frame._parent = object;
  return frame;
}

function blockParams(params, ids) {
  params.path = ids;
  return params;
}

function appendContextPath(contextPath, id) {
  return (contextPath ? contextPath + '.' : '') + id;
}


},{}],21:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime')['default'];

},{"./dist/cjs/handlebars.runtime":3}],22:[function(require,module,exports){
module.exports = require("handlebars/runtime")["default"];

},{"handlebars/runtime":21}],23:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Module for full management of requesting AJAX from server.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;

/**
 * @constructor
 */
function AJAX() {}

AJAX.ERROR = {
    NOT_SUPPORT: '사용하시는 브라우저가 서비스 이용에 필요한 필수 기능을 지원하지 않습니다. 최신 버전의 브라우저를 사용해 주세요.'
};

/**********
 * ajax
 **********/

/**
 * 비동기 요청을 위한 객체를 만들어 반환한다
 * @return {(XMLHttpRequest|ActiveXObject)} 비동기 통신 지원 객체
 */
AJAX.prototype._createXHR = function() {
    if (util.isExisty(util.pick(window, 'XMLHttpRequest'))) {
        return new XMLHttpRequest();
    } else if (util.isExisty(util.pick(window, 'ActiveXObject'))) {
        return new ActiveXObject('Microsoft.XMLHTTP'); // jshint ignore:line
    }

    window.alert(AJAX.ERROR.NOT_SUPPORT);
};

/**
 * 타입에 따라 데이터를 추가 가공한다
 *
 * TODO: 현재는 JSON데이터만 처리중이고 필요에 따라 늘어나야 한다
 * @param {string} dataType 데이터 타입
 * @param {*} data 가공할 데이터
 * @return {*} 가공된 데이터
 */
AJAX.prototype._processRawData = function(dataType, data) {
    var result = data;
    if (dataType === 'json') {
        try {
            result = JSON.parse(data);
        } catch (e) {
            result = data;
        }
    }

    return result;
};

/**
 * XHR의 응답 데이터를 처리한다
 * @param {object} options - ajax옵션 객체
 * @param {(XMLHttpRequest|ActiveXObject)} xhr - 비동기 요청 객체
 */
AJAX.prototype._onReadyStateChange = function(options, xhr) {
    var status,
        response,
        responseHeader;

    if (xhr.readyState !== 4) {
        return;
    }

    status = xhr.status;

    if ((status >= 200 && status < 300) || status === 304) {
        response = this._processRawData(options.dataType, xhr.responseText);
        responseHeader = util.pick(response, 'header');

        if (!responseHeader) {
            options.error();
        } else if (responseHeader.isSuccessful) {
            options.success(response);
        } else {
            options.fail(response);
        }
    } else if (status !== 0) {
        options.error();
    }

    options.complete();
};


/**
 * ajax 요청을 수행한다.
 * 
 * 요청 타입에 따른 추가 데이터 처리는 따로 하지 않으므로 사전에 미리 준비해야 한다
 * 예를 들어, get요청은 QueryString으로 url을 설정해야 하고, post등의 data를 사용하
 * 는 요청은 미리 stringfy된 값을 data옵션으로 전달해야 한다.
 *
 * @param {string} url ajax요청 할 url
 * @param {Object} options 옵션
 * @param {string} [options.method='POST'] 요청 시 사용할 http methods
 * @param {boolean} [options.async=true] 비동기 요청 사용 여부
 * @param {string} [options.type='application/json; charset=utf-8'] type 헤더 값
 * @param {string} [options.contentType='application/json'] Content-Type 헤더 값
 * @param {string} [options.dataType='json'] 서버에서 응답받기 바라는 결과의 타입
 * @param {function} [optoins.success] - isSuccessful true에 대한 콜백
 * @param {function} [options.fail] - isSuccessful false 에 대한 콜백
 * @param {function} [options.error] 요청에 대한 에러 발생 시 수행할 콜백
 * @param {function} [options.complete] 요청이 끝났을 때 (성공, 실패 여부와 무관) 수행하는 콜백
 * @param {bollean} [options.cache=true] - false 일 경우 timestamp 파라미터를 url에 붙여 캐시를 무시
 */
AJAX.prototype.ajax = function(url, options) {
    var xhr,
        data,
        separator,
        defaultOptions = {
            method: 'GET',
            async: true,
            type: 'application/json; charset=utf-8',
            contentType: 'application/json',
            dataType: 'json',
            success: function() {},
            fail: function() {},
            error: function() {},
            complete: function() {},
            cache: true
        };

    options = util.extend(defaultOptions, options);
    data = util.pick(options, 'data');
    if (!options.cache) {
        separator = ~url.indexOf('?') ? '&' : '?';
        url = url + separator + '_=' + +(new Date());
    }

    xhr = this._createXHR();
    xhr.open(options.method, url, options.async);
    xhr.setRequestHeader('type', options.type);
    xhr.setRequestHeader('content-type', options.contentType);
    xhr.onreadystatechange = util.bind(this._onReadyStateChange, this, options, xhr);
    xhr.send(data ? data : null);
};

module.exports = AJAX;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],24:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Utility module for array sort, binary search.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../common/datetime');

/**
 * A module for sorting array.
 * @module array
 */

/**********
 * Search
 **********/

/**
 * search item index using binary search algorithm.
 *
 * the array must be sorted.
 * @param {array} arr array to search.
 * @param {(string|number|boolean)} search value to search.
 * @param {function} [fn] iteratee for retrieve each element's value to search.
 * @param {function} [compare] compare function for specific sort status. default is string ascending.
 * @returns {number} The number of item index searched. return negative number when no exist that item.
 * It can use insert index after Math.abs()
 * @example
 *
 * var arr = [1, 3, 7, 11, 15, 23];
 *
 * function sortNumber(a, b) {
 *     return a - b;
 * }
 *
 * bsearch(arr, 15, null, sortNumber);    // 4
 * bsearch(arr, 21, null, sortNumber);    // -5
 *
 * arr.splice(Math.abs(bsearch(arr, 21, null, sortNumber)), 0, 21);
 * // [1, 2, 7, 11, 15, 21, 23]
 */
function bsearch(arr, search, fn, compare) {
    var minIndex = 0,
        maxIndex = arr.length - 1,
        currentIndex,
        value,
        comp;

    compare = compare || stringASC;

    while (minIndex <= maxIndex) {
        currentIndex = (minIndex + maxIndex) / 2 | 0;    // Math.floor
        value = fn ? fn(arr[currentIndex]) : arr[currentIndex];
        comp = compare(value, search);

        if (comp < 0) {
            minIndex = currentIndex + 1;
        } else if (comp > 0) {
            maxIndex = currentIndex - 1;
        } else {
            return currentIndex;
        }
    }

    return ~maxIndex;
}

/**********
 * Compare Functions
 **********/

/**
 * compare function for array sort.
 *
 * sort array by ascending.
 * @param {boolean} a The boolean to compare
 * @param {boolean} b The boolean to compare.
 * @returns {number} Result of comparison.
 */
function booleanASC(a, b) {
    if (a !== b) {
        return a ? -1 : 1;
    }
    return 0;
}

/**
 * compare function for array sort.
 *
 * sort array by descending.
 * @param {boolean} a The boolean to compare
 * @param {boolean} b The boolean to compare.
 * @returns {number} Result of comparison.
 */
function booleanDESC(a, b) {
    if (a !== b) {
        return a ? 1 : -1;
    }
    return 0;
}

/**
 * compare function for array sort.
 *
 * sort array by number ascending.
 * @param {number} _a The number to compare.
 * @param {number} _b The number to compare.
 * @returns {number} Result of comparison.
 */
function numberASC(_a, _b) {
    var a = +_a,
        b = +_b;

    return a - b;
}

/**
 * compare function for array sort.
 *
 * sort array by number descending.
 * @param {number} _a The number to compare.
 * @param {number} _b The number to compare.
 * @returns {number} Result of comparison.
 */
function numberDESC(_a, _b) {
    var a = +_a,
        b = +_b;

    return b - a;
}

/**
 * compare function for array sort.
 *
 * sort array by string ascending
 * @param {string} _a The string to compare.
 * @param {string} _b The string to compare.
 * @returns {number} Result of comparison.
 */
function stringASC(_a, _b) {
    var a = _a + '',
        b = _b + '';

    if (a > b) {
        return 1;
    } else if (a < b) {
        return -1;
    }

    return 0;
}

/**
 * compare function for array sort.
 *
 * sort array by string descending
 * @param {string} _a The string to compare.
 * @param {string} _b The string to compare.
 * @returns {number} Result of comparison.
 */
function stringDESC(_a, _b) {
    var a = _a + '',
        b = _b + '';

    if (a > b) {
        return -1;
    } else if (a < b) {
        return 1;
    }

    return 0;
}

/**
 * compare function for array sort.
 *
 * sort array by string ascending with ignore case.
 * @param {string} _a The string to compare.
 * @param {string} _b The string to compare.
 * @returns {number} Result of comparison.
 */
function stringASCIgnoreCase(_a, _b) {
    var a = (_a + '').toLowerCase(),
        b = (_b + '').toLowerCase();

    if (a > b) {
        return 1;
    } else if (a < b) {
        return -1;
    }

    return 0;
}

/**
 * compare function for array sort.
 *
 * sort array by string descending with ignore case.
 * @param {string} _a The string to compare.
 * @param {string} _b The string to compare.
 * @returns {number} Result of comparison.
 */
function stringDESCIgnoreCase(_a, _b) {
    var a = (_a + '').toLowerCase(),
        b = (_b + '').toLowerCase();

    if (a > b) {
        return -1;
    } else if (a < b) {
        return 1;
    }

    return 0;
}

/**
 * Compare event models for sort.
 *
 * 1. all day event first.
 * 2. early starts.
 * 3. longest duration.
 * 4. early created.
 * @param {(Event|EventViewModel)} a The object event instance.
 * @param {(Event|EventViewModel)} b The object event instance.
 * @returns {number} Result of comparison.
 */
function eventASC(a, b) {
    var durationA,
        durationB,
        allDayCompare,
        startsCompare;

    a = a.valueOf();
    b = b.valueOf();

    allDayCompare = booleanASC(a.isAllDay, b.isAllDay);

    if (allDayCompare) {
        return allDayCompare;
    }

    startsCompare = datetime.compare(a.getStarts(), b.getStarts());

    if (startsCompare) {
        return startsCompare;
    }

    durationA = a.duration().getTime();
    durationB = b.duration().getTime();

    if (durationA < durationB) {
        return 1;
    } else if (durationA > durationB) {
        return -1;
    }

    return util.stamp(a) - util.stamp(b);
}


module.exports = {
    bsearch: bsearch,
    compare: {
        event: {
            asc: eventASC
        },
        bool: {
            asc: booleanASC,
            desc: booleanDESC
        },
        num: {
            asc: numberASC,
            desc: numberDESC
        },
        str: {
            asc: stringASC,
            desc: stringDESC,
            ascIgnoreCase: stringASCIgnoreCase,
            descIgnoreCase: stringDESCIgnoreCase
        }
    }
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/datetime":28}],25:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Add autoscroll feature to elements that prevented text selection.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domevent = require('../common/domevent');
var domutil = require('../common/domutil');
var Point = require('../common/point');

var SCROLL_INTERVAL = 30;
var SCROLL_MAX = 15;
var SCROLL_CLICK_INCREASED = 2;    // IE에서 스크롤 바 클릭 시 실제 UI pixel 보다 넓게 잡히는 현상 offset.

/**
 * Add autoscroll feature to elements that prevented text selection.
 * @constructor
 * @param {HTMLElement} container - HTMLElement to add autoscroll features.
 */
function AutoScroll(container) {
    /**
     * @type {HTMLElement}
     */
    this.container = container;

    /**
     * @type {AutoScroll.DIRECTION}
     */
    this._direction = AutoScroll.DIRECTION.INSIDE;

    /**
     * @type {number}
     */
    this._offset = 0;

    /**
     * interval to scrolling
     * @type {number}
     */
    this._intervalID = 0;

    domevent.on(container, {
        'mousedown': this._onMouseDown
    }, this);
}

/**
 * @enum
 */
AutoScroll.DIRECTION = {
    INSIDE: 0,
    TOP: 1,
    RIGHT: 2,
    BOTTOM: 3,
    LEFT: 4
};

/**
 * Instance destroy method.
 */
AutoScroll.prototype.destroy = function() {
    domevent.off(this.container, {
        'mousedown': this._onMouseDown,
        'mousemove': this._onMouseMove,
        'mouseup': this._onMouseUp
    }, this);

    window.clearInterval(this._intervalID);
    this._intervalID = this._direction = this.container = null;
};

/**
 * Normalize ClientRect and calculate each position of edges.
 * @param {ClientRect} clientRect - ClientRect object of element.
 * @returns {object} edges.
 */
AutoScroll.prototype._getEdgePositions = function(clientRect) {
    return {
        top: clientRect.top,
        right: clientRect.left + clientRect.width,
        bottom: clientRect.bottom,
        left: clientRect.left
    };
};

/**
 * Get element real size ("real size" -> size without scrollbar)
 * @param {HTMLElement} el - element want to know real size ("real size" -> size without scrollbar)
 * @returns {number[]} real size [width, height]
 */
AutoScroll.prototype.getRealSize = function(el) {
    var computed = domutil.getComputedStyle(el),
        border,
        padding;

    border = parseFloat(computed.getPropertyValue('border-top-width')) +
        parseFloat(computed.getPropertyValue('border-bottom-width'));
    padding = parseFloat(computed.getPropertyValue('padding-top')) +
        parseFloat(computed.getPropertyValue('padding-bottom'));

    return [el.clientWidth + border + padding, el.clientHeight + border + padding];
};

/**
 * Check supplied element has scrollbar.
 * @param {HTMLElement} el - element want to know has scrollbar.
 * @returns {boolean[]} has scrollbar? [horizontal, vertical]
 */
AutoScroll.prototype.hasScrollbar = function(el) {
    var realSize = this.getRealSize(el);

    return [
        el.offsetWidth > Math.ceil(realSize[0]),
        el.offsetHeight > Math.ceil(realSize[1])
    ];
};

/**
 * @param {HTMLElement} el - element want to know.
 * @param {MouseEvent} mouseEvent - mouse event object.
 * @returns {boolean} mouse pointer is on the scrollbar?
 */
AutoScroll.prototype.isOnScrollbar = function(el, mouseEvent) {
    var realSize = this.getRealSize(el),
        pos = domevent.getMousePosition(mouseEvent, el),
        mouseInScrollbar = false;

    mouseInScrollbar = (realSize[0] - SCROLL_CLICK_INCREASED < pos[0] ||
                        realSize[1] - SCROLL_CLICK_INCREASED < pos[1]);

    return mouseInScrollbar;
};

/**
 * MouseDown event handler
 * @param {MouseEvent} mouseDownEvent - mouse down event
 */
AutoScroll.prototype._onMouseDown = function(mouseDownEvent) {
    // only primary button can start drag.
    if (domevent.getMouseButton(mouseDownEvent) !== 0) {
        return;
    }

    // deactivate autoscroll feature when mouse is on the scrollbar. (IE)
    if (util.browser.msie && this.isOnScrollbar(this.container, mouseDownEvent)) {
        return;
    }

    window.clearInterval(this._intervalID);
    this._intervalID = window.setInterval(util.bind(this._onTick, this), SCROLL_INTERVAL);

    domevent.on(global, {
        'mousemove': this._onMouseMove,
        'mouseup': this._onMouseUp
    }, this);
};

/**
 * MouseMove event handler
 * @param {MouseEvent} mouseEvent - mouse move event object.
 */
AutoScroll.prototype._onMouseMove = function(mouseEvent) {
    var edge = this._getEdgePositions(this.container.getBoundingClientRect()),
        pos = Point.n(domevent.getMousePosition(mouseEvent));

    if (pos.y >= edge.top && pos.y <= edge.bottom &&
        pos.x >= edge.left && pos.x <= edge.right) {
        this._direction = AutoScroll.DIRECTION.INSIDE;
        return;
    }

    if (pos.y < edge.top) {
        this._direction = AutoScroll.DIRECTION.TOP;
        this._offset = edge.top - pos.y;
        return;
    }

    if (pos.y > edge.bottom) {
        this._direction = AutoScroll.DIRECTION.BOTTOM;
        this._offset = pos.y - edge.bottom;
        return;
    }

    if (pos.x < edge.left) {
        this._direction = AutoScroll.DIRECTION.LEFT;
        this._offset = edge.left - pos.x;
        return;
    }

    this._direction = AutoScroll.DIRECTION.RIGHT;
    this._offset = pos.x - edge.right;
    return;
};

/**
 * MouseUp event handler.
 */
AutoScroll.prototype._onMouseUp = function() {
    window.clearInterval(this._intervalID);
    this._intervalID = 0;
    this._direction = AutoScroll.DIRECTION.INSIDE;
    this._offset = 0;

    domevent.off(global, {
        'mousemove': this._onMouseMove,
        'mouseup': this._onMouseUp
    }, this);
};

/**
 * Interval tick event handler
 */
AutoScroll.prototype._onTick = function() {
    var direction = this._direction,
        container,
        factor;

    if (!direction) {
        return;
    }

    container = this.container;
    factor = Math.min(this._offset, SCROLL_MAX);

    switch (direction) {
        case AutoScroll.DIRECTION.TOP:
            container.scrollTop -= factor;
            break;
        case AutoScroll.DIRECTION.RIGHT:
            container.scrollLeft += factor;
            break;
        case AutoScroll.DIRECTION.BOTTOM:
            container.scrollTop += factor;
            break;
        default:
            container.scrollLeft -= factor;
            break;
    }
};

module.exports = AutoScroll;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/domevent":30,"../common/domutil":31,"../common/point":33}],26:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Common collections.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util,
    forEachProp = util.forEachOwnProperties,
    forEachArr = util.forEachArray,
    isFunc = util.isFunction,
    isObj = util.isObject;

var aps = Array.prototype.slice;

/**
 * Common collection.
 *
 * It need function for get model's unique id.
 *
 * if the function is not supplied then it use default function {@link Collection#getItemID}
 * @constructor
 * @param {function} [getItemIDFn] function for get model's id.
 */
function Collection(getItemIDFn) {
    /**
     * @type {object.<string, *>}
     */
    this.items = {};

    /**
     * @type {number}
     */
    this.length = 0;

    if (isFunc(getItemIDFn)) {
        /**
         * @type {function}
         */
        this.getItemID = getItemIDFn;
    }
}

/**********
 * static props
 **********/

Collection.filter = {
    /**
     * return AND operate all of function's return value
     * @param {array} arr filters
     * @param {...*} [params] support filter parameters
     * @return {boolean} AND operated value
     */
    and: function(arr, params) {    // eslint-disable-line
        var args = aps.call(arguments, 1),
            i = 0,
            cnt = arr.length;

        for (; i < cnt; i += 1) {
            if (!arr[i].apply(null, args)) {
                return false;
            }
        }

        return true;
    },

    /**
     * return OR operate all of function's return value
     * @param {array} arr filters
     * @param {...*} [params] support filter parameters
     * @return {boolean} OR operated value
     */
    or: function(arr, params) {    // eslint-disable-line
        var args = aps.call(arguments, 1),
            tmp,
            result;

        forEachArr(arr, function(filter) {
            tmp = filter.apply(null, args);

            if (util.isUndefined(result)) {
                result = tmp;
            }

            result = (result || tmp);
        });

        return result;
    }
};

/**
 * Merge several collections.
 *
 * You can\'t merge collections different _getEventID functions. Take case of use.
 * @param {...Collection} collections collection arguments to merge
 * @returns {Collection} merged collection.
 */
Collection.merge = function(collections) {    // eslint-disable-line
    var cols = aps.call(arguments),
        newItems = {},
        merged = new Collection(cols[0].getItemID),
        extend = util.extend;

    forEachArr(cols, function(col) {
        extend(newItems, col.items);
    });

    merged.items = newItems;
    merged.length = util.keys(merged.items).length;

    return merged;
};

/**********
 * prototype props
 **********/

/**
 * get model's unique id.
 * @param {object} item model instance.
 * @returns {number} model unique id.
 */
Collection.prototype.getItemID = function(item) {
    return item._id + '';
};

/**
 * add models.
 * @param {...*} item models to add this collection.
 */
Collection.prototype.add = function(item) {
    var id,
        ownItems;

    if (arguments.length > 1) {
        forEachArr(aps.call(arguments), function(o) {
            this.add(o);
        }, this);

        return;
    }

    id = this.getItemID(item);
    ownItems = this.items;

    if (!ownItems[id]) {
        this.length += 1;
    }
    ownItems[id] = item;
};

/**
 * remove models.
 * @param {...(object|string|number)} id model instance or unique id to delete.
 * @returns {array} deleted model list.
 */
Collection.prototype.remove = function(id) {
    var removed = [],
        ownItems,
        itemToRemove;

    if (!this.length) {
        return removed;
    }

    if (arguments.length > 1) {
        removed = util.map(aps.call(arguments), function(id) {
            return this.remove(id);
        }, this);

        return removed;
    }

    ownItems = this.items;

    if (isObj(id)) {
        id = this.getItemID(id);
    }

    if (!ownItems[id]) {
        return removed;
    }

    this.length -= 1;
    itemToRemove = ownItems[id];
    delete ownItems[id];

    return itemToRemove;
};

/**
 * remove all models in collection.
 */
Collection.prototype.clear = function() {
    this.items = {};
    this.length = 0;
};

/**
 * check collection has specific model.
 * @param {(object|string|number|function)} id model instance or id or filter function to check
 * @returns {boolean} is has model?
 */
Collection.prototype.has = function(id) {
    var isFilter,
        has;

    if (!this.length) {
        return false;
    }

    isFilter = isFunc(id);
    has = false;

    if (isFilter) {
        this.each(function(item) {
            if (id(item) === true) {
                has = true;
                return false;
            }
        });
    } else {
        id = isObj(id) ? this.getItemID(id) : id;
        has = util.isExisty(this.items[id]);
    }

    return has;
};

/**
 * invoke callback when model exist in collection.
 * @param {(string|number)} id model unique id.
 * @param {function} fn the callback.
 * @param {*} [context] callback context.
 */
Collection.prototype.doWhenHas = function(id, fn, context) {
    var item = this.items[id];

    if (!util.isExisty(item)) {
        return;
    }

    fn.call(context || this, item);
};

/**
 * Search model. and return new collection.
 * @param {function} filter filter function.
 * @returns {Collection} new collection with filtered models.
 * @example
 * collection.find(function(item) {
 *     return item.edited === true;
 * });
 *
 * function filter1(item) {
 *     return item.edited === false;
 * }
 *
 * function filter2(item) {
 *     return item.disabled === false;
 * }
 *
 * collection.find(function(item) {
 *     return Collection.filter.and([filter1, filter2], item);
 * });
 *
 * collection.find(function(item) {
 *     return Collection.filter.or([filter1, filter2], item);
 * });
 */
Collection.prototype.find = function(filter) {
    var result = new Collection();

    if (this.hasOwnProperty('getItemID')) {
        result.getItemID = this.getItemID;
    }

    this.each(function(item) {
        if (filter(item) === true) {
            result.add(item);
        }
    });

    return result;
};

/**
 * Group element by specific key values.
 *
 * if key parameter is function then invoke it and use returned value.
 * @param {(string|number|function|array)} key key property or getter function. if string[] supplied, create each collection before grouping.
 * @param {function} [groupFunc] - function that return each group's key
 * @returns {object.<string, Collection>} grouped object
 * @example
 * 
 * // pass `string`, `number`, `boolean` type value then group by property value.
 * collection.groupBy('gender');    // group by 'gender' property value.
 * collection.groupBy(50);          // group by '50' property value.
 * 
 * // pass `function` then group by return value. each invocation `function` is called with `(item)`.
 * collection.groupBy(function(item) {
 *     if (item.score > 60) {
 *         return 'pass';
 *     }
 *     return 'fail';
 * });
 *
 * // pass `array` with first arguments then create each collection before grouping.
 * collection.groupBy(['go', 'ruby', 'javascript']);
 * // result: { 'go': empty Collection, 'ruby': empty Collection, 'javascript': empty Collection }
 *
 * // can pass `function` with `array` then group each elements.
 * collection.groupBy(['go', 'ruby', 'javascript'], function(item) {
 *     if (item.isFast) {
 *         return 'go';
 *     }
 *
 *     return item.name;
 * });
 */
Collection.prototype.groupBy = function(key, groupFunc) {
    var result = {},
        collection,
        baseValue,
        isFunc = util.isFunction,
        keyIsFunc = isFunc(key),
        getItemIDFn = this.getItemID;

    if (util.isArray(key)) {
        util.forEachArray(key, function(k) {
            result[k + ''] = new Collection(getItemIDFn);
        });

        if (!groupFunc) {
            return result;
        }

        key = groupFunc;
        keyIsFunc = true;
    }

    this.each(function(item) {
        if (keyIsFunc) {
            baseValue = key(item);
        } else {
            baseValue = item[key];

            if (isFunc(baseValue)) {
                baseValue = baseValue.apply(item);
            }
        }

        collection = result[baseValue];

        if (!collection) {
            collection = result[baseValue] = new Collection(getItemIDFn);
        }

        collection.add(item);
    });

    return result;
};

/**
 * Return single item in collection.
 *
 * Returned item is inserted in this collection firstly.
 * @returns {object} item.
 */
Collection.prototype.single = function() {
    var result;

    this.each(function(item) {
        result = item;
        return false;
    }, this);

    return result;
};

/**
 * sort a basis of supplied compare function.
 * @param {function} compareFunction compareFunction
 * @returns {array} sorted array.
 */
Collection.prototype.sort = function(compareFunction) {
    var arr = [];

    this.each(function(item) {
        arr.push(item);
    });

    if (isFunc(compareFunction)) {
        arr = arr.sort(compareFunction);
    }

    return arr;
};

/**
 * iterate each model element.
 *
 * when iteratee return false then break the loop.
 * @param {function} iteratee iteratee(item, index, items)
 * @param {*} [context] context
 */
Collection.prototype.each = function(iteratee, context) {
    forEachProp(this.items, iteratee, context || this);
};

/**
 * return new array with collection items.
 * @returns {array} new array.
 */
Collection.prototype.toArray = function() {
    if (!this.length) {
        return [];
    }

    return util.map(this.items, function(item) {
        return item;
    });
};

module.exports = Collection;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],27:[function(require,module,exports){
(function (global){
/**
 * @fileoverview common/general utilities.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var Collection = require('../common/collection');
var aps = Array.prototype.slice;

function eventIDGetter(event) {
    return event.cid();
}

module.exports = {
    /**
     * @param {...*} initItems - items to add newly created collection.
     * @returns {Collection} new collection for event models.
     */
    createEventCollection: function(initItems) {    // eslint-disable-line
        var collection = new Collection(eventIDGetter);

        if (arguments.length) {
            collection.add.apply(collection, arguments);
        }

        return collection;
    },

    /**
     * Get ratio value.
     *
     * a : b = y : X;
     *
     * =
     *
     * X = (b * y) / a;
     * @param {number} a - a
     * @param {number} b - b
     * @param {number} y - y
     * @returns {number} ratio value
     */
    ratio: function(a, b, y) {
        // a : b = y : x;
        return (b * y) / a;
    },

    /**
     * Find nearest value from supplied params.
     * @param {number} value - value to find.
     * @param {array} nearest - nearest array.
     * @returns {number} nearest value
     */
    nearest: function(value, nearest) {
        var diff = util.map(nearest, function(v) {
                return Math.abs(value - v);
            }),
            nearestIndex = util.inArray(Math.min.apply(null, diff), diff);

        return nearest[nearestIndex];
    },

    /**
     * pick value from object then return utility object to treat it.
     * @param {object} obj - object to search supplied path property.
     * @param {...string} paths - rest parameter that string value to search property in object.
     * @returns {object} pick object.
     */
    pick2: function(obj, paths) {    // eslint-disable-line
        var result = util.pick.apply(null, arguments),
            pick;

        pick = {
            /**
             * @returns {*} picked value.
             */
            val: function() {
                return result;
            },

            /**
             * invoke supplied function in picked object.
             *
             * the callback context is set picked object.
             * @param {string|function} fn - function to invoke in picked object.
             * @returns {*} result of invoke.
             */
            then: function(fn) {
                var args;

                if (!result) {
                    return undefined;    //eslint-disable-line
                }

                args = aps.call(arguments, 1);

                if (util.isString(fn)) {
                    return (util.pick(result, fn) || function() {}).apply(result, args);
                }

                return fn.call(result, result);
            }
        };

        return pick;
    },

    /**
     * Mixin method.
     *
     * (extend methods except property name 'mixin')
     * @param {object} from - mixin object.
     * @param {object} to - object to mixin.
     */
    mixin: function(from, to) {
        util.extend(to.prototype, from);
    }
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/collection":26}],28:[function(require,module,exports){
(function (global){
/**
 * @fileoverview datetime utility module
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util,
    opt = Object.prototype.toString;

var dateFormatRx = /^(\d{4}[-|\/]*\d{2}[-|\/]*\d{2})\s?(\d{2}:\d{2}:\d{2})?$/;

var datetime,
    tokenFunc;

var memo = {
    millisecondsTo: {},
    millisecondsFrom: {}
};

tokenFunc = {
    /**
     * @param {Date} date date object.
     * @returns {string} YYYYMMDD
     */
    'YYYYMMDD': function(date) {
        return [
            date.getFullYear(),
            datetime.leadingZero(date.getMonth() + 1, 2),
            datetime.leadingZero(date.getDate(), 2)
        ].join('');
    },
    /**
     * @param {Date} date date object
     * @returns {string} four digit year number
     */
    'YYYY': function(date) {
        return date.getFullYear() + '';
    },

    /**
     * @param {Date} date date object
     * @returns {string} two digit month number
     */
    'MM': function(date) {
        return datetime.leadingZero(date.getMonth() + 1, 2);
    },

    /**
     * @param {Date} date date object
     * @returns {string} two digit date number
     */
    'DD': function(date) {
        return datetime.leadingZero(date.getDate(), 2);
    },

    /**
     * @param {Date} date date object
     * @returns {string} HH:mm
     */
    'HH:mm': function(date) {
        var hour = date.getHours(),
            minutes = date.getMinutes();

        return datetime.leadingZero(hour, 2) + ':' +
            datetime.leadingZero(minutes, 2);
    },

    /**
     * format to local date
     * @param {Date} date date object
     * @returns {string} 1988-09-25T09:00:00+09:00
     */
    'LOCAL': function(date) {
        var timeZoneOffset = -date.getTimezoneOffset(),
            diff = timeZoneOffset >= 0 ? '+' : '-',
            pad = function(num) {
                return datetime.leadingZero(num, 2);
            };

        return date.getFullYear() 
            + '-' + pad(date.getMonth() + 1)
            + '-' + pad(date.getDate())
            + 'T' + pad(date.getHours())
            + ':' + pad(date.getMinutes()) 
            + ':' + pad(date.getSeconds()) 
            + diff + pad(timeZoneOffset / 60) 
            + ':' + pad(timeZoneOffset % 60);
    }
};

datetime = {
    /**
     * The number of milliseconds one day.
     * @type {number}
     */
    MILLISECONDS_PER_DAY: 86400000,

    /**
     * The number of milliseconds one hour.
     * @type {number}
     */
    MILLISECONDS_PER_HOUR: 3600000,

    /**
     * convert milliseconds
     * @param {string} type - type of value.
     * @param {number} value - value to convert.
     * @param {function} iteratee - iteratee function to use reduce.
     * @returns {number} converted value.
     */
    _convMilliseconds: function(type, value, iteratee) {
        var conv = [60, 60, 1000],
            index = {
                hour: 0,
                minutes: 1,
                seconds: 2
            };

        if (!(type in index) || global.isNaN(value)) {
            return false;
        }

        return util.reduce([value].concat(conv.slice(index[type])), iteratee);
    },

    /**
     * Convert milliseconds value to other type
     * @param {type} type convert to type want to. support "hour", "minutes", "seconds" only.
     * @param {value} value - value to convert.
     * @returns {number} converted value.
     */
    millisecondsTo: function(type, value) {
        var cache = memo.millisecondsTo,
            key = type + value;

        if (cache[key]) {
            return cache[key];
        }

        cache[key] = datetime._convMilliseconds(type, value, function(memo, v) {
            return memo / v;
        });

        return cache[key];
    },

    /**
     * Convert value to milliseconds
     * @param {type} type - type of supplied value. support "hour", "minutes", "seconds" only.
     * @param {value} value - value to convert.
     * @returns {number} converted value.
     */
    millisecondsFrom: function(type, value) {
        var cache = memo.millisecondsFrom,
            key = type + value;

        if (cache[key]) {
            return cache[key];
        }

        cache[key] = datetime._convMilliseconds(type, value, function(memo, v) {
            return memo * v;
        });

        return cache[key];
    },

    /**
     * Make date array from supplied paramters.
     * @param {Date} start Start date.
     * @param {Date} end End date.
     * @param {number} step The number of milliseconds to use increment.
     * @returns {array} Date array.
     */
    range: function(start, end, step) {
        var cursor = new Date(start.getTime()),
            result = [];

        while (cursor <= end) {
            result.push(cursor);
            cursor = new Date(cursor.getTime() + step);
        }

        return result;
    },

    /**
     * Clone supplied date.
     * @param {Date} date date object to clone.
     * @returns {Date} Cloned date object
     */
    clone: function(date) {
        return new Date(date.getTime());
    },

    /**
     * Compare two dates.
     *
     * when first date is latest then seconds then return -1.
     *
     * return +1 reverse, and return 0 is same.
     * @param {Date} d1 Date object to compare.
     * @param {Date} d2 Date object to compare.
     * @returns {number} result of compare
     */
    compare: function(d1, d2) {
        var _d1 = d1.getTime(),
            _d2 = d2.getTime();

        if (_d1 < _d2) {
            return -1;
        } else if (_d1 > _d2) {
            return 1;
        }
        return 0;
    },

    /**
     * @param {Date} d1 - date one
     * @param {Date} d2 - date two
     * @returns {boolean} is two date are same year, month?
     */
    isSameMonth: function(d1, d2) {
        return (d1.getFullYear() === d2.getFullYear() &&
                d1.getMonth() === d2.getMonth());
    },

    /**
     * @param {Date} d1 - date one
     * @param {Date} d2 - date two
     * @returns {boolean} is two date are same year, month, date?
     */
    isSameDate: function(d1, d2) {
        var sameMonth = datetime.isSameMonth(d1, d2);
        return sameMonth && (d1.getDate() === d2.getDate());
    },

    /**
     * Check supplied parameter is valid date object.
     * @param {*} d Object to validate.
     * @returns {boolean} return true when parameter is valid date object.
     */
    isValid: function(d) {
        if (opt.call(d) === '[object Date]') {
            return !window.isNaN(d.getTime());
        }
        return false;
    },

    /**
     * convert non local date to UTC date.
     * @param {Date} d Date to convert UTC.
     * @returns {Date} The UTC Date.
     */
    toUTC: function(d) {
        var l = d.getTime(),
            offset = datetime.millisecondsFrom('minutes', new Date().getTimezoneOffset());

        return new Date(l + offset);
    },

    /**
     * pad left zero characters.
     * @param {number} number number value to pad zero.
     * @param {number} length pad length to want.
     * @returns {string} padded string.
     */
    leadingZero: function(number, length) {
        var zero = '',
            i = 0;

        if ((number + '').length > length) {
            return number + '';
        }

        for (; i < (length - 1); i += 1) {
            zero += '0';
        }

        return (zero + number).slice(length * -1);
    },

    /**
     * Convert date string to date object.
     *
     * Only listed below formats avaliable.
     *
     * - YYYYMMDD
     * - YYYY/MM/DD
     * - YYYY-MM-DD
     * - YYYY/MM/DD HH:mm:SS
     * - YYYY-MM-DD HH:mm:SS
     *
     * @param {string} str Formatted string.
     * @param {number} [fixMonth=-1] - number for fix month calculating.
     * @returns {(Date|boolean)} Converted Date object. when supplied str is not available then return false.
     */
    parse: function(str, fixMonth) {
        var separator,
            matches = str.match(dateFormatRx),
            ymd,
            hms;

        if (util.isUndefined(fixMonth)) {
            fixMonth = -1;
        }

        if (!matches) {
            return false;
        }

        if (str.length > 8) {
            // YYYY/MM/DD
            // YYYY-MM-DD
            // YYYY/MM/DD HH:mm:SS
            // YYYY-MM-DD HH:mm:SS
            separator = ~str.indexOf('/') ? '/' : '-';
            matches = matches.splice(1);

            ymd = matches[0].split(separator);
            hms = matches[1] ? matches[1].split(':') : [0, 0, 0];
        } else {
            // YYYYMMDD
            matches = matches[0];
            ymd = [matches.substr(0, 4), matches.substr(4, 2), matches.substr(6, 2)];
            hms = [0, 0, 0];
        }

        return new Date(+ymd[0], +ymd[1] + fixMonth, +ymd[2], +hms[0], +hms[1], +hms[2]);
    },

    /**
     * Return date object from Date.
     * @param {Date} date date
     * @returns {object} Date object.
     */
    raw: function(date) {
        return {
            y: date.getFullYear(),
            M: date.getMonth(),
            d: date.getDate(),
            h: date.getHours(),
            m: date.getMinutes(),
            s: date.getSeconds(),
            ms: date.getMilliseconds()
        };
    },

    /**
     * Return 00:00:00 supplied date.
     * @param {Date} date date.
     * @returns {Date} start date.
     */
    start: function(date) {
        var d = new Date(date.getTime());
        d.setHours(0, 0, 0, 0);

        return d;
    },

    /**
     * Return 23:59:59 supplied date.
     * @param {Date} date date.
     * @returns {Date} end date.
     */
    end: function(date) {
        var d = new Date(date.getTime());
        d.setHours(23, 59, 59, 0);

        return d;
    },

    /**
     * Return formatted string as basis of supplied string.
     *
     * Supported Token Lists.
     *
     * - YYYY => 1988
     * - MM => 01 ~ 12
     * - DD => 01 ~ 31
     * - YYYYMMDD => 19880925
     * @param {Date} date String want to formatted.
     * @param {string} format format str.
     * @returns {string}  Formatted date string.
     */
    format: function(date, format) {
        var result = format;
        util.forEachOwnProperties(tokenFunc, function(converter, token) {
            result = result.replace(token, converter(date));
        });

        return result;
    },

    /**
     * Return 2-dimensional array month calendar
     *
     * dates that different month with given date are negative values
     * @param {Date} month - date want to calculate month calendar
     * @param {number} [startDayOfWeek=0] - start day of week
     * @param {function} [iteratee] - iteratee for customizing calendar object
     * @returns {Array.<string[]>} calendar 2d array
     */
    arr2dCalendar: function(month, startDayOfWeek, iteratee) {
        var weekArr,
            starts, ends,
            startIndex, endIndex,
            afterDates,
            cursor, week,
            calendar = [];

        starts = new Date(new Date(+month).setDate(1));
        ends = new Date(new Date(+starts).setMonth(starts.getMonth() + 1));
        ends = new Date(new Date(+ends).setDate(ends.getDate() - 1));

        // create day number array by startDayOfWeek number
        // 4 -> [4, 5, 6, 0, 1, 2, 3]
        // 2 -> [2, 3, 4, 5, 6, 0, 1]
        weekArr = util.range(startDayOfWeek, 7).concat(util.range(7)).slice(0, 7);
        startIndex = util.inArray(starts.getDay(), weekArr);
        endIndex = util.inArray(ends.getDay(), weekArr);
        // free dates after last date of this month
        afterDates = 7 - (endIndex + 1);

        cursor = new Date(new Date(+starts).setDate(starts.getDate() - startIndex));
        // iteratee all dates to render
        util.forEachArray(util.range(startIndex + ends.getDate() + afterDates), function(i) {
            var date;

            if (!(i % 7)) {
                // group each date by week
                week = calendar[i / 7] = [];
            }

            date = new Date(+cursor);
            date = iteratee ? iteratee(date) : date;
            week.push(date);

            // add date
            cursor = new Date(cursor.setDate(cursor.getDate() + 1));
        });

        return calendar;
    }
};

module.exports = datetime;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],29:[function(require,module,exports){
/**
 * @fileoverview Dirty flagging module for objects.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var common = ne.util,
    existy = common.isExisty,
    pick = common.pick,
    isFunc = common.isFunction;

/**
 * Mixin module for dirty flagging on specific objects.
 * @mixin
 * @example
 * var obj = { hello: 'good', test: '123' };
 * dirty.mixin(obj);
 *
 * obj.set('hello', 'world');
 * obj.isDirty();    // true
 * obj.isPropChanged('hello');    // true
 * obj.isPropChanged('test');    // false
 * obj.dirty(false);
 *
 * obj.isDirty();    // false
 * obj.isPropChanged('hello');    // false
 */
var dirty = {
    /**
     * Set property value with dirty flagging.
     * @param {string} propName Property name.
     * @param {*} value Proprty value.
     */
    set: function(propName, value) {
        var originValue = this[propName];

        if (originValue === value) {
            return;
        }

        this[propName] = value;

        if (!this._changed) {
            /**
             * Save changed properties.
             * @memberof dirty
             * @name _changed
             * @type {Object}
             */
            this._changed = {};
        }

        this._changed[propName] = true;

        /**
         * Dirty flag
         * @type {Boolean}
         * @name _dirty
         * @memberof dirty
         */
        this._dirty = true;
    },

    /**
     * Check dirty flag.
     * @returns {boolean} Property is changed.
     */
    isDirty: function() {
        return !!this._dirty;
    },

    /**
     * Set dirty flag manually.
     * @param {Boolean} [toDirty=true] This will set dirty flag directly.
     */
    dirty: function(toDirty) {
        toDirty = existy(toDirty) ? toDirty : true;

        /* istanbul ignore else */
        if (!toDirty) {
            this._changed = {};
        }

        this._dirty = toDirty;
    },

    /**
     * Delete property safety.
     * @param {String} propName The name of property.
     */
    deleteProp: function(propName) {
        delete this[propName];

        if (this._changed) {
            delete this._changed[propName];
        }
    },

    /**
     * Check the changes with specific property.
     * @param {String} propName The name of property you want.
     * @returns {boolean} Is property changed?
     */
    isPropChanged: function(propName) {
        if (!this._changed) {
            return false;
        }

        return this._changed[propName] === true;
    },

    /**
     * Mixin to specific objects.
     * @param {Object} target The object to mix this module.
     * @memberof module:util/dirty
     * @example
     * function Animal() {}
     * dirty.mixin(Animal.prototype);
     */
    mixin: function(target) {
        var methodFilterR = /(^_|mixin|wrap)/;

        common.forEachOwnProperties(dirty, function(o, k) {
            if (!methodFilterR.test(k)) {
                target[k] = dirty[k];
            }
        });
    },

    /**
     * Wrapper method for dirty flagging.
     *
     * This method invoke after invoked specific method that added by you.
     *
     * The method want to add are must exist before add.
     * @param {object} target Target object to method wrap.
     * @param {(string|object)} methodName
     *  Method name to wrap or methodName: flag objects.
     * @param {boolean} [flag=true]
     *  this will used to flagging by dirty flagger after invoke the methods added by you.
     * @memberof module:util/dirty
     * @example
     * function Animal(name) {
     *     this.name = name;
     * }
     * Animal.prototype.growl = jasmine.createSpy('growl');
     * Animal.prototype.test = function() {
     *     return this.name;
     * };
     *
     * dirty.mixin(Animal.prototype);
     * // single
     * dirty.wrap(Animal.prototype, 'growl', true);
     * // multiple
     * dirty.wrap(Animap.prototype, {
     *     growl: true,
     *     test: false
     * });
     *
     */
    wrap: function(target, methodName, flag) {
        var wrap = dirty.wrap,
            fn;

        if (common.isObject(methodName)) {
            common.forEachOwnProperties(methodName, function(flag, methodName) {
                wrap(target, methodName, flag);
            });
            return;
        }

        flag = existy(flag) ? flag : true;

        if (!target._wrapper) {
            /**
             * @param {function} fn Original method to wrap.
             * @param {boolean} flagToSet The boolean value to using dirty flagging.
             * @returns {*} The result value of original method.
             * @name _wrapper
             * @memberof dirty
             */
            target._wrapper = function(fn, flagToSet) {
                return function() {
                    var args = Array.prototype.slice.call(arguments);
                    var result = fn.apply(this, args);
                    this._dirty = flagToSet;
                    return result;
                };
            };
        }

        if (existy(pick(target, methodName)) &&
            isFunc(target[methodName]) &&
            !existy(pick(target, methodName, '_wrapped'))) {
            fn = target[methodName];
            target[methodName] = target._wrapper(fn, flag);
            target[methodName]._wrapped = true;
        }
    }
};

module.exports = dirty;


},{}],30:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Utility module for handling DOM events.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util,
    browser = util.browser,
    eventKey = '_evt',
    DRAG = {
        START: ['touchstart', 'mousedown'],
        END: {
            mousedown: 'mouseup',
            touchstart: 'touchend',
            pointerdown: 'touchend',
            MSPointerDown: 'touchend'
        },
        MOVE: {
            mousedown: 'mousemove',
            touchstart: 'touchmove',
            pointerdown: 'touchmove',
            MSPointerDown: 'touchmove'
        }
    };

var domevent = {
    /**
     * Bind dom events.
     * @param {HTMLElement} obj HTMLElement to bind events.
     * @param {(string|object)} types Space splitted events names or eventName:handler object.
     * @param {*} fn handler function or context for handler method.
     * @param {*} [context] context object for handler method.
     */
    on: function(obj, types, fn, context) {
        if (util.isString(types)) {
            util.forEach(types.split(' '), function(type) {
                domevent._on(obj, type, fn, context);
            });

            return;
        }

        util.forEachOwnProperties(types, function(handler, type) {
            domevent._on(obj, type, handler, fn);
        });
    },

    /**
     * DOM event binding.
     * @param {HTMLElement} obj HTMLElement to bind events.
     * @param {String} type The name of events.
     * @param {*} fn handler function
     * @param {*} [context] context object for handler method.
     * @private
     */
    _on: function(obj, type, fn, context) {
        var id,
            handler,
            originHandler;

        id = type + util.stamp(fn) + (context ? '_' + util.stamp(context) : '');

        if (obj[eventKey] && obj[eventKey][id]) {
            return;
        }

        handler = function(e) {
            fn.call(context || obj, e || window.event);
        };

        originHandler = handler;

        if ('addEventListener' in obj) {
            if (type === 'mouseenter' || type === 'mouseleave') {
                handler = function(e) {
                    e = e || window.event;
                    if (!domevent._checkMouse(obj, e)) {
                        return;
                    }
                    originHandler(e);
                };
                obj.addEventListener((type === 'mouseenter') ?
                    'mouseover' : 'mouseout', handler, false);
            } else {
                if (type === 'mousewheel') {
                    obj.addEventListener('DOMMouseScroll', handler, false);
                }

                obj.addEventListener(type, handler, false);
            }
        } else if ('attachEvent' in obj) {
            obj.attachEvent('on' + type, handler);
        }

        obj[eventKey] = obj[eventKey] || {};
        obj[eventKey][id] = handler;
    },

    /**
     * Unbind DOM Event handler.
     * @param {HTMLElement} obj HTMLElement to unbind.
     * @param {(string|object)} types Space splitted events names or eventName:handler object.
     * @param {*} fn handler function or context for handler method.
     * @param {*} [context] context object for handler method.
     */
    off: function(obj, types, fn, context) {
        if (util.isString(types)) {
            util.forEach(types.split(' '), function(type) {
                domevent._off(obj, type, fn, context);
            });

            return;
        }

        util.forEachOwnProperties(types, function(handler, type) {
            domevent._off(obj, type, handler, fn);
        });
    },

    /**
     * Unbind DOM event handler.
     * @param {HTMLElement} obj HTMLElement to unbind.
     * @param {String} type The name of event to unbind.
     * @param {function()} fn Event handler that supplied when binding.
     * @param {*} context context object that supplied when binding.
     * @private
     */
    _off: function(obj, type, fn, context) {
        var id = type + util.stamp(fn) + (context ? '_' + util.stamp(context) : ''),
            handler = obj[eventKey] && obj[eventKey][id];

        if (!handler) {
            return;
        }

        if ('removeEventListener' in obj) {
            if (type === 'mouseenter' || type === 'mouseleave') {
                obj.removeEventListener((type === 'mouseenter') ?
                    'mouseover' : 'mouseout', handler, false);
            } else {
                if (type === 'mousewheel') {
                    obj.removeEventListener('DOMMouseScroll', handler, false);
                }

                obj.removeEventListener(type, handler, false);
            }
        } else if ('detachEvent' in obj) {
            try {
                obj.detachEvent('on' + type, handler);
            } catch (e) {}    //eslint-disable-line
        }

        delete obj[eventKey][id];

        if (util.keys(obj[eventKey]).length) {
            return;
        }

        delete obj[eventKey];
    },

    /**
     * Bind DOM event. this event will unbind after invokes.
     * @param {HTMLElement} obj HTMLElement to bind events.
     * @param {(string|object)} types Space splitted events names or eventName:handler object.
     * @param {*} fn handler function or context for handler method.
     * @param {*} [context] context object for handler method.
     */
    once: function(obj, types, fn, context) {
        var that = this;

        if (util.isObject(types)) {
            util.forEachOwnProperties(types, function(handler, type) {
                domevent.once(obj, type, handler, fn);
            });
            return;
        }

        function onceHandler() {
            fn.apply(context || obj, arguments);
            that._off(obj, types, onceHandler, context);
        }

        domevent.on(obj, types, onceHandler, context);
    },

    /**
     * Cancel event bubbling.
     * @param {Event} e Event object.
     */
    stopPropagation: function(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
        } else {
            e.cancelBubble = true;
        }
    },

    /**
     * Cancel browser default actions.
     * @param {Event} e Event object.
     */
    preventDefault: function(e) {
        if (e.preventDefault) {
            e.preventDefault();
        } else {
            e.returnValue = false;
        }
    },

    /**
     * Syntatic sugar of stopPropagation and preventDefault
     * @param {Event} e Event object.
     */
    stop: function(e) {
        domevent.preventDefault(e);
        domevent.stopPropagation(e);
    },

    /**
     * Stop scroll events.
     * @param {HTMLElement} el HTML element to prevent scroll.
     */
    disableScrollPropagation: function(el) {
        domevent.on(el, 'mousewheel MozMousePixelScroll', domevent.stopPropagation);
    },

    /**
     * Stop all events related with click.
     * @param {HTMLElement} el HTML element to prevent all event related with click.
     */
    disableClickPropagation: function(el) {
        domevent.on(el, DRAG.START.join(' ') + ' click dblclick', domevent.stopPropagation);
    },

    /**
     * Get mouse position from mouse event.
     *
     * If supplied relatveElement parameter then return relative position based on element.
     * @param {Event} mouseEvent Mouse event object
     * @param {HTMLElement} relativeElement HTML element that calculate relative position.
     * @returns {number[]} mouse position.
     */
    getMousePosition: function(mouseEvent, relativeElement) {
        var rect;

        if (!relativeElement) {
            return [mouseEvent.clientX, mouseEvent.clientY];
        }

        rect = relativeElement.getBoundingClientRect();

        return [
            mouseEvent.clientX - rect.left - relativeElement.clientLeft,
            mouseEvent.clientY - rect.top - relativeElement.clientTop
        ];
    },

    /**
     * Normalize mouse wheel event that different each browsers.
     * @param {MouseEvent} e Mouse wheel event.
     * @returns {Number} delta
     */
    getWheelDelta: function(e) {
        var delta = 0;

        if (e.wheelDelta) {
            delta = e.wheelDelta / 120;
        }

        if (e.detail) {
            delta = -e.detail / 3;
        }

        return delta;
    },

    /**
     * prevent firing mouseleave event when mouse entered child elements.
     * @param {HTMLElement} el HTML element
     * @param {MouseEvent} e Mouse event
     * @returns {Boolean} leave?
     * @private
     */
    _checkMouse: function(el, e) {
        var related = e.relatedTarget;

        if (!related) {
            return true;
        }

        try {
            while (related && (related !== el)) {
                related = related.parentNode;
            }
        } catch (err) {
            return false;
        }

        return (related !== el);
    },

    /**
     * Trigger specific events to html element.
     * @param {HTMLElement} obj HTMLElement
     * @param {string} type Event type name
     * @param {object} [eventData] Event data
     */
    trigger: function(obj, type, eventData) {
        var rMouseEvent = /(mouse|click)/;
        if (util.isUndefined(eventData) && rMouseEvent.exec(type)) {
            eventData = domevent.mouseEvent(type);
        }

        if (obj.dispatchEvent) {
            obj.dispatchEvent(eventData);
        } else if (obj.fireEvent) {
            obj.fireEvent('on' + type, eventData);
        }
    },

    /**
     * Create virtual mouse event.
     *
     * Tested at
     *
     * - IE7 ~ IE11
     * - Chrome
     * - Firefox
     * - Safari
     * @param {string} type Event type
     * @param {object} [eventObj] Event data
     * @returns {MouseEvent} Virtual mouse event.
     */
    mouseEvent: function(type, eventObj) {
        var evt,
            e;

        e = util.extend({
            bubbles: true,
            cancelable: (type !== 'mousemove'),
            view: window,
            wheelDelta: 0,
            detail: 0,
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            button: 0,
            relatedTarget: undefined  // eslint-disable-line
        }, eventObj);

        // prevent throw error when inserting wheelDelta property to mouse event on below IE8
        if (browser.msie && browser.version < 9) {
            delete e.wheelDelta;
        }

        if (typeof document.createEvent === 'function') {
            evt = document.createEvent('MouseEvents');
            evt.initMouseEvent(type,
                e.bubbles, e.cancelable, e.view, e.detail,
                e.screenX, e.screenY, e.clientX, e.clientY,
                e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
                e.button, document.body.parentNode
            );
        } else if (document.createEventObject) {
            evt = document.createEventObject();

            util.forEach(e, function(value, propName) {
                evt[propName] = value;
            }, this);
            evt.button = {0: 1, 1: 4, 2: 2}[evt.button] || evt.button;
        }
        return evt;
    },

    /**
     * Normalize mouse event's button attributes.
     *
     * Can detect which button is clicked by this method.
     *
     * Meaning of return numbers
     *
     * - 0: primary mouse button
     * - 1: wheel button or center button
     * - 2: secondary mouse button
     * @param {MouseEvent} mouseEvent - The mouse event object want to know.
     * @returns {number} - The value of meaning which button is clicked?
     */
    getMouseButton: function(mouseEvent) {
        var button,
            primary = '0,1,3,5,7',
            secondary = '2,6',
            wheel = '4';

        /* istanbul ignore else */
        if (document.implementation.hasFeature('MouseEvents', '2.0')) {
            return mouseEvent.button;
        }

        button = mouseEvent.button + '';
        if (~primary.indexOf(button)) {
            return 0;
        } else if (~secondary.indexOf(button)) {
            return 2;
        } else if (~wheel.indexOf(button)) {
            return 1;
        }
    }
};

module.exports = domevent;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],31:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Utility modules for manipulate DOM elements.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var domevent = require('./domevent');
var Collection = require('./collection');

var util = global.ne.util,
    posKey = '_pos',
    domutil;

var CSS_AUTO_REGEX = /^auto$|^$|%/;

function trim(str) {
    return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
}

domutil = {
    /**
     * Create DOM element and return it.
     * @param {string} tagName Tag name to append.
     * @param {HTMLElement} [container] HTML element will be parent to created element.
     * if not supplied, will use **document.body**
     * @param {string} [className] Design class names to appling created element.
     * @returns {HTMLElement} HTML element created.
     */
    appendHTMLElement: function(tagName, container, className) {
        var el;

        className = className || '';

        el = document.createElement(tagName);
        el.className = className;

        if (container) {
            container.appendChild(el);
        } else {
            document.body.appendChild(el);
        }

        return el;
    },

    /**
     * Remove element from parent node.
     * @param {HTMLElement} el - element to remove.
     */
    remove: function(el) {
        if (el && el.parentNode) {
            el.parentNode.removeChild(el);
        }
    },

    /**
     * Get element by id
     * @param {string} id element id attribute
     * @returns {HTMLElement} element
     */
    get: function(id) {
        return document.getElementById(id);
    },

    /**
     * Check supplied element is matched selector.
     * @param {HTMLElement} el - element to check
     * @param {string} selector - selector string to check
     * @return {boolean} match?
     */
    _matcher: function(el, selector) {
        var cssClassSelector = /^\./,
            idSelector = /^#/;

        if (cssClassSelector.test(selector)) {
            return domutil.hasClass(el, selector.replace('.', ''));
        } else if (idSelector.test(selector)) {
            return el.id === selector.replace('#', '');
        }

        return el.nodeName.toLowerCase() === selector.toLowerCase();
    },

    /**
     * Find DOM element by specific selectors.
     * below three selector only supported.
     *
     * 1. css selector
     * 2. id selector
     * 3. nodeName selector
     * @param {string} selector selector
     * @param {(HTMLElement|string)} [root] You can assign root element to find. if not supplied, document.body will use.
     * @param {boolean|function} [multiple=false] - set true then return all elements that meet condition, if set function then use it filter function.
     * @returns {HTMLElement} HTML element finded.
     */
    find: function(selector, root, multiple) {
        var result = [],
            found = false,
            isFirst = util.isUndefined(multiple) || multiple === false,
            isFilter = util.isFunction(multiple);

        if (util.isString(root)) {
            root = domutil.get(root);
        }
        
        root = root || window.document.body;

        function recurse(el, selector) {
            var childNodes = el.childNodes,
                i = 0,
                len = childNodes.length,
                cursor;

            for (; i < len; i += 1) {
                cursor = childNodes[i];

                if (cursor.nodeName === '#text') {
                    continue;
                }

                if (domutil._matcher(cursor, selector)) {
                    if ((isFilter && multiple(cursor)) || !isFilter) {
                        result.push(cursor);
                    }

                    if (isFirst) {
                        found = true;
                        break;
                    }
                } else if (cursor.childNodes.length > 0) {
                    recurse(cursor, selector);
                    if (found) {
                        break;
                    }
                }
            }
        }

        recurse(root, selector);

        return isFirst ? (result[0] || null) : result;
    },

    /**
     * Find parent element recursively.
     * @param {HTMLElement} el - base element to start find.
     * @param {string} selector - selector string for find
     * @returns {HTMLElement} - element finded or undefined.
     */
    closest: function(el, selector) {
        var parent = el.parentNode;

        if (domutil._matcher(el, selector)) {
            return el;
        }

        while (parent && parent !== window.document.body) {
            if (domutil._matcher(parent, selector)) {
                return parent;
            }

            parent = parent.parentNode;
        }
    },

    /**
     * Return texts inside element.
     * @param {HTMLElement} el target element
     * @return {string} text inside node
     */
    text: function(el) {
        var ret = '',
            i = 0,
            nodeType = el.nodeType;

        if (nodeType) {
            if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                // nodes that available contain other nodes
                if (typeof el.textContent === 'string') {
                    return el.textContent;
                }

                for (el = el.firstChild; el; el = el.nextSibling) {
                    ret += domutil.text(el);
                }
            } else if (nodeType === 3 || nodeType === 4) {
                // TEXT, CDATA SECTION
                return el.nodeValue;
            }
        } else {
            for (; el[i]; i += 1) {
                ret += domutil.text(el[i]);
            }
        }
        return ret;
    },

    setData: function(el, key, data) {
        if ('dataset' in el) {
            el.dataset[key] = data;
            return;
        }

        el.setAttribute('data-' + key, data);
    },

    getData: function(el, key) {
        if ('dataset' in el) {
            return el.dataset[key];
        }

        return el.getAttribute('data-' + key);
    },

    /**
     * Check element has specific design class name.
     * @param {HTMLElement} el target element
     * @param {string} name css class
     * @returns {boolean} return true when element has that css class name
     */
    hasClass: function(el, name) {
        var className;

        if (!util.isUndefined(el.classList)) {
            return el.classList.contains(name);
        }

        className = domutil.getClass(el);

        return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
    },

    /**
     * Add design class to HTML element.
     * @param {HTMLElement} el target element
     * @param {string} name css class name
     */
    addClass: function(el, name) {
        var className;

        if (!util.isUndefined(el.classList)) {
            util.forEachArray(name.split(' '), function(value) {
                el.classList.add(value);
            });
        } else if (!domutil.hasClass(el, name)) {
            className = domutil.getClass(el);
            domutil.setClass(el, (className ? className + ' ' : '') + name);
        }
    },

    /**
     *
     * Overwrite design class to HTML element.
     * @param {HTMLElement} el target element
     * @param {string} name css class name
     */
    setClass: function(el, name) {
        if (util.isUndefined(el.className.baseVal)) {
            el.className = name;
        } else {
            el.className.baseVal = name;
        }
    },

    /**
     * Element에 cssClass속성을 제거하는 메서드
     * Remove specific design class from HTML element.
     * @param {HTMLElement} el target element
     * @param {string} name class name to remove
     */
    removeClass: function(el, name) {
        var removed = '';

        if (!util.isUndefined(el.classList)) {
            el.classList.remove(name);
        } else {
            removed = (' ' + domutil.getClass(el) + ' ').replace(' ' + name + ' ', ' ');
            domutil.setClass(el, trim(removed));
        }
    },

    /**
     * Get HTML element's design classes.
     * @param {HTMLElement} el target element
     * @returns {string} element css class name
     */
    getClass: function(el) {
        if (!el || !el.className) {
            return '';
        }

        return util.isUndefined(el.className.baseVal) ? el.className : el.className.baseVal;
    },

    /**
     * Get specific CSS style value from HTML element.
     * @param {HTMLElement} el target element
     * @param {string} style css attribute name
     * @returns {(string|null)} css style value
     */
    getStyle: function(el, style) {
        var value = el.style[style] || (el.currentStyle && el.currentStyle[style]),
            css;

        if ((!value || value === 'auto') && document.defaultView) {
            css = document.defaultView.getComputedStyle(el, null);
            value = css ? css[style] : null;
        }

        return value === 'auto' ? null : value;
    },

    /**
     * get element's computed style values.
     *
     * in lower IE8. use polyfill function that return object. it has only one function 'getPropertyValue'
     * @param {HTMLElement} el - element want to get style.
     * @returns {object} virtual CSSStyleDeclaration object.
     */
    getComputedStyle: function(el) {
        var defaultView = document.defaultView;

        if (!defaultView || !defaultView.getComputedStyle) {
            return {
                getPropertyValue: function(prop) {
                    var re = /(\-([a-z]){1})/g;
                    if (prop === 'float') {
                        prop = 'styleFloat';
                    }

                    if (re.test(prop)) {
                        prop = prop.replace(re, function () {
                            return arguments[2].toUpperCase();
                        });
                    }

                    return el.currentStyle[prop] ? el.currentStyle[prop] : null;
                }
            };
        }

        return document.defaultView.getComputedStyle(el);
    },

    /**
     * Set position CSS style.
     * @param {HTMLElement} el target element
     * @param {number} [x=0] left pixel value.
     * @param {number} [y=0] top pixel value.
     */
    setPosition: function(el, x, y) {
        x = util.isUndefined(x) ? 0 : x;
        y = util.isUndefined(y) ? 0 : y;

        el[posKey] = [x, y];

        el.style.left = x + 'px';
        el.style.top = y + 'px';
    },

    /**
     * Get position from HTML element.
     * @param {HTMLElement} el target element
     * @param {boolean} [clear=false] clear cache before calculating position.
     * @returns {number[]} point
     */
    getPosition: function(el, clear) {
        var left,
            top,
            bound;

        if (clear) {
            el[posKey] = null;
        }

        if (el[posKey]) {
            return el[posKey];
        }

        left = 0;
        top = 0;

        if ((CSS_AUTO_REGEX.test(el.style.left) || CSS_AUTO_REGEX.test(el.style.top)) &&
            'getBoundingClientRect' in el) {
            // 엘리먼트의 left또는 top이 'auto'일 때 수단
            bound = el.getBoundingClientRect();

            left = bound.left;
            top = bound.top;
        } else {
            left = parseFloat(el.style.left || 0);
            top = parseFloat(el.style.top || 0);
        }

        return [left, top];
    },

    /**
     * Return element's size
     * @param {HTMLElement} el target element
     * @return {number[]} width, height
     */
    getSize: function(el) {
        var bound,
            width = domutil.getStyle(el, 'width'),
            height = domutil.getStyle(el, 'height');

        if ((CSS_AUTO_REGEX.test(width) || CSS_AUTO_REGEX.test(height)) &&
            'getBoundingClientRect' in el) {
            bound = el.getBoundingClientRect();
            width = bound.width;
            height = bound.height;
        } else {
            width = parseFloat(width || 0);
            height = parseFloat(height || 0);
        }

        return [width, height];
    },

    /**
     * Check specific CSS style is available.
     * @param {array} props property name to testing
     * @return {(string|boolean)} return true when property is available
     * @example
     * var props = ['transform', '-webkit-transform'];
     * domutil.testProp(props);    // 'transform'
     */
    testProp: function(props) {
        var style = document.documentElement.style,
            i = 0,
            len = props.length;

        for (; i < len; i += 1) {
            if (props[i] in style) {
                return props[i];
            }
        }
        return false;
    },

    /**
     * Get form data
     * @param {HTMLFormElement} formElement - form element to extract data
     * @returns {object} form data
     */
    getFormData: function(formElement) {
        var groupedByName = new Collection(function() { return this.length; }),
            noDisabledFilter = function(el) { return !el.disabled; },
            output = {};
            
        groupedByName.add.apply(
            groupedByName, 
            domutil.find('input', formElement, noDisabledFilter)
                .concat(domutil.find('select', formElement, noDisabledFilter))
                .concat(domutil.find('textarea', formElement, noDisabledFilter))
        );

        groupedByName = groupedByName.groupBy(function(el) {
            return el && el.getAttribute('name') || '_other';
        });

        util.forEach(groupedByName, function(elements, name) {
            if (name === '_other') {
                return;
            }

            elements.each(function(el) {
                var nodeName = el.nodeName.toLowerCase(),
                    type = el.type,
                    result = [];

                if (type === 'radio' || type === 'checkbox') {
                    result = elements.find(function(el) { return el.checked; }).toArray();
                } else if (nodeName === 'select') {
                    elements.find(function(el) { return !!el.childNodes.length; })
                        .each(function(el) {
                            result = result.concat(domutil.find('option', el, function(opt) {
                                return opt.selected;
                            }));
                        });
                } else {
                    result = elements.find(function(el) { return el.value !== ''; }).toArray();
                }

                result = util.map(result, function(el) { return el.value; });

                if (!result.length) {
                    result = '';
                } else if (result.length === 1) {
                    result = result[0];
                }

                output[name] = result;
            });
        });

        return output;
    }
};

/*eslint-disable*/
var userSelectProperty = domutil.testProp([
    'userSelect', 
    'WebkitUserSelect', 
    'OUserSelect', 
    'MozUserSelect', 
    'msUserSelect'
]);
var supportSelectStart = 'onselectstart' in document;
var prevSelectStyle = '';
/*eslint-enable*/

/**
 * Disable browser's text selection behaviors.
 * @method
 */
domutil.disableTextSelection = (function() {
    if (supportSelectStart) {
        return function() {
            domevent.on(window, 'selectstart', domevent.preventDefault);
        };
    }

    return function() {
        var style = document.documentElement.style;
        prevSelectStyle = style[userSelectProperty];
        style[userSelectProperty] = 'none';
    };
})();

/**
 * Enable browser's text selection behaviors.
 * @method
 */
domutil.enableTextSelection = (function() {
    if (supportSelectStart) {
        return function() {
            domevent.off(window, 'selectstart', domevent.preventDefault);
        };
    }

    return function() {
        document.documentElement.style[userSelectProperty] = prevSelectStyle;
    };
})();

/**
 * Disable browser's image drag behaviors.
 */
domutil.disableImageDrag = function() {
    domevent.on(window, 'dragstart', domevent.preventDefault);
};

/**
 * Enable browser's image drag behaviors.
 */
domutil.enableImageDrag = function() {
    domevent.off(window, 'dragstart', domevent.preventDefault);
};

module.exports = domutil;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./collection":26,"./domevent":30}],32:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Mixin module for models.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util,
    spaceRx = /^\s*|\s*$/g,
    model;

var datetime = require('../common/datetime');

/**
 * Mixin module for models.
 * @mixin
 */
model = {
    /**
     * string trim
     * @param {string} str string to trim
     * @returns {string} trimed string
     */
    trim: function(str) {
        return str.replace(spaceRx, '');
    },
    /**
     * The collections of validator functions.
     */
    validators: {
        /**
         * check all of supplied fields(property) is not undefined or empty string.
         * @param {object} instance model instance.
         * @param {string[]} fields property names to check.
         * @returns {boolean} return true when supplied fields are not undefined or empty string.
         */
        required: function(instance, fields) {
            var valid = true,
                isValid = function(obj) {
                    return !util.isUndefined(obj) && model.trim(obj) !== '';
                };

            util.forEach(fields, function(fieldName) {
                valid = isValid(instance[fieldName]);
                return valid;
            });

            return valid;
        },

        /**
         * check supplied fields are valid dates and valid date ranges.
         * @param {object} instance model instance.
         * @param {Date[]} fields array of date range (starts, ends)
         * @returns {boolean} is valid date range?
         */
        dateRange: function(instance, fields) {
            var starts,
                ends;

            if (!util.isExisty(instance) || fields.length !== 2) {
                return true;
            }

            starts = new Date(instance[fields[0]]);
            ends = new Date(instance[fields[1]]);

            if (!datetime.isValid(starts) || !datetime.isValid(ends)) {
                return false;
            }

            if (datetime.compare(starts, ends) === 1) {
                return false;
            }

            return true;
        }
    },

    /**
     * Check validate for model instance.
     *
     * The validate are works on a basis of constructor's "schema" property.
     *
     * You can customize validators add some method to model#validators.
     * @returns {Boolean} model is valid?
     */
    isValid: function() {
        var that = this,
            schema = this.constructor.schema,
            validators = model.validators,
            validator,
            valid = true;

        if (!schema) {
            return true;
        }

        util.forEach(schema, function(values, validatorName) {
            validator = validators[validatorName];

            if (validator) {
                valid = validator(that, values);
                return valid;
            }
        });

        return valid;
    },

    /**
     * Make data object form instance.
     *
     * It return object fill with all owned properties but exclude functions.
     * @returns {object} Data object
     */
    parameterize: function() {
        var param = {},
            isFunc = util.isFunction;

        util.forEach(this, function(value, propName) {
            if (!isFunc(value)) {
                param[propName] = value;
            }
        });

        return param;
    },

    /**
     * Mixin model module to supplied target.
     * @param {Object} target The object of want to mixed.
     * @example
     * function Man() {
     *     this.name = 'john';
     * }
     * model.mixin(Man.prototype);
     */
    mixin: function(target) {
        util.forEach(model, function(method, name) {
            if (name !== 'mixin') {
                target[name] = method;
            }
        });
    }
};

module.exports = model;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/datetime":28}],33:[function(require,module,exports){
(function (global){
/**
 * @fileoverview
 * Class for represent two dimensional x, y coordinates.
 *
 * It suppliy a group of functions for manipulate coordinates.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 * @example
 * var p = point(10, 10);
 * var r1 = p.add(Point(5, 5));
 * console.log(p.toString())    // "Point(10, 10)"
 * console.log(r1.toString())    // "Point(15, 15)"
 *
 * var p2 = new Point(10, 10);
 * p2._add(point(5, 5));
 * console.log(p2.toString())   // "Point(15, 15)"
 */
'use strict';

var util = global.ne.util;

/**
 * Class for represent two dimentional x, y coordinates.
 * @constructor
 * @param {number} x The number of X coordinates.
 * @param {number} y The number of Y coordinates.
 * @param {boolean} [useRound=false] set true when each coordinates are rounded before initialize.
 * @example
 * var t = new Point(13, 5);
 */
function Point(x, y, useRound) {
    /**
     * @type {number}
     */
    this.x = (useRound ? Math.round(x) : x);

    /**
     * @type {number}
     */
    this.y = (useRound ? Math.round(y) : y);
}

/**********
 * static props
 **********/

/**
 * Calculate point ratio.
 * @param {Point} point The instance of point.
 * @param {number} factor From factor
 * @param {number} toFactor To factor
 * @returns {Point} Point instance calculated.
 */
Point.getRatio = function(point, factor, toFactor) {
    if (factor === toFactor) {
        return point.clone();
    }

    return point.multiplyBy(toFactor)._divideBy(factor);
};

/**
 * Syntatic sugar of new Point()
 * @param {(Point|number|number[])} x X coordinate value.
 * @param {(number|boolean)} [y] Y coordinate value or boolean value for coordinates round.
 * @param {boolean} [useRound] Set true then round initial coordinate values.
 * @returns {Point} The instance of point.
 * @example
 * var p1 = point(10, 15);
 * var p2 = point([10, 15]);
 */
Point.n = function(x, y, useRound) {
    if (x instanceof Point) {
        return x;
    }

    if (util.isArray(x)) {
        return new Point(x[0], x[1], y);
    }

    return new Point(x, y, useRound);
};

/**********
 * prototype props
 **********/

/**
 * Clone points
 * @returns {Point} The point instance cloned.
 */
Point.prototype.clone = function() {
    return new Point(this.x, this.y);
};

/**
 * Add points.
 * @param {Point} point The point instance to add.
 * @return {Point} Point calculated.
 */
Point.prototype.add = function(point) {
    return this.clone()._add(Point.n(point));
};

/**
 * Add self points.
 * @param {Point} point The point instance to add.
 * @return {Point} Point calculated.
 */
Point.prototype._add = function(point) {
    this.x += point.x;
    this.y += point.y;
    return this;
};

/**
 * Subtract points.
 * @param {Point} point The point instance to subtract.
 * @return {Point} Point calculated.
 */
Point.prototype.subtract = function(point) {
    return this.clone()._subtract(Point.n(point));
};

/**
 * Subtract points. (manipulate self)
 * @param {Point} point The point instance to subtract.
 * @returns {Point} Point calculated.
 */
Point.prototype._subtract = function(point) {
    this.x -= point.x;
    this.y -= point.y;
    return this;
};

/**
 * Divide points.
 * @param {number} num The number to divide.
 * @returns {Point} Point calculated.
 */
Point.prototype.divideBy = function(num) {
    return this.clone()._divideBy(num);
};

/**
 * Divide points. (manipulate self)
 * @param {number} num The number to divide.
 * @returns {Point} Point calculated.
 */
Point.prototype._divideBy = function(num) {
    this.x /= num;
    this.y /= num;
    return this;
};

/**
 * Multiply coordinates.
 * @param {number} num Thyen number to multiply
 * @return {Point} Point calculated.
 */
Point.prototype.multiplyBy = function(num) {
    return this.clone()._multiplyBy(num);
};

/**
 * Multiply self coordinates.
 * @param {number} num The number to multiply.
 * @returns {Point} Point calculated.
 */
Point.prototype._multiplyBy = function(num) {
    this.x *= num;
    this.y *= num;
    return this;
};

/**
 * Round coordinates.
 * @returns {Point} Point calculated.
 */
Point.prototype.round = function() {
    return this.clone()._round();
};

/**
 * Round self coordinates.
 * @returns {Point} Point calculated.
 */
Point.prototype._round = function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
};

/**
 * Reverse values between positive and negative.
 * @returns {Point} Point calculated.
 */
Point.prototype.reverse = function() {
    return this.clone()._reverse();
};

/**
 * Reverse self values between positive and negative.
 * @returns {Point} Point calculated.
 */
Point.prototype._reverse = function() {
    this.x *= -1;
    this.y *= -1;
    return this;
};

/**
 * Floor coordinates.
 * @returns {Point} Point calculated.
 */
Point.prototype.floor = function() {
    return this.clone()._floor();
};

/**
 * Floor self coordinates.
 * @returns {Point} Point calculated.
 */
Point.prototype._floor = function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
};

/**
 * Ceil coordinates.
 * @returns {Point} Point calculated.
 */
Point.prototype.ceil = function() {
    return this.clone()._ceil();
};

/**
 * Ceil self coodinates.
 * @returns {Point} Point calculated.
 */
Point.prototype._ceil = function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
};

/**
 * Rotate point.
 * @param {number} deg The number of rotate degree.
 * @param {Point} [center=this] Center point instance to use rotate center. use own when not supplied.
 * @param {number} [cos] Cosine values for rotate. it useful when multi point rotate.
 * @param {number} [sin] Sine values for rotate. it useful when multi point rotate.
 * @returns {Point} The point instance rotated.
 */
Point.prototype.rotate = function(deg, center, cos, sin) {
    return this.clone()._rotate(deg, center, cos, sin);
};

/**
 * Rotate self.
 * @param {number} deg The number of rotate degree.
 * @param {Point} [center=this] Center point instance to use rotate center. use own when not supplied.
 * @param {number} [cos] Cosine values for rotate. it useful when multi point rotate.
 * @param {number} [sin] Sine values for rotate. it useful when multi point rotate.
 * @returns {Point} The point instance rotated.
 */
Point.prototype._rotate = function(deg, center, cos, sin) {
    var rad = deg * (Math.PI / 180),
        x,
        y;

    cos = cos || parseFloat(Math.cos(rad).toFixed(8));
    sin = sin || parseFloat(Math.sin(rad).toFixed(8));

    this._subtract(center);

    x = this.x;
    y = this.y;

    this.x = x * cos - y * sin;
    this.y = x * sin + y * cos;

    this._add(center);

    return this;
};

/**
 * Calculate distance between two points.
 * @param {Point} point Point instance.
 * @returns {number} The number of distance between two points.
 */
Point.prototype.distanceTo = function(point) {
    var x,
        y;

    point = Point.n(point);

    x = point.x - this.x;
    y = point.y - this.y;

    return Math.sqrt(x * x + y * y);
};

/**
 * Check point equals.
 * @param {Point} point Point instance to compare
 * @returns {boolean} equality
 */
Point.prototype.equals = function(point) {
    point = Point.n(point);
    return point.x === this.x && point.y === this.y;
};

/**
 * Return formatted string. 'Point(x, y)'
 * @returns {string} string
 */
Point.prototype.toString = function() {
    return 'Point(' + this.x + ', ' + this.y + ')';
};

/**
 * Return coodinates to array. [x, y]
 * @returns {number[]} coordinate array.
 */
Point.prototype.toArray = function() {
    return [this.x, this.y];
};

module.exports = Point;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],34:[function(require,module,exports){
(function (global){
/**
 * @fileoverview RequestAnimFrame
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var requestFn,
    cancelFn;

function getPrefixed(name) {
    return global['webkit' + name] || global['moz' + name] || global['ms' + name];
}

requestFn = global.requestAnimationFrame ||
    getPrefixed('RequestAnimationFrame') ||
    function(fn, context) {
        fn.call(context);
    };

cancelFn = global.cancelAnimationFrame ||
    getPrefixed('CancelAnimationFrame') ||
    getPrefixed('CancelRequestAnimationFrame') ||
    function() {};

/**
 * @module module:reqAnimFrame
 */

module.exports = {
    /**
     * Shim of requestAnimationFrame
     * @param {function} fn callback function
     * @param {*} context context for callback
     * @returns {number} Unique id
     */
    requestAnimFrame: function(fn, context) {
        return requestFn.call(global, util.bind(fn, context));
    },

    /**
     * Shim of cancelAnimationFrame
     * @param {number} id requestAnimationFrame id
     */
    cancelAnimFrame: function(id) {
        if (!id) {
            return;
        }

        cancelFn.call(global, id);
    }
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],35:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Base calendar controller
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var Event = require('../model/event');
var EventViewModel = require('../model/viewModel/event');
var datetime = require('../common/datetime');
var common = require('../common/common');

/**
 * @constructor
 * @param {object} options - options for base controller
 * @param {function} [options.groupFunc] - function for group each models {@see Collection#groupBy}
 * @mixes util.CustomEvents
 */
function Base(options) {
    options = options || {};

    /**
     * function for group each event models.
     * @type {function}
     * @param {EventViewModel} viewModel - view model instance
     * @return {string} group key
     */
    this.groupFunc = options.groupFunc || function(viewModel) {
        if (viewModel.model.isAllDay) {
            return 'allday';
        }
        return 'time';
    }

    /**
     * events collection.
     * @type {Collection}
     */
    this.events = common.createEventCollection();

    /**
     * Matrix for multidate events.
     * @type {object.<string, array>}
     */
    this.dateMatrix = {};
}

/**
 * Calculate contain dates in event.
 * @private
 * @param {Event} event The instance of event.
 * @returns {array} contain dates.
 */
Base.prototype._getContainDatesInEvent = function(event) {
    var range = datetime.range(
        datetime.start(event.getStarts()),
        datetime.start(event.getEnds()),
        datetime.MILLISECONDS_PER_DAY
    );

    return range;
};

/**********
 * CRUD
 **********/

/**
 * Create an event instance from raw data.
 * @emits Base#createdEvent
 * @param {object} options Data object to create event.
 * @param {boolean} silent - set true then don't fire events.
 * @returns {Event} The instance of Event that created.
 */
Base.prototype.createEvent = function(options, silent) {
    var event = this.addEvent(Event.create(options));

    if (!silent) {
        /**
         * @event Base#createdEvent
         * @type {Event}
         */
        this.fire('createdEvent', event);
    }

    return event;
};

/**
 * Set date matrix to supplied event instance.
 * @param {Event} event - instance of event.
 */
Base.prototype._addToMatrix = function(event) {
    var ownMatrix = this.dateMatrix,
        containDates = this._getContainDatesInEvent(event);

    util.forEach(containDates, function(date) {
        var ymd = datetime.format(date, 'YYYYMMDD'),
            matrix = ownMatrix[ymd] = ownMatrix[ymd] || [];

        matrix.push(util.stamp(event));
    });
};

/**
 * Remove event's id from matrix.
 * @param {Event} event - instance of event
 */
Base.prototype._removeFromMatrix = function(event) {
    var modelID = util.stamp(event);

    util.forEach(this.dateMatrix, function(matrix) {
        var index = util.inArray(modelID, matrix);

        if (~index) {
            matrix.splice(index, 1);
        }
    }, this);
};

/**
 * Add an event instance.
 * @emits Base#addedEvent
 * @param {Event} event The instance of Event.
 * @param {boolean} silent - set true then don't fire events.
 * @returns {Event} The instance of Event that added.
 */
Base.prototype.addEvent = function(event, silent) {
    this.events.add(event);
    this._addToMatrix(event);

    if (!silent) {
        /**
         * @event Base#addedEvent
         * @type {object}
         */
        this.fire('addedEvent', event);
    }

    return event;
};

/**
 * split event model by ymd.
 * @param {Date} starts - start date
 * @param {Date} ends - end date
 * @param {Collection} eventCollection - collection of event model.
 * @returns {object.<string, Collection>} splitted event model collections.
 */
Base.prototype.splitEventByDateRange = function(starts, ends, eventCollection) {
    var range = datetime.range(
            datetime.start(starts),
            datetime.start(ends),
            datetime.MILLISECONDS_PER_DAY
        ),
        ownMatrix = this.dateMatrix,
        result = {};

    util.forEachArray(range, function(date) {
        var ymd = datetime.format(date, 'YYYYMMDD'),
            matrix = ownMatrix[ymd],
            collection;

        collection = result[ymd] = common.createEventCollection();

        if (matrix && matrix.length) {
            util.forEachArray(matrix, function(id) {
                eventCollection.doWhenHas(id, function(event) {
                    collection.add(event);
                });
            });
        }
    });

    return result;
};

/**
 * Return events in supplied date range.
 *
 * available only YMD.
 * @param {Date} starts start date.
 * @param {Date} ends end date.
 * @returns {object.<string, Collection>} event collection grouped by dates.
 */
Base.prototype.findByDateRange = function(starts, ends) {
    var range = datetime.range(
            datetime.start(starts),
            datetime.start(ends),
            datetime.MILLISECONDS_PER_DAY
        ),
        ownEvents = this.events.items,
        ownMatrix = this.dateMatrix,
        dformat = datetime.format,
        result = {},
        matrix,
        ymd,
        viewModels;

    util.forEachArray(range, function(date) {
        ymd = dformat(date, 'YYYYMMDD');
        matrix = ownMatrix[ymd];
        viewModels = result[ymd] = common.createEventCollection();

        if (matrix && matrix.length) {
            viewModels.add.apply(viewModels, util.map(matrix, function(id) {
                return EventViewModel.create(ownEvents[id]);
            }));
        }
    });

    return result;
};

// Update
/**
 * Update an event.
 * @emits Base#updateEvent
 * @param {number} id The unique id of Event instance.
 * @param {object} options updated object data.
 * @returns {Event|boolean} updated event instance, when it fail then return false.
 */
Base.prototype.updateEvent = function(id, options) {
    var result = false;

    this.events.doWhenHas(id, function(event) {
        options = options || {};

        if (options.title) {
            event.set('title', options.title);
        }

        if (options.isAllDay) {
            event.set('isAllDay', options.isAllDay);
        }

        if (options.starts) {
            event.set('starts', new Date(options.starts));
        }

        if (options.ends) {
            event.set('ends', new Date(options.ends));
        }

        this._removeFromMatrix(event);
        this._addToMatrix(event);

        result = event;
    }, this);

    /**
     * @event Base#updateEvent
     */
    this.fire('updateEvent');

    return result;
};

// Delete
/**
 * Delete event instance from controller.
 * @param {number} id - unique id of model instance.
 * @returns {Event} deleted model instance.
 */
Base.prototype.deleteEvent = function(id) {
    var result = false;

    this.events.doWhenHas(id, function(event) {
        result = event;
        this._removeFromMatrix(event);
        this.events.remove(event);
    }, this);

    return result;
};

// mixin
util.CustomEvents.mixin(Base);

module.exports = Base;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/common":27,"../common/datetime":28,"../model/event":70,"../model/viewModel/event":71}],36:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Controller mixin modules for day views.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../../common/datetime');
var common = require('../../common/common');
var array = require('../../common/array');
var EventViewModel = require('../../model/viewModel/event');
var aps = Array.prototype.slice;

/**
 * @mixin Base.Week
 */
var Week = {
    /**********
     * COMMON
     **********/

    /**
     * Calculate collision group.
     * @this Base.Week
     * @param {array} viewModels List of viewmodels.
     * @returns {array} Collision Group.
     */
    getCollisionGroup: function(viewModels) {
        var collisionGroups = [],
            foundPrevCollisionEvent = false,
            previousEventList;

        if (!viewModels.length) {
            return collisionGroups;
        }

        collisionGroups[0] = [util.stamp(viewModels[0].valueOf())];
        util.forEachArray(viewModels.slice(1), function(event, index) {
            foundPrevCollisionEvent = false;
            previousEventList = aps.apply(viewModels, [0, index + 1]).reverse();

            util.forEachArray(previousEventList, function(previous) {
                if (event.collidesWith(previous)) {
                    // 이전 일정들과 겹치는 경우 겹치는 일정의 Collision Group을
                    // 찾아 이 일정을 추가한다
                    foundPrevCollisionEvent = true;

                    util.forEachArray(collisionGroups.slice(0).reverse(), function(group) {
                        if (~util.inArray(util.stamp(previous.valueOf()), group)) {
                            // 겹치는 이전 일정을 찾은 경우 그 일정이 속한
                            // Collision Group에 이 일정을 포함시킨다.
                            group.push(util.stamp(event.valueOf()));
                            return false;
                        }
                    });

                    return false;
                }
            });

            if (!foundPrevCollisionEvent) {
                // 이 일정은 이전일정과 겹치지 않는 일정이므로
                // 새 Collision Group을 구성한다.
                collisionGroups.push([util.stamp(event.valueOf())]);
            }
        });

        return collisionGroups;
    },

    /**
     * Get row length by column index in 2d matrix.
     * @this Base.Week
     * @param {array[]} arr2d Matrix
     * @param {number} col Column index.
     * @return {number} Last row number in column.
     */
    getLastRowInColumn: function(arr2d, col) {
        var row = arr2d.length;

        while (row > 0) {
            row -= 1;
            if (!util.isUndefined(arr2d[row][col])) {
                return row;
            }
        }

        return false;
    },

    /**
     * Calculate matrix for appointment block element placing.
     * @this Base.Week
     * @param {Collection} collection model collection.
     * @param {array[]} collisionGroups Collision groups for event set.
     * @returns {array} matrices
     */
    getMatrices: function(collection, collisionGroups) {
        var result = [],
            getLastRowInColumn = Week.getLastRowInColumn;

        util.forEachArray(collisionGroups, function(group) {
            var matrix = [[]];

            util.forEachArray(group, function(eventID) {
                var event = collection.items[eventID],
                    col = 0,
                    found = false,
                    nextRow,
                    lastRowInColumn;

                while (!found) {
                    lastRowInColumn = getLastRowInColumn(matrix, col);

                    if (lastRowInColumn === false) {
                        matrix[0].push(event);
                        found = true;
                    } else if (!event.collidesWith(matrix[lastRowInColumn][col])) {
                        nextRow = lastRowInColumn + 1;
                        if (util.isUndefined(matrix[nextRow])) {
                            matrix[nextRow] = [];
                        }
                        matrix[nextRow][col] = event;
                        found = true;
                    }

                    col += 1;
                }
            });

            result.push(matrix);
        });

        return result;
    },

    /**********
     * TIME GRID VIEW
     **********/

    /**
     * Make array with start and end times on events.
     * @this Base.Week
     * @param {array[]} matrix - matrix from controller.
     * @returns {array[]} starttime, endtime array (exclude first row's events)
     */
    generateTimeArrayInRow: function(matrix) {
        var row,
            col,
            event,
            map = [],
            cursor = [],
            maxColLen = Math.max.apply(null, util.map(matrix, function(col) {
                return col.length;
            }));

        for (col = 1; col < maxColLen; col += 1) {
            row = 0;
            event = util.pick(matrix, row, col);

            while (event) {
                cursor.push([event.getStarts().getTime(), event.getEnds().getTime()]);

                row += 1;
                event = util.pick(matrix, row, col);
            }

            map.push(cursor);
            cursor = [];
        }

        return map;
    },

    /**
     * Get collision information from list
     * @this Base.Week
     * @param {array.<number[]>} arr - list to detecting collision. [[start, end], [start, end]]
     * @param {number} start - event start time that want to detect collisions.
     * @param {number} end - event end time that want to detect collisions.
     * @returns {boolean} target has collide in supplied array?
     */
    hasCollide: function(arr, start, end) {
        var startStart,
            startEnd,
            endStart,
            endEnd,
            getFunc = function(index) {
                return function(block) {
                    return block[index];
                };
            },
            abs = Math.abs,
            compare = array.compare.num.asc,
            hasCollide;

        if (!arr.length) {
            return false;
        }

        startStart = abs(array.bsearch(arr, start, getFunc(0), compare));
        startEnd = abs(array.bsearch(arr, start, getFunc(1), compare));
        endStart = abs(array.bsearch(arr, end, getFunc(0), compare));
        endEnd = abs(array.bsearch(arr, end, getFunc(1), compare));
        hasCollide = !(startStart === startEnd && startEnd === endStart && endStart === endEnd);

        return hasCollide;
    },

    /**
     * Initialize values to viewmodels for detect real collision at rendering phase.
     * @this Base.Week
     * @param {array[]} matrices - Matrix data.
     */
    getCollides: function(matrices) {
        util.forEachArray(matrices, function(matrix) {
            var binaryMap,
                maxRowLength;

            binaryMap = Week.generateTimeArrayInRow(matrix);
            maxRowLength = Math.max.apply(null, util.map(matrix, function(row) {
                return row.length;
            }));

            util.forEachArray(matrix, function(row) {
                util.forEachArray(row, function(viewModel, col) {
                    var startTime,
                        endTime,
                        hasCollide,
                        i;

                    if (!viewModel) {
                        return;
                    }

                    startTime = viewModel.getStarts().getTime() + 1;
                    endTime = viewModel.getEnds().getTime() - 1;

                    for (i = (col + 1); i < maxRowLength; i += 1) {
                        hasCollide = Week.hasCollide(binaryMap[i - 1], startTime, endTime);

                        if (hasCollide) {
                            viewModel.hasCollide = true;
                            break;
                        }

                        viewModel.extraSpace += 1;
                    }
                });
            });
        });
    },

    /**
     * @this Base
     * @param {Date} starts - start date.
     * @param {Date} ends - end date.
     * @param {Collection} time - view model collection.
     * @returns {object} view model for time part.
     */
    getViewModelForTimeView: function(starts, ends, time) {
        var ymdSplitted = this.splitEventByDateRange(starts, ends, time),
            result = {};

        util.forEach(ymdSplitted, function(collection, ymd) {
            var viewModels = collection.sort(array.compare.event.asc),
                collisionGroups,
                matrices;

            collisionGroups = this.getCollisionGroup(viewModels);
            matrices = this.getMatrices(collection, collisionGroups);
            this.getCollides(matrices);

            result[ymd] = matrices;
        }, Week);

        return result;
    },

    /**********
     * ALLDAY VIEW
     **********/

    /**
     * create view model for allday view part.
     * @param {Date} starts start date.
     * @param {Date} ends end date.
     * @param {Collection} viewModels - allday event viewModel viewModels.
     * @returns {object} allday viewModel.
     */
    getViewModelForAlldayView: function(starts, ends, viewModels) {
        var list,
            ymdsToRender,
            collisionGroups,
            matrices;

        if (!viewModels || !viewModels.length) {
            return [];
        }

        ymdsToRender = util.map(
            datetime.range(starts, ends, datetime.MILLISECONDS_PER_DAY),
            function(date) {
                return datetime.format(date, 'YYYYMMDD');
            }
        );

        list = viewModels.sort(array.compare.event.asc);
        collisionGroups = Week.getCollisionGroup(list);
        matrices = Week.getMatrices(viewModels, collisionGroups);

        util.forEachArray(matrices, function(matrix) {
            util.forEachArray(matrix, function(column) {
                util.forEachArray(column, function(viewModel, index) {
                    var ymd, dateLength;

                    if (!viewModel) {
                        return;
                    }

                    ymd = datetime.format(viewModel.getStarts(), 'YYYYMMDD');
                    dateLength = datetime.range(
                        viewModel.getStarts(),
                        viewModel.getEnds(),
                        datetime.MILLISECONDS_PER_DAY
                    ).length;

                    viewModel.top = index;
                    viewModel.left = util.inArray(ymd, ymdsToRender);
                    viewModel.width = dateLength;
                });
            });
        });

        return matrices;
    },

    /**********
     * READ
     **********/

    /**
     * Populate events in date range.
     * @this Base
     * @param {Date} starts start date.
     * @param {Date} ends end date.
     * @returns {object} events grouped by dates.
     */
    findByDateRange: function(starts, ends) {
        var that = this,
            events,
            viewModels;

        // QUERY EVENTS
        events = this.events.find(function(model) {
            var ownStarts = model.getStarts(),
                ownEnds = model.getEnds();

            return (ownStarts >= starts && ownEnds <= ends) ||
                (ownStarts < starts && ownEnds >= starts) ||
                (ownEnds > ends && ownStarts <= ends);
        });

        // CONVERT TO VIEWMODEL
        viewModels = common.createEventCollection.apply(
            null,
            util.map(events.items, function(event) {
                return EventViewModel.create(event);
            })
        ).groupBy(['allday', 'time'], this.groupFunc);

        // CUSTOMIZE VIEWMODEL FOR EACH VIEW
        util.forEach(viewModels, function(coll, key, obj) {
            if (key === 'allday') {
                coll.each(function(viewModel) {
                    var ownStarts = viewModel.getStarts(),
                        ownEnds = viewModel.getEnds();

                    if (ownStarts < starts) {
                        viewModel.renderStarts = new Date(starts.getTime());
                    }

                    if (ownEnds > ends) {
                        viewModel.renderEnds = new Date(ends.getTime());
                    }
                });

                obj.allday = util.bind(Week.getViewModelForAlldayView, that)(starts, ends, coll);
            } else if (key === 'time') {
                obj.time = util.bind(Week.getViewModelForTimeView, that)(starts, ends, coll);
            }
        });

        return viewModels;
    }
};

module.exports = Week;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/array":24,"../../common/common":27,"../../common/datetime":28,"../../model/viewModel/event":71}],37:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Base controller for Dooray service project.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var Base = require('../../controller/base');
var DoorayEvent = require('../model/event');

/**
 * @constructor
 * @param {object} options - options for base controller
 * @param {function} [options.groupFunc] - function for group each models {@see Collection#groupBy}
 * @extends {Base}
 */
function DoorayBase(options) {
    Base.call(this, options);
}

util.inherit(DoorayBase, Base);

/**********
 * CRUD override
 **********/

/**
 * Create an event instance from raw data.
 * @override
 * @emits Base#beforeCreateEvent
 * @emits Base#createdEvent
 * @param {ServiceCalendar~Events} data - Data object to create event.
 * @param {boolean} silent - set true then don't fire events.
 * @returns {DoorayEvent} The instance of Event that created.
 */
DoorayBase.prototype.createEvent = function(data, silent) {
    var inst,
        eventData = {
            data: data
        };

    /**
     * @event Base#beforeCreateEvent
     * @type {ServiceCalendar~Events[]}
     */
    if (!this.invoke('beforeCreateEvent', eventData)) {
        return;
    }

    inst = this.addEvent(DoorayEvent.create(data));

    if (!silent) {
        /**
         * @event Base#createdEvent
         * @type {DoorayEvent}
         */
        this.fire('createdEvent', inst);
    }

    return inst;
};

/**
 * @emits Base#beforeCreateEvent
 * @emits Base#createdEvent
 * @param {ServiceCalendar~Events[]} dataList - dataObject list to create event.
 * @param {boolean} [silent=false] - set true then don't fire events.
 * @returns {DoorayEvent[]} The instance list of Event that created.
 */
DoorayBase.prototype.createEvents = function(dataList, silent) {
    return util.map(dataList, function(data) {
        return this.createEvent(data, silent);
    }, this);
};

module.exports = DoorayBase;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../controller/base":35,"../model/event":42}],38:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Calendar for service.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../../common/datetime');
var Calendar = require('../../factory/calendar');
var DoorayBase = require('../controller/base');
var Week = require('../../controller/viewMixin/week');
var serviceWeekViewFactory = require('./weekView');

/**
 * @typedef {object} ServiceCalendar~Events
 * @property {string} [id] - 일정의 uniqueID.
 * @property {string} [calendarID] - 각 일정을 캘린더별로 그룹지을 수 있는 값.
 * @property {string} title - 이벤트 제목
 * @property {string} category - 이벤트 타입
 * @property {string} dueDateClass - 업무 일정 분류 (category가 'task'일 때 유효)
 * @property {string} starts - 일정 시작 시간
 * @property {string} ends - 일정 종료 시간
 * @property {string} [color] - 일정 텍스트색
 * @property {string} [bgColor] - 일정 배경색
 */

/**
 * Calendar factor module for service (dooray)
 * @constructor
 * @extends {Calendar}
 * @param {object} options - options for calendar
 *  @param {function} [options.groupFunc] - function for group event models {@see Collection#groupBy}
 *  @param {function} [options.controller] - controller instance
 *  @param {string} [options.defaultView='week'] - default view of calendar
 *  @param {object} [options.week] - options for week view
 *   @param {string} options.week.renderStartDate - YYYY-MM-DD render start date
 *   @param {string} options.week.renderEndDate - YYYY-MM-DD render end date
 *  @param {ServiceCalendar~Events[]} options.events - 기본 일정 목록
 *  @param {object} [options.month] - options for month view
 *  @param {string} options.month.renderMonth - YYYY-MM render month
 * @param {HTMLDivElement} container = container element for calendar
 */
function ServiceCalendar(options, container) {
    var controller;
    /**
     * 서비스에서 사용되는 모델 구분용 옵션 함수
     * @param {EventViewModel} viewModel - DoorayEvent를 래핑한 뷰 모델
     * @returns {string} 구분 키 값
     */
    options.groupFunc = function(viewModel) {
        return viewModel.model.category;
    };

    // 컨트롤러 만들기
    controller = options.controller = (function() {
        var controller = new DoorayBase(options),
            originFindByDateRange;

        // 주뷰 컨트롤러 믹스인
        controller.Week = {};
        util.forEach(Week, function(method, methodName) {
            controller.Week[methodName] = util.bind(method, controller);
        });

        // 일정 조회 API에 기존 캘린더에 없었던 milstone, task를 지원하도록
        // 하기 위해 메서드를 오버라이딩한다.
        originFindByDateRange = controller.Week.findByDateRange;
        controller.Week.findByDateRange = function(starts, ends) {
            var dateRange = util.map(datetime.range(
                    datetime.start(starts),
                    datetime.end(ends),
                    datetime.MILLISECONDS_PER_DAY
                ), function(d) { return datetime.format(d, 'YYYY-MM-DD'); }),
                viewModel = originFindByDateRange(starts, ends);

            util.forEach(viewModel, function(coll, key, obj) {
                var groupedByYMD;

                // 마일스톤, 업무 뷰 뷰모델 가공
                if (key === 'task' || key === 'milestone') {
                    groupedByYMD = coll.groupBy(dateRange, function(viewModel) {
                        return datetime.format(viewModel.model.ends, 'YYYY-MM-DD');
                    });

                    if (key === 'task') {
                        util.forEach(groupedByYMD, function(coll, ymd, obj) {
                            obj[ymd] = coll.groupBy(function(viewModel) {
                                return viewModel.model.dueDateClass;
                            });
                        });
                    }

                    obj[key] = groupedByYMD;
                }
            });

            return viewModel;
        };

        return controller;
    })();

    // FullCalendar 기본 모듈은 category, dueDateClass 플래그를 모름. 때문에
    // 이곳에서 이벤트 핸들러를 등록해서 일정 생성 전에 isAllDay플래그를 보고
    // category를 수동으로 지정해준다
    controller.on('beforeCreateEvent', function(e) {
        var data = e.data;

        if (!data.category) {
            data.category = data.isAllDay ? 'allday' : 'time';
        }
    });

    if (options.events) {
        controller.createEvents(options.events, true);
    }

    Calendar.call(this, options, container);
}

util.inherit(ServiceCalendar, Calendar);

/**
 * 각 뷰의 클릭 핸들러와 사용자 클릭 이벤트 핸들러를 잇기 위한 브릿지 개념의 이벤트 핸들러
 * @emits ServiceCalendar#click
 * @param {object} clickEventData - 'click' 핸들러의 이벤트 데이터
 */
ServiceCalendar.prototype._onClick = function(clickEventData) {
    /**
     * @events ServiceCalendar#click
     * @type {object}
     * @property {DoorayEvent} model - 클릭 이벤트 블록과 관련된 일정 모델 인스턴스
     */
    this.fire('click', clickEventData);
};

/**
 * 캘린더 팩토리 클래스와 주뷰, 월뷰의 이벤트 연결을 토글한다
 * @param {boolean} isAttach - true면 이벤트 연결함.
 * @param {Week|Month} view - 주뷰 또는 월뷰
 * @param {ServiceCalendar} calendar - 캘린더 팩토리 클래스
 */
ServiceCalendar.prototype._toggleViewEvent = function(isAttach, view, calendar) {
    var handlers = view.handlers;

    util.forEach(handlers.click, function(handler) {
        if (isAttach) {
            handler.on('click', calendar._onClick, calendar);
            return;
        }

        handler.off('click', calendar._onClick, calendar);
    });
};

/**
 * 주뷰, 월뷰 간 전환
 * @override
 * @param {string} viewName - 'week', 'month' 중 하나
 * @param {boolean} [force=false] - true 지정시 뷰 전환이 없어도 전환을 위한 동작을 수행한다
 */
ServiceCalendar.prototype.toggleView = function(viewName, force) {
    var layout = this.layout,
        controller = this.controller,
        dragHandler = this.dragHandler,
        options = this.options;

    if (!force && this.currentViewName === viewName) {
        return;
    }
    
    layout.childs.doWhenHas(viewName, function(view) {
        this._toggleViewEvent(false, view, this);
    }, this);
    layout.clear();

    if (viewName === 'week') {
        layout.addChild(function() {
            return serviceWeekViewFactory(controller, layout.container, dragHandler, options);
        });
    } else if (viewName === 'month') {
        //TODO: implements
        console.log('월뷰 전환');
    }

    layout.childs.doWhenHas(viewName, function(view) {
        this._toggleViewEvent(true, view, this);
    }, this);
    layout.render();

    this.currentViewName = viewName;
};

module.exports = ServiceCalendar;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../controller/viewMixin/week":36,"../../factory/calendar":50,"../controller/base":37,"./weekView":39}],39:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Factory module for WeekView (customized for service)
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../../common/domutil');

// Parent views
var Week = require('../../view/week/week');

// Sub views
var DayName = require('../../view/week/dayname');
var Milestone = require('../view/milestone');
var TaskView = require('../view/taskview');
var TimeGrid = require('../../view/week/timeGrid');
var Allday = require('../../view/week/allday');


// Handlers
var AlldayClick = require('../../handler/allday/click');
var AlldayCreation = require('../../handler/allday/creation');
var AlldayMove = require('../../handler/allday/move');
var AlldayResize = require('../../handler/allday/resize');
var TimeClick = require('../../handler/time/click');
var TimeCreation = require('../../handler/time/creation');
var TimeMove = require('../../handler/time/move');
var TimeResize = require('../../handler/time/resize');
var MilestoneClick = require('../handler/milestoneClick');
var TaskClick = require('../handler/taskClick');

// Base Templates
var weekViewTmpl = require('../../dooray/view/template/factory/weekView.hbs');

module.exports = function(baseController, layoutContainer, dragHandler, options) {
    var weekView,
        dayNameView,
        milestoneView,
        taskView,
        alldayView,
        timeGridView,
        milestoneClickHandler,
        taskClickHandler,
        alldayClickHandler,
        alldayCreationHandler,
        alldayMoveHandler,
        alldayResizeHandler,
        timeClickHandler,
        timeCreationHandler,
        timeMoveHandler,
        timeResizeHandler;

    weekView = new Week(null, options.week, layoutContainer);
    weekView.container.innerHTML = weekViewTmpl();

    /**********
     * 일자표기 (상단 일월화수...)
     **********/
    dayNameView = new DayName(null, domutil.find('.schedule-view-dayname-layout', weekView.container));
    weekView.addChild(dayNameView);

    /**********
     * 마일스톤
     **********/
    milestoneView = new Milestone(options.week, domutil.find('.schedule-view-milestone-layout'));
    weekView.addChild(milestoneView);
    milestoneClickHandler = new MilestoneClick(dragHandler, milestoneView, baseController);

    /**********
     * 업무
     **********/
    taskView = new TaskView(options.week, domutil.find('.schedule-view-milestone-layout'));
    weekView.addChild(taskView);
    taskClickHandler = new TaskClick(dragHandler, taskView, baseController);

    /**********
     * 종일일정
     **********/
    alldayView = new Allday(options.week, domutil.find('.schedule-view-allday-layout', weekView.container));
    weekView.addChild(alldayView);
    alldayClickHandler = new AlldayClick(dragHandler, alldayView, baseController);
    alldayCreationHandler = new AlldayCreation(dragHandler, alldayView, baseController);
    alldayMoveHandler = new AlldayMove(dragHandler, alldayView, baseController);
    alldayResizeHandler = new AlldayResize(dragHandler, alldayView, baseController);

    /**********
     * 시간별 일정
     **********/
    timeGridView = new TimeGrid(options.week, domutil.find('.schedule-view-timegrid-layout', weekView.container));
    weekView.addChild(timeGridView);
    timeClickHandler = new TimeClick(dragHandler, timeGridView, baseController);
    timeCreationHandler = new TimeCreation(dragHandler, timeGridView, baseController);
    timeMoveHandler = new TimeMove(dragHandler, timeGridView, baseController);
    timeResizeHandler = new TimeResize(dragHandler, timeGridView, baseController);

    weekView.handlers = {
        click: {
            milestone: milestoneClickHandler,
            task: taskClickHandler,
            allday: alldayClickHandler,
            time: timeClickHandler
        },
        creation: {
            allday: alldayCreationHandler,
            time: timeCreationHandler
        },
        move: {
            allday: alldayMoveHandler,
            time: timeMoveHandler
        },
        resize: {
            allday: alldayResizeHandler,
            time: timeResizeHandler
        }
    };


    // add controller
    weekView.controller = baseController.Week;

    // add destroy
    weekView._beforeDestroy = function() {
        util.forEach(weekView.handlers, function(type) {
            util.forEach(type, function(handler) {
                handler.off();
                handler.destroy();
            });
        });
    };

    return weekView;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/domutil":31,"../../dooray/view/template/factory/weekView.hbs":49,"../../handler/allday/click":53,"../../handler/allday/creation":55,"../../handler/allday/move":57,"../../handler/allday/resize":59,"../../handler/time/click":62,"../../handler/time/creation":64,"../../handler/time/move":66,"../../handler/time/resize":68,"../../view/week/allday":83,"../../view/week/dayname":84,"../../view/week/timeGrid":86,"../../view/week/week":87,"../handler/milestoneClick":40,"../handler/taskClick":41,"../view/milestone":44,"../view/taskview":48}],40:[function(require,module,exports){
(function (global){
/**
 * @fileoverview 마일스톤 항목 클릭 이벤트 핸들러 모듈
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../../common/domutil');

/**
 * 마일스톤 클릭 이벤트 핸들러 모듈
 * @constructor
 * @implelements {Handler}
 * @mixes util.CustomEvents
 * @param {Drag} dragHandler - dragHandler instance
 * @param {Milestone} milestoneView - milstone view instance
 * @param {Base} baseController - baseController instance
 */
function MilestoneClick(dragHandler, milestoneView, baseController) {
    /**
     * @type {Drag}
     */
    this.dragHandler = dragHandler;

    /**
     * @type {Milestone}
     */
    this.milestoneView = milestoneView;

    /**
     * @type {Base}
     */
    this.baseController = baseController;

    dragHandler.on({
        'click': this._onClick
    }, this);
}

/**
 * Destroy
 */
MilestoneClick.prototype.destroy = function() {
    this.dragHandler.off(this);
    this.dragHandler = this.milestoneView = this.baseController = null;
};

/**
 * @param {HTMLElement} target - check reponsibility to this handler module supplied element
 * @returns {boolean|string} return false when handler has no responsibility for supplied element. 
 * otherwise, return event model id that related with target element.
 */
MilestoneClick.prototype.checkExpectedCondition = function(target) {
    if (!domutil.hasClass(target, 'schedule-view-dot') &&
        !domutil.hasClass(target, 'schedule-view-milestone-item')) {
        return false;
    }

    target = domutil.closest(target, '.schedule-view-milestone-item');
    
    if (!target) {
        return false;
    }

    return domutil.getData(target, 'id');
};

/**
 * @emits MilestoneClick#click
 * @param {object} clickEvent - click event object
 */
MilestoneClick.prototype._onClick = function(clickEvent) {
    var modelID = this.checkExpectedCondition(clickEvent.target);

    if (!modelID) {
        return;
    }

    this.baseController.events.doWhenHas(modelID, function(model) {
        /**
         * @events MilestoneClick#click
         * @type {object}
         * @property {Event} model - model instance
         */
        this.fire('click', {
            model:  model
        });
    }, this);
};

util.CustomEvents.mixin(MilestoneClick);

module.exports = MilestoneClick;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/domutil":31}],41:[function(require,module,exports){
(function (global){
/**
 * @fileoverview 마일스톤 항목 클릭 이벤트 핸들러 모듈
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../../common/domutil');

/**
 * 마일스톤 클릭 이벤트 핸들러 모듈
 * @constructor
 * @implelements {Handler}
 * @mixes util.CustomEvents
 * @param {Drag} dragHandler - dragHandler instance
 * @param {Task} taskView - milstone view instance
 * @param {Base} baseController - baseController instance
 */
function TaskClick(dragHandler, taskView, baseController) {
    /**
     * @type {Drag}
     */
    this.dragHandler = dragHandler;

    /**
     * @type {Task}
     */
    this.taskView = taskView;

    /**
     * @type {Base}
     */
    this.baseController = baseController;

    dragHandler.on({
        'click': this._onClick
    }, this);
}

/**
 * Destroy
 */
TaskClick.prototype.destroy = function() {
    this.dragHandler.off(this);
    this.dragHandler = this.taskView = this.baseController = null;
};

/**
 * @param {HTMLElement} target - check reponsibility to this handler module supplied element
 * @returns {boolean|string} return false when handler has no responsibility for supplied element. 
 * otherwise, return event model id that related with target element.
 */
TaskClick.prototype.checkExpectedCondition = function(target) {
    if (!domutil.hasClass(target, 'schedule-view-dot') &&
        !domutil.hasClass(target, 'schedule-view-task-item')) {
        return false;
    }

    target = domutil.closest(target, '.schedule-view-task-item');

    if (!target) {
        return false;
    }

    return domutil.getData(target, 'id');
};

/**
 * @emits TaskClick#click
 * @param {object} clickEvent - click event object
 */
TaskClick.prototype._onClick = function(clickEvent) {
    var modelID = this.checkExpectedCondition(clickEvent.target);

    if (!modelID) {
        return;
    }

    this.baseController.events.doWhenHas(modelID, function(model) {
        /**
         * @events TaskClick#click
         * @type {object}
         * @property {Event} model - model instance
         */
        this.fire('click', {
            model:  model
        });
    }, this);
};

util.CustomEvents.mixin(TaskClick);

module.exports = TaskClick;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/domutil":31}],42:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Extend model class for Dooray Calendar project.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var Event = require('../../model/event');

/**
 * 일정 카테고리
 * @readonly
 * @enum {string}
 */
var EVENT_CATEGORY = {
    /** 마일스톤 */
    MILESTONE: 'milestone',

    /** 업무 */
    TASK: 'task',
    
    /** 종일일정 */
    ALLDAY: 'allday',

    /** 시간별 일정 */
    TIME: 'time'
};

/**
 * Event class for dooray project
 * @constructor
 * @extends {Event}
 */
function DoorayEvent() {
    Event.call(this);

    /**
     * 일정 카테고리 (마일스톤, 업무, 종일일정, 시간별일정)
     * @type {string}
     */
    this.category = '';

    /**
     * 업무 일정의 경우 구분 (출근전, 점심전, 퇴근전)
     * @type {string}
     */
    this.dueDateClass = '';
}

util.inherit(DoorayEvent, Event);

/**
 * @override
 */
DoorayEvent.create = function(data) {
    var inst = new DoorayEvent();
    inst.init(data);

    return inst;
};

/**
 * @override
 * @param {object} options options.
 */
DoorayEvent.prototype.init = function(options) {
    options = options || {};

    Event.prototype.init.call(this, options);

    this.isAllDay = options.category === EVENT_CATEGORY.ALLDAY;
    this.category = options.category;
    this.dueDateClass = options.dueDateClass;

    if (options.category === EVENT_CATEGORY.MILESTONE ||
        options.category === EVENT_CATEGORY.TASK) {
        this.starts = new Date(+this.ends);
        this.starts.setMinutes(this.starts.getMinutes() - 30);
    }
};

module.exports = DoorayEvent;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../model/event":70}],43:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : {};

  return "<div class=\"schedule-view-milestone-day\" \n        style=\"width:"
    + alias2(alias1(((stack1 = (data && data.root)) && stack1.width), depth0))
    + "%;left:"
    + alias2((helpers.multiply || (depth0 && depth0.multiply) || helpers.helperMissing).call(alias3,((stack1 = (data && data.root)) && stack1.width),(data && data.index),{"name":"multiply","hash":{},"data":data}))
    + "%;min-height:"
    + alias2(alias1(((stack1 = (data && data.root)) && stack1.minHeight), depth0))
    + "px;height:"
    + alias2(alias1(((stack1 = (data && data.root)) && stack1.height), depth0))
    + "px\">\n        <ul class=\"schedule-view-milestone-list\">\n"
    + ((stack1 = helpers.each.call(alias3,(depth0 != null ? depth0.items : depth0),{"name":"each","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</ul>\n    </div>\n";
},"2":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=container.escapeExpression, alias2=container.lambda;

  return "<li data-id="
    + alias1((helpers.stamp || (depth0 && depth0.stamp) || helpers.helperMissing).call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.model : depth0),{"name":"stamp","hash":{},"data":data}))
    + " data-title=\""
    + alias1(alias2(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.title : stack1), depth0))
    + "\" class=\"schedule-view-milestone-item\" \n            style=\"line-height:"
    + alias1(alias2(((stack1 = (data && data.root)) && stack1.lineHeight), depth0))
    + "px;color:"
    + alias1(alias2(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.color : stack1), depth0))
    + "\"><span class=\"schedule-view-dot\" style=\"background-color:"
    + alias1(alias2(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.bgColor : stack1), depth0))
    + "\"></span> "
    + alias1(alias2(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.title : stack1), depth0))
    + "</li>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<div class=\"schedule-view-milestone-left\">\n    <span>마일스톤</span>\n</div>\n<div class=\"schedule-view-milestone-right schedule-view-clear\">\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.events : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],44:[function(require,module,exports){
(function (global){
/**
 * @fileoverview 마일스톤 뷰
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var View = require('../../view/view');
var tmpl = require('./milestone.hbs');

var PADDING = 4;    // 마일스톤 그리드 내 패딩 값 (top + height)

/**
 * @constructor
 * @extends {View}
 * @param {object} options - options
 * @param {string} options.renderStartDate - start date of allday view's render date. YYYY-MM-DD
 * @param {string} options.renderEndDate - end date of allday view's render date. YYYY-MM-DD
 * @param {number} [options.minHeight=40] - min-height of milestone view 
 * @param {number} [options.lineHeight=12] - line height of milestone view
 * @param {HTMLElement} container - container element
 */
function Milestone(options, container) {
    container = domutil.appendHTMLElement(
        'div',
        container,
        'schedule-view-milestone-container'
    );

    View.call(this, options, container);

    /**
     * @type {object}
     */
    this.options = util.extend({
        renderStartDate: '',
        renderEndDate: '',
        minHeight: 40,
        lineHeight: 12
    }, options);
}

util.inherit(Milestone, View);

/**
 * Get base viewmodel for task view
 * @param {object} [viewModel] - view model from parent view
 * @returns {object} view model for task view
 */
Milestone.prototype._getBaseViewModel = function(viewModel) {
    var options = this.options,
        events = {},
        range = datetime.range(
            datetime.start(datetime.parse(options.renderStartDate)),
            datetime.end(datetime.parse(options.renderEndDate)),
            datetime.MILLISECONDS_PER_DAY
        ),
        height;

    util.forEach(range, function(d) {
        events[datetime.format(d, 'YYYY-MM-DD')] = {};
    });

    util.extend(events, viewModel);

    height = Math.max.apply(null, util.map(events, function(coll) {
        return coll.length;
    })) * options.lineHeight;

    height = Math.max(options.minHeight, height);

    return {
        events: events,
        width: 100 / range.length,
        minHeight: options.minHeight,
        height: height + PADDING,
        lineHeight: options.lineHeight
    };
};

/**
 * 마일스톤 뷰 렌더링
 * @override
 */
Milestone.prototype.render = function(viewModel) {
    var container = this.container,
        baseViewModel = this._getBaseViewModel(util.pick(viewModel.eventsInDateRange, 'milestone'));

    container.style.minHeight = this.options.minHeight + 'px';
    container.innerHTML = tmpl(baseViewModel);

    util.forEach(domutil.find('li', container, true), function(el) {
        if (el.offsetWidth < el.scrollWidth) {
            el.setAttribute('title', domutil.getData(el, 'title'));
        }
    });
};

module.exports = Milestone;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../../view/view":82,"./milestone.hbs":43}],45:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    return "<th>"
    + container.escapeExpression(container.lambda(depth0, depth0))
    + "</th>\n";
},"3":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<tr>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},depth0,{"name":"each","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</tr>\n";
},"4":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<td class=\"schedule-view-minicalendar-"
    + alias4(((helper = (helper = helpers.ymd || (depth0 != null ? depth0.ymd : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"ymd","hash":{},"data":data}) : helper)))
    + " \n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.isNotThisMonth : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.selected : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.today : depth0),{"name":"if","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.hasSchedule : depth0),{"name":"if","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.weekend : depth0),{"name":"if","hash":{},"fn":container.program(13, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\">\n<button type=\"button\" tabindex=\"-1\" class=\"schedule-view-minicalendar-date\">\n    <div class=\"schedule-view-minicalendar-label\"><span>"
    + alias4(((helper = (helper = helpers.d || (depth0 != null ? depth0.d : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"d","hash":{},"data":data}) : helper)))
    + "</span></div>\n</button>\n</td>\n";
},"5":function(container,depth0,helpers,partials,data) {
    return "schedule-view-minicalendar-other ";
},"7":function(container,depth0,helpers,partials,data) {
    return "schedule-view-minicalendar-focused ";
},"9":function(container,depth0,helpers,partials,data) {
    return "schedule-view-minicalendar-today ";
},"11":function(container,depth0,helpers,partials,data) {
    return "schedule-view-minicalendar-has-schedule ";
},"13":function(container,depth0,helpers,partials,data) {
    return "schedule-view-minicalendar-weekend ";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {};

  return "<table>\n<caption>\n    <button type=\"button\" class=\"schedule-view-minicalendar-nav schedule-view-minicalendar-prev\"><span>&lt;</span></button>\n    <span class=\"schedule-view-minicalendar-title\">"
    + container.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
    + "</span>\n    <button type=\"button\" class=\"schedule-view-minicalendar-nav schedule-view-minicalendar-next\"><span>&gt;</span></button>\n</caption>\n<thead><tr>\n"
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.dayname : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</tr></thead>\n<tbody>\n"
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.calendar : depth0),{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</tbody>\n</table>\n";
},"useData":true});

},{"hbsfy/runtime":22}],46:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Minicalendar view.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var View = require('../../view/view');
var domutil = require('../../common/domutil');
var domevent = require('../../common/domevent');
var datetime = require('../../common/datetime');
var tmpl = require('./minicalendar.hbs');

var getDateRx = /schedule-view-minicalendar-(\d{4}-\d{2}-\d{2})/;

/**
 * @constructor
 * @extends {View}
 * @param {object} options - options for minicalendar view
 *  @param {number} [options.startDayOfWeek=0] - start day of week. default 0 (sunday)
 *  @param {string|Date} [options.renderMonth] - month to render
 *  @param {string[]} [options.highlightDate] - dates to highlight
 *  @param {string[]} [options.daynames] - array of each days name.
 * @param {HTMLDivElement} container - element to use container
 */
function MiniCalendar(options, container) {
    var today = datetime.start(new Date());

    if (!(this instanceof MiniCalendar)) {
        return new MiniCalendar(options, container);
    }

    View.call(this, options, container);
    domutil.addClass(container, 'schedule-view-minicalendar');
    domevent.on(this.container, 'click', this._onClick, this);

    /**
     * @type {object}
     */
    options = this.options = util.extend({
        startDayOfWeek: 0,
        renderMonth: new Date(+today),
        highlightDate: [],
        daynames: ['일', '월', '화', '수', '목', '금', '토']
    }, options);

    // parse renderMonth options if it is an string
    if (util.isString(options.renderMonth)) {
        options.renderMonth = datetime.start(datetime.parse(options.renderMonth));
    }

    /**
     * 일자 강조 데이터
     * @type {object}
     */
    this.hlData = {};
    if (options.highlightDate.length) {
        this.highlightDate(options.highlightDate);
    }

    this.render();
}

util.inherit(MiniCalendar, View);

/**
 * Next, Prev button event handler
 * @fires Minicalendar#change
 * @param {HTMLButtonElement} buttonElement - next, prev button from _onClick event handler
 */
MiniCalendar.prototype._nav = function(buttonElement) {
    var isNext = domutil.hasClass(buttonElement, 'schedule-view-minicalendar-next'),
        options = this.options,
        offset = isNext ? 1 : -1,
        eventData = {
            before: this.getSelectedDate()
        };

    options.renderMonth.setMonth(options.renderMonth.getMonth() + offset);

    this.render();

    eventData.after = this.getSelectedDate();

    /**
     * @event MiniCalendar#change
     * @type {object}
     * @property {Date} before - the date of before changed
     * @property {Date} after - the date of after changed
     */
    this.fire('change', eventData);
};

/**
 * Date button event handler
 * @fires Minicalendar#change
 * @param {HTMLButtonElement} buttonElement - date button from _onClick event handler
 */
MiniCalendar.prototype._date = function(buttonElement) {
    var td = domutil.closest(buttonElement, 'td'),
        today = (new Date()),
        previous,
        selected,
        eventData = {
            before: this.getSelectedDate()
        };

    if (td) {
        previous = domutil.find('.schedule-view-minicalendar-focused', this.container);

        if (previous) {
            domutil.removeClass(previous, 'schedule-view-minicalendar-focused');
        }

        domutil.addClass(td, 'schedule-view-minicalendar-focused');

        selected = this.getSelectedDate();

        if (datetime.isSameDate(selected, today)) {
            domutil.addClass(td, 'schedule-view-minicalendar-today');
        }

        eventData.after = selected;

        /**
         * @event MiniCalendar#change
         * @type {object}
         * @property {Date} before - the date of before changed
         * @property {Date} after - the date of after changed
         */
        this.fire('change', eventData);
    }
};

/**
 * Click event handler
 * @param {MouseEvent} clickEvent - click mouse event object
 */
MiniCalendar.prototype._onClick = function(clickEvent) {
    var target = clickEvent.srcElement || clickEvent.target,
        button = domutil.closest(target, 'button');

    if (!button) {
        return;
    }

    if (domutil.hasClass(button, 'schedule-view-minicalendar-date')) {
        this._date(button);
        return;
    }

    if (domutil.hasClass(button, 'schedule-view-minicalendar-nav')) {
        this._nav(button);
        return;
    }
};

/**
 * Get selected data
 * @returns {Date} selected date
 */
MiniCalendar.prototype.getSelectedDate = function() {
    var selected = domutil.find('.schedule-view-minicalendar-focused', this.container),
        matches;

    if (!selected) {
        return null;
    }

    matches = selected.className.match(getDateRx);

    if (!matches || matches.length < 2) {
        return;
    }

    return datetime.parse(matches[1]);
};

/**
 * select specific date.
 * @param {Date|string} date - date to select
 */
MiniCalendar.prototype.selectDate = function(date) {
    var _date,
        td, button;

    if (util.isString(date)) {
        date = datetime.parse(date);
    }

    _date = datetime.format(date, 'YYYY-MM-DD');
    td = domutil.find('.schedule-view-minicalendar-' + _date, this.container);
    button = domutil.find('button', td);

    if (!td || !button) {
        return;
    }

    this._date(button);
};

/**
 * Get minicalendar view model
 * @param {Date} renderDate - Date to render minicalendar
 * @param {number} startDayOfWeek - number of start of week (0:sun ...)
 * @returns {object} viewmodel
 */
MiniCalendar.prototype._getViewModel = function(renderDate, startDayOfWeek) {
    var daynames = this.options.daynames,
        hlData = this.hlData,
        today = datetime.start(new Date()),
        isCurrentMonth = datetime.isSameMonth(renderDate, today),
        viewModel = {
            title: datetime.format(renderDate, 'YYYY.MM'),
            startDayOfWeek: startDayOfWeek
        };

    viewModel.dayname = util.map(
        util.range(startDayOfWeek, 7).concat(util.range(7)).slice(0, 7),
        function(i) { return daynames[i]; } 
    );

    viewModel.calendar = datetime.arr2dCalendar(renderDate, startDayOfWeek, function(date) {
        var d = date.getDate(),
            ymd = datetime.format(date, 'YYYY-MM-DD'),
            day = date.getDay(),
            selected = false,
            isToday = datetime.isSameDate(date, today),
            dateIsInThisMonth = datetime.isSameMonth(date, renderDate);

        if (dateIsInThisMonth) {
            if (isCurrentMonth) {
                if (isToday) {
                    selected = true;
                    isToday = true;
                }
            } else if (d === 1) {
                selected = true;
            }
        }

        return {
            d: d,
            ymd: ymd,
            hasSchedule: hlData[ymd],
            isNotThisMonth: !dateIsInThisMonth,
            weekend: (day === 0 || day === 6),
            selected: selected,
            today: isToday
        };
    });

    return viewModel;
};

/**
 * Render view
 */
MiniCalendar.prototype.render = function() {
    var container = this.container,
        options = this.options,
        renderDate = options.renderMonth,
        startDayOfWeek = options.startDayOfWeek,
        viewModel;

    viewModel = this._getViewModel(renderDate, startDayOfWeek);

    container.innerHTML = tmpl(viewModel);
};

/**
 * Cache data for highlight specific dates in calendar.
 * @param {string[]} dateStrList - the array of dates to highlight. (YYYY-MM-DD)
 * @param {boolean} [silent=false] - set true for prevent auto rendering.
 */
MiniCalendar.prototype.highlightDate = function(dateStrList, silent) {
    var ownData = this.hlData;

    util.forEach(dateStrList, function(ymd) {
        ownData[ymd] = true;
    });

    if (!silent) {
        this.render();
    }
};

/**
 * Clear cached data for highlighting specific date for represent the date has schedule.
 * @param {boolean} [silent=false] - set true for prevent auto rendering.
 */
MiniCalendar.prototype.clearHighlightDate = function(silent) {
    delete this.hlData;
    this.hlData = {};

    if (!silent) {
        this.render();
    }
};

util.CustomEvents.mixin(MiniCalendar);

module.exports = MiniCalendar;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domevent":30,"../../common/domutil":31,"../../view/view":82,"./minicalendar.hbs":45}],47:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : {};

  return "<div class=\"schedule-view-task-day\" \n    style=\"width:"
    + alias2(alias1(((stack1 = (data && data.root)) && stack1.width), depth0))
    + "%;left:"
    + alias2((helpers.multiply || (depth0 && depth0.multiply) || helpers.helperMissing).call(alias3,((stack1 = (data && data.root)) && stack1.width),(data && data.index),{"name":"multiply","hash":{},"data":data}))
    + "%;\n        min-height:"
    + alias2(alias1(((stack1 = (data && data.root)) && stack1.minHeight), depth0))
    + "px;height:"
    + alias2(alias1(((stack1 = (data && data.root)) && stack1.height), depth0))
    + "px;\">\n    <div class=\"schedule-view-task-day-wrap\">\n"
    + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.morning : depth0),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.lunch : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.evening : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</div>\n</div>\n";
},"2":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<h6 style=\"line-height:"
    + container.escapeExpression(container.lambda(((stack1 = (data && data.root)) && stack1.lineHeight), depth0))
    + "px\">출근 전</h6>\n        <ul>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},((stack1 = (depth0 != null ? depth0.morning : depth0)) != null ? stack1.items : stack1),{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</ul>\n";
},"3":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=container.escapeExpression, alias2=container.lambda;

  return "<li data-id="
    + alias1((helpers.stamp || (depth0 && depth0.stamp) || helpers.helperMissing).call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.model : depth0),{"name":"stamp","hash":{},"data":data}))
    + " data-title=\""
    + alias1(alias2(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.title : stack1), depth0))
    + "\" class=\"schedule-view-task-item\" \n            style=\"line-height:"
    + alias1(alias2(((stack1 = (data && data.root)) && stack1.lineHeight), depth0))
    + "px;color:"
    + alias1(alias2(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.color : stack1), depth0))
    + "\"><span class=\"schedule-view-dot\" style=\"background-color:"
    + alias1(alias2(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.bgColor : stack1), depth0))
    + "\"></span> "
    + alias1(alias2(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.title : stack1), depth0))
    + "</li>\n";
},"5":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<h6 style=\"line-height:"
    + container.escapeExpression(container.lambda(((stack1 = (data && data.root)) && stack1.lineHeight), depth0))
    + "px\">점심 전</h6>\n        <ul>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},((stack1 = (depth0 != null ? depth0.lunch : depth0)) != null ? stack1.items : stack1),{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</ul>\n";
},"7":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<h6 style=\"line-height:"
    + container.escapeExpression(container.lambda(((stack1 = (data && data.root)) && stack1.lineHeight), depth0))
    + "px\">퇴근 전</h6>\n        <ul>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},((stack1 = (depth0 != null ? depth0.evening : depth0)) != null ? stack1.items : stack1),{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</ul>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<div class=\"schedule-view-task-left\">\n    <span>업무</span>\n</div>\n<div class=\"schedule-view-task-right schedule-view clear\">\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.events : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],48:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Task view for upper area of Week view.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var View = require('../../view/view');
var tmpl = require('./taskview.hbs');

var PADDING = 4;    // 그리드 내 패딩 값 (top + height)

/**
 * @constructor
 * @extends {View}
 * @param {object} options - options for TaskView
 * @param {string} options.renderStartDate - start date of allday view's render date. YYYY-MM-DD
 * @param {string} options.renderEndDate - end date of allday view's render date. YYYY-MM-DD
 * @param {number} [options.minHeight=40] - min-height of taskview
 * @param {number} [options.lineHeight=12] - line height of milestone view
 * @param {HTMLElement} container - container element
 */
function TaskView(options, container) {
    container = domutil.appendHTMLElement(
        'div',
        container,
        'schedule-view-task-container'
    );

    View.call(this, options, container);

    /**
     * @type {object}
     */
    this.options = util.extend({
        renderStartDate: '',
        renderEndDate: '',
        minHeight: 40,
        lineHeight: 12
    }, options);
}

util.inherit(TaskView, View);

/**
 * Get base viewmodel for task view
 * @param {object} [viewModel] - view model from parent view
 * @returns {object} view model for task view
 */
TaskView.prototype._getBaseViewModel = function(viewModel) {
    var options = this.options,
        events = {},
        range = datetime.range(
            datetime.start(datetime.parse(options.renderStartDate)),
            datetime.end(datetime.parse(options.renderEndDate)),
            datetime.MILLISECONDS_PER_DAY
        ),
        height = 0,
        mmax = Math.max;

    util.forEach(range, function(d) {
        events[datetime.format(d, 'YYYY-MM-DD')] = {};
    });

    util.extend(events, viewModel);

    // (출근전, 점심전, 퇴근전 항목 수 * 12px) + (각 항목의 아이템 수 * 12px)
    height = mmax.apply(null, util.map(events, function(g) {
        var subcount = util.keys(g).length;

        util.forEach(g, function(coll) {
            subcount += coll.length;
        });

        return subcount;
    })) * options.lineHeight;

    height = mmax(options.minHeight, height);

    return {
        events: events,
        width: 100 / range.length,
        height: height + PADDING,
        lineHeight: options.lineHeight
    };
};

/**
 * 업무 뷰 렌더링
 * @override
 */
TaskView.prototype.render = function(viewModel) {
    var container = this.container,
        baseViewModel = this._getBaseViewModel(util.pick(viewModel.eventsInDateRange, 'task'));

    container.style.minHeight = this.options.minHeight + 'px';
    container.innerHTML = tmpl(baseViewModel);

    util.forEach(domutil.find('li', container, true), function(el) {
        if (el.offsetWidth < el.scrollWidth) {
            el.setAttribute('title', domutil.getData(el, 'title'));
        }
    });
};

module.exports = TaskView;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../../view/view":82,"./taskview.hbs":47}],49:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<div class=\"schedule-view-display-table\">\n    <div class=\"schedule-view-display-table-row\">\n        <div class=\"schedule-view-display-table-cell\">\n            <div class=\"schedule-view-scroll-y schedule-view-dayname-layout\"></div>\n        </div>\n    </div>\n\n    <div class=\"schedule-view-display-table-row\">\n        <div class=\"schedule-view-display-table-cell\">\n            <div class=\"schedule-view-scroll-y schedule-view-milestone-layout\" style=\"min-height:80px;max-height:100px\"></div>\n        </div>\n    </div>\n\n    <div class=\"schedule-view-display-table-row\">\n        <div class=\"schedule-view-display-table-cell\">\n            <div class=\"schedule-view-scroll-y schedule-view-allday-layout\"></div>\n        </div>\n    </div>\n    <div class=\"schedule-view-display-table-row\">\n        <div class=\"schedule-view-display-table-cell schedule-view-timegrid-layout\"></div>\n    </div>\n</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],50:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Factory module for control all other factory.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../common/datetime');
var Layout = require('../view/layout');
var Drag = require('../handler/drag');
var controllerFactory = require('./controller');
var weekViewFactory = require('./weekView');

/**
 * @typedef {object} Calendar~Events
 * @property {string} title - 이벤트 제목
 * @property {boolean} isAllDay - 종일일정여부
 * @property {string} starts - 일정 시작 시간
 * @property {string} ends - 일정 종료 시간
 * @property {string} [color] - 일정 텍스트색
 * @property {string} [bgColor] - 일정 배경색
 */

/**
 * Calendar class
 * @constructor
 * @mixes util.CustomEvents
 * @param {object} options - options for calendar
 *  @param {function} [options.groupFunc] - function for group event models {@see Collection#groupBy}
 *  @param {function} [options.controller] - controller instance
 *  @param {string} [options.defaultView='week'] - default view of calendar
 *  @param {object} [options.week] - options for week view
 *   @param {string} options.week.renderStartDate - YYYY-MM-DD render start date
 *   @param {string} options.week.renderEndDate - YYYY-MM-DD render end date
 *  @param {object} [options.month] - options for month view
 *   @param {string} options.month.renderMonth - YYYY-MM render month
 * @param {HTMLDivElement} container = container element for calendar
 */
function Calendar(options, container) {
    /**
     * base date of view (today() will use this property)
     * @type {Date}
     */
    this.baseDate = datetime.start(new Date());

    /**
     * default option from service page
     * @type {object}
     */
    this.options = this.setOptions(options);

    /**
     * original options for reference when ui reset
     * @type {object}
     */
    this.originOptions = JSON.parse(JSON.stringify(this.options));

    /**
     * base controller
     * @type {Base}
     */
    this.controller = options.controller || controllerFactory(options);

    /**
     * layout view (layout manager)
     * @type {Layout}
     */
    this.layout = new Layout(container);

    /**
     * global drag handler
     * @type {Drag}
     */
    this.dragHandler = new Drag(null, this.layout);

    /**
     * current rendered view name.
     * @type {string}
     */
    this.currentViewName = options.defaultView || 'week';

    /**********
     * SETTING
     **********/
    this.layout.controller = this.controller;

    function refresh() {
        this.refreshChildView();
    }

    this.controller.on({
        updateEvent: refresh,
        createdEvent: refresh
    }, this);

    this.toggleView(options.defaultView, true);

    this.render();
}

/**
 * Create events instance and render calendar.
 * @param {Calendar~Event[]} dataObjectList - array of {@see Calendar~Event} object
 */
Calendar.prototype.createEvent = function(dataObjectList) {
    this.controller.createEvents(dataObjectList, true);
    this.render();
};

/**
 * Render calendar.
 */
Calendar.prototype.render = function() {
    this.layout.render();
};

/**
 * Delete all data and clear view.
 */
Calendar.prototype.clear = function() {
    this.controller.dateMatrix = {};
    this.controller.events.clear();
    this.render();
};

/**
 * Move next.
 */
Calendar.prototype.next = function() {
    this.move(1);
};

/**
 * Move previous.
 */
Calendar.prototype.prev = function() {
    this.move(-1);
};

/**
 * Move to today.
 */
Calendar.prototype.today = function() {
    var currentView = this.getCurrentView(),
        originOptions = this.originOptions;

    if (currentView.viewName === 'week') {
        originOptions = originOptions.week;
        this.options.week = {
            renderStartDate: originOptions.renderStartDate,
            renderEndDate: originOptions.renderEndDate 
        };
        currentView.recursive(function(view) {
            if (!view.options) {
                return;
            }

            view.options.renderStartDate = originOptions.renderStartDate;
            view.options.renderEndDate = originOptions.renderEndDate;
        });
    }

    this.refreshChildView(currentView.viewName);
};

/**
 * Move calendar by direction
 * @param {number} direction - the number that want to move (+1, -1)
 */
Calendar.prototype.move = function(direction) {
    var currentView = this.getCurrentView(),
        options = this.options,

        dateOffset,
        newStart,
        newEnd;

    if (currentView.viewName === 'week') {
        newStart = datetime.start(datetime.parse(options.week.renderStartDate));
        newEnd = datetime.end(datetime.parse(options.week.renderEndDate));
        dateOffset = datetime.range(newStart, newEnd, datetime.MILLISECONDS_PER_DAY).length * direction;
        newStart = datetime.format(new Date(newStart.setDate(newStart.getDate() + dateOffset)), 'YYYY-MM-DD');
        newEnd = datetime.format(new Date(newEnd.setDate(newEnd.getDate() + dateOffset)), 'YYYY-MM-DD');

        options.week = {
            renderStartDate: newStart,
            renderEndDate: newEnd
        };
        currentView.recursive(function(view) {
            if (!view.options) {
                return;
            }

            view.options.renderStartDate = newStart;
            view.options.renderEndDate = newEnd;
        });
    }

    this.refreshChildView(currentView.viewName);
}

/**
 * Return current rendered view.
 * @returns {View} current view instance
 */
Calendar.prototype.getCurrentView = function() {
    return util.pick(this.layout.childs.items, this.currentViewName);
}

/**
 * Toggle current view
 * @param {string} viewName - the name of view.
 * @param {boolean} force - force render despite of current view and new view are equal
 */
Calendar.prototype.toggleView = function(viewName, force) {
    var layout = this.layout,
        controller = this.controller,
        dragHandler = this.dragHandler,
        options = this.options;

    if (!force && this.currentViewName === viewName) {
        return;
    }

    this.currentViewName = viewName;
    layout.clear();

    if (viewName === 'week') {
        layout.addChild(function() {
            return weekViewFactory(controller, layout.container, dragHandler, options);
        });
    }
}

/**
 * Destroy calendar instance.
 */
Calendar.prototype.destory = function() {
    this.dragHandler.destroy();
    this.controller.off();
    this.layout.clear();
    this.layout.destroy();

    this.options = this.baseDate = this.controller =
        this.layout = this.dragHandler = null;
}

/**
 * Refresh child views
 * @param {string} [viewName] - the name of view to render. if not supplied then refresh all.
 */
Calendar.prototype.refreshChildView = function(viewName) {
    if (!viewName) {
        this.render();
        return;
    }

    this.layout.childs.items[viewName].render();
};

/**
 * Create default option
 * @param {object} options - option from service page
 * @returns {object} default option. 
 */
Calendar.prototype.setOptions = function(options) {
    var today = this.baseDate,
        dateRange;

    options = util.extend({
        defaultView: 'week',    // 기본 주간 뷰 설정
        week: null,
        month: null 
    }, options);

    if (!options.week) {
        dateRange = datetime.range(
            datetime.start(new Date(new Date(today).setDate(today.getDate() - 3))),
            datetime.end(new Date(new Date(today).setDate(today.getDate() + 3))),
            datetime.MILLISECONDS_PER_DAY
        );

        options.week = {
            renderStartDate: datetime.format(dateRange[0], 'YYYY-MM-DD'),
            renderEndDate: datetime.format(dateRange[6], 'YYYY-MM-DD')
        };
    }

    if (!options.month) {
        options.month = {
            renderMonth: datetime.format(today, 'YYYY-MM')
        };
    }

    return options;
};

util.CustomEvents.mixin(Calendar);

module.exports = Calendar;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/datetime":28,"../handler/drag":61,"../view/layout":72,"./controller":51,"./weekView":52}],51:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Controller factory module.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var Base = require('../controller/base');
var Week = require('../controller/viewMixin/week');

/**
 * @param {object} options - options for base controller
 * @param {function} [options.groupFunc] - function for group each models {@see Collection#groupBy}
 * @returns {Base} The controller instance.
 */
module.exports = function(options) {
    var controller = new Base(options);

    controller.Week = {};
    util.forEach(Week, function(method, methodName) {
        controller.Week[methodName] = util.bind(method, controller);
    });

    return controller;
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../controller/base":35,"../controller/viewMixin/week":36}],52:[function(require,module,exports){
/**
 * @fileoverview Factory module for WeekView
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var domutil = require('../common/domutil');

// Parent views
var Week = require('../view/week/week');

// Sub views
var DayName = require('../view/week/dayname');
var TimeGrid = require('../view/week/timeGrid');
var Allday = require('../view/week/allday');

// Handlers
var AlldayClick = require('../handler/allday/click');
var AlldayCreation = require('../handler/allday/creation');
var AlldayMove = require('../handler/allday/move');
var AlldayResize = require('../handler/allday/resize');
var TimeClick = require('../handler/time/click');
var TimeCreation = require('../handler/time/creation');
var TimeMove = require('../handler/time/move');
var TimeResize = require('../handler/time/resize');

// Base Templates
var weekViewTmpl = require('../view/template/factory/weekView.hbs');

module.exports = function(baseController, layoutContainer, dragHandler, options) {
    var weekView,
        dayNameView,
        alldayView,
        timeGridView,
        alldayClickHandler,
        alldayCreationHandler,
        alldayMoveHandler,
        alldayResizeHandler,
        timeClickHandler,
        timeCreationHandler,
        timeMoveHandler,
        timeResizeHandler;

    weekView = new Week(null, options.week, layoutContainer);
    weekView.container.innerHTML = weekViewTmpl();

    /**********
     * 일자표기 (상단 일월화수...)
     **********/
    dayNameView = new DayName(null, domutil.find('.schedule-view-dayname-layout', weekView.container));
    weekView.addChild(dayNameView);

    /**********
     * 종일일정
     **********/
    alldayView = new Allday(options.week, domutil.find('.schedule-view-allday-layout', weekView.container));
    weekView.addChild(alldayView);
    alldayClickHandler = new AlldayClick(dragHandler, alldayView, baseController);
    alldayCreationHandler = new AlldayCreation(dragHandler, alldayView, baseController);
    alldayMoveHandler = new AlldayMove(dragHandler, alldayView, baseController);
    alldayResizeHandler = new AlldayResize(dragHandler, alldayView, baseController);

    /**********
     * 시간별 일정
     **********/
    timeGridView = new TimeGrid(options.week, domutil.find('.schedule-view-timegrid-layout', weekView.container));
    weekView.addChild(timeGridView);
    timeClickHandler = new TimeClick(dragHandler, timeGirdView);
    timeCreationHandler = new TimeCreation(dragHandler, timeGridView, baseController);
    timeMoveHandler = new TimeMove(dragHandler, timeGridView, baseController);
    timeResizeHandler = new TimeResize(dragHandler, timeGridView, baseController);

    weekView.handlers = {
        click: {
            allday: alldayClickHandler,
            time: timeClickHandler
        },
        creation: {
            allday: alldayCreationHandler,
            time: timeCreationHandler
        },
        move: {
            allday: alldayMoveHandler,
            time: timeMoveHandler
        },
        resize: {
            allday: alldayResizeHandler,
            time: timeResizeHandler
        }
    };

    // add controller
    weekView.controller = baseController.Week;

    // add destroy
    weekView._beforeDestroy = function() {
        util.forEach(weekView.handlers, function(type) {
            util.forEach(type, function(handler) {
                handler.off();
                handler.destroy();
            });
        });
    };

    return weekView;
};

},{"../common/domutil":31,"../handler/allday/click":53,"../handler/allday/creation":55,"../handler/allday/move":57,"../handler/allday/resize":59,"../handler/time/click":62,"../handler/time/creation":64,"../handler/time/move":66,"../handler/time/resize":68,"../view/template/factory/weekView.hbs":74,"../view/week/allday":83,"../view/week/dayname":84,"../view/week/timeGrid":86,"../view/week/week":87}],53:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Click handle module for allday events
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../../common/domutil');
var AlldayMove = require('./move');

/**
 * @constructor
 * @implements {Handler}
 * @mixes CustomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {Allday} [alldayView] - MonthWeek view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function AlldayClick(dragHandler, alldayView, baseController) {
    /**
     * @type {Drag}
     */
    this.dragHandler = dragHandler;

    /**
     * @type {Allday}
     */
    this.alldayView = alldayView;

    /**
     * @type {Base}
     */
    this.baseController = baseController;

    dragHandler.on({
        'click': this._onClick
    }, this);
}

/**
 * Destroy handler module
 */
AlldayClick.prototype.destroy = function() {
    this.dragHandler.off(this);
    this.alldayView = this.baseController = this.dragHandler = null;
};

/**
 * Check target element is expected condition for activate this plugins.
 * @param {HTMLElement} target - The element to check
 * @returns {string} - model id
 */
AlldayClick.prototype.checkExpectCondition = AlldayMove.prototype.checkExpectedCondition;

/**
 * Click event handler
 * @param {object} clickEvent - click event data
 * @emits AlldayClick#click
 */
AlldayClick.prototype._onClick = function(clickEvent) {
    var target = clickEvent.target,
        timeView = this.checkExpectCondition(target),
        blockElement = domutil.closest(target, '.schedule-view-allday-event-block'),
        eventCollection = this.baseController.events;

    if (!timeView || !blockElement) {
        return;
    }

    eventCollection.doWhenHas(domutil.getData(blockElement, 'id'), function(model) {
        /**
         * @events AlldayClick#click
         * @type {object}
         * @property {Event} model - model instance
         */
        this.fire('click', {
            model:  model
        });
    }, this);
};

util.CustomEvents.mixin(AlldayClick);

module.exports = AlldayClick;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/domutil":31,"./move":57}],54:[function(require,module,exports){
/**
 * @fileoverview Base mixin object for handler/allday
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var domutil = require('../../common/domutil');
var domevent = require('../../common/domevent');
var datetime = require('../../common/datetime');
var common = require('../../common/common');

var mmax = Math.max,
    mmin = Math.min,
    CONTAINER_PADDING_LEFT = 60;

/**
 * @mixin Allday.Core
 */
var alldayCore = {
    /**
     * @param {Allday} alldayView - view instance of allday.
     * @param {MouseEvent} mouseEvent - mouse event object.
     * @returns {function} function that return event data by mouse events.
     */
    _retriveEventData: function(alldayView, mouseEvent) {
        var container = alldayView.container,
            renderStartDate,
            renderEndDate,
            datesInRange,
            containerWidth,
            mousePos,
            dragStartXIndex;

        renderStartDate = datetime.parse(alldayView.options.renderStartDate);
        renderEndDate = datetime.end(datetime.parse(alldayView.options.renderEndDate));
        datesInRange = datetime.range(renderStartDate, renderEndDate, datetime.MILLISECONDS_PER_DAY).length;
        containerWidth = domutil.getSize(container)[0] - CONTAINER_PADDING_LEFT;    // subtract container left padding.

        mousePos = domevent.getMousePosition(mouseEvent, container);
        dragStartXIndex = common.ratio(containerWidth, datesInRange, mousePos[0] - CONTAINER_PADDING_LEFT) | 0;

        /**
         * @param {MouseEvent} mouseEvent - mouse event in drag actions.
         * @returns {object} event data.
         */
        return function(mouseEvent) {
            var pos = domevent.getMousePosition(mouseEvent, container),
                mouseX = pos[0] - CONTAINER_PADDING_LEFT,
                xIndex = common.ratio(containerWidth, datesInRange, mouseX) | 0;

            // apply limitation of creation event X index.
            xIndex = mmax(xIndex, 0);
            xIndex = mmin(xIndex, datesInRange - 1);

            return {
                relatedView: alldayView,
                dragStartXIndex: dragStartXIndex,
                datesInRange: datesInRange,
                xIndex: xIndex
            };
        };
    }
};

module.exports = alldayCore;


},{"../../common/common":27,"../../common/datetime":28,"../../common/domevent":30,"../../common/domutil":31}],55:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Handler module for MonthWeek view's creation actions.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.ne.util;
var datetime = require('../../common/datetime');
var common = require('../../common/common');
var domutil = require('../../common/domutil');
var alldayCore = require('./core');
var AlldayCreationGuide = require('./creationGuide');

var parseViewIDRx = /^schedule-view-allday-monthweek[\s]schedule-view-(\d+)/;

/**
 * @constructor
 * @implements {Handler}
 * @mixes AlldayCore
 * @mixes CutomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {Allday} [alldayView] - MonthWeek view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function AlldayCreation(dragHandler, alldayView, baseController) {    // eslint-disable-line
    /**
     * Drag handler instance.
     * @type {Drag}
     */
    this.dragHandler = null;

    /**
     * allday view instance.
     * @type {Allday}
     */
    this.alldayView = null;

    /**
     * Base controller instance.
     * @type {Base}
     */
    this.baseController = null;

    /**
     * @type {function}
     */
    this.getEventDataFunc = null;

    if (arguments.length) {
        this.connect.apply(this, arguments);
    }

    /**
     * @type {AlldayCreationGuide}
     */
    this.guide = new AlldayCreationGuide(this);
}

/**
 * Destroy method
 */
AlldayCreation.prototype.destroy = function() {
    this.guide.destroy();
    this.dragHandler.off(this);
    this.dragHandler = this.alldayView = this.baseController =
        this.getEventDataFunc = null;
};

/**
 * Check dragstart target is expected conditions for this handler.
 * @param {HTMLElement} target - dragstart event handler's target element.
 * @returns {boolean|MonthWeek} return MonthWeek view instance when satiate condition.
 */
AlldayCreation.prototype.checkExpectedCondition = function(target) {
    var cssClass = domutil.getClass(target),
        matches;

    if (cssClass !== 'schedule-view-monthweek-events') {
        return false;
    }

    target = target.parentNode;
    cssClass = domutil.getClass(target);
    matches = cssClass.match(parseViewIDRx);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.alldayView.childs.items, matches[1]);
};

/**
 * Connect handler, view, controller.
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {Allday} [alldayView] - MonthWeek view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
AlldayCreation.prototype.connect = function(dragHandler, alldayView, baseController) {
    this.dragHandler = dragHandler;
    this.alldayView = alldayView;
    this.baseController = baseController;

    dragHandler.on({
        dragStart: this._onDragStart
    }, this);
};

/**
 * Request event model creation to controller by custom events.
 * @param {object} eventData - event data from AlldayCreation module.
 */
AlldayCreation.prototype._createEvent = function(eventData) {
    var title = window.prompt('Name of event to create:'),
        ctrl = this.baseController,
        viewOptions = eventData.relatedView.options,
        dateRange = datetime.range(
            datetime.start(datetime.parse(viewOptions.renderStartDate)),
            datetime.end(datetime.parse(viewOptions.renderEndDate)),
            datetime.MILLISECONDS_PER_DAY
        ),
        startXIndex = eventData.dragStartXIndex,
        xIndex = eventData.xIndex,
        newStarts,
        newEnds;

    this.guide.clearGuideElement();

    if (!title) {
        return;
    }

    // when inverse start, end then change it.
    if (xIndex < startXIndex) {
        startXIndex = xIndex + startXIndex;
        xIndex = startXIndex - xIndex;
        startXIndex = startXIndex - xIndex;
    }

    newStarts = new Date(dateRange[startXIndex].getTime());
    newEnds = datetime.end(dateRange[xIndex]);

    // request event creation to "base" controller.
    ctrl.createEvent({
        title: title,
        isAllDay: true,
        starts: newStarts,
        ends: newEnds
    });
};

/**
 * DragStart event handler method.
 * @emits AlldayCreation#allday_creation_dragstart
 * @param {object} dragStartEventData - Drag#dragStart event handler event data.
 */
AlldayCreation.prototype._onDragStart = function(dragStartEventData) {
    var target = dragStartEventData.target,
        result = this.checkExpectedCondition(target),
        getEventDataFunc,
        eventData;

    if (!result) {
        return;
    }

    this.dragHandler.on({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    getEventDataFunc = this.getEventDataFunc = this._retriveEventData(this.alldayView, dragStartEventData.originEvent);
    eventData = getEventDataFunc(dragStartEventData.originEvent);

    /**
     * @event AlldayCreation#allday_creation_dragstart
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire('allday_creation_dragstart', eventData);
};

/**
 * Drag event handler method.
 * @emits AlldayCreation#allday_creation_drag
 * @param {object} dragEventData - Drag#drag event handler eventdata.
 */
AlldayCreation.prototype._onDrag = function(dragEventData) {
    var getEventDataFunc = this.getEventDataFunc,
        eventData;

    if (!getEventDataFunc) {
        return;
    }

    eventData = getEventDataFunc(dragEventData.originEvent);

    /**
     * @event AlldayCreation#allday_creation_drag
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire('allday_creation_drag', eventData);
};

/**
 * DragEnd event hander method.
 * @emits AlldayCreation#allday_creation_dragend
 * @param {object} dragEndEventData - Drag#DragEnd event handler data.
 * @param {string} [overrideEventName] - override emitted event name when supplied.
 */
AlldayCreation.prototype._onDragEnd = function(dragEndEventData, overrideEventName) {
    var getEventDataFunc = this.getEventDataFunc,
        eventData;

    if (!getEventDataFunc) {
        return;
    }

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    eventData = getEventDataFunc(dragEndEventData.originEvent);

    this._createEvent(eventData);

    /**
     * @event AlldayCreation#allday_creation_dragend
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire(overrideEventName || 'allday_creation_dragend', eventData);

    this.getEventDataFunc = null;
};

/**
 * Click event handler method.
 * @emits AlldayCreation#allday_creation_click
 * @param {object} clickEventData - Drag#Click event handler data.
 */
AlldayCreation.prototype._onClick = function(clickEventData) {
    /**
     * @event AlldayCreation#allday_creation_click
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this._onDragEnd(clickEventData, 'allday_creation_click');
};

common.mixin(alldayCore, AlldayCreation);
util.CustomEvents.mixin(AlldayCreation);

module.exports = AlldayCreation;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/datetime":28,"../../common/domutil":31,"./core":54,"./creationGuide":56}],56:[function(require,module,exports){
/**
 * @fileoverview Guide element for Allday.Creation
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var domutil = require('../../common/domutil');
var reqAnimFrame = require('../../common/reqAnimFrame');

var CREATE_NEW_LABEL = '새 일정';

/**
 * Class for Allday.Creation dragging effect.
 * @constructor
 * @param {AlldayCreation} alldayCreation - instance of AlldayCreation.
 */
function AlldayCreationGuide(alldayCreation) {
    /**
     * @type {AlldayCreation}
     */
    this.alldayCreation = alldayCreation;

    /**
     * @type {HTMLDIVElement}
     */
    this.eventContainer = null;

    /**
     * @type {HTMLDIVElement}
     */
    this.guideElement = document.createElement('div');

    this.initializeGuideElement();

    alldayCreation.on({
        'allday_creation_dragstart': this._onDragStart,
        'allday_creation_drag': this._onDrag,
        // 'allday_creation_dragend': this.clearGuideElement,
        'allday_creation_click': this.clearGuideElement
    }, this);
}

/**
 * Destroy method
 */
AlldayCreationGuide.prototype.destroy = function() {
    this.clearGuideElement();
    this.alldayCreation.off(this);
    this.alldayCreation = this.eventContainer =
        this.guideElement = null;
};

/**
 * initialize guide element's default style.
 */
AlldayCreationGuide.prototype.initializeGuideElement = function() {
    var guideElement = this.guideElement,
        alldayView = this.alldayCreation.alldayView,
        eventBlockHeight = alldayView.options.eventBlockHeight,
        spanElement;

    domutil.addClass(guideElement, 'schedule-view-allday-creation-guide-block');
    domutil.appendHTMLElement('div', guideElement, 'schedule-view-allday-creation-guide');

    spanElement = domutil.appendHTMLElement('span', guideElement);
    spanElement.innerHTML = CREATE_NEW_LABEL;
};

/**
 * Refresh guide element.
 * @param {object} eventData - event data from Allday.Creation handler.
 */
AlldayCreationGuide.prototype._refreshGuideElement = function(eventData) {
    var guideElement = this.guideElement,
        baseWidthPercent = (100 / eventData.datesInRange),
        dragStartXIndex = eventData.dragStartXIndex,
        xIndex = eventData.xIndex,
        length = xIndex - dragStartXIndex,
        leftPercent,
        widthPercent;

    // when revert dragging.
    if (length < 0) {
        dragStartXIndex = xIndex;
        length = Math.abs(length);
    }

    leftPercent = baseWidthPercent * dragStartXIndex;
    widthPercent = baseWidthPercent * (length + 1);

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.display = 'block';
        guideElement.style.left = leftPercent + '%';
        guideElement.style.width = widthPercent + '%';
    });
};

/**
 * Clear guide element.
 */
AlldayCreationGuide.prototype.clearGuideElement = function() {
    var guideElement = this.guideElement;

    domutil.remove(guideElement);

    guideElement.style.display = 'none';
    guideElement.style.left = '';
    guideElement.style.width = '';
};

/**
 * DragStart event handler.
 * @param {object} dragStartEventData - event data object of Allday.Creation.
 */
AlldayCreationGuide.prototype._onDragStart = function(dragStartEventData) {
    var alldayCreation = this.alldayCreation,
        alldayView = alldayCreation.alldayView,
        alldayContainerElement = alldayView.container,
        eventContainer = domutil.find('.schedule-view-monthweek-events', alldayContainerElement);

    eventContainer.appendChild(this.guideElement);
    this._refreshGuideElement(dragStartEventData);
};

/**
 * Drag event handler.
 * @param {object} dragEventData - event data object of Allday.Creation.
 */
AlldayCreationGuide.prototype._onDrag = function(dragEventData) {
    this._refreshGuideElement(dragEventData);
};

module.exports = AlldayCreationGuide;


},{"../../common/domutil":31,"../../common/reqAnimFrame":34}],57:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Move handler for Allday view.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.ne.util;
var common = require('../../common/common');
var domutil = require('../../common/domutil');
var AlldayCore = require('./core');
var AlldayMoveGuide = require('./moveGuide');

var checkExpectedConditionIDRx = /^schedule-view-allday-event(-title)?$/;
var parseViewIDRx = /^schedule-view-allday-monthweek[\s]schedule-view-(\d+)/;

/**
 * @constructor
 * @implements {Handler}
 * @mixes AlldayCore
 * @mixes CustomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {Allday} [alldayView] - MonthWeek view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function AlldayMove(dragHandler, alldayView, baseController) {
    /**
     * Drag handler instance.
     * @type {Drag}
     */
    this.dragHandler = dragHandler;

    /**
     * allday view instance.
     * @type {Allday}
     */
    this.alldayView = alldayView;

    /**
     * Base controller instance.
     * @type {Base}
     */
    this.baseController = baseController;

    /**
     * Temporary variable for dragstart event data.
     * @type {object}
     */
    this._dragStart = null;

    dragHandler.on({
        dragStart: this._onDragStart
    }, this);

    /**
     * @type {AlldayMoveGuide}
     */
    this.guide = new AlldayMoveGuide(this);
}

AlldayMove.prototype.destroy = function() {
    this.guide.destroy();
    this.dragHandler.off(this);
    this.dragHandler = this.alldayView = this.baseController =
        this.guide = this._dragStart = null;
};

/**
 * Check dragstart target is expected conditions for this handler.
 * @param {HTMLElement} target - dragstart event handler's target element.
 * @returns {boolean|MonthWeek} return MonthWeek view instance when satiate condition.
 */
AlldayMove.prototype.checkExpectedCondition = function(target) {
    var cssClass = domutil.getClass(target),
        parentView,
        matches;

    if (!checkExpectedConditionIDRx.test(cssClass)) {
        return false;
    }

    parentView = domutil.closest(target, '.schedule-view-allday-monthweek');

    if (!parentView) {
        return false;
    }

    cssClass = domutil.getClass(parentView);
    matches = cssClass.match(parseViewIDRx);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.alldayView.childs.items, matches[1]);
};

/**
 * DragStart event handler method.
 * @emits AlldayMove#allday_move_dragstart
 * @param {object} dragStartEventData - Drag#dragStart event handler event data.
 */
AlldayMove.prototype._onDragStart = function(dragStartEventData) {
    var target = dragStartEventData.target,
        result = this.checkExpectedCondition(target),
        controller = this.baseController,
        eventBlockElement,
        modelID,
        targetModel,
        getEventDataFunc,
        eventData;

    if (!result) {
        return;
    }

    eventBlockElement = domutil.closest(target, '.schedule-view-allday-event-block');
    modelID = domutil.getData(eventBlockElement, 'id');
    targetModel = controller.events.items[modelID];

    if (!targetModel) {
        return;
    }

    getEventDataFunc = this.getEventDataFunc = this._retriveEventData(this.alldayView, dragStartEventData.originEvent);
    eventData = this._dragStart = getEventDataFunc(dragStartEventData.originEvent);

    util.extend(eventData, {
        eventBlockElement: eventBlockElement,
        model: targetModel
    });

    this.dragHandler.on({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    /**
     * @event AlldayMove#allday_move_dragstart
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     * @property {Event} model - data object of model isntance.
     * @property {HTMLDivElement} eventBlockElement - target event block element.
     */
    this.fire('allday_move_dragstart', eventData);
};


/**
 * Drag event handler method.
 * @emits AlldayMove#allday_move_drag
 * @param {object} dragEventData - Drag#drag event handler eventdata.
 */
AlldayMove.prototype._onDrag = function(dragEventData) {
    var getEventDataFunc = this.getEventDataFunc;

    if (!getEventDataFunc) {
        return;
    }

    /**
     * @event AlldayMove#allday_move_drag
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire('allday_move_drag', getEventDataFunc(dragEventData.originEvent));
};

/**
 * Request update event model to base controller.
 * @param {object} eventData - event data from AlldayMove handler module.
 */
AlldayMove.prototype._updateEvent = function(eventData) {
    var ctrl = this.baseController,
        model = eventData.targetModel,
        dateOffset = eventData.xIndex - eventData.dragStartXIndex,
        newStarts = new Date(model.starts.getTime()),
        newEnds = new Date(model.ends.getTime());

    newStarts = new Date(newStarts.setDate(newStarts.getDate() + dateOffset));
    newEnds = new Date(newEnds.setDate(newEnds.getDate() + dateOffset));

    ctrl.updateEvent(model.cid(), {
        starts: newStarts,
        ends: newEnds
    });
};

/**
 * DragEnd event hander method.
 * @emits AlldayMove#allday_move_dragend
 * @param {object} dragEndEventData - Drag#DragEnd event handler data.
 * @param {string} [overrideEventName] - override emitted event name when supplied.
 * @param {?boolean} skipUpdate - true then skip update event model.
 */
AlldayMove.prototype._onDragEnd = function(dragEndEventData, overrideEventName, skipUpdate) {
    var getEventDataFunc = this.getEventDataFunc,
        dragStart = this._dragStart,
        eventData;

    if (!getEventDataFunc || !dragStart) {
        return;
    }

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    eventData = getEventDataFunc(dragEndEventData.originEvent);
    util.extend(eventData, {
        targetModel: dragStart.model
    });
    
    if (!skipUpdate) {
        this._updateEvent(eventData);
    }

    /**
     * @event AlldayMove#allday_move_dragend
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire(overrideEventName || 'allday_move_dragend', eventData);

    this.getEventDataFunc = this._dragStart = null;
};

/**
 * Click event handler method.
 * @emits AlldayMove#allday_move_click
 * @param {object} clickEventData - Drag#Click event handler data.
 */
AlldayMove.prototype._onClick = function(clickEventData) {
    /**
     * @event AlldayMove#allday_move_click
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this._onDragEnd(clickEventData, 'allday_move_click', true);
};

common.mixin(AlldayCore, AlldayMove);
util.CustomEvents.mixin(AlldayMove);

module.exports = AlldayMove;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/domutil":31,"./core":54,"./moveGuide":58}],58:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Effect module for Allday.Move
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.ne.util;
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var reqAnimFrame = require('../../common/reqAnimFrame');

/**
 * Class for Allday.Move dragging effect.
 * @constructor
 * @param {AlldayMove} alldayMove - instance of AlldayMove.
 */
function AlldayMoveGuide(alldayMove) {
    /**
     * @type {AlldayMove}
     */
    this.alldayMove = alldayMove;

    /**
     * 실제로 이벤트 엘리먼트를 담는 엘리먼트
     * @type {HTMLDIVElement}
     */
    this.eventContainer = null;

    /**
     * @type {number}
     */
    this._dragStartXIndex = null;

    /**
     * @type {HTMLDIVElement}
     */
    this.guideElement = null;

    alldayMove.on({
        'allday_move_dragstart': this._onDragStart,
        'allday_move_drag': this._onDrag,
        'allday_move_dragend': this._clearGuideElement,
        'allday_move_click': this._clearGuideElement
    }, this);
}

/**
 * Destroy method
 */
AlldayMoveGuide.prototype.destroy = function() {
    this._clearGuideElement();
    this.alldayMove.off(this);
    this.alldayMove = this.eventContainer = this._dragStartXIndex =
        this.guideElement = null;
};

/**
 * Clear guide element.
 */
AlldayMoveGuide.prototype._clearGuideElement = function() {
    domutil.remove(this.guideElement);

    if (!util.browser.msie) {
        domutil.removeClass(global.document.body, 'schedule-view-dragging');
    }

    this._dragStartXIndex = this.getEventDataFunc = this.guideElement = null;
};

/**
 * Refresh guide element.
 * @param {number} leftPercent - left percent of guide element.
 * @param {number} widthPercent - width percent of guide element.
 * @param {boolean} isExceededLeft - event starts is faster then render start date?
 * @param {boolean} isExceededRight - event ends is later then render end date?
 */
AlldayMoveGuide.prototype.refreshGuideElement = function(leftPercent, widthPercent, isExceededLeft, isExceededRight) {
    var guideElement = this.guideElement;

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.left = leftPercent + '%';
        guideElement.style.width = widthPercent + '%';

        if (isExceededLeft) {
            domutil.addClass(guideElement, 'schedule-view-allday-exceed-left');
        } else {
            domutil.removeClass(guideElement, 'schedule-view-allday-exceed-left');
        }

        if (isExceededRight) {
            domutil.addClass(guideElement, 'schedule-view-allday-exceed-right');
        } else {
            domutil.removeClass(guideElement, 'schedule-view-allday-exceed-right');
        }
    });
};

/**
 * Get event block information from event data.
 *
 * For example, there is single event has 10 length. but render range in view is 5 then
 * rendered block must be cut out to render properly. in this case, this method return
 * how many block are cut before rendering.
 * 
 * 이벤트 데이터에서 이벤트 블록 엘리먼트 렌더링에 대한 필요 정보를 추출한다.
 *
 * ex) 렌더링 된 블록의 길이는 5지만 실제 이 이벤트는 10의 길이를 가지고 있을 때
 * 좌 우로 몇 만큼 잘려있는지에 관한 정보를 반환함.
 * @param {object} dragStartEventData - event data from Allday.Move handler.
 * @returns {function} function that return event block information.
 */
AlldayMoveGuide.prototype._getEventBlockDataFunc = function(dragStartEventData) {
    var model = dragStartEventData.model,
        datesInRange = dragStartEventData.datesInRange,
        baseWidthPercent = (100 / datesInRange),
        originEventStarts = datetime.start(model.starts),
        originEventEnds = datetime.end(model.ends),
        viewOptions = this.alldayMove.alldayView.options,
        renderStartDate = datetime.start(datetime.parse(viewOptions.renderStartDate)),
        renderEndDate = datetime.end(datetime.parse(viewOptions.renderEndDate)),
        fromLeft = (new Date(originEventStarts.getTime() - renderStartDate.getTime())) / datetime.MILLISECONDS_PER_DAY | 0,
        fromRight = (new Date(originEventEnds.getTime() - renderEndDate.getTime())) / datetime.MILLISECONDS_PER_DAY | 0;

    return function(indexOffset) {
        return {
            baseWidthPercent: baseWidthPercent,
            fromLeft: fromLeft + indexOffset,
            fromRight: fromRight + indexOffset
        };
    };
};

/**
 * DragStart event handler.
 * @param {object} dragStartEventData - event data.
 */
AlldayMoveGuide.prototype._onDragStart = function(dragStartEventData) {
    var alldayViewContainer = this.alldayMove.alldayView.container,
        guideElement = this.guideElement = dragStartEventData.eventBlockElement.cloneNode(true),
        eventContainer;

    if (!util.browser.msie) {
        domutil.addClass(global.document.body, 'schedule-view-dragging');
    }

    eventContainer = domutil.find('.schedule-view-monthweek-events', alldayViewContainer);
    domutil.addClass(guideElement, 'schedule-view-allday-move-guide');
    eventContainer.appendChild(guideElement);

    this._dragStartXIndex = dragStartEventData.xIndex;
    this.getEventDataFunc = this._getEventBlockDataFunc(dragStartEventData);
};

/**
 * Drag event handler.
 * @param {object} dragEventData - event data.
 */
AlldayMoveGuide.prototype._onDrag = function(dragEventData) {
    var getEventDataFunc = this.getEventDataFunc,
        dragStartXIndex = this._dragStartXIndex,
        datesInRange = dragEventData.datesInRange,
        eventData,
        isExceededLeft,
        isExceededRight,
        originLength,
        newLeft,
        newWidth;

    if (!getEventDataFunc) {
        return;
    }

    eventData = getEventDataFunc(dragEventData.xIndex - dragStartXIndex);
    isExceededLeft = eventData.fromLeft < 0;
    isExceededRight = eventData.fromRight > 0;

    newLeft = Math.max(0, eventData.fromLeft);
    originLength = (eventData.fromLeft * -1) + (datesInRange + eventData.fromRight);
    newWidth = isExceededLeft ? (originLength + eventData.fromLeft) : originLength;
    newWidth = isExceededRight ? (newWidth - eventData.fromRight) : newWidth;

    newLeft *= eventData.baseWidthPercent;
    newWidth *= eventData.baseWidthPercent;

    this.refreshGuideElement(newLeft, newWidth, isExceededLeft, isExceededRight);
};

module.exports = AlldayMoveGuide;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../../common/reqAnimFrame":34}],59:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Resize handler module for Allday view.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.ne.util;
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var common = require('../../common/common');
var AlldayCore = require('./core');
var AlldayResizeGuide = require('./resizeGuide');

var parseViewIDRx = /^schedule-view-allday-monthweek[\s]schedule-view-(\d+)/;

/**
 * @constructor
 * @implements {Handler}
 * @mixes AlldayCore
 * @mixes CustomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {Allday} [alldayView] - MonthWeek view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function AlldayResize(dragHandler, alldayView, baseController) {
    /**
     * Drag handler instance.
     * @type {Drag}
     */
    this.dragHandler = dragHandler;

    /**
     * allday view instance.
     * @type {Allday}
     */
    this.alldayView = alldayView;

    /**
     * Base controller instance.
     * @type {Base}
     */
    this.baseController = baseController;

    /**
     * Temporary variable for dragStart event data.
     * @type {object}
     */
    this._dragStart = null;

    dragHandler.on({
        dragStart: this._onDragStart
    }, this);

    /**
     * @type {AlldayResizeGuide}
     */
    this.guide = new AlldayResizeGuide(this);
}

/**
 * Destroy method
 */
AlldayResize.prototype.destroy = function() {
    this.guide.destroy();
    this.dragHandler.off(this);
    this.dragHandler = this.alldayView = this.baseController =
        this.guide = this._dragStart = null;
};

/**
 * Check dragstart target is expected conditions for this handler.
 * @param {HTMLElement} target - dragstart event handler's target element.
 * @returns {boolean|MonthWeek} return MonthWeek view instance when satiate condition.
 */
AlldayResize.prototype.checkExpectedCondition = function(target) {
    var cssClass = domutil.getClass(target),
        matches;

    if (!~cssClass.indexOf('schedule-view-allday-resize-handle')) {
        return false;
    }

    target = domutil.closest(target, '.schedule-view-allday-monthweek');

    if (!target) {
        return false;
    }

    cssClass = domutil.getClass(target);
    matches = cssClass.match(parseViewIDRx);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.alldayView.childs.items, matches[1]);
};

/**
 * DragStart event handler.
 * @emits AlldayResize#allday_resize_dragstart
 * @param {object} dragStartEventData - event data.
 */
AlldayResize.prototype._onDragStart = function(dragStartEventData) {
    var target = dragStartEventData.target,
        result = this.checkExpectedCondition(target),
        controller = this.baseController,
        eventBlockElement,
        modelID,
        targetModel,
        getEventDataFunc,
        eventData;

    if (!result) {
        return;
    }

    eventBlockElement = domutil.closest(target, '.schedule-view-allday-event-block');
    modelID = domutil.getData(eventBlockElement, 'id');
    targetModel = controller.events.items[modelID];

    if (!targetModel) {
        return;
    }

    getEventDataFunc = this.getEventDataFunc = this._retriveEventData(this.alldayView, dragStartEventData.originEvent);
    eventData = this._dragStart = getEventDataFunc(dragStartEventData.originEvent);

    util.extend(eventData, {
        eventBlockElement: eventBlockElement,
        model: targetModel
    });

    this.dragHandler.on({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    /**
     * @event AlldayResize#allday_resize_dragstart
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     * @property {Event} model - data object of model isntance.
     * @property {HTMLDivElement} eventBlockElement - target event block element.
     */
    this.fire('allday_resize_dragstart', eventData);
};

/**
 * Drag event handler method.
 * @emits AlldayResize#allday_resize_drag
 * @param {object} dragEventData - Drag#drag event handler eventdata.
 */
AlldayResize.prototype._onDrag = function(dragEventData) {
    var getEventDataFunc = this.getEventDataFunc;

    if (!getEventDataFunc) {
        return;
    }

    /**
     * @event AlldayResize#allday_resize_drag
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire('allday_resize_drag', getEventDataFunc(dragEventData.originEvent));
};

/**
 * Request update event instance to base controller.
 * @param {object} eventData - event data from AlldayResize handler.
 */
AlldayResize.prototype._updateEvent = function(eventData) {
    var ctrl = this.baseController,
        model = eventData.targetModel,
        dateOffset = eventData.xIndex - eventData.dragStartXIndex,
        newEnds = new Date(model.ends.getTime());

    newEnds = new Date(newEnds.setDate(newEnds.getDate() + dateOffset));
    newEnds = new Date(Math.max(datetime.end(model.starts).getTime(), newEnds.getTime()));

    ctrl.updateEvent(model.cid(), {
        ends: newEnds
    });
};

/**
 * DragEnd event hander method.
 * @emits AlldayResize#allday_resize_dragend
 * @param {object} dragEndEventData - Drag#DragEnd event handler data.
 * @param {string} [overrideEventName] - override emitted event name when supplied.
 * @param {?boolean} skipUpdate - true then skip update event model.
 */
AlldayResize.prototype._onDragEnd = function(dragEndEventData, overrideEventName, skipUpdate) {
    var getEventDataFunc = this.getEventDataFunc,
        dragStart = this._dragStart,
        eventData;

    if (!getEventDataFunc || !dragStart) {
        return;
    }

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    eventData = getEventDataFunc(dragEndEventData.originEvent);
    util.extend(eventData, {
        targetModel: dragStart.model
    });

    if (!skipUpdate) {
        this._updateEvent(eventData);
    }

    /**
     * @event AlldayResize#allday_resize_dragend
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this.fire(overrideEventName || 'allday_resize_dragend', eventData);

    this.getEventDataFunc = this._dragStart = null;
};

/**
 * Click event handler method.
 * @emits AlldayResize#allday_resize_click
 * @param {object} clickEventData - Drag#Click event handler data.
 */
AlldayResize.prototype._onClick = function(clickEventData) {
    /**
     * @event AlldayResize#allday_resize_click
     * @type {object}
     * @property {AlldayView} relatedView - allday view instance.
     * @property {number} datesInRange - date count of this view.
     * @property {number} dragStartXIndex - index number of dragstart grid index.
     * @property {number} xIndex - index number of mouse positions.
     */
    this._onDragEnd(clickEventData, 'allday_resize_click', true);
};

common.mixin(AlldayCore, AlldayResize);
util.CustomEvents.mixin(AlldayResize);

module.exports = AlldayResize;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/datetime":28,"../../common/domutil":31,"./core":54,"./resizeGuide":60}],60:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Resize Guide module.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = window.ne.util;
var domutil = require('../../common/domutil');
var datetime = require('../../common/datetime');
var reqAnimFrame = require('../../common/reqAnimFrame');


/**
 * @constructor
 * @param {AlldayResize} alldayResize - instance of AlldayResize
 */
function AlldayResizeGuide(alldayResize) {
    /**
     * @type {AlldayResize}
     */
    this.alldayResize = alldayResize;

    /**
     * 실제로 이벤트 엘리먼트를 담는 엘리먼트
     * @type {HTMLDIVElement}
     */
    this.eventContainer = null;

    /**
     * @type {function}
     */
    this.getEventDataFunc = null;

    /**
     * @type {HTMLDIVElement}
     */
    this.guideElement = null;

    alldayResize.on({
        'allday_resize_dragstart': this._onDragStart,
        'allday_resize_drag': this._onDrag,
        'allday_resize_dragend': this._clearGuideElement,
        'allday_resize_click': this._clearGuideElement
    }, this);
}

/**
 * Destroy method
 */
AlldayResizeGuide.prototype.destroy = function() {
    this._clearGuideElement();
    this.alldayResize.off(this);
    this.alldayResize = this.eventContainer = this.getEventDataFunc =
        this.guideElement = null;
};

/**
 * Clear guide element.
 */
AlldayResizeGuide.prototype._clearGuideElement = function() {
    domutil.remove(this.guideElement);

    if (!util.browser.msie) {
        domutil.removeClass(global.document.body, 'schedule-view-resizing-x');
    }

    this.getEventDataFunc = null;
};

/**
 * Refresh guide element
 * @param {number} newWidth - new width percentage value to resize guide element.
 */
AlldayResizeGuide.prototype.refreshGuideElement = function(newWidth) {
    var guideElement = this.guideElement;

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.width = newWidth + '%';
    });
};

/**
 * Return function that calculate guide element's new width percentage value.
 * @param {object} dragStartEventData - dragstart event data.
 * @returns {function} return function that calculate guide element new width percentage.
 */
AlldayResizeGuide.prototype.getGuideElementWidthFunc = function(dragStartEventData) {
    var model = dragStartEventData.model,
        viewOptions = this.alldayResize.alldayView.options,
        startDate = datetime.start(new Date(Math.max(model.starts.getTime(), datetime.parse(viewOptions.renderStartDate).getTime()))),
        endDate = datetime.end(new Date(Math.min(model.ends.getTime(), datetime.parse(viewOptions.renderEndDate).getTime()))),
        originLength = datetime.range(startDate, endDate, datetime.MILLISECONDS_PER_DAY).length,
        baseWidthPercent = 100 / dragStartEventData.datesInRange,
        dragStartIndex = dragStartEventData.xIndex;

    return function(xIndex) {
        var offset = xIndex - dragStartIndex,
            newLength = originLength + offset;

        newLength = Math.max(1, newLength);

        return newLength * baseWidthPercent;
    }
};

/**
 * DragStart event handler.
 * @param {object} dragStartEventData - event data.
 */
AlldayResizeGuide.prototype._onDragStart = function(dragStartEventData) {
    var alldayViewContainer = this.alldayResize.alldayView.container,
        guideElement = this.guideElement = dragStartEventData.eventBlockElement.cloneNode(true),
        eventContainer;

    if (!util.browser.msie) {
        domutil.addClass(global.document.body, 'schedule-view-resizing-x');
    }

    eventContainer = domutil.find('.schedule-view-monthweek-events', alldayViewContainer);
    domutil.addClass(guideElement, 'schedule-view-allday-move-guide');
    eventContainer.appendChild(guideElement);

    this.getEventDataFunc = this.getGuideElementWidthFunc(dragStartEventData);
};

/**
 * Drag event handler.
 * @param {object} dragEventData - event data.
 */
AlldayResizeGuide.prototype._onDrag = function(dragEventData) {
    var func = this.getEventDataFunc;

    if (!func) {
        return;
    }

    this.refreshGuideElement(func(dragEventData.xIndex));
};

module.exports = AlldayResizeGuide;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../../common/reqAnimFrame":34}],61:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Drag handler for calendar.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../common/domutil');
var domevent = require('../common/domevent');

/**
 * @constructor
 * @mixes CustomEvents
 * @param {object} options - options for drag handler
 * @param {number} [options.distance=10] - distance in pixels after mouse must move before dragging should start
 * @param {LayoutView} layoutView Layout view instance.
 */
function Drag(options, layoutView) {
    var container = layoutView.container;

    domevent.on(container, 'mousedown', this._onMouseDown, this);

    this.options = util.extend({
        distance: 10
    }, options);

    /**
     * @type {HTMLElement}
     */
    this.container = container;

    /**
     * @type {boolean}
     */
    this._isMoved = false;

    /**
     * dragging distance in pixel between mousedown and firing dragStart events
     * @type {number}
     */
    this._distance = 0;

    /**
     * @type {boolean}
     */
    this._dragStartFired = false;

    /**
     * @type {object}
     */
    this._dragStartEventData = null;
}

/**
 * Destroy method.
 */
Drag.prototype.destroy = function() {
    domevent.off(this.container, 'mousedown', this._onMouseDown, this);
    this._isMoved = null;
    this.container = null;
};

/**
 * Toggle events for mouse dragging.
 * @param {boolean} toBind - bind events related with dragging when supplied "true"
 */
Drag.prototype._toggleDragEvent = function(toBind) {
    var container = this.container,
        domMethod,
        method;

    if (toBind) {
        domMethod = 'on';
        method = 'disable';
    } else {
        domMethod = 'off';
        method = 'enable';
    }

    domutil[method + 'TextSelection'](container);
    domutil[method + 'ImageDrag'](container);
    domevent[domMethod](global, {
        mousemove: this._onMouseMove,
        mouseup: this._onMouseUp
    }, this);
};

/**
 * Normalize mouse event object.
 * @param {MouseEvent} mouseEvent - mouse event object.
 * @returns {object} normalized mouse event data.
 */
Drag.prototype._getEventData = function(mouseEvent) {
    return {
        target: mouseEvent.target || mouseEvent.srcElement,
        originEvent: mouseEvent
    };
};

/**
 * MouseDown DOM event handler.
 * @param {MouseEvent} mouseDownEvent MouseDown event object.
 */
Drag.prototype._onMouseDown = function(mouseDownEvent) {
    // only primary button can start drag.
    if (domevent.getMouseButton(mouseDownEvent) !== 0) {
        return;
    }

    this._distance = 0;
    this._dragStartFired = false;
    this._dragStartEventData = this._getEventData(mouseDownEvent);

    this._toggleDragEvent(true);
};

/**
 * MouseMove DOM event handler.
 * @emits Drag#drag
 * @emits Drag#dragStart
 * @param {MouseEvent} mouseMoveEvent MouseMove event object.
 */
Drag.prototype._onMouseMove = function(mouseMoveEvent) {
    var distance = this.options.distance;
    // prevent automatic scrolling.
    domevent.preventDefault(mouseMoveEvent);

    this._isMoved = true;

    if (this._distance < distance) {
        this._distance += 1;
        return;
    }

    if (!this._dragStartFired) {
        this._dragStartFired = true;

        /**
         * Drag starts events. cancelable.
         * @event Drag#dragStart
         * @type {object}
         * @property {HTMLElement} target - target element in this event.
         * @property {MouseEvent} originEvent - original mouse event object.
         */
        if (!this.invoke('dragStart', this._dragStartEventData)) {
            this._toggleDragEvent(false);
            return;
        }
    }

    /**
     * Events while dragging.
     * @event Drag#drag
     * @type {object}
     * @property {HTMLElement} target - target element in this event.
     * @property {MouseEvent} originEvent - original mouse event object.
     */
    this.fire('drag', this._getEventData(mouseMoveEvent));
};

/**
 * MouseUp DOM event handler.
 * @param {MouseEvent} mouseUpEvent MouseUp event object.
 * @emits Drag#dragEnd
 * @emits Drag#click
 */
Drag.prototype._onMouseUp = function(mouseUpEvent) {
    this._toggleDragEvent(false);

    // emit "click" event when not emitted drag event between mousedown and mouseup.
    if (this._isMoved) {
        this._isMoved = false;

        /**
         * Drag end events.
         * @event Drag#dragEnd
         * @type {MouseEvent}
         * @property {HTMLElement} target - target element in this event.
         * @property {MouseEvent} originEvent - original mouse event object.
         */
        this.fire('dragEnd', this._getEventData(mouseUpEvent));
        return;
    }

    /**
     * Click events.
     * @event Drag#click
     * @type {MouseEvent}
     * @property {HTMLElement} target - target element in this event.
     * @property {MouseEvent} originEvent - original mouse event object.
     */
    this.fire('click', this._getEventData(mouseUpEvent));
};

util.CustomEvents.mixin(Drag);

module.exports = Drag;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/domevent":30,"../common/domutil":31}],62:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Allday event click event hander module
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var TimeMove = require('./move');
var domutil = require('../../common/domutil');
var parseTimeViewIDRx = /^schedule-view-time-date[\s]schedule-view-(\d+)/;

/**
 * @constructor
 * @implements {Handler}
 * @mixes util.CustomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function TimeClick(dragHandler, timeGridView, baseController) {
    /**
     * @type {Drag}
     */
    this.dragHandler = dragHandler;

    /**
     * @type {TimeGrid}
     */
    this.timeGridView = timeGridView;

    /**
     * @type {Base}
     */
    this.baseController = baseController;

    dragHandler.on({
        'click': this._onClick
    }, this);
}

/**
 * Destroy method
 */
TimeClick.prototype.destroy = function() {
    this.dragHandler.off(this);
    this.timeGridView = this.baseController = this.dragHandler = null;
};

/**
 * Check target element is expected condition for activate this plugins.
 * @param {HTMLElement} target - The element to check
 * @returns {string} - model id
 */
TimeClick.prototype.checkExpectCondition = function(target) {
    var container,
        matches;

    if (!domutil.hasClass(target, 'schedule-view-time-event')) {
        return false;
    }

    container = domutil.closest(target, '.schedule-view-time-date');

    if (!container) {
        return false;
    }

    matches = domutil.getClass(container).match(parseTimeViewIDRx);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.timeGridView.childs.items, +matches[1]);
};

/**
 * Click event hander
 * @param {object} clickEvent - click event from {@link Drag}
 * @emits TimeClick#click
 */
TimeClick.prototype._onClick = function(clickEvent) {
    var target = clickEvent.target,
        timeView = this.checkExpectCondition(target),
        blockElement = domutil.closest(target, '.schedule-view-time-date-event-block'),
        eventCollection = this.baseController.events;

    if (!timeView || !blockElement) {
        return;
    }

    eventCollection.doWhenHas(domutil.getData(blockElement, 'id'), function(model) {
        /**
         * @events TimeClick#click
         * @type {object}
         * @property {Event} model - model instance
         */
        this.fire('click', {
            model:  model
        });
    }, this);
};

util.CustomEvents.mixin(TimeClick);

module.exports = TimeClick;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/domutil":31,"./move":66}],63:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Core methods for dragging actions
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var common = require('../../common/common');
var datetime = require('../../common/datetime');
var domevent = require('../../common/domevent');
var Point = require('../../common/point');

/**
 * @mixin Time.Core
 */
var timeCore = {
    /**
     * Get Y index ratio(hour) in time grids by supplied parameters.
     * @param {number} baseMil - base milliseconds number for supplied height.
     * @param {number} height - container element height.
     * @param {number} y - Y coordinate to calculate hour ratio.
     * @returns {number} hour index ratio value.
     */
    _calcGridYIndex: function(baseMil, height, y) {
        // get ratio from right expression > point.y : x = session.height : baseMil
        // and convert milliseconds value to hours.
        var result = datetime.millisecondsTo('hour', (y * baseMil) / height),
            floored = result | 0,
            nearest = common.nearest(result - floored, [0, 1]);

        return floored + (nearest ? 0.5 : 0);
    },

    /**
     * Get function to makes event data from Time and mouseEvent
     * @param {Time} timeView - Instance of time view.
     * @returns {function} - Function that return event data from mouse event.
     */
    _retriveEventData: function(timeView) {
        var container = timeView.container,
            options = timeView.options,
            viewHeight = timeView.getViewBound().height,
            viewTime = +timeView.getDate(),
            hourLength = options.hourEnd - options.hourStart,
            baseMil = datetime.millisecondsFrom('hour', hourLength);

        /**
         * @param {MouseEvent} mouseEvent - mouse event object to get common event data.
         * @param {object} [extend] - object to extend event data before return.
         * @returns {object} - common event data for time.*
         */
        return util.bind(function(mouseEvent, extend) {
            var mouseY = Point.n(domevent.getMousePosition(mouseEvent, container)).y,
                gridY = common.ratio(viewHeight, hourLength, mouseY),
                timeY = viewTime + datetime.millisecondsFrom('hour', gridY),
                nearestGridY = this._calcGridYIndex(baseMil, viewHeight, mouseY),
                nearestGridTimeY = viewTime + datetime.millisecondsFrom('hour', nearestGridY + options.hourStart);

            return util.extend({
                target: mouseEvent.target || mouseEvent.srcElement,
                relatedView: timeView,
                originEvent: mouseEvent,
                mouseY: mouseY,
                gridY: gridY,
                timeY: timeY,
                nearestGridY: nearestGridY,
                nearestGridTimeY: nearestGridTimeY
            }, extend);
        }, this);
    },

    /**
     * Mixin method.
     * @param {(TimeCreation|TimeMove)} obj - Constructor functions
     */
    mixin: function(obj) {
        var proto = obj.prototype;
        util.forEach(timeCore, function(method, methodName) {
            if (methodName === 'mixin') {
                return;
            }

            proto[methodName] = method;
        });
    }
};

module.exports = timeCore;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/datetime":28,"../../common/domevent":30,"../../common/point":33}],64:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Handling creation events from drag handler and time grid view
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var array = require('../../common/array');
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var TimeCreationGuide = require('./creationGuide');
var timeCore = require('./core');

var parseViewIDRx = /^schedule-view-time-date[\s]schedule-view-(\d+)/;

/**
 * @constructor
 * @implements {Handler}
 * @mixes timeCore
 * @mixes CustomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function TimeCreation(dragHandler, timeGridView, baseController) {
    /**
     * Drag handler instance.
     * @type {Drag}
     */
    this.dragHandler = null;

    /**
     * TimeGrid view instance.
     * @type {TimeGrid}
     */
    this.timeGridView = null;

    /**
     * Base controller instance.
     * @type {Base}
     */
    this.baseController = null;

    /**
     * @type {TimeCreationGuide}
     */
    this.guide = new TimeCreationGuide(this);

    /**
     * Temporary function for single drag session's calc.
     * @type {function}
     */
    this._getEventDataFunc = null;

    /**
     * Temporary function for drag start data cache.
     * @type {object}
     */
    this._dragStart = null;

    if (arguments.length) {
        this.connect.apply(this, arguments);
    }
}

/**
 * Destroy method
 */
TimeCreation.prototype.destroy = function() {
    this.guide.destroy();
    this.dragHandler.off(this);
    this.dragHandler = this.timeGridView = this.baseController =
        this._getEventDataFunc = this._dragStart = this.guide = null;
};

/**
 * Connect handler, view, controllers for event creations.
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
TimeCreation.prototype.connect = function(dragHandler, timeGridView, baseController) {
    this.dragHandler = dragHandler;
    this.timeGridView = timeGridView;
    this.baseController = baseController;

    dragHandler.on({
        dragStart: this._onDragStart
    }, this);
};

/**
 * Check target element is expected condition for activate this plugins.
 * @param {HTMLElement} target - The element to check
 * @returns {(boolean|Time)} - return Time view instance when satiate condition.
 */
TimeCreation.prototype.checkExpectedCondition = function(target) {
    var cssClass = domutil.getClass(target),
        matches;

    if (cssClass === 'schedule-view-time-date-event-block') {
        target = target.parentNode;
        cssClass = domutil.getClass(target);
    }

    matches = cssClass.match(parseViewIDRx);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.timeGridView.childs.items, matches[1]);
};

/**
 * Drag#dragStart event handler.
 * @emits TimeCreation#time_creation_dragstart
 * @param {object} dragStartEventData - Drag#dragStart event data.
 * @param {string} [overrideEventName] - override emitted event name when supplied.
 * @param {function} [revise] - supply function for revise event data before emit.
 */
TimeCreation.prototype._onDragStart = function(dragStartEventData, overrideEventName, revise) {
    var target = dragStartEventData.target,
        result = this.checkExpectedCondition(target),
        getEventDataFunc,
        eventData;

    if (!result) {
        return;
    }

    getEventDataFunc = this._getEventDataFunc = this._retriveEventData(result);
    eventData = this._dragStart = getEventDataFunc(dragStartEventData.originEvent);

    if (revise) {
        revise(eventData);
    }

    this.dragHandler.on({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    /**
     * @event TimeCreation#time_creation_dragstart
     * @type {object}
     * @property {Time} relatedView - time view instance related with mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     */
    this.fire(overrideEventName || 'time_creation_dragstart', eventData);
};

/**
 * Drag#drag event handler
 * @emits TimeCreation#time_creation_drag
 * @param {object} dragEventData - event data from Drag#drag.
 * @param {string} [overrideEventName] - override emitted event name when supplied.
 * @param {function} [revise] - supply function for revise event data before emit.
 */
TimeCreation.prototype._onDrag = function(dragEventData, overrideEventName, revise) {
    var getEventDataFunc = this._getEventDataFunc,
        eventData;

    if (!getEventDataFunc) {
        return;
    }

    eventData = getEventDataFunc(dragEventData.originEvent);

    if (revise) {
        revise(eventData);
    }

    /**
     * @event TimeCreation#time_creation_drag
     * @type {object}
     * @property {Time} relatedView - time view instance related with mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     */
    this.fire(overrideEventName || 'time_creation_drag', eventData);
};

/**
 * @param {object} eventData - event data object from TimeCreation#time_creation_dragend
 * or TimeCreation#time_creation_click
 */
TimeCreation.prototype._createEvent = function(eventData) {
    var title = window.prompt('Name of event to create:'),
        ctrl = this.baseController,
        relatedView = eventData.relatedView,
        createRange = eventData.createRange,
        nearestGridTimeY = eventData.nearestGridTimeY,
        baseDate,
        dateStart,
        dateEnd,
        newStarts,
        newEnds;

    this.guide.clearGuideElement();

    if (!title) {
        return;
    }

    if (!createRange) {
        createRange = [
            nearestGridTimeY,
            nearestGridTimeY + datetime.millisecondsFrom('minutes', 30)
        ];
    }

    baseDate = new Date(relatedView.getDate());
    dateStart = datetime.start(baseDate);
    dateEnd = datetime.end(baseDate);
    newStarts = Math.max(dateStart.getTime(), createRange[0]);
    newEnds = Math.min(dateEnd.getTime(), createRange[1]);

    ctrl.createEvent({
        title: title,
        isAllDay: false,
        starts: new Date(newStarts),
        ends: new Date(newEnds)
    });
};

/**
 * Drag#dragEnd event handler
 * @emits TimeCreation#time_creation_dragend
 * @param {object} dragEndEventData - event data from Drag#dragend
 */
TimeCreation.prototype._onDragEnd = function(dragEndEventData) {
    var dragStart = this._dragStart;

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    function reviseFunc(eventData) {
        var range = [
            dragStart.nearestGridTimeY,
            eventData.nearestGridTimeY
        ].sort(array.compare.num.asc);
        range[1] += datetime.millisecondsFrom('hour', 0.5);

        eventData.createRange = range;

        this._createEvent(eventData);
    }

    /**
     * @event TimeCreation#time_creation_dragend
     * @type {object}
     * @property {Time} relatedView - time view instance related with mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {number[]} createRange - milliseconds range between drag start and end to create.
     */
    this._onDrag(dragEndEventData, 'time_creation_dragend', util.bind(reviseFunc, this));

    this._dragStart = this._getEventDataFunc = null;
};

/**
 * Drag#click event handler
 * @emits TimeCreation#time_creation_click
 * @param {object} clickEventData - event data from Drag#click.
 */
TimeCreation.prototype._onClick = function(clickEventData) {
    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    function reviseFunc(eventData) {
        this._createEvent(eventData);
    }

    /**
     * @event TimeCreation#time_creation_click
     * @type {object}
     * @property {Time} relatedView - time view instance related with mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     */
    this._onDrag(clickEventData, 'time_creation_click', util.bind(reviseFunc, this));

    this._dragStart = this._getEventDataFunc = null;
};

timeCore.mixin(TimeCreation);
util.CustomEvents.mixin(TimeCreation);

module.exports = TimeCreation;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/array":24,"../../common/datetime":28,"../../common/domutil":31,"./core":63,"./creationGuide":65}],65:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Module for Time.Creation effect while dragging.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../../common/domutil');
var reqAnimFrame = require('../../common/reqAnimFrame');

var ratio = require('../../common/common').ratio;

/**
 * Class for Time.Creation dragging effect.
 * @constructor
 * @param {TimeCreation} timeCreation - instance of TimeCreation.
 */
function TimeCreationGuide(timeCreation) {
    /**
     * Guide element for creation effect.
     * @type {HTMLElement}
     */
    this.guideElement = global.document.createElement('div');

    /**
     * @type {TimeCreation}
     */
    this.timeCreation = timeCreation;

    /**
     * @type {number}
     */
    this._startGridY = 0;

    /**
     * @type {function}
     */
    this._getTopFunc = null;

    domutil.addClass(this.guideElement, 'schedule-view-time-creation-guide');

    timeCreation.on({
        'time_creation_dragstart': this._onDragStart,
        'time_creation_drag': this._onDrag,
        // 'time_creation_dragend': this.clearGuideElement,
        'time_creation_click': this.clearGuideElement
    }, this);
}

/**
 * Destroy method.
 */
TimeCreationGuide.prototype.destroy = function() {
    this.clearGuideElement();
    this.timeCreation.off(this);
    this.guideElement = this.timeCreation = this._startGridY =
        this._getTopFunc = null;
};

/**
 * Clear guide element.
 */
TimeCreationGuide.prototype.clearGuideElement = function() {
    var guideElement = this.guideElement;

    domutil.remove(guideElement);

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.display = 'none';
        guideElement.style.top = '';
        guideElement.style.height = '';
    });
};

/**
 * Refresh guide element
 * @param {number} top - The number of guide element's style top.
 * @param {number} height - The number of guide element's style height.
 */
TimeCreationGuide.prototype._refreshGuideElement = function(top, height) {
    var guideElement = this.guideElement;

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.top = top + 'px';
        guideElement.style.height = height + 'px';
        guideElement.style.display = 'block';
    });
};

/**
 * DragStart event handler
 * @param {object} dragStartEventData - dragStart event data.
 */
TimeCreationGuide.prototype._onDragStart = function(dragStartEventData) {
    var timeView = dragStartEventData.relatedView,
        viewOptions = timeView.options,
        viewHeight = timeView.getViewBound().height,
        hourLength = viewOptions.hourEnd - viewOptions.hourStart,
        getTopFunc;

    getTopFunc = this._getTopFunc = util.bind(function(indexY) {
        // memo
        if (getTopFunc[indexY]) {
            return getTopFunc[indexY];
        }

        getTopFunc[indexY] = ratio(hourLength, viewHeight, indexY);

        return getTopFunc[indexY];
    }, this);

    this._startGridY = getTopFunc(dragStartEventData.nearestGridY);

    this._refreshGuideElement(
        this._startGridY,
        getTopFunc(0.5)
    );

    timeView.container.appendChild(this.guideElement);
};

/**
 * Drag event handler
 * @param {object} dragEventData - drag event data.
 */
TimeCreationGuide.prototype._onDrag = function(dragEventData) {
    var getTopFunc = this._getTopFunc,
        startGridY = this._startGridY,
        endGridY;

    if (!getTopFunc) {
        return;
    }

    // drawing guide from start point to at least 30min points.
    endGridY = getTopFunc(dragEventData.nearestGridY) + getTopFunc(0.5);

    if (endGridY > startGridY) {
        this._refreshGuideElement(startGridY, endGridY - startGridY);
        return;
    }

    this._refreshGuideElement(
        endGridY - getTopFunc(0.5),
        (startGridY + getTopFunc(1)) - endGridY
    );
};

module.exports = TimeCreationGuide;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/domutil":31,"../../common/reqAnimFrame":34}],66:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Handling move events from drag handler and time grid view
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var timeCore = require('./core');
var TimeMoveGuide = require('./moveGuide');

var parseTimeViewIDRx = /^schedule-view-time-date[\s]schedule-view-(\d+)/;

/**
 * @constructor
 * @implements {Handler}
 * @mixes timeCore
 * @mixes util.CustomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function TimeMove(dragHandler, timeGridView, baseController) {
    /**
     * @type {Drag}
     */
    this.dragHandler = null;

    /**
     * @type {TimeGrid}
     */
    this.timeGridView = null;

    /**
     * @type {Base}
     */
    this.baseController = null;

    /**
     * @type {function}
     */
    this._getEventDataFunc = null;

    /**
     * @type {object}
     */
    this._dragStart = null;

    /**
     * @type {TimeMoveGuide}
     */
    this._guide = new TimeMoveGuide(this);

    if (arguments.length) {
        this.connect.apply(this, arguments);
    }
}

/**
 * Destroy method.
 */
TimeMove.prototype.destroy = function() {
    this._guide.destroy();
    this.dragHandler.off(this);
    this.dragHandler = this.timeGridView = this.baseController =
        this._getEventDataFunc = this._dragStart = this._guide = null;
};

/**
 * Connect handler, view, controllers for event creations.
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
TimeMove.prototype.connect = function(dragHandler, timeGridView, baseController) {
    this.dragHandler = dragHandler;
    this.timeGridView = timeGridView;
    this.baseController = baseController;

    dragHandler.on({
        dragStart: this._onDragStart
    }, this);
};

/**
 * Check target element is expected condition for activate this plugins.
 * @param {HTMLElement} target - The element to check
 * @returns {boolean|object} - return object when satiate condition.
 */
TimeMove.prototype.checkExpectCondition = function(target) {
    if (domutil.getClass(target) !== 'schedule-view-time-event') {
        return false;
    }

    return this._getTimeView(target);
};

/**
 * Get Time view container from supplied element.
 * @param {HTMLElement} target - element to find time view container.
 * @returns {object|boolean} - return time view instance when finded.
 */
TimeMove.prototype._getTimeView = function(target) {
    var container = domutil.closest(target, '.schedule-view-time-date'),
        matches;

    if (!container) {
        return false;
    }

    matches = domutil.getClass(container).match(parseTimeViewIDRx);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.timeGridView.childs.items, +matches[1]);
};

/**
 * @emits TimeMove#time_move_dragstart
 * @param {object} dragStartEventData - Drag#dragStart event data.
 */
TimeMove.prototype._onDragStart = function(dragStartEventData) {
    var target = dragStartEventData.target,
        timeView = this.checkExpectCondition(target),
        blockElement = domutil.closest(target, '.schedule-view-time-date-event-block'),
        getEventDataFunc,
        eventData;

    if (!timeView || !blockElement) {
        return;
    }

    getEventDataFunc = this._getEventDataFunc = this._retriveEventData(timeView);
    eventData = this._dragStart = getEventDataFunc(
        dragStartEventData.originEvent, {
            targetModelID: domutil.getData(blockElement, 'id')
        }
    );

    this.dragHandler.on({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    /**
     * @event TimeMove#time_move_dragstart
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {string} targetModelID - The model unique id emitted move event.
     */
    this.fire('time_move_dragstart', eventData);
};

/**
 * @emits TimeMove#time_move_drag
 * @param {MouseEvent} dragEventData - mousemove event object
 * @param {string} [overrideEventName] - name of emitting event to override.
 * @param {function} [revise] - supply function for revise event data before emit.
 */
TimeMove.prototype._onDrag = function(dragEventData, overrideEventName, revise) {
    var getEventDataFunc = this._getEventDataFunc,
        timeView = this._getTimeView(dragEventData.target),
        dragStart = this._dragStart,
        eventData;

    if (!timeView || !getEventDataFunc || !dragStart) {
        return;
    }

    eventData = getEventDataFunc(dragEventData.originEvent, {
        currentView: timeView,
        targetModelID: dragStart.targetModelID
    });

    if (revise) {
        revise(eventData);
    }

    /**
     * @event TimeMove#time_move_drag
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with drag start position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {Time} currentView - time view instance related with current mouse position.
     * @property {string} targetModelID - The model unique id emitted move event.
     */
    this.fire(overrideEventName || 'time_move_drag', eventData);
};

/**
 * Update model instance by dragend event results.
 * @param {object} eventData - event data from TimeMove#time_move_dragend
 */
TimeMove.prototype._updateEvent = function(eventData) {
    var ctrl = this.baseController,
        modelID = eventData.targetModelID,
        range = eventData.nearestRange,
        timeDiff = range[1] - range[0],
        dateDiff = 0,
        model = ctrl.events.items[modelID],
        relatedView = eventData.relatedView,
        currentView = eventData.currentView,
        eventDuration,
        dateStart,
        dateEnd,
        newStarts,
        newEnds,
        baseDate;

    if (!model || !currentView) {
        return;
    }

    timeDiff -= datetime.millisecondsFrom('minutes', 30);
    baseDate = new Date(relatedView.getDate());
    dateStart = datetime.start(baseDate);
    dateEnd = datetime.end(baseDate);
    newStarts = new Date(model.getStarts().getTime() + timeDiff);
    newEnds = new Date(model.getEnds().getTime() + timeDiff);
    eventDuration = model.duration();

    if (currentView) {
        dateDiff = currentView.getDate() - relatedView.getDate();
    }

    if (newStarts < dateStart) {
        newStarts = new Date(dateStart.getTime());
        newEnds = new Date(newStarts.getTime() + eventDuration.getTime());
    } else if (newEnds > dateEnd) {
        newEnds = new Date(dateEnd.getTime());
        newStarts = new Date(newEnds.getTime() - eventDuration.getTime());
    }

    newStarts = new Date(newStarts.getTime() + dateDiff);
    newEnds = new Date(newEnds.getTime() + dateDiff);

    ctrl.updateEvent(modelID, {
        starts: newStarts,
        ends: newEnds
    });
};

/**
 * @emits TimeMove#time_move_dragend
 * @param {MouseEvent} dragEndEventData - mouseup mouse event object.
 */
TimeMove.prototype._onDragEnd = function(dragEndEventData) {
    var getEventDataFunc = this._getEventDataFunc,
        currentView = this._getTimeView(dragEndEventData.target),
        dragStart = this._dragStart,
        eventData;

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    if (!getEventDataFunc || !dragStart) {
        return;
    }

    eventData = getEventDataFunc(dragEndEventData.originEvent, {
        currentView: currentView,
        targetModelID: dragStart.targetModelID
    });

    eventData.range = [
        dragStart.timeY,
        eventData.timeY + datetime.millisecondsFrom('hour', 0.5)
    ];

    eventData.nearestRange = [
        dragStart.nearestGridTimeY,
        eventData.nearestGridTimeY + datetime.millisecondsFrom('hour', 0.5)
    ];

    this._updateEvent(eventData);

    /**
     * @event TimeMove#time_move_dragend
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with drag start position.
     * @property {Time} currentView - time view instance related with current mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {string} targetModelID - The model unique id emitted move event.
     * @property {number[]} range - milliseconds range between drag start and end.
     * @property {number[]} nearestRange - milliseconds range related with nearestGridY between start and end.
     */
    this.fire('time_move_dragend', eventData);
};

/**
 * @emits TimeMove#time_move_click
 * @param {MouseEvent} clickEventData - click mouse event object.
 */
TimeMove.prototype._onClick = function(clickEventData) {
    var getEventDataFunc = this._getEventDataFunc,
        dragStart = this._dragStart,
        eventData;

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    if (!getEventDataFunc || !dragStart) {
        return;
    }

    eventData = getEventDataFunc(clickEventData.originEvent, {
        targetModelID: dragStart.targetModelID
    });

    /**
     * @event TimeMove#time_move_click
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with drag start position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {string} targetModelID - The model unique id emitted move event.
     */
    this.fire('time_move_click', eventData);
};

timeCore.mixin(TimeMove);
util.CustomEvents.mixin(TimeMove);

module.exports = TimeMove;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"./core":63,"./moveGuide":67}],67:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Module for Time.Move effect while dragging.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../../common/domutil');
var reqAnimFrame = require('../../common/reqAnimFrame');

var ratio = require('../../common/common').ratio;

/**
 * Class for Time.Move effect.
 * @constructor
 * @param {TimeMove} timeMove - The instance of TimeMove.
 */
function TimeMoveGuide(timeMove) {
    /**
     * @type {HTMLElement}
     */
    this.guideElement = null;

    /**
     * @type {TimeMove}
     */
    this.timeMove = timeMove;

    /**
     * @type {HTMLElement}
     */
    this._container = null;

    /**
     * @type {function}
     */
    this._getTopFunc = null;

    /**
     * @type {number}
     */
    this._startGridY = 0;

    /**
     * @type {number}
     */
    this._startTopPixel = 0;

    timeMove.on({
        'time_move_dragstart': this._onDragStart,
        'time_move_drag': this._onDrag,
        'time_move_dragend': this._clearGuideElement,
        'time_move_click': this._clearGuideElement
    }, this);
}

/**
 * Destroy method
 */
TimeMoveGuide.prototype.destroy = function() {
    this._clearGuideElement();
    this.timeMove.off(this);
    this.guideElement = this.timeMove = this._container =
        this._getTopFunc = this._startGridY = this._startTopPixel = null;
};

/**
 * Clear guide element.
 */
TimeMoveGuide.prototype._clearGuideElement = function() {
    var guideElement = this.guideElement;

    if (!util.browser.msie) {
        domutil.removeClass(global.document.body, 'schedule-view-dragging');
    }

    domutil.remove(guideElement);

    this.guideElement = this._getTopFunc =
        this._startGridY = this._startTopPixel = null;
};

/**
 * Refresh guide element
 * @param {string} top - guide element's style top.
 */
TimeMoveGuide.prototype._refreshGuideElement = function(top) {
    var guideElement = this.guideElement;

    if (!guideElement) {
        return;
    }

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.top = top + 'px';
        guideElement.style.display = 'block';
    });
};

/**
 * TimeMove#time_move_dragstart event handler
 * @param {object} dragStartEventData - dragstart event data
 */
TimeMoveGuide.prototype._onDragStart = function(dragStartEventData) {
    var guideElement = domutil.closest(
        dragStartEventData.target,
        '.schedule-view-time-date-event-block'
    );

    if (!guideElement) {
        return;
    }

    guideElement = guideElement.cloneNode(true);
    domutil.addClass(guideElement, 'schedule-view-time-move-guide');

    this._startTopPixel = parseFloat(guideElement.style.top);
    this._startGridY = dragStartEventData.nearestGridY;
    this.guideElement = guideElement;
    this._container = dragStartEventData.relatedView.container;
    this._container.appendChild(guideElement);
};

/**
 * TimeMove#time_move_drag event handler
 * @param {object} dragEventData - drag event data
 */
TimeMoveGuide.prototype._onDrag = function(dragEventData) {
    var timeView = dragEventData.currentView,
        viewOptions = timeView.options,
        viewHeight = timeView.getViewBound().height,
        guideHeight = parseFloat(this.guideElement.style.height),
        hourLength = viewOptions.hourEnd - viewOptions.hourStart,
        gridYOffset = dragEventData.nearestGridY - this._startGridY,
        // hourLength : viewHeight = gridYOffset : X;
        gridYOffsetPixel = ratio(hourLength, viewHeight, gridYOffset),
        bottomLimit,
        top;

    if (!util.browser.msie) {
        domutil.addClass(global.document.body, 'schedule-view-dragging');
    }

    if (this._container !== timeView.container) {
        this._container = timeView.container;
        this._container.appendChild(this.guideElement);
    }

    top = this._startTopPixel + gridYOffsetPixel;
    bottomLimit = viewHeight - guideHeight;

    top = Math.max(top, 0);
    top = Math.min(top, bottomLimit);

    this._refreshGuideElement(top);
};

module.exports = TimeMoveGuide;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/domutil":31,"../../common/reqAnimFrame":34}],68:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Handling resize events from drag handler and time grid view
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.ne.util;
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var timeCore = require('./core');
var TimeResizeGuide = require('./resizeGuide');

var parseTimeViewIDRx = /^schedule-view-time-date[\s]schedule-view-(\d+)/;

/**
 * @constructor
 * @implements {Handler}
 * @mixes timeCore
 * @mixes util.CustomEvents
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
function TimeResize(dragHandler, timeGridView, baseController) {
    /**
     * @type {Drag}
     */
    this.dragHandler = null;

    /**
     * @type {TimeGrid}
     */
    this.timeGridView = null;

    /**
     * @type {Base}
     */
    this.baseController = null;

    /**
     * @type {function}
     */
    this._getEventDataFunc = null;

    /**
     * @type {object}
     */
    this._dragStart = null;

    /**
     * @type {TimeResizeGuide}
     */
    this._guide = new TimeResizeGuide(this);

    if (arguments.length) {
        this.connect.apply(this, arguments);
    }
}

/**
 * Destroy method
 */
TimeResize.prototype.destroy = function() {
    this._guide.destroy();
    this.dragHandler.off(this);
    this.dragHandler = this.timeGridView = this.baseController =
        this._getEventDataFunc = this._dragStart = this._guide = null;
};

/**
 * Connect handler, view, controllers for event creations.
 * @param {Drag} [dragHandler] - Drag handler instance.
 * @param {TimeGrid} [timeGridView] - TimeGrid view instance.
 * @param {Base} [baseController] - Base controller instance.
 */
TimeResize.prototype.connect = function(dragHandler, timeGridView, baseController) {
    this.dragHandler = dragHandler;
    this.timeGridView = timeGridView;
    this.baseController = baseController;

    dragHandler.on({
        dragStart: this._onDragStart
    }, this);
};

/**
 * @param {HTMLElement} target - element to check condition.
 * @returns {object|boolean} - return time view instance or false
 */
TimeResize.prototype.checkExpectCondition = function(target) {
    var container,
        matches;

    if (!domutil.hasClass(target, 'schedule-view-time-resize-handle')) {
        return false;
    }

    container = domutil.closest(target, '.schedule-view-time-date');

    if (!container) {
        return false;
    }

    matches = domutil.getClass(container).match(parseTimeViewIDRx);

    if (!matches || matches.length < 2) {
        return false;
    }

    return util.pick(this.timeGridView.childs.items, +matches[1]);
};

/**
 * @emits TimeResize#time_resize_dragstart
 * @param {object} dragStartEventData - event data of Drag#dragstart
 */
TimeResize.prototype._onDragStart = function(dragStartEventData) {
    var target = dragStartEventData.target,
        timeView = this.checkExpectCondition(target),
        blockElement = domutil.closest(target, '.schedule-view-time-date-event-block'),
        getEventDataFunc,
        eventData;

    if (!timeView || !blockElement) {
        return;
    }

    getEventDataFunc = this._getEventDataFunc = this._retriveEventData(timeView);
    eventData = this._dragStart = getEventDataFunc(
        dragStartEventData.originEvent, {
            targetModelID: domutil.getData(blockElement, 'id')
        }
    );

    this.dragHandler.on({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    /**
     * @event TimeResize#time_resize_dragstart
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with mouse position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {string} targetModelID - The model unique id emitted move event.
     */
    this.fire('time_resize_dragstart', eventData);
};

/**
 * Drag#drag event handler
 * @emits TimeResize#time_resize_drag
 * @param {object} dragEventData - event data of Drag#drag custom event.
 * @param {string} [overrideEventName] - override emitted event name when supplied.
 * @param {function} [revise] - supply function for revise event data before emit.
 */
TimeResize.prototype._onDrag = function(dragEventData, overrideEventName, revise) {
    var getEventDataFunc = this._getEventDataFunc,
        startEventData = this._dragStart,
        eventData;

    if (!getEventDataFunc || !startEventData) {
        return;
    }

    eventData = getEventDataFunc(dragEventData.originEvent, {
        targetModelID: startEventData.targetModelID
    });

    if (revise) {
        revise(eventData);
    }

    /**
     * @event TimeResize#time_resize_drag
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with drag start position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {string} targetModelID - The model unique id emitted move event.
     */
    this.fire(overrideEventName || 'time_resize_drag', eventData);
};

/**
 * Update model instance by dragend event results.
 * @param {object} eventData - event data from TimeResize#time_resize_dragend
 */
TimeResize.prototype._updateEvent = function(eventData) {
    var ctrl = this.baseController,
        modelID = eventData.targetModelID,
        range = eventData.nearestRange,
        timeDiff = range[1] - range[0],
        model = ctrl.events.items[modelID],
        relatedView = eventData.relatedView,
        dateEnd,
        newEnds,
        baseDate;

    if (!model) {
        return;
    }

    timeDiff -= datetime.millisecondsFrom('minutes', 30);

    baseDate = new Date(relatedView.getDate());
    dateEnd = datetime.end(baseDate);
    newEnds = new Date(model.getEnds().getTime() + timeDiff);

    if (newEnds > dateEnd) {
        newEnds = new Date(dateEnd.getTime());
    }

    if (newEnds.getTime() - model.getStarts().getTime() < datetime.millisecondsFrom('minutes', 30)) {
        newEnds = new Date(model.getStarts().getTime() + datetime.millisecondsFrom('minutes', 30));
    }

    ctrl.updateEvent(modelID, {
        ends: newEnds
    });
};

/**
 * Drag#dragEnd event handler
 * @emits TimeResize#time_resize_dragend
 * @param {MouseEvent} dragEndEventData - Mouse event of Drag#dragEnd custom event.
 */
TimeResize.prototype._onDragEnd = function(dragEndEventData) {
    var getEventDataFunc = this._getEventDataFunc,
        dragStart = this._dragStart,
        eventData;

    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    if (!getEventDataFunc || !dragStart) {
        return;
    }

    eventData = getEventDataFunc(dragEndEventData.originEvent, {
        targetModelID: dragStart.targetModelID
    });

    eventData.range = [
        dragStart.timeY,
        eventData.timeY + datetime.millisecondsFrom('hour', 0.5)
    ];

    eventData.nearestRange = [
        dragStart.nearestGridTimeY,
        eventData.nearestGridTimeY + datetime.millisecondsFrom('hour', 0.5)
    ];

    this._updateEvent(eventData);

    /**
     * @event TimeResize#time_resize_dragend
     * @type {object}
     * @property {HTMLElement} target - current target in mouse event object.
     * @property {Time} relatedView - time view instance related with drag start position.
     * @property {MouseEvent} originEvent - mouse event object.
     * @property {number} mouseY - mouse Y px mouse event.
     * @property {number} gridY - grid Y index value related with mouseY value.
     * @property {number} timeY - milliseconds value of mouseY points.
     * @property {number} nearestGridY - nearest grid index related with mouseY value.
     * @property {number} nearestGridTimeY - time value for nearestGridY.
     * @property {string} targetModelID - The model unique id emitted move event.
     * @property {number[]} range - milliseconds range between drag start and end.
     * @property {number[]} nearestRange - milliseconds range related with nearestGridY between start and end.
     */
    this.fire('time_resize_dragend', eventData);

    this._getEventDataFunc = this._dragStart = null;
};

/**
 * @emits TimeResize#time_resize_click
 */
TimeResize.prototype._onClick = function() {
    this.dragHandler.off({
        drag: this._onDrag,
        dragEnd: this._onDragEnd,
        click: this._onClick
    }, this);

    /**
     * @event TimeResize#time_resize_click
     */
    this.fire('time_resize_click');
};

timeCore.mixin(TimeResize);
util.CustomEvents.mixin(TimeResize);

module.exports = TimeResize;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"./core":63,"./resizeGuide":69}],69:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Module for Time.Resize effect while dragging.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';
var util = global.ne.util;
var domutil = require('../../common/domutil');
var reqAnimFrame = require('../../common/reqAnimFrame');

var ratio = require('../../common/common').ratio;

/**
 * Class for Time.Resize effect.
 * @constructor
 * @param {TimeResize} timeResize - the instance of TimeResize handler.
 */
function TimeResizeGuide(timeResize) {
    /**
     * @type {HTMLElement}
     */
    this.guideElement = null;

    /**
     * @type {TimeResize}
     */
    this.timeResize = timeResize;

    /**
     * @type {function}
     */
    this._getTopFunc = null;

    /**
     * @type {HTMLElement}
     */
    this._originEventElement = null;

    /**
     * @type {number}
     */
    this._startTopPixel = 0;

    /**
     * @type {number}
     */
    this._startHeightPixel = 0;

    /**
     * @type {number}
     */
    this._startGridY = 0;

    timeResize.on({
        'time_resize_dragstart': this._onDragStart,
        'time_resize_drag': this._onDrag,
        'time_resize_dragend': this._clearGuideElement,
        'time_resize_click': this._clearGuideElement
    }, this);
}

/**
 * Destroy method
 */
TimeResizeGuide.prototype.destroy = function() {
    this._clearGuideElement();
    this.timeResize.off(this);
    this.guideElement = this.timeResize = this._getTopFunc =
        this._originEventElement = this._startHeightPixel =
        this._startGridY = this._startTopPixel = null;
};

/**
 * Clear guide element.
 */
TimeResizeGuide.prototype._clearGuideElement = function() {
    var guideElement = this.guideElement,
        originElement = this._originEventElement;

    if (!util.browser.msie) {
        domutil.removeClass(global.document.body, 'schedule-view-resizing');
    }

    if (originElement) {
        originElement.style.display = 'block';
    }

    domutil.remove(guideElement);

    this.guideElement = this._getTopFunc = this._originEventElement =
        this._startHeightPixel = this._startGridY = this._startTopPixel = null;
};

/**
 * Refresh guide element
 * @param {string} height - guide element's style height.
 */
TimeResizeGuide.prototype._refreshGuideElement = function(height) {
    var guideElement = this.guideElement;

    if (!guideElement) {
        return;
    }

    reqAnimFrame.requestAnimFrame(function() {
        guideElement.style.height = height + 'px';
        guideElement.style.display = 'block';
    });
};


/**
 * TimeMove#time_move_dragstart event handler
 * @param {object} dragStartEventData - dragstart event data
 */
TimeResizeGuide.prototype._onDragStart = function(dragStartEventData) {
    var originElement = domutil.closest(
            dragStartEventData.target,
            '.schedule-view-time-date-event-block'
        ),
        guideElement;

    if (!util.browser.msie) {
        domutil.addClass(global.document.body, 'schedule-view-resizing');
    }

    if (!originElement) {
        return;
    }

    this._startGridY = dragStartEventData.nearestGridY;
    this._startHeightPixel = parseFloat(originElement.style.height);
    this._startTopPixel = parseFloat(originElement.style.top);

    this._originEventElement = originElement;
    guideElement = this.guideElement = originElement.cloneNode(true);
    domutil.addClass(guideElement, 'schedule-view-time-resize-guide');

    originElement.style.display = 'none';
    dragStartEventData.relatedView.container.appendChild(guideElement);
};

/**
 * @param {object} dragEventData - event data from Drag#drag.
 */
TimeResizeGuide.prototype._onDrag = function(dragEventData) {
    var timeView = dragEventData.relatedView,
        viewOptions = timeView.options,
        viewHeight = timeView.getViewBound().height,
        hourLength = viewOptions.hourEnd - viewOptions.hourStart,
        guideElement = this.guideElement,
        guideTop = parseFloat(guideElement.style.top),
        gridYOffset = dragEventData.nearestGridY - this._startGridY,
        // hourLength : viewHeight = gridYOffset : X;
        gridYOffsetPixel = ratio(hourLength, viewHeight, gridYOffset),
        minHeight,
        maxHeight,
        height;

    height = (this._startHeightPixel + gridYOffsetPixel);
    // at least large than 30min from event start time.
    minHeight = guideTop + ratio(hourLength, viewHeight, 0.5);
    minHeight -= this._startTopPixel;
    // smaller than 24h
    maxHeight = viewHeight - guideTop;

    height = Math.max(height, minHeight);
    height = Math.min(height, maxHeight);

    this._refreshGuideElement(height);
};

module.exports = TimeResizeGuide;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/common":27,"../../common/domutil":31,"../../common/reqAnimFrame":34}],70:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Model of event.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../common/datetime');
var dirty = require('../common/dirty');
var model = require('../common/model');

/**
 * The model of calendar events.
 * @constructor
 * @mixes dirty
 * @mixes model
 */
function Event() {
    /**
     * `Optional` unique id for various use.
     * @type {string}
     */
    this.id = '';

    /**
     * title for event.
     * @type {string}
     */
    this.title = '';

    /**
     * is event is all day event?
     * @type {boolean}
     */
    this.isAllDay = false;

    /**
     * event starts
     * @type {Date}
     */
    this.starts = null;

    /**
     * event ends
     * @type {Date}
     */
    this.ends = null;

    /**
     * event text color
     * @type {string}
     */
    this.color = '#000';

    /**
     * event background color
     * @type {string}
     */
    this.bgColor = '#a1b56c';

    // initialize model id
    util.stamp(this);
}

/**********
 * static props
 **********/

Event.schema = {
    required: ['title'],
    dateRange: ['starts', 'ends']
};

/**
 * create event model from json(object) data.
 * @param {object} data object for model.
 * @returns {Event} Event model instance.
 */
Event.create = function(data) {
    var inst = new Event();
    inst.init(data);

    return inst;
};

/**********
 * prototype props
 **********/

/**
 * Initialize event instance.
 * @param {object} options options.
 */
Event.prototype.init = function(options) {
    options = options || {};

    this.id = options.id || '';
    this.title = options.title || '';
    this.isAllDay = util.isExisty(options.isAllDay) ? options.isAllDay : false;

    if (options.starts) {
        this.starts = new Date(options.starts);
    } else {
        this.starts = new Date();
    }

    if (options.ends) {
        this.ends = new Date(options.ends);
    } else {
        this.ends = new Date(this.starts.getTime());
        this.ends.setMinutes(this.ends.getMinutes() + 30);
    }

    this.color = options.color || this.color;
    this.bgColor = options.bgColor || this.bgColor;
};

/**
 * @returns {Date} render start date.
 */
Event.prototype.getStarts = function() {
    return this.starts;
};

/**
 * @returns {Date} render end date.
 */
Event.prototype.getEnds = function() {
    return this.ends;
};

/**
 * @returns {number} instance unique id.
 */
Event.prototype.cid = function() {
    return util.stamp(this);
};

/**
 * Check two event are equals (means title, isAllDay, starts, ends are same)
 * @param {Event} event Event model instance to compare.
 * @returns {boolean} Return false when not same.
 */
Event.prototype.equals = function(event) {
    if (this.id !== event.id) {
        return false;
    }

    if (this.title !== event.title) {
        return false;
    }

    if (this.isAllDay !== event.isAllDay) {
        return false;
    }

    if (datetime.compare(this.getStarts(), event.getStarts()) !== 0) {
        return false;
    }

    if (datetime.compare(this.getEnds(), event.getEnds()) !== 0) {
        return false;
    }

    if (this.color !== event.color) {
        return false;
    }

    if (this.bgColor !== event.bgColor) {
        return false;
    }

    return true;
};

/**
 * return duration between starts and ends.
 * @returns {Date} duration (UTC)
 */
Event.prototype.duration = function() {
    var starts = this.getStarts(),
        ends = this.getEnds(),
        duration;

    if (this.isAllDay) {
        duration = new Date(datetime.end(ends) - datetime.start(starts));
    } else {
        duration = new Date(ends - starts);
    }

    return duration;
};

/**
 * Returns true if the given Event coincides with the same time as the
 * calling Event.
 * @param {Event} event The other event to compare with this Event.
 * @returns {boolean} If the other event occurs within the same time as the first object.
 */
Event.prototype.collidesWith = function(event) {
    var ownStarts = this.getStarts(),
        ownEnds = this.getEnds(),
        starts = event.getStarts(),
        ends = event.getEnds();

    if ((starts > ownStarts && starts < ownEnds) ||
        (ends > ownStarts && ends < ownEnds) ||
        (starts <= ownStarts && ends >= ownEnds)) {
        return true;
    }
    return false;
};

model.mixin(Event.prototype);
dirty.mixin(Event.prototype);

module.exports = Event;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/datetime":28,"../common/dirty":29,"../common/model":32}],71:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Model for views
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;

/**
 * Event ViewModel
 * @constructor
 * @param {Event} event Event instance.
 */
function EventViewModel(event) {
    /**
     * The model of event.
     * @type {Event}
     */
    this.model = event;

    /**
     * @type {number}
     */
    this.top = 0;

    /**
     * @type {number}
     */
    this.left = 0;

    /**
     * @type {number}
     */
    this.width = 0;

    /**
     * @type {number}
     */
    this.height = 0;

    /**
     * Represent event has collide with other events when rendering.
     * @type {boolean}
     */
    this.hasCollide = false;

    /**
     * Extra space at rigth side of this event.
     * @type {number}
     */
    this.extraSpace = 0;

    /**
     * represent this event block is not visible after rendered.
     *
     * in month view, some viewmodel in date need to hide when already rendered before dates.
     *
     * set true then it just shows empty space.
     * @type {boolean}
     */
    this.hidden = false;

    /**
     * represent render start date used at rendering.
     *
     * if set null then use model's 'starts' property.
     * @type {Date}
     */
    this.renderStarts = null;

    /**
     * represent render end date used at rendering.
     *
     * if set null then use model's 'ends' property.
     * @type {Date}
     */
    this.renderEnds = null;
}

/**********
 * static props
 **********/

/**
 * EventViewModel factory method.
 * @param {Event} event Event instance.
 * @returns {EventViewModel} EventViewModel instance.
 */
EventViewModel.create = function(event) {
    return new EventViewModel(event);
};


/**********
 * prototype props
 **********/

/**
 * return renderStarts property to render properly when specific event that exceed rendering date range.
 *
 * if renderStarts is not set. return model's starts property.
 * @override
 * @returns {Date} render start date.
 */
EventViewModel.prototype.getStarts = function() {
    if (this.renderStarts) {
        return this.renderStarts;
    }

    return this.model.starts;
};

/**
 * return renderStarts property to render properly when specific event that exceed rendering date range.
 *
 * if renderEnds is not set. return model's ends property.
 * @override
 * @returns {Date} render end date.
 */
EventViewModel.prototype.getEnds = function() {
    if (this.renderEnds) {
        return this.renderEnds;
    }

    return this.model.ends;
};

/**
 * @returns {number} unique number for model.
 */
EventViewModel.prototype.cid = function() {
    return util.stamp(this.model);
};

/**
 * Shadowing valueOf method for event sorting.
 * @returns {Event} The model of event.
 */
EventViewModel.prototype.valueOf = function() {
    return this.model;
};

/**
 * Link duration method
 * @returns {number} Event#duration result.
 */
EventViewModel.prototype.duration = function() {
    return this.model.duration();
};

/**
 * Link collidesWith method
 * @param {Event|EventViewModel} viewModel - Model or viewmodel instance of Events.
 * @returns {boolean} Event#collidesWith result.
 */
EventViewModel.prototype.collidesWith = function(viewModel) {
    return this.model.collidesWith(viewModel.valueOf());
};

module.exports = EventViewModel;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],72:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Layout view. wrap all view containers at outside.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../common/domutil');
var Collection = require('../common/collection');
var View = require('./view');

/**
 * Layout view for toggle each child view. It will controlled via navigation UI.
 * @constructor
 * @extends {View}
 * @param {HTMLElement} container Container element to use layout view.
 */
function Layout(container) {
    /*eslint-disable*/
    /**
     * @type {Collection} Child view collection.
     */
    this.childs = new Collection(function(childView) {
        return childView.viewName;
    });
    /*eslint-enable*/

    domutil.addClass(container, 'schedule-view-layout');

    /**
     * @type {HTMLElement}
     */
    this.container = container;
}

util.inherit(Layout, View);

/**
 * Clear child views.
 */
Layout.prototype.clear = function() {
    this.childs.each(function(childView) {
        childView.destroy();
    });

    this.childs.clear();
    this.container.innerHTML = '';
};

/**
 * Add an view object by creation function **(adderFunc)**.
 *
 * Invocations of adderFunc is called with layout view's container.
 *
 * As result of adderFunc. added it to layout view's childs.
 * @override
 * @param {function} adderFunc The adder function.
 * @returns {View} View instance added.
 */
Layout.prototype.addChild = function(adderFunc) {
    var childView = adderFunc(this.container);
    this.childs.add(childView);
    return childView;
};

/**
 * Remove child view.
 * @override
 * @param {(string|View)} viewName - name of view or instance.
 */
Layout.prototype.removeChild = function(viewName) {
    this.childs.remove(viewName);
};

/**
 * Toggle child views.
 * @param {string} viewName - Name of view.
 */
Layout.prototype.toggleChildView = function(viewName) {
    var container,
        prefix = ['add', 'remove'],
        flag;

    this.childs.each(function(childView) {
        container = childView.container;
        flag = +(childView.viewName === viewName);
        domutil[prefix[flag] + 'Class'](container, 'schedule-view-hidden');
    });
};

module.exports = Layout;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/collection":26,"../common/domutil":31,"./view":82}],73:[function(require,module,exports){
(function (global){
/**
 * @fileoverview View of week event container inside of Week view.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../common/domutil');
var datetime = require('../common/datetime');
var View = require('./view');
var tmpl = require('./template/monthweek.hbs');

/**
 * @constructor
 * @extends {View}
 * @param {object} options - view options.
 * @param {number} [options.containerHeight=40] - minimum height of event container element.
 * @param {number} [options.containerButtonGutter=8] - free space at bottom to make create easy.
 * @param {number} [options.eventHeight=18] - height of each event block.
 * @param {number} [options.eventGutter=2] - gutter height of each event block.
 * @param {function} [options._getViewModelFunc] - function for extract partial view model data from whole view models.
 * @param {HTMLDIVElement} container - DOM element to use container for this view.
 */
function MonthWeek(options, container) {
    container = domutil.appendHTMLElement(
        'div',
        container,
        'schedule-view-allday-monthweek'
    );

    /**
     * @type {object}
     */
    options = this.options = util.extend({
        containerHeight: 40,
        containerBottomGutter: 8,
        eventHeight: 18,
        eventGutter: 2
    }, options);

    options.minHeight = options.containerHeight + options.containerBottomGutter;

    View.call(this, null, container);
}

util.inherit(MonthWeek, View);

/**
 * @param {object} viewModel - viewModel from parent views.
 * @returns {object} viewModel to rendering.
 */
MonthWeek.prototype._getBaseViewModel = function(viewModel) {
    var options = this.options,
        range = datetime.range(
            viewModel.renderStartDate,
            viewModel.renderEndDate,
            datetime.MILLISECONDS_PER_DAY
        ),
        matrices = options._getViewModelFunc(viewModel),
        widthPercent = 100 / range.length;

    return {
        width: widthPercent,
        height: options.containerHeight,
        eventBlockHeight: options.eventHeight + options.eventGutter,
        eventBlockGutter: options.eventGutter,
        eventGrid: util.map(range, function() {
            return widthPercent;
        }),
        matrices: matrices
    };
};

/**
 * @override
 * @param {object} viewModel - viewModel from parent views.
 */
MonthWeek.prototype.render = function(viewModel) {
    var baseViewModel = this._getBaseViewModel(viewModel),
        maxEventInDay = 0;

    maxEventInDay = Math.max.apply(null, util.map(baseViewModel.matrices, function(matrix) {
        return Math.max.apply(null, util.map(matrix, function(row) {
            return row.length;
        }));
    }));

    this.resize(maxEventInDay);

    this.container.innerHTML = tmpl(baseViewModel);
};

/**
 * Resize MonthWeek container and send information to parent views.
 * @override
 * @param {number} maxEventInDay - how largest event block in one day?
 */
MonthWeek.prototype.resize = function(maxEventInDay) {
    var options = this.options,
        newHeight = (maxEventInDay * (options.eventHeight + options.eventGutter)) + options.containerBottomGutter;

    newHeight = Math.max(newHeight, options.minHeight);
    
    this.container.style.height = newHeight + 'px';
};

module.exports = MonthWeek;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/datetime":28,"../common/domutil":31,"./template/monthweek.hbs":76,"./view":82}],74:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<div class=\"schedule-view-display-table\">\n    <div class=\"schedule-view-display-table-row\">\n        <div class=\"schedule-view-display-table-cell\">\n            <div class=\"schedule-view-scroll-y schedule-view-dayname-layout\"></div>\n        </div>\n    </div>\n    <div class=\"schedule-view-display-table-row\">\n        <div class=\"schedule-view-display-table-cell\">\n            <div class=\"schedule-view-scroll-y schedule-view-allday-layout\"></div>\n        </div>\n    </div>\n    <div class=\"schedule-view-display-table-row\">\n        <div class=\"schedule-view-display-table-cell schedule-view-timegrid-layout\"></div>\n    </div>\n</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],75:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Helpers for handlebar templates.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;

function getElSize(value, postfix, prefix) {
    prefix = prefix || '';
    if (util.isNumber(value)) {
        return prefix + ':' + value + postfix;
    }

    return prefix + ':auto';
}

module.exports = {
    'stamp': function(obj) {
        return util.stamp(obj);
    },

    'equal': function(a, b) {
        return a === b;
    },

    'or': function(a, b) {
        return a || b;
    },

    'fi': function(a, oper, b, options) {
        switch (oper) {
            case '==':
                return (a == b) ? options.fn(this) : options.inverse(this);
            case '===':
                return  (a === b) ? options.fn(this) : options.inverse(this);
            default:
                break;
        }
    },

    'common-width': function(width) {
        return getElSize(width, '%', 'width');
    },

    /**
     * Use in time.hbs
     * @param {EventViewModel} eventViewModel viewModel
     * @returns {string} element size css class
     */
    'time-eventBlock': function(eventViewModel) {
        var top = getElSize(eventViewModel.top, 'px', 'top'),
            left = getElSize(eventViewModel.left, '%', 'left'),
            width = getElSize(eventViewModel.width, '%', 'width'),
            height = getElSize(eventViewModel.height, 'px', 'height');

        return [top, left, width, height].join(';');
    },

    /**
     * Use in dayname.hbs
     * @returns {string} css class
     */
    'dayname-isHolliday': function() {
        if (this.day === 0 || this.day === 6) {
            return 'schedule-view-dayname schedule-holliday';
        }

        return 'schedule-view-dayname';
    },

    'multiply': function(a, b) {
        return a * b;
    },

    /**
     * 셀렉트박스 헬퍼
     * @param {string} name - 셀렉트박스 name 속성값
     * @param {{value: string, label: string}} list - 옵션 리스트
     * @param {string} selectedValue - 기본선택처리 원하는 값
     * @returns {string} html tag
     */
    'selectbox': function(name, list, selectedValue) {
        var html = '<select name="' + name + '">';

        util.forEach(list, function(data) {
            html += '<option value="' + data.value + '"' + (selectedValue === data.value ? ' selected' : '') + '>' + data.label + '</option>';
        });

        return html + '</select>';
    },

    'radioCalendarColor': function(name, list, checkedValue) {
        return util.map(list, function(data) {
            return '<label>' + 
                '<input type="radio" name="' + name + '" value="' + data.value + '"' + 
                (data.value === checkedValue ? ' checked' : '') + ' />' + 
                '<span style="background-color:#' + data.value + '">&nbsp;</span>' +
                '</label>';
        }).join('');
    }
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],76:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var alias1=container.escapeExpression;

  return "<div class=\"schedule-view-monthweek-grid-line\" style=\"width:"
    + alias1(container.lambda(depth0, depth0))
    + "%;left:"
    + alias1((helpers.multiply || (depth0 && depth0.multiply) || helpers.helperMissing).call(depth0 != null ? depth0 : {},depth0,(data && data.index),{"name":"multiply","hash":{},"data":data}))
    + "%;\">&nbsp;</div>\n";
},"3":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},depth0,{"name":"each","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"4":function(container,depth0,helpers,partials,data) {
    var stack1;

  return " \n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},depth0,{"name":"each","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"5":function(container,depth0,helpers,partials,data) {
    var stack1;

  return " \n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},depth0,{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"6":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3=container.escapeExpression, alias4=container.lambda;

  return " \n<div data-id=\""
    + alias3((helpers.stamp || (depth0 && depth0.stamp) || alias2).call(alias1,(depth0 != null ? depth0.model : depth0),{"name":"stamp","hash":{},"data":data}))
    + "\" \n    class=\"schedule-view-allday-event-block "
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.renderStarts : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.renderEnds : depth0),{"name":"if","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\"\n    style=\"top:"
    + alias3((helpers.multiply || (depth0 && depth0.multiply) || alias2).call(alias1,(depth0 != null ? depth0.top : depth0),((stack1 = (data && data.root)) && stack1.eventBlockHeight),{"name":"multiply","hash":{},"data":data}))
    + "px;left:"
    + alias3((helpers.multiply || (depth0 && depth0.multiply) || alias2).call(alias1,(depth0 != null ? depth0.left : depth0),((stack1 = (data && data.root)) && stack1.width),{"name":"multiply","hash":{},"data":data}))
    + "%;width:"
    + alias3((helpers.multiply || (depth0 && depth0.multiply) || alias2).call(alias1,(depth0 != null ? depth0.width : depth0),((stack1 = (data && data.root)) && stack1.width),{"name":"multiply","hash":{},"data":data}))
    + "%;height:"
    + alias3(alias4(((stack1 = (data && data.root)) && stack1.eventBlockHeight), depth0))
    + "px;margin-top:"
    + alias3(alias4(((stack1 = (data && data.root)) && stack1.eventBlockGutter), depth0))
    + "px\">\n    <div class=\"schedule-view-allday-event\" style=\"height:"
    + alias3(alias4(((stack1 = (data && data.root)) && stack1.eventHeight), depth0))
    + "px;background-color:"
    + alias3(alias4(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.bgColor : stack1), depth0))
    + "\">\n        <span class=\"schedule-view-allday-event-title\" style=\"color:"
    + alias3(alias4(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.color : stack1), depth0))
    + "\">"
    + alias3(alias4(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.title : stack1), depth0))
    + "</span>\n        <span class=\"schedule-view-allday-resize-handle handle-y\">&nbsp;</span>\n    </div> \n</div>\n";
},"7":function(container,depth0,helpers,partials,data) {
    return " schedule-view-allday-exceed-left";
},"9":function(container,depth0,helpers,partials,data) {
    return " schedule-view-allday-exceed-right";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {};

  return "<div class=\"schedule-view-monthweek-grid\">\n"
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.eventGrid : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</div>\n<div class=\"schedule-view-monthweek-events\">\n"
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.matrices : depth0),{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],77:[function(require,module,exports){
(function (global){
/**
 * @fileoverview Register developed custom handlebars helper.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var helper = require('./helper');
var Handlebars = require('hbsfy/runtime');

util.forEach(helper, function(helper, name) {
    Handlebars.registerHelper(name, helper);
}, this);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./helper":75,"hbsfy/runtime":22}],78:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var helper;

  return "<div class=\"schedule-view-allday-left\">\n    <span>"
    + container.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"title","hash":{},"data":data}) : helper)))
    + "</span>\n</div>\n<div class=\"schedule-view-allday-right\">\n    <div class=\"schedule-view-allday-monthweek-container\"></div>\n</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],79:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<div class=\""
    + alias4(((helper = (helper = helpers["dayname-isHolliday"] || (depth0 != null ? depth0["dayname-isHolliday"] : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"dayname-isHolliday","hash":{},"data":data}) : helper)))
    + "\" style=\""
    + alias4((helpers["common-width"] || (depth0 && depth0["common-width"]) || alias2).call(alias1,(depth0 != null ? depth0.width : depth0),{"name":"common-width","hash":{},"data":data}))
    + "\">\n    <div class=\"schedule-view-dayname-label\">"
    + alias4(((helper = (helper = helpers.dayName || (depth0 != null ? depth0.dayName : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"dayName","hash":{},"data":data}) : helper)))
    + "</div>\n    <div class=\"schedule-view-dayname-date\">"
    + alias4(((helper = (helper = helpers.date || (depth0 != null ? depth0.date : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"date","hash":{},"data":data}) : helper)))
    + "</div>\n</div>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},depth0,{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"useData":true});

},{"hbsfy/runtime":22}],80:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},depth0,{"name":"each","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"2":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},depth0,{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"3":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},depth0,{"name":"if","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n";
},"4":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3=container.escapeExpression, alias4=container.lambda;

  return "            <div class=\"schedule-view-time-date-event-block\" data-id=\""
    + alias3((helpers.stamp || (depth0 && depth0.stamp) || alias2).call(alias1,(depth0 != null ? depth0.model : depth0),{"name":"stamp","hash":{},"data":data}))
    + "\" style=\""
    + alias3((helpers["time-eventBlock"] || (depth0 && depth0["time-eventBlock"]) || alias2).call(alias1,depth0,{"name":"time-eventBlock","hash":{},"data":data}))
    + "\">\n                <div class=\"schedule-view-time-event\" style=\"color:"
    + alias3(alias4(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.color : stack1), depth0))
    + ";background-color:"
    + alias3(alias4(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.bgColor : stack1), depth0))
    + "\">"
    + alias3(alias4(((stack1 = (depth0 != null ? depth0.model : depth0)) != null ? stack1.title : stack1), depth0))
    + "</div>\n                <div class=\"schedule-view-time-resize-handle handle-x\">&nbsp;</div>\n            </div>";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.matrices : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"useData":true});

},{"hbsfy/runtime":22}],81:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<li class=\"schedule-view-timegrid-hour-"
    + alias4(((helper = (helper = helpers.hour || (depth0 != null ? depth0.hour : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"hour","hash":{},"data":data}) : helper)))
    + "\"><span>"
    + alias4(((helper = (helper = helpers.hour || (depth0 != null ? depth0.hour : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"hour","hash":{},"data":data}) : helper)))
    + "</span></li>";
},"3":function(container,depth0,helpers,partials,data) {
    return "<div class=\"schedule-view-timegrid-grid\"></div>";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {};

  return "<div class=\"schedule-view-timegrid\">\n    <ul class=\"schedule-view-timegrid-left\">\n        "
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.hours : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n    </ul>\n    <div class=\"schedule-view-timegrid-right\">\n        "
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.hours : depth0),{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n    </div>\n    <div class=\"schedule-view-timegrid-events\">\n        <div class=\"schedule-view-timegrid-events-container\"></div>\n    </div>\n    <div class=\"schedule-view-timegrid-hourmarker\" style=\"display:none;\">\n        <div class=\"schedule-view-timegrid-hourmarker-wrap\">\n            <div class=\"schedule-view-timegrid-hourmarker-line\"></div>\n            <div class=\"schedule-view-timegrid-hourmarker-time\">00:00</div>\n            <div class=\"schedule-view-timegrid-todaymarker\">today</div>\n        </div>\n    </div>\n</div>\n";
},"useData":true});

},{"hbsfy/runtime":22}],82:[function(require,module,exports){
(function (global){
/**
 * @fileoverview The base class of views.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../common/domutil');
var Collection = require('../common/collection');

/**
 * Base class of views.
 *
 * All views create own container element inside supplied container element.
 * @constructor
 * @param {options} options The object for describe view's specs.
 * @param {HTMLElement} container Default container element for view. you can use this element for this.container syntax.
 */
function View(options, container) {
    var id = util.stamp(this);

    options = options || {};

    if (util.isUndefined(container)) {
        container = domutil.appendHTMLElement('div');
    }

    domutil.addClass(container, 'schedule-view-' + id);

    /**
     * unique id
     * @type {number}
     */
    this.id = id;

    /**
     * base element of view.
     * @type {HTMLDIVElement}
     */
    this.container = container;

    /*eslint-disable*/
    /**
     * child views.
     * @type {Collection}
     */
    this.childs = new Collection(function(view) {
        return util.stamp(view);
    });
    /*eslint-enable*/

    /**
     * parent view instance.
     * @type {View}
     */
    this.parent = null;
}

/**
 * Add child views.
 * @param {View} view The view instance to add.
 * @param {function} [fn] Function for invoke before add. parent view class is supplied first arguments.
 */
View.prototype.addChild = function(view, fn) {
    if (fn) {
        fn.call(view, this);
    }
    // add parent view
    view.parent = this;

    this.childs.add(view);
};

/**
 * Remove added child view.
 * @param {(number|View)} id View id or instance itself to remove.
 * @param {function} [fn] Function for invoke before remove. parent view class is supplied first arguments.
 */
View.prototype.removeChild = function(id, fn) {
    var view = util.isNumber(id) ? this.childs.items[id] : id;

    id = util.stamp(view);

    if (fn) {
        fn.call(view, this);
    }

    this.childs.remove(id);
};

/**
 * Render view recursively.
 */
View.prototype.render = function() {
    this.childs.each(function(childView) {
        childView.render();
    });
};

/**
 * Invoke function recursively.
 * @param {function} fn - function to invoke child view recursively
 * @param {boolean} [skipThis=false] - set true then skip invoke with this(root) view.
 */
View.prototype.recursive = function(fn, skipThis) {
    if (!util.isFunction(fn)) {
        return;
    }

    if (!skipThis) {
        fn(this);
    }

    this.childs.each(function(childView) {
        childView.recursive(fn);
    });
};

/**
 * Resize view recursively to parent.
 */
View.prototype.resize = function() {
    var args = Array.prototype.slice.call(arguments),
        parent = this.parent;

    while (parent) {
        if (util.isFunction(parent._onResize)) {
            parent._onResize.apply(parent, args);
        }

        parent = parent.parent;
    }
};

/**
 * Invoking method before destroying.
 */
View.prototype._beforeDestroy = function() {};

/**
 * Clear properties
 */
View.prototype._destroy = function() {
    this._beforeDestroy();
    this.childs.clear();
    this.container.innerHTML = '';

    this.id = this.parent = this.childs = this.container = null;
};

/*eslint-disable*/
/**
 * Destroy child view recursively.
 */
View.prototype.destroy = function(isChildView) {
    this.childs.each(function(childView) {
        childView.destroy(true);
        childView._destroy();
    });

    if (isChildView) {
        return;
    }

    this._destroy();
};
/*eslint-enable*/

/**
 * Calculate view's container element bound.
 * @returns {object} The bound of container element.
 */
View.prototype.getViewBound = function() {
    var container = this.container,
        position = domutil.getPosition(container),
        size = domutil.getSize(container);

    return {
        x: position[0],
        y: position[1],
        width: size[0],
        height: size[1]
    };
};

module.exports = View;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common/collection":26,"../common/domutil":31}],83:[function(require,module,exports){
(function (global){
/**
 * @fileoverview View of allday event container inside of Week view.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../../common/domutil');
var View = require('../view');
var MonthWeek = require('../monthweek');
var mainTmpl = require('../template/week/allday.hbs');

/**
 * @constructor
 * @extends {View}
 * @param {object} options The object for view customization.
 * @param {string} options.renderStartDate - start date of allday view's render date. YYYY-MM-DD
 * @param {string} options.renderEndDate - end date of allday view's render date. YYYY-MM-DD
 * @param {number} [options.height=60] - minimum height of event container element.
 * @param {number} [options.eventBlockHeight=18] - height of each event block.
 * @param {number} [options.eventBlockGutter=2] - gutter height of each event block.
 * @param {function} [options._getViewModelFunc] - function for extract partial view model data from whole view models.
 * @param {HTMLElement} container Container element.
 */
function Allday(options, container) {
    container = domutil.appendHTMLElement(
        'div',
        container,
        'schedule-view-allday-container'
    );

    /**
     * rendering options.
     * @type {object}
     */
    this.options = util.extend({
        title: '종일일정',
        renderStartDate: '',
        renderEndDate: '',
        containerHeight: 40,
        containerBottomGutter: 8,
        eventHeight: 18,
        eventGutter: 2,
        _getViewModelFunc: function(viewModel) {
            return viewModel.eventsInDateRange.allday;
        }
    }, options);

    View.call(this, null, container);
}

util.inherit(Allday, View);

/**
 * create month week view model for render allday events in top of week views.
 * @override
 * @param {object} viewModel - viewModel from parent views.
 */
Allday.prototype.render = function(viewModel) {
    var container = this.container,
        monthWeekInst;

    container.innerHTML = mainTmpl(this.options);

    this.childs.clear();

    monthWeekInst = new MonthWeek(
        this.options, 
        domutil.find('.schedule-view-allday-monthweek-container', container)
    );

    this.addChild(monthWeekInst);

    this.childs.each(function(childView) {
        childView.render(viewModel);
    });
};

module.exports = Allday;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/domutil":31,"../monthweek":73,"../template/week/allday.hbs":78,"../view":82}],84:[function(require,module,exports){
(function (global){
/**
 * @fileoverview View for rendering daynames
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var View = require('../view');
var daynameTmpl = require('../template/week/daynames.hbs');

/**
 * @constructor
 * @paran {object} options - options for dayname view
 * @param {HTMLElement} container Container element to use.
 * @extends {View}
 */
function DayName(options, container) {
    container = domutil.appendHTMLElement(
        'div',
        container,
        'schedule-view-dayname-container'
    );

    this.options = util.extend({
        daynames: ['일', '월', '화', '수', '목', '금', '토']
    }, options);

    View.call(this, null, container);
}

util.inherit(DayName, View);

/**
 * Get default viewmodels.
 * @param {Date} start The date of start render
 * @param {Date} end The end of end render
 * @returns {array} viewmodel.
 */
DayName.prototype._getBaseViewModel = function(start, end) {
    var daynames = this.options.daynames,
        viewModel;

    viewModel = util.map(datetime.range(
        datetime.start(start),
        datetime.start(end),
        datetime.MILLISECONDS_PER_DAY
    ), function(d, i, arr) {
        var day = d.getDay();

        return {
            day: day,
            dayName: daynames[day],
            date: d.getDate(),
            width: 100 / arr.length
        };
    });

    return viewModel;
};

/**
 * @override
 * @param {object} viewModel View model from parent (WeekView)
 */
DayName.prototype.render = function(viewModel) {
    var _viewModel = this._getBaseViewModel(
        viewModel.renderStartDate,
        viewModel.renderEndDate
    );

    this.container.innerHTML = daynameTmpl(_viewModel);
};

module.exports = DayName;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../template/week/daynames.hbs":79,"../view":82}],85:[function(require,module,exports){
(function (global){
/**
 * @fileoverview View of time.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var datetime = require('../../common/datetime');
var domutil = require('../../common/domutil');
var View = require('../view');
var timeTmpl = require('../template/week/time.hbs');
var forEachArr = util.forEachArray;

/**
 * @constructor
 * @extends {View}
 * @param {number} width Date element width (percent)
 * @param {object} options Options
 * @param {string} options.ymd YYYMMDD string for this view
 * @param {boolean} options.isToday when set true then assign today design class to container.
 * @param {number} options.hourStart Can limit of render hour start.
 * @param {number} options.hourEnd Can limit of render hour end.
 * @param {HTMLElement} container Element to use container for this view.
 */
function Time(width, options, container) {
    View.call(this, null, container);

    container.style.width = width + '%';

    this.options = util.extend({
        ymd: '',
        isToday: false,
        hourStart: 0,
        hourEnd: 24
    }, options);

    if (this.options.isToday) {
        domutil.addClass(this.container, 'schedule-view-time-date-today');
    }
}

util.inherit(Time, View);

/**
 * Convert YYYYMMDD formatted string date to Date.
 * @param {string} str formatted string.
 * @returns {Date} start of date.
 */
Time.prototype._parseDateGroup = function(str) {
    var y = parseInt(str.substr(0, 4), 10),
        m = parseInt(str.substr(4, 2), 10),
        d = parseInt(str.substr(6, 2), 10);

    return new Date(y, m - 1, d);
};

/**
 * @param {EventViewModel} viewModel - view model instance to calculate bound.
 * @param {object} options - options for calculating event element's bound.
 * @param {Date} options.todayStart - date object represent event date's start (00:00:00)
 * @param {number} options.baseMS - the number of milliseconds to render event blocks.
 * @param {number} options.baseHeight - pixel value related with baseMS options.
 * @param {number[]} options.baseLeft - left position percents for each columns.
 * @param {number} options.baseWidth - the unit of event blocks width percent.
 * @param {number} options.columnIndex - the number index of event blocks.
 * it represent rendering index from left sides in view.
 * @returns {object} bound object for supplied view model.
 */
Time.prototype.getEventViewBound = function(viewModel, options) {
    var baseMS = options.baseMS,
        baseHeight = options.baseHeight,
        offsetStart,
        width,
        height,
        top;

    offsetStart = viewModel.valueOf().starts - options.todayStart;

    // containerHeight : milliseconds in day = x : event's milliseconds
    top = (baseHeight * offsetStart) / baseMS;
    height = (baseHeight * viewModel.duration()) / baseMS;
    width = options.baseWidth * (viewModel.extraSpace + 1);

    // set width auto when has no collisions.
    if (!viewModel.hasCollide) {
        width = null;
    }

    return {
        top: top,
        left: options.baseLeft[options.columnIndex],
        width: width,
        height: height
    };
};

/**
 * Set viewmodels for rendering.
 * @param {string} ymd The date of events. YYYYMMDD format.
 * @param {array} matrices The matrices for event placing.
 */
Time.prototype._getBaseViewModel = function(ymd, matrices) {
    var options = this.options,
        hourStart = options.hourStart,
        hourEnd = options.hourEnd,
        containerHeight,
        todayStart,
        baseMS;

    /**
     * Calculate each event element bounds relative with rendered hour milliseconds and
     * wrap each event model to viewmodels.
     */
    containerHeight = this.getViewBound().height;
    todayStart = this._parseDateGroup(ymd);
    todayStart.setHours(hourStart);
    baseMS = datetime.millisecondsFrom('hour', (hourEnd - hourStart));

    forEachArr(matrices, function(matrix) {
        var maxRowLength,
            widthPercent,
            leftPercents,
            i;

        maxRowLength = Math.max.apply(null, util.map(matrix, function(row) {
            return row.length;
        }));

        widthPercent = 100 / maxRowLength;

        leftPercents = [];
        for (i = 0; i < maxRowLength; i += 1) {
            leftPercents[i] = widthPercent * i;
        }

        forEachArr(matrix, function(row) {
            forEachArr(row, function(viewModel, col) {
                var viewBound;

                if (!viewModel) {
                    return;
                }

                viewBound = this.getEventViewBound(viewModel, {
                    todayStart: todayStart,
                    baseMS: baseMS,
                    baseLeft: leftPercents,
                    baseWidth: widthPercent,
                    baseHeight: containerHeight,
                    columnIndex: col
                });

                util.extend(viewModel, viewBound);
            }, this);
        }, this);
    }, this);
};

/**
 * @returns {Date} - Date of this view.
 */
Time.prototype.getDate = function() {
    return this._parseDateGroup(this.options.ymd);
};


/**
 * @override
 * @param {string} ymd The date of events. YYYYMMDD format
 * @param {array} matrices Matrices for placing events
 */
Time.prototype.render = function(ymd, matrices) {
    this._getBaseViewModel(ymd, matrices);
    this.container.innerHTML = timeTmpl({
        matrices: matrices
    });
};

module.exports = Time;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../template/week/time.hbs":80,"../view":82}],86:[function(require,module,exports){
(function (global){
/**
 * @fileoverview View for rendered events by times.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../../common/domutil');
var datetime = require('../../common/datetime');
var reqAnimFrame = require('../../common/reqAnimFrame');
var View = require('../view');
var Time = require('./time');
var AutoScroll = require('../../common/autoScroll');
var mainTmpl = require('../template/week/timeGrid.hbs');

var PIXEL_RENDER_ERROR = 0.5;
var HOURMARKER_REFRESH_INTERVAL = 1000 * 10;
var INITIAL_AUTOSCROLL_DELAY = util.browser.msie ? 100 : 50;

/**
 * @constructor
 * @extends {View}
 * @param {object} options The object for view customization.
 * @param {number} [options.hourStart=0] You can change view's start hours.
 * @param {number} [options.hourEnd=0] You can change view's end hours.
 * @param {HTMLElement} container Container element.
 */
function TimeGrid(options, container) {
    container = domutil.appendHTMLElement(
        'div',
        container,
        'schedule-view-timegrid-container'
    );

    View.call(this, null, container);

    if (!util.browser.safari) {
        /**
         * @type {AutoScroll}
         */
        this._autoScroll = new AutoScroll(container);
    }

    /**
     * Time view options.
     * @type {object}
     */
    this.options = util.extend({
        hourStart: 0,
        hourEnd: 24
    }, options);

    /**
     * Interval id for hourmarker animation.
     * @type {number}
     */
    this.intervalID = 0;

    /**
     * @type {boolean}
     */
    this._scrolled = false;

    this.attachEvent();
}

util.inherit(TimeGrid, View);

/**********
 * Prototype props
 **********/

/**
 * @type {string}
 */
TimeGrid.prototype.viewName = 'timegrid';

/**
 * Destroy view.
 * @override
 */
TimeGrid.prototype._beforeDestroy = function() {
    window.clearInterval(this.intervalID);

    if (this._autoScroll) {
        this._autoScroll.destroy();
    }

    this._autoScroll = this.hourmarker = null;
};

/**
 * Get base viewModel.
 * @returns {object} ViewModel
 */
TimeGrid.prototype._getBaseViewModel = function() {
    var options = this.options,
        end = options.hourEnd,
        i = options.hourStart,
        hours = [];

    for (; i < end; i += 1) {
        hours.push({hour: i});
    }

    return {hours: hours};
};

/**
 * Reconcilation child views and render.
 * @param {object} viewModels Viewmodel
 * @param {number} width The width percent of each time view.
 * @param {HTMLElement} container Container element for each time view.
 */
TimeGrid.prototype._renderChilds = function(viewModels, width, container) {
    var options = this.options,
        childOption,
        child,
        isToday,
        today = datetime.format(new Date(), 'YYYYMMDD');

    // clear contents
    container.innerHTML = '';
    this.childs.clear();
    this.todaymarkerLeft = null;

    // reconcilation of child views
    util.forEach(viewModels, function(events, ymd) {
        isToday = ymd === today;

        if (isToday) {
            this.todaymarkerLeft = width * this.childs.length;
        }

        childOption = {
            ymd: ymd,
            isToday: isToday,
            hourStart: options.hourStart,
            hourEnd: options.hourEnd
        };

        child = new Time(
            width,
            childOption,
            domutil.appendHTMLElement('div', container, 'schedule-view-time-date')
        );
        child.render(ymd, events);

        this.addChild(child);
    }, this);
};

/**
 * @override
 * @param {object} viewModel ViewModel list from Week view.
 */
TimeGrid.prototype.render = function(viewModel) {
    var timeViewModel = viewModel.eventsInDateRange.time,
        container = this.container,
        baseViewModel = this._getBaseViewModel(),
        eventLen = util.keys(timeViewModel).length;

    if (!eventLen) {
        return;
    }

    container.innerHTML = mainTmpl(baseViewModel);

    /**********
     * Render childs
     **********/
    this._renderChilds(
        timeViewModel,
        100 / eventLen,
        domutil.find('.schedule-view-timegrid-events-container', container)
    );

    this._hourLabels = domutil.find('ul', container);

    /**********
     * Render hourmarker
     **********/
    this.hourmarker = domutil.find('.schedule-view-timegrid-hourmarker', container);
    this.refreshHourmarker();

    if (!this._scrolled) {
        this._scrolled = true;
        this.scrollToNow();
    }
};

/**
 * Refresh hourmarker element.
 */
TimeGrid.prototype.refreshHourmarker = function() {
    var hourLabels = this._hourLabels,
        hourmarker = this.hourmarker,

        viewModel = this._getHourmarkerViewModel(),
        todaymarkerLeft = this.todaymarkerLeft,
        todaymarker,
        text,
        labelToVisible,
        labelToInvisible;

    if (!hourmarker || !viewModel) {
        return;
    }

    todaymarker = domutil.find('.schedule-view-timegrid-todaymarker', hourmarker);
    text = domutil.find('.schedule-view-timegrid-hourmarker-time', hourmarker);
    labelToVisible = domutil.find('.schedule-invisible', hourLabels);
    labelToInvisible = domutil.find('.schedule-view-timegrid-hour-' + viewModel.hour, hourLabels);

    reqAnimFrame.requestAnimFrame(function() {
        if (labelToVisible !== labelToInvisible) {
            if (labelToVisible) {
                domutil.removeClass(labelToVisible, 'schedule-invisible');
            }

            if (labelToInvisible) {
                domutil.addClass(labelToInvisible, 'schedule-invisible');
            }
        }

        hourmarker.style.display = 'block';
        hourmarker.style.top = (viewModel.top - PIXEL_RENDER_ERROR) + 'px';

        if (!util.isNull(todaymarkerLeft)) {
            todaymarker.style.display = 'block';
            todaymarker.style.left = todaymarkerLeft + '%';
        } else {
            todaymarker.style.display = 'none';
        }

        text.innerHTML = viewModel.text;
    });
};

/**
 * Return grid size.
 * @returns {number[]} The size of grid element.
 */
TimeGrid.prototype._getGridSize = function() {
    var childNode = this.container.childNodes[0];

    if (!childNode) {
        return false;
    }

    return domutil.getSize(childNode);
};

/**
 * @param {Date} [time] - date object to convert pixel in grids.
 * use **Date.now()** when not supplied.
 * @returns {number} The pixel value represent current time in grids.
 */
TimeGrid.prototype._getTopByTime = function(time) {
    var now = util.isDate(time) ? new Date(time.getTime()) : new Date(),
        start = datetime.start(now),
        hourStart = this.options.hourStart,
        gridSize = this._getGridSize(),
        offset,
        top;

    if (!gridSize) {
        return 0;
    }

    offset = +now - +start;
    if (hourStart) {
        offset -= datetime.millisecondsFrom('hour', hourStart);
    }

    top = (offset * gridSize[1]) / (datetime.millisecondsFrom('hour', this._getBaseViewModel().hours.length));

    return top;
};

/**
 * Get Hourmarker viewmodel.
 * @returns {object} ViewModel of hourmarker.
 */
TimeGrid.prototype._getHourmarkerViewModel = function() {
    var now = new Date();

    return {
        top: this._getTopByTime(),
        hour: now.getHours(),
        text: datetime.format(now, 'HH:mm')
    };
};

/**
 * Attach events
 */
TimeGrid.prototype.attachEvent = function() {
    window.clearInterval(this.intervalID);
    this.intervalID = window.setInterval(util.bind(this.onTick, this), HOURMARKER_REFRESH_INTERVAL);
};

/**
 * Scroll time grid to current hourmarker.
 */
TimeGrid.prototype.scrollToNow = function() {
    var currentHourTop = this._getTopByTime(),
        viewBound = this.getViewBound(),
        container = this.container;

    window.setTimeout(function() {
        container.scrollTop = (0, currentHourTop - (viewBound.height / 2));
    }, INITIAL_AUTOSCROLL_DELAY);
};

/**********
 * Event handlers
 **********/

/**
 * Interval tick handler
 */
TimeGrid.prototype.onTick = function() {
    this.refreshHourmarker();
};

module.exports = TimeGrid;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/autoScroll":25,"../../common/datetime":28,"../../common/domutil":31,"../../common/reqAnimFrame":34,"../template/week/timeGrid.hbs":81,"../view":82,"./time":85}],87:[function(require,module,exports){
(function (global){
/**
 * @fileoverview View of days UI.
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var util = global.ne.util;
var domutil = require('../../common/domutil');
var datetime = require('../../common/datetime');
var View = require('../view');

/**
 * @constructor
 * @param {Base.Week} controller The controller mixin part.
 * @param {object} options View options
 * @param {string} [options.renderStartDate] Start date of render. if not supplied then use -3d from today. YYYY-MM-DD format.
 * @param {string} [options.renderEndDate] End date of render. if not supplied then use +3d from today. YYYY-MM-DD format.
 * @param {HTMLElement} container The element to use container for this view.
 * @extends {View}
 */
function Week(controller, options, container) {
    var range;

    container = domutil.appendHTMLElement(
        'div',
        container,
        'schedule-view-week-container'
    );

    View.call(this, null, container);

    range = this._getRenderDateRange(new Date());

    /**
     * @type {object} Options for view.
     */
    this.options = util.extend({
        renderStartDate: datetime.format(range.start, 'YYYY-MM-DD'),
        renderEndDate: datetime.format(range.end, 'YYYY-MM-DD')
    }, options);

    /**
     * Week controller mixin.
     * @type {Base.Week}
     */
    this.controller = controller;
}

util.inherit(Week, View);

/**********
 * Override props
 **********/

/**
 * Render each child view with events in ranges.
 * @override
 */
Week.prototype.render = function() {
    var options = this.options,
        renderStartDate = datetime.parse(options.renderStartDate),
        renderEndDate = datetime.parse(options.renderEndDate),
        eventsInDateRange = this.controller.findByDateRange(
            datetime.start(renderStartDate),
            datetime.end(renderEndDate)
        ),
        viewModel = {
            eventsInDateRange: eventsInDateRange,
            renderStartDate: renderStartDate,
            renderEndDate: renderEndDate
        };

    this.childs.each(function(childView) {
        childView.render(viewModel);
    });
};

/**********
 * Prototype props
 **********/

Week.prototype.viewName = 'week';

/**
 * Calculate default render date range from supplied date.
 * @param {Date} baseDate base date.
 * @returns {object} date range.
 */
Week.prototype._getRenderDateRange = function(baseDate) {
    var base = datetime.start(baseDate),
        start = new Date(+base),
        end = new Date(+base);

    start.setDate(start.getDate() - 3);
    end.setDate(end.getDate() + 3);

    return {
        start: start,
        end: end
    };
};

module.exports = Week;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../common/datetime":28,"../../common/domutil":31,"../view":82}]},{},[1])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb2RlLXNuaXBwZXQvY29kZS1zbmlwcGV0LmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvbGliL2hhbmRsZWJhcnMucnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvZGVjb3JhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvZGVjb3JhdG9ycy9saWIvaGFuZGxlYmFycy9kZWNvcmF0b3JzL2lubGluZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvZXhjZXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9oZWxwZXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvYmxvY2staGVscGVyLW1pc3NpbmcuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2hlbHBlcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy9lYWNoLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9oZWxwZXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvaGVscGVyLW1pc3NpbmcuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2hlbHBlcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy9pZi5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvaGVscGVycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2xvZy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvaGVscGVycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2xvb2t1cC5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvaGVscGVycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL3dpdGguanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2xvZ2dlci5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvbm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9uby1jb25mbGljdC5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvc2FmZS1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9oYnNmeS9ydW50aW1lLmpzIiwic3JjL2pzL2NvbW1vbi9hamF4LmpzIiwic3JjL2pzL2NvbW1vbi9hcnJheS5qcyIsInNyYy9qcy9jb21tb24vYXV0b1Njcm9sbC5qcyIsInNyYy9qcy9jb21tb24vY29sbGVjdGlvbi5qcyIsInNyYy9qcy9jb21tb24vY29tbW9uLmpzIiwic3JjL2pzL2NvbW1vbi9kYXRldGltZS5qcyIsInNyYy9qcy9jb21tb24vZGlydHkuanMiLCJzcmMvanMvY29tbW9uL2RvbWV2ZW50LmpzIiwic3JjL2pzL2NvbW1vbi9kb211dGlsLmpzIiwic3JjL2pzL2NvbW1vbi9tb2RlbC5qcyIsInNyYy9qcy9jb21tb24vcG9pbnQuanMiLCJzcmMvanMvY29tbW9uL3JlcUFuaW1GcmFtZS5qcyIsInNyYy9qcy9jb250cm9sbGVyL2Jhc2UuanMiLCJzcmMvanMvY29udHJvbGxlci92aWV3TWl4aW4vd2Vlay5qcyIsInNyYy9qcy9kb29yYXkvY29udHJvbGxlci9iYXNlLmpzIiwic3JjL2pzL2Rvb3JheS9mYWN0b3J5L2NhbGVuZGFyLmpzIiwic3JjL2pzL2Rvb3JheS9mYWN0b3J5L3dlZWtWaWV3LmpzIiwic3JjL2pzL2Rvb3JheS9oYW5kbGVyL21pbGVzdG9uZUNsaWNrLmpzIiwic3JjL2pzL2Rvb3JheS9oYW5kbGVyL3Rhc2tDbGljay5qcyIsInNyYy9qcy9kb29yYXkvbW9kZWwvZXZlbnQuanMiLCJzcmMvanMvZG9vcmF5L3ZpZXcvbWlsZXN0b25lLmhicyIsInNyYy9qcy9kb29yYXkvdmlldy9taWxlc3RvbmUuanMiLCJzcmMvanMvZG9vcmF5L3ZpZXcvbWluaWNhbGVuZGFyLmhicyIsInNyYy9qcy9kb29yYXkvdmlldy9taW5pY2FsZW5kYXIuanMiLCJzcmMvanMvZG9vcmF5L3ZpZXcvdGFza3ZpZXcuaGJzIiwic3JjL2pzL2Rvb3JheS92aWV3L3Rhc2t2aWV3LmpzIiwic3JjL2pzL2Rvb3JheS92aWV3L3RlbXBsYXRlL2ZhY3Rvcnkvd2Vla1ZpZXcuaGJzIiwic3JjL2pzL2ZhY3RvcnkvY2FsZW5kYXIuanMiLCJzcmMvanMvZmFjdG9yeS9jb250cm9sbGVyLmpzIiwic3JjL2pzL2ZhY3Rvcnkvd2Vla1ZpZXcuanMiLCJzcmMvanMvaGFuZGxlci9hbGxkYXkvY2xpY2suanMiLCJzcmMvanMvaGFuZGxlci9hbGxkYXkvY29yZS5qcyIsInNyYy9qcy9oYW5kbGVyL2FsbGRheS9jcmVhdGlvbi5qcyIsInNyYy9qcy9oYW5kbGVyL2FsbGRheS9jcmVhdGlvbkd1aWRlLmpzIiwic3JjL2pzL2hhbmRsZXIvYWxsZGF5L21vdmUuanMiLCJzcmMvanMvaGFuZGxlci9hbGxkYXkvbW92ZUd1aWRlLmpzIiwic3JjL2pzL2hhbmRsZXIvYWxsZGF5L3Jlc2l6ZS5qcyIsInNyYy9qcy9oYW5kbGVyL2FsbGRheS9yZXNpemVHdWlkZS5qcyIsInNyYy9qcy9oYW5kbGVyL2RyYWcuanMiLCJzcmMvanMvaGFuZGxlci90aW1lL2NsaWNrLmpzIiwic3JjL2pzL2hhbmRsZXIvdGltZS9jb3JlLmpzIiwic3JjL2pzL2hhbmRsZXIvdGltZS9jcmVhdGlvbi5qcyIsInNyYy9qcy9oYW5kbGVyL3RpbWUvY3JlYXRpb25HdWlkZS5qcyIsInNyYy9qcy9oYW5kbGVyL3RpbWUvbW92ZS5qcyIsInNyYy9qcy9oYW5kbGVyL3RpbWUvbW92ZUd1aWRlLmpzIiwic3JjL2pzL2hhbmRsZXIvdGltZS9yZXNpemUuanMiLCJzcmMvanMvaGFuZGxlci90aW1lL3Jlc2l6ZUd1aWRlLmpzIiwic3JjL2pzL21vZGVsL2V2ZW50LmpzIiwic3JjL2pzL21vZGVsL3ZpZXdNb2RlbC9ldmVudC5qcyIsInNyYy9qcy92aWV3L2xheW91dC5qcyIsInNyYy9qcy92aWV3L21vbnRod2Vlay5qcyIsInNyYy9qcy92aWV3L3RlbXBsYXRlL2ZhY3Rvcnkvd2Vla1ZpZXcuaGJzIiwic3JjL2pzL3ZpZXcvdGVtcGxhdGUvaGVscGVyLmpzIiwic3JjL2pzL3ZpZXcvdGVtcGxhdGUvbW9udGh3ZWVrLmhicyIsInNyYy9qcy92aWV3L3RlbXBsYXRlL3JlZ2lzdGVySGVscGVycy5qcyIsInNyYy9qcy92aWV3L3RlbXBsYXRlL3dlZWsvYWxsZGF5LmhicyIsInNyYy9qcy92aWV3L3RlbXBsYXRlL3dlZWsvZGF5bmFtZXMuaGJzIiwic3JjL2pzL3ZpZXcvdGVtcGxhdGUvd2Vlay90aW1lLmhicyIsInNyYy9qcy92aWV3L3RlbXBsYXRlL3dlZWsvdGltZUdyaWQuaGJzIiwic3JjL2pzL3ZpZXcvdmlldy5qcyIsInNyYy9qcy92aWV3L3dlZWsvYWxsZGF5LmpzIiwic3JjL2pzL3ZpZXcvd2Vlay9kYXluYW1lLmpzIiwic3JjL2pzL3ZpZXcvd2Vlay90aW1lLmpzIiwic3JjL2pzL3ZpZXcvd2Vlay90aW1lR3JpZC5qcyIsInNyYy9qcy92aWV3L3dlZWsvd2Vlay5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OzhCQ3ZqSXNCLG1CQUFtQjs7Ozs7SUFBN0IsSUFBSTs7b0NBSU8sMEJBQTBCOzs7O21DQUMzQix3QkFBd0I7Ozs7K0JBQ3ZCLG9CQUFvQjs7SUFBL0IsS0FBSzs7aUNBQ1Esc0JBQXNCOztJQUFuQyxPQUFPOztvQ0FFSSwwQkFBMEI7Ozs7OztBQUdqRCxTQUFTLE1BQU0sR0FBRztBQUNoQixNQUFJLEVBQUUsR0FBRyxJQUFJLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDOztBQUUxQyxPQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUN2QixJQUFFLENBQUMsVUFBVSxvQ0FBYSxDQUFDO0FBQzNCLElBQUUsQ0FBQyxTQUFTLG1DQUFZLENBQUM7QUFDekIsSUFBRSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDakIsSUFBRSxDQUFDLGdCQUFnQixHQUFHLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQzs7QUFFN0MsSUFBRSxDQUFDLEVBQUUsR0FBRyxPQUFPLENBQUM7QUFDaEIsSUFBRSxDQUFDLFFBQVEsR0FBRyxVQUFTLElBQUksRUFBRTtBQUMzQixXQUFPLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0dBQ25DLENBQUM7O0FBRUYsU0FBTyxFQUFFLENBQUM7Q0FDWDs7QUFFRCxJQUFJLElBQUksR0FBRyxNQUFNLEVBQUUsQ0FBQztBQUNwQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQzs7QUFFckIsa0NBQVcsSUFBSSxDQUFDLENBQUM7O0FBRWpCLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxJQUFJLENBQUM7O3FCQUVSLElBQUk7Ozs7Ozs7Ozs7Ozs7cUJDcEN5QixTQUFTOzt5QkFDL0IsYUFBYTs7Ozt1QkFDRSxXQUFXOzswQkFDUixjQUFjOztzQkFDbkMsVUFBVTs7OztBQUV0QixJQUFNLE9BQU8sR0FBRyxPQUFPLENBQUM7O0FBQ3hCLElBQU0saUJBQWlCLEdBQUcsQ0FBQyxDQUFDOzs7QUFFNUIsSUFBTSxnQkFBZ0IsR0FBRztBQUM5QixHQUFDLEVBQUUsYUFBYTtBQUNoQixHQUFDLEVBQUUsZUFBZTtBQUNsQixHQUFDLEVBQUUsZUFBZTtBQUNsQixHQUFDLEVBQUUsVUFBVTtBQUNiLEdBQUMsRUFBRSxrQkFBa0I7QUFDckIsR0FBQyxFQUFFLGlCQUFpQjtBQUNwQixHQUFDLEVBQUUsVUFBVTtDQUNkLENBQUM7OztBQUVGLElBQU0sVUFBVSxHQUFHLGlCQUFpQixDQUFDOztBQUU5QixTQUFTLHFCQUFxQixDQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFO0FBQ25FLE1BQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxJQUFJLEVBQUUsQ0FBQztBQUM3QixNQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsSUFBSSxFQUFFLENBQUM7QUFDL0IsTUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLElBQUksRUFBRSxDQUFDOztBQUVuQyxXQXhCTSxzQkFBc0IsQ0F3QkwsSUFBSSxDQUFDLENBQUM7QUFDN0IsY0F4Qk0seUJBQXlCLENBd0JMLElBQUksQ0FBQyxDQUFDO0NBQ2pDOztBQUVELHFCQUFxQixDQUFDLFNBQVMsR0FBRztBQUNoQyxhQUFXLEVBQUUscUJBQXFCOztBQUVsQyxRQUFNLHFCQUFRO0FBQ2QsS0FBRyxFQUFFLG9CQUFPLEdBQUc7O0FBRWYsZ0JBQWMsRUFBRSx3QkFBUyxJQUFJLEVBQUUsRUFBRSxFQUFFO0FBQ2pDLFFBQUksT0FyQ3FCLFFBQVEsQ0FxQ3BCLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxVQUFVLEVBQUU7QUFDdEMsVUFBSSxFQUFFLEVBQUU7QUFBRSxjQUFNLDJCQUFjLHlDQUF5QyxDQUFDLENBQUM7T0FBRTtBQUMzRSxhQXZDZSxNQUFNLENBdUNkLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDNUIsTUFBTTtBQUNMLFVBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0tBQ3pCO0dBQ0Y7QUFDRCxrQkFBZ0IsRUFBRSwwQkFBUyxJQUFJLEVBQUU7QUFDL0IsV0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0dBQzNCOztBQUVELGlCQUFlLEVBQUUseUJBQVMsSUFBSSxFQUFFLE9BQU8sRUFBRTtBQUN2QyxRQUFJLE9BakRxQixRQUFRLENBaURwQixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssVUFBVSxFQUFFO0FBQ3RDLGFBbERlLE1BQU0sQ0FrRGQsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztLQUM3QixNQUFNO0FBQ0wsVUFBSSxPQUFPLE9BQU8sS0FBSyxXQUFXLEVBQUU7QUFDbEMsY0FBTSwyQkFBYywrQ0FBK0MsQ0FBQyxDQUFDO09BQ3RFO0FBQ0QsVUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxPQUFPLENBQUM7S0FDL0I7R0FDRjtBQUNELG1CQUFpQixFQUFFLDJCQUFTLElBQUksRUFBRTtBQUNoQyxXQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7R0FDNUI7O0FBRUQsbUJBQWlCLEVBQUUsMkJBQVMsSUFBSSxFQUFFLEVBQUUsRUFBRTtBQUNwQyxRQUFJLE9BL0RxQixRQUFRLENBK0RwQixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssVUFBVSxFQUFFO0FBQ3RDLFVBQUksRUFBRSxFQUFFO0FBQUUsY0FBTSwyQkFBYyw0Q0FBNEMsQ0FBQyxDQUFDO09BQUU7QUFDOUUsYUFqRWUsTUFBTSxDQWlFZCxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQy9CLE1BQU07QUFDTCxVQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztLQUM1QjtHQUNGO0FBQ0QscUJBQW1CLEVBQUUsNkJBQVMsSUFBSSxFQUFFO0FBQ2xDLFdBQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztHQUM5QjtDQUNGLENBQUM7O0FBRUssSUFBSSxHQUFHLEdBQUcsb0JBQU8sR0FBRyxDQUFDOzs7UUFFcEIsV0FBVyxVQTdFWCxXQUFXO1FBNkVFLE1BQU07Ozs7Ozs7Ozs7OztnQ0M3RUEscUJBQXFCOzs7O0FBRXpDLFNBQVMseUJBQXlCLENBQUMsUUFBUSxFQUFFO0FBQ2xELGdDQUFlLFFBQVEsQ0FBQyxDQUFDO0NBQzFCOzs7Ozs7OztxQkNKb0IsVUFBVTs7cUJBRWhCLFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUUsVUFBUyxFQUFFLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUU7QUFDM0UsUUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ2IsUUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUU7QUFDbkIsV0FBSyxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7QUFDcEIsU0FBRyxHQUFHLFVBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTs7QUFFL0IsWUFBSSxRQUFRLEdBQUcsU0FBUyxDQUFDLFFBQVEsQ0FBQztBQUNsQyxpQkFBUyxDQUFDLFFBQVEsR0FBRyxPQVZyQixNQUFNLENBVXNCLEVBQUUsRUFBRSxRQUFRLEVBQUUsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzFELFlBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDL0IsaUJBQVMsQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0FBQzlCLGVBQU8sR0FBRyxDQUFDO09BQ1osQ0FBQztLQUNIOztBQUVELFNBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxFQUFFLENBQUM7O0FBRTdDLFdBQU8sR0FBRyxDQUFDO0dBQ1osQ0FBQyxDQUFDO0NBQ0o7Ozs7Ozs7Ozs7QUNwQkQsSUFBTSxVQUFVLEdBQUcsQ0FBQyxhQUFhLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQzs7QUFFbkcsU0FBUyxTQUFTLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRTtBQUNoQyxNQUFJLEdBQUcsR0FBRyxJQUFJLElBQUksSUFBSSxDQUFDLEdBQUc7TUFDdEIsSUFBSSxZQUFBO01BQ0osTUFBTSxZQUFBLENBQUM7QUFDWCxNQUFJLEdBQUcsRUFBRTtBQUNQLFFBQUksR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQztBQUN0QixVQUFNLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7O0FBRTFCLFdBQU8sSUFBSSxLQUFLLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUM7R0FDeEM7O0FBRUQsTUFBSSxHQUFHLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQzs7O0FBRzFELE9BQUssSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxVQUFVLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxFQUFFO0FBQ2hELFFBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7R0FDOUM7OztBQUdELE1BQUksS0FBSyxDQUFDLGlCQUFpQixFQUFFO0FBQzNCLFNBQUssQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7R0FDMUM7O0FBRUQsTUFBSSxHQUFHLEVBQUU7QUFDUCxRQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztBQUN2QixRQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztHQUN0QjtDQUNGOztBQUVELFNBQVMsQ0FBQyxTQUFTLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQzs7cUJBRW5CLFNBQVM7Ozs7Ozs7Ozs7Ozs7eUNDbENlLGdDQUFnQzs7OzsyQkFDOUMsZ0JBQWdCOzs7O29DQUNQLDBCQUEwQjs7Ozt5QkFDckMsY0FBYzs7OzswQkFDYixlQUFlOzs7OzZCQUNaLGtCQUFrQjs7OzsyQkFDcEIsZ0JBQWdCOzs7O0FBRWxDLFNBQVMsc0JBQXNCLENBQUMsUUFBUSxFQUFFO0FBQy9DLHlDQUEyQixRQUFRLENBQUMsQ0FBQztBQUNyQywyQkFBYSxRQUFRLENBQUMsQ0FBQztBQUN2QixvQ0FBc0IsUUFBUSxDQUFDLENBQUM7QUFDaEMseUJBQVcsUUFBUSxDQUFDLENBQUM7QUFDckIsMEJBQVksUUFBUSxDQUFDLENBQUM7QUFDdEIsNkJBQWUsUUFBUSxDQUFDLENBQUM7QUFDekIsMkJBQWEsUUFBUSxDQUFDLENBQUM7Q0FDeEI7Ozs7Ozs7O3FCQ2hCcUQsVUFBVTs7cUJBRWpELFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxjQUFjLENBQUMsb0JBQW9CLEVBQUUsVUFBUyxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3ZFLFFBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPO1FBQ3pCLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDOztBQUVwQixRQUFJLE9BQU8sS0FBSyxJQUFJLEVBQUU7QUFDcEIsYUFBTyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDakIsTUFBTSxJQUFJLE9BQU8sS0FBSyxLQUFLLElBQUksT0FBTyxJQUFJLElBQUksRUFBRTtBQUMvQyxhQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUN0QixNQUFNLElBQUksT0FYeUIsT0FBTyxDQVd4QixPQUFPLENBQUMsRUFBRTtBQUMzQixVQUFJLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO0FBQ3RCLFlBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUNmLGlCQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzlCOztBQUVELGVBQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO09BQ2hELE1BQU07QUFDTCxlQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztPQUN0QjtLQUNGLE1BQU07QUFDTCxVQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUMvQixZQUFJLElBQUksR0FBRyxPQXZCUSxXQUFXLENBdUJQLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNyQyxZQUFJLENBQUMsV0FBVyxHQUFHLE9BeEJuQixpQkFBaUIsQ0F3Qm9CLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM3RSxlQUFPLEdBQUcsRUFBQyxJQUFJLEVBQUUsSUFBSSxFQUFDLENBQUM7T0FDeEI7O0FBRUQsYUFBTyxFQUFFLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0tBQzdCO0dBQ0YsQ0FBQyxDQUFDO0NBQ0o7Ozs7Ozs7Ozs7Ozs7cUJDL0I4RSxVQUFVOzt5QkFDbkUsY0FBYzs7OztxQkFFckIsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsVUFBUyxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3pELFFBQUksQ0FBQyxPQUFPLEVBQUU7QUFDWixZQUFNLDJCQUFjLDZCQUE2QixDQUFDLENBQUM7S0FDcEQ7O0FBRUQsUUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDLEVBQUU7UUFDZixPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU87UUFDekIsQ0FBQyxHQUFHLENBQUM7UUFDTCxHQUFHLEdBQUcsRUFBRTtRQUNSLElBQUksWUFBQTtRQUNKLFdBQVcsWUFBQSxDQUFDOztBQUVoQixRQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUMvQixpQkFBVyxHQUFHLE9BakJaLGlCQUFpQixDQWlCYSxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0tBQ2pGOztBQUVELFFBQUksT0FwQnNELFVBQVUsQ0FvQnJELE9BQU8sQ0FBQyxFQUFFO0FBQUUsYUFBTyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FBRTs7QUFFMUQsUUFBSSxPQUFPLENBQUMsSUFBSSxFQUFFO0FBQ2hCLFVBQUksR0FBRyxPQXZCMkIsV0FBVyxDQXVCMUIsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ2xDOztBQUVELGFBQVMsYUFBYSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFO0FBQ3pDLFVBQUksSUFBSSxFQUFFO0FBQ1IsWUFBSSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUM7QUFDakIsWUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDbkIsWUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLEtBQUssQ0FBQyxDQUFDO0FBQ3pCLFlBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQzs7QUFFbkIsWUFBSSxXQUFXLEVBQUU7QUFDZixjQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsR0FBRyxLQUFLLENBQUM7U0FDeEM7T0FDRjs7QUFFRCxTQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDN0IsWUFBSSxFQUFFLElBQUk7QUFDVixtQkFBVyxFQUFFLE9BeENNLFdBQVcsQ0F3Q0wsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUsS0FBSyxDQUFDLEVBQUUsQ0FBQyxXQUFXLEdBQUcsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO09BQy9FLENBQUMsQ0FBQztLQUNKOztBQUVELFFBQUksT0FBTyxJQUFJLE9BQU8sT0FBTyxLQUFLLFFBQVEsRUFBRTtBQUMxQyxVQUFJLE9BN0MyQyxPQUFPLENBNkMxQyxPQUFPLENBQUMsRUFBRTtBQUNwQixhQUFLLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN2QyxjQUFJLENBQUMsSUFBSSxPQUFPLEVBQUU7QUFDaEIseUJBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsS0FBSyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1dBQy9DO1NBQ0Y7T0FDRixNQUFNO0FBQ0wsWUFBSSxRQUFRLFlBQUEsQ0FBQzs7QUFFYixhQUFLLElBQUksR0FBRyxJQUFJLE9BQU8sRUFBRTtBQUN2QixjQUFJLE9BQU8sQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUU7Ozs7QUFJL0IsZ0JBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtBQUMxQiwyQkFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDaEM7QUFDRCxvQkFBUSxHQUFHLEdBQUcsQ0FBQztBQUNmLGFBQUMsRUFBRSxDQUFDO1dBQ0w7U0FDRjtBQUNELFlBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtBQUMxQix1QkFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ3RDO09BQ0Y7S0FDRjs7QUFFRCxRQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDWCxTQUFHLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3JCOztBQUVELFdBQU8sR0FBRyxDQUFDO0dBQ1osQ0FBQyxDQUFDO0NBQ0o7Ozs7Ozs7Ozs7Ozs7eUJDOUVxQixjQUFjOzs7O3FCQUVyQixVQUFTLFFBQVEsRUFBRTtBQUNoQyxVQUFRLENBQUMsY0FBYyxDQUFDLGVBQWUsRUFBRSxpQ0FBZ0M7QUFDdkUsUUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTs7QUFFMUIsYUFBTyxTQUFTLENBQUM7S0FDbEIsTUFBTTs7QUFFTCxZQUFNLDJCQUFjLG1CQUFtQixHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztLQUN2RjtHQUNGLENBQUMsQ0FBQztDQUNKOzs7Ozs7Ozs7O3FCQ1ppQyxVQUFVOztxQkFFN0IsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsVUFBUyxXQUFXLEVBQUUsT0FBTyxFQUFFO0FBQzNELFFBQUksT0FKUyxVQUFVLENBSVIsV0FBVyxDQUFDLEVBQUU7QUFBRSxpQkFBVyxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FBRTs7Ozs7QUFLdEUsUUFBSSxBQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLElBQUksQ0FBQyxXQUFXLElBQUssT0FUL0MsT0FBTyxDQVNnRCxXQUFXLENBQUMsRUFBRTtBQUN2RSxhQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDOUIsTUFBTTtBQUNMLGFBQU8sT0FBTyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUN6QjtHQUNGLENBQUMsQ0FBQzs7QUFFSCxVQUFRLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFBRSxVQUFTLFdBQVcsRUFBRSxPQUFPLEVBQUU7QUFDL0QsV0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsV0FBVyxFQUFFLEVBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxJQUFJLEVBQUMsQ0FBQyxDQUFDO0dBQ3ZILENBQUMsQ0FBQztDQUNKOzs7Ozs7Ozs7O3FCQ25CYyxVQUFTLFFBQVEsRUFBRTtBQUNoQyxVQUFRLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxrQ0FBaUM7QUFDOUQsUUFBSSxJQUFJLEdBQUcsQ0FBQyxTQUFTLENBQUM7UUFDbEIsT0FBTyxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzlDLFNBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUM3QyxVQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3pCOztBQUVELFFBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztBQUNkLFFBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxFQUFFO0FBQzlCLFdBQUssR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztLQUM1QixNQUFNLElBQUksT0FBTyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLEVBQUU7QUFDckQsV0FBSyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO0tBQzVCO0FBQ0QsUUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQzs7QUFFaEIsWUFBUSxDQUFDLEdBQUcsTUFBQSxDQUFaLFFBQVEsRUFBUyxJQUFJLENBQUMsQ0FBQztHQUN4QixDQUFDLENBQUM7Q0FDSjs7Ozs7Ozs7OztxQkNsQmMsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsVUFBUyxHQUFHLEVBQUUsS0FBSyxFQUFFO0FBQ3JELFdBQU8sR0FBRyxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztHQUMxQixDQUFDLENBQUM7Q0FDSjs7Ozs7Ozs7OztxQkNKOEUsVUFBVTs7cUJBRTFFLFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLFVBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN6RCxRQUFJLE9BSnNELFVBQVUsQ0FJckQsT0FBTyxDQUFDLEVBQUU7QUFBRSxhQUFPLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUFFOztBQUUxRCxRQUFJLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDOztBQUVwQixRQUFJLENBQUMsT0FSNEMsT0FBTyxDQVEzQyxPQUFPLENBQUMsRUFBRTtBQUNyQixVQUFJLElBQUksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDO0FBQ3hCLFVBQUksT0FBTyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFO0FBQy9CLFlBQUksR0FBRyxPQVh5QixXQUFXLENBV3hCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNqQyxZQUFJLENBQUMsV0FBVyxHQUFHLE9BWm5CLGlCQUFpQixDQVlvQixPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7T0FDaEY7O0FBRUQsYUFBTyxFQUFFLENBQUMsT0FBTyxFQUFFO0FBQ2pCLFlBQUksRUFBRSxJQUFJO0FBQ1YsbUJBQVcsRUFBRSxPQWpCTSxXQUFXLENBaUJMLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO09BQ2hFLENBQUMsQ0FBQztLQUNKLE1BQU07QUFDTCxhQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDOUI7R0FDRixDQUFDLENBQUM7Q0FDSjs7Ozs7Ozs7OztxQkN2QnFCLFNBQVM7O0FBRS9CLElBQUksTUFBTSxHQUFHO0FBQ1gsV0FBUyxFQUFFLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDO0FBQzdDLE9BQUssRUFBRSxNQUFNOzs7QUFHYixhQUFXLEVBQUUscUJBQVMsS0FBSyxFQUFFO0FBQzNCLFFBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO0FBQzdCLFVBQUksUUFBUSxHQUFHLE9BVGIsT0FBTyxDQVNjLE1BQU0sQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7QUFDOUQsVUFBSSxRQUFRLElBQUksQ0FBQyxFQUFFO0FBQ2pCLGFBQUssR0FBRyxRQUFRLENBQUM7T0FDbEIsTUFBTTtBQUNMLGFBQUssR0FBRyxRQUFRLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO09BQzdCO0tBQ0Y7O0FBRUQsV0FBTyxLQUFLLENBQUM7R0FDZDs7O0FBR0QsS0FBRyxFQUFFLGFBQVMsS0FBSyxFQUFjO0FBQy9CLFNBQUssR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDOztBQUVsQyxRQUFJLE9BQU8sT0FBTyxLQUFLLFdBQVcsSUFBSSxNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLEVBQUU7QUFDL0UsVUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNyQyxVQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFOztBQUNwQixjQUFNLEdBQUcsS0FBSyxDQUFDO09BQ2hCOzt3Q0FQbUIsT0FBTztBQUFQLGVBQU87OztBQVEzQixhQUFPLENBQUMsTUFBTSxPQUFDLENBQWYsT0FBTyxFQUFZLE9BQU8sQ0FBQyxDQUFDO0tBQzdCO0dBQ0Y7Q0FDRixDQUFDOztxQkFFYSxNQUFNOzs7Ozs7Ozs7OztxQkNqQ04sVUFBUyxVQUFVLEVBQUU7O0FBRWxDLE1BQUksSUFBSSxHQUFHLE9BQU8sTUFBTSxLQUFLLFdBQVcsR0FBRyxNQUFNLEdBQUcsTUFBTTtNQUN0RCxXQUFXLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQzs7QUFFbEMsWUFBVSxDQUFDLFVBQVUsR0FBRyxZQUFXO0FBQ2pDLFFBQUksSUFBSSxDQUFDLFVBQVUsS0FBSyxVQUFVLEVBQUU7QUFDbEMsVUFBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUM7S0FDL0I7R0FDRixDQUFDO0NBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUJDWHNCLFNBQVM7O0lBQXBCLEtBQUs7O3lCQUNLLGFBQWE7Ozs7b0JBQzhCLFFBQVE7O0FBRWxFLFNBQVMsYUFBYSxDQUFDLFlBQVksRUFBRTtBQUMxQyxNQUFNLGdCQUFnQixHQUFHLFlBQVksSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztNQUN2RCxlQUFlLFNBSmQsaUJBQWlCLEFBSWlCLENBQUM7O0FBRTFDLE1BQUksZ0JBQWdCLEtBQUssZUFBZSxFQUFFO0FBQ3hDLFFBQUksZ0JBQWdCLEdBQUcsZUFBZSxFQUFFO0FBQ3RDLFVBQU0sZUFBZSxHQUFHLE1BUkYsZ0JBQWdCLENBUUcsZUFBZSxDQUFDO1VBQ25ELGdCQUFnQixHQUFHLE1BVEgsZ0JBQWdCLENBU0ksZ0JBQWdCLENBQUMsQ0FBQztBQUM1RCxZQUFNLDJCQUFjLHlGQUF5RixHQUN2RyxxREFBcUQsR0FBRyxlQUFlLEdBQUcsbURBQW1ELEdBQUcsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLENBQUM7S0FDaEssTUFBTTs7QUFFTCxZQUFNLDJCQUFjLHdGQUF3RixHQUN0RyxpREFBaUQsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7S0FDbkY7R0FDRjtDQUNGOztBQUVNLFNBQVMsUUFBUSxDQUFDLFlBQVksRUFBRSxHQUFHLEVBQUU7O0FBRTFDLE1BQUksQ0FBQyxHQUFHLEVBQUU7QUFDUixVQUFNLDJCQUFjLG1DQUFtQyxDQUFDLENBQUM7R0FDMUQ7QUFDRCxNQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRTtBQUN2QyxVQUFNLDJCQUFjLDJCQUEyQixHQUFHLE9BQU8sWUFBWSxDQUFDLENBQUM7R0FDeEU7O0FBRUQsY0FBWSxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQzs7OztBQUlsRCxLQUFHLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7O0FBRTVDLFdBQVMsb0JBQW9CLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUU7QUFDdkQsUUFBSSxPQUFPLENBQUMsSUFBSSxFQUFFO0FBQ2hCLGFBQU8sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2xELFVBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUNmLGVBQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO09BQ3ZCO0tBQ0Y7O0FBRUQsV0FBTyxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztBQUN0RSxRQUFJLE1BQU0sR0FBRyxHQUFHLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7O0FBRXhFLFFBQUksTUFBTSxJQUFJLElBQUksSUFBSSxHQUFHLENBQUMsT0FBTyxFQUFFO0FBQ2pDLGFBQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxlQUFlLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDekYsWUFBTSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztLQUMzRDtBQUNELFFBQUksTUFBTSxJQUFJLElBQUksRUFBRTtBQUNsQixVQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUU7QUFDbEIsWUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUMvQixhQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzVDLGNBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDNUIsa0JBQU07V0FDUDs7QUFFRCxlQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdEM7QUFDRCxjQUFNLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztPQUMzQjtBQUNELGFBQU8sTUFBTSxDQUFDO0tBQ2YsTUFBTTtBQUNMLFlBQU0sMkJBQWMsY0FBYyxHQUFHLE9BQU8sQ0FBQyxJQUFJLEdBQUcsMERBQTBELENBQUMsQ0FBQztLQUNqSDtHQUNGOzs7QUFHRCxNQUFJLFNBQVMsR0FBRztBQUNkLFVBQU0sRUFBRSxnQkFBUyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFCLFVBQUksRUFBRSxJQUFJLElBQUksR0FBRyxDQUFBLEFBQUMsRUFBRTtBQUNsQixjQUFNLDJCQUFjLEdBQUcsR0FBRyxJQUFJLEdBQUcsbUJBQW1CLEdBQUcsR0FBRyxDQUFDLENBQUM7T0FDN0Q7QUFDRCxhQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNsQjtBQUNELFVBQU0sRUFBRSxnQkFBUyxNQUFNLEVBQUUsSUFBSSxFQUFFO0FBQzdCLFVBQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDMUIsV0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUM1QixZQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxFQUFFO0FBQ3hDLGlCQUFPLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN4QjtPQUNGO0tBQ0Y7QUFDRCxVQUFNLEVBQUUsZ0JBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUNqQyxhQUFPLE9BQU8sT0FBTyxLQUFLLFVBQVUsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLE9BQU8sQ0FBQztLQUN4RTs7QUFFRCxvQkFBZ0IsRUFBRSxLQUFLLENBQUMsZ0JBQWdCO0FBQ3hDLGlCQUFhLEVBQUUsb0JBQW9COztBQUVuQyxNQUFFLEVBQUUsWUFBUyxDQUFDLEVBQUU7QUFDZCxVQUFJLEdBQUcsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDMUIsU0FBRyxDQUFDLFNBQVMsR0FBRyxZQUFZLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQ3ZDLGFBQU8sR0FBRyxDQUFDO0tBQ1o7O0FBRUQsWUFBUSxFQUFFLEVBQUU7QUFDWixXQUFPLEVBQUUsaUJBQVMsQ0FBQyxFQUFFLElBQUksRUFBRSxtQkFBbUIsRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFO0FBQ25FLFVBQUksY0FBYyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1VBQ2pDLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLFVBQUksSUFBSSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksbUJBQW1CLEVBQUU7QUFDeEQsc0JBQWMsR0FBRyxXQUFXLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLG1CQUFtQixFQUFFLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztPQUMzRixNQUFNLElBQUksQ0FBQyxjQUFjLEVBQUU7QUFDMUIsc0JBQWMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO09BQzlEO0FBQ0QsYUFBTyxjQUFjLENBQUM7S0FDdkI7O0FBRUQsUUFBSSxFQUFFLGNBQVMsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUMzQixhQUFPLEtBQUssSUFBSSxLQUFLLEVBQUUsRUFBRTtBQUN2QixhQUFLLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQztPQUN2QjtBQUNELGFBQU8sS0FBSyxDQUFDO0tBQ2Q7QUFDRCxTQUFLLEVBQUUsZUFBUyxLQUFLLEVBQUUsTUFBTSxFQUFFO0FBQzdCLFVBQUksR0FBRyxHQUFHLEtBQUssSUFBSSxNQUFNLENBQUM7O0FBRTFCLFVBQUksS0FBSyxJQUFJLE1BQU0sSUFBSyxLQUFLLEtBQUssTUFBTSxBQUFDLEVBQUU7QUFDekMsV0FBRyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztPQUN2Qzs7QUFFRCxhQUFPLEdBQUcsQ0FBQztLQUNaOztBQUVELFFBQUksRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUk7QUFDakIsZ0JBQVksRUFBRSxZQUFZLENBQUMsUUFBUTtHQUNwQyxDQUFDOztBQUVGLFdBQVMsR0FBRyxDQUFDLE9BQU8sRUFBZ0I7UUFBZCxPQUFPLHlEQUFHLEVBQUU7O0FBQ2hDLFFBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUM7O0FBRXhCLE9BQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDcEIsUUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLElBQUksWUFBWSxDQUFDLE9BQU8sRUFBRTtBQUM1QyxVQUFJLEdBQUcsUUFBUSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztLQUNoQztBQUNELFFBQUksTUFBTSxZQUFBO1FBQ04sV0FBVyxHQUFHLFlBQVksQ0FBQyxjQUFjLEdBQUcsRUFBRSxHQUFHLFNBQVMsQ0FBQztBQUMvRCxRQUFJLFlBQVksQ0FBQyxTQUFTLEVBQUU7QUFDMUIsVUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFO0FBQ2xCLGNBQU0sR0FBRyxPQUFPLEtBQUssT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQztPQUM1RixNQUFNO0FBQ0wsY0FBTSxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7T0FDcEI7S0FDRjs7QUFFRCxhQUFTLElBQUksQ0FBQyxPQUFPLGdCQUFlO0FBQ2xDLGFBQU8sRUFBRSxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLE9BQU8sRUFBRSxTQUFTLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztLQUNySDtBQUNELFFBQUksR0FBRyxpQkFBaUIsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLE1BQU0sSUFBSSxFQUFFLEVBQUUsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBQ3RHLFdBQU8sSUFBSSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztHQUMvQjtBQUNELEtBQUcsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDOztBQUVqQixLQUFHLENBQUMsTUFBTSxHQUFHLFVBQVMsT0FBTyxFQUFFO0FBQzdCLFFBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFO0FBQ3BCLGVBQVMsQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7QUFFbEUsVUFBSSxZQUFZLENBQUMsVUFBVSxFQUFFO0FBQzNCLGlCQUFTLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7T0FDdEU7QUFDRCxVQUFJLFlBQVksQ0FBQyxVQUFVLElBQUksWUFBWSxDQUFDLGFBQWEsRUFBRTtBQUN6RCxpQkFBUyxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO09BQzVFO0tBQ0YsTUFBTTtBQUNMLGVBQVMsQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQztBQUNwQyxlQUFTLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUM7QUFDdEMsZUFBUyxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDO0tBQzNDO0dBQ0YsQ0FBQzs7QUFFRixLQUFHLENBQUMsTUFBTSxHQUFHLFVBQVMsQ0FBQyxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFO0FBQ2xELFFBQUksWUFBWSxDQUFDLGNBQWMsSUFBSSxDQUFDLFdBQVcsRUFBRTtBQUMvQyxZQUFNLDJCQUFjLHdCQUF3QixDQUFDLENBQUM7S0FDL0M7QUFDRCxRQUFJLFlBQVksQ0FBQyxTQUFTLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFDckMsWUFBTSwyQkFBYyx5QkFBeUIsQ0FBQyxDQUFDO0tBQ2hEOztBQUVELFdBQU8sV0FBVyxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0dBQ2pGLENBQUM7QUFDRixTQUFPLEdBQUcsQ0FBQztDQUNaOztBQUVNLFNBQVMsV0FBVyxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxtQkFBbUIsRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFO0FBQzVGLFdBQVMsSUFBSSxDQUFDLE9BQU8sRUFBZ0I7UUFBZCxPQUFPLHlEQUFHLEVBQUU7O0FBQ2pDLFFBQUksYUFBYSxHQUFHLE1BQU0sQ0FBQztBQUMzQixRQUFJLE1BQU0sSUFBSSxPQUFPLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFO0FBQ25DLG1CQUFhLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDMUM7O0FBRUQsV0FBTyxFQUFFLENBQUMsU0FBUyxFQUNmLE9BQU8sRUFDUCxTQUFTLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxRQUFRLEVBQ3JDLE9BQU8sQ0FBQyxJQUFJLElBQUksSUFBSSxFQUNwQixXQUFXLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUN4RCxhQUFhLENBQUMsQ0FBQztHQUNwQjs7QUFFRCxNQUFJLEdBQUcsaUJBQWlCLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQzs7QUFFekUsTUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7QUFDakIsTUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDeEMsTUFBSSxDQUFDLFdBQVcsR0FBRyxtQkFBbUIsSUFBSSxDQUFDLENBQUM7QUFDNUMsU0FBTyxJQUFJLENBQUM7Q0FDYjs7QUFFTSxTQUFTLGNBQWMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN4RCxNQUFJLENBQUMsT0FBTyxFQUFFO0FBQ1osUUFBSSxPQUFPLENBQUMsSUFBSSxLQUFLLGdCQUFnQixFQUFFO0FBQ3JDLGFBQU8sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0tBQ3pDLE1BQU07QUFDTCxhQUFPLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDMUM7R0FDRixNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRTs7QUFFekMsV0FBTyxDQUFDLElBQUksR0FBRyxPQUFPLENBQUM7QUFDdkIsV0FBTyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7R0FDckM7QUFDRCxTQUFPLE9BQU8sQ0FBQztDQUNoQjs7QUFFTSxTQUFTLGFBQWEsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN2RCxTQUFPLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztBQUN2QixNQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUU7QUFDZixXQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDO0dBQ3ZFOztBQUVELE1BQUksWUFBWSxZQUFBLENBQUM7QUFDakIsTUFBSSxPQUFPLENBQUMsRUFBRSxJQUFJLE9BQU8sQ0FBQyxFQUFFLEtBQUssSUFBSSxFQUFFO0FBQ3JDLFdBQU8sQ0FBQyxJQUFJLEdBQUcsTUF0TzJCLFdBQVcsQ0FzTzFCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN6QyxnQkFBWSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsT0FBTyxDQUFDLEVBQUUsQ0FBQzs7QUFFMUQsUUFBSSxZQUFZLENBQUMsUUFBUSxFQUFFO0FBQ3pCLGFBQU8sQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsT0FBTyxDQUFDLFFBQVEsRUFBRSxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7S0FDOUU7R0FDRjs7QUFFRCxNQUFJLE9BQU8sS0FBSyxTQUFTLElBQUksWUFBWSxFQUFFO0FBQ3pDLFdBQU8sR0FBRyxZQUFZLENBQUM7R0FDeEI7O0FBRUQsTUFBSSxPQUFPLEtBQUssU0FBUyxFQUFFO0FBQ3pCLFVBQU0sMkJBQWMsY0FBYyxHQUFHLE9BQU8sQ0FBQyxJQUFJLEdBQUcscUJBQXFCLENBQUMsQ0FBQztHQUM1RSxNQUFNLElBQUksT0FBTyxZQUFZLFFBQVEsRUFBRTtBQUN0QyxXQUFPLE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7R0FDbEM7Q0FDRjs7QUFFTSxTQUFTLElBQUksR0FBRztBQUFFLFNBQU8sRUFBRSxDQUFDO0NBQUU7O0FBRXJDLFNBQVMsUUFBUSxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUU7QUFDL0IsTUFBSSxDQUFDLElBQUksSUFBSSxFQUFFLE1BQU0sSUFBSSxJQUFJLENBQUEsQUFBQyxFQUFFO0FBQzlCLFFBQUksR0FBRyxJQUFJLEdBQUcsTUE3UDRCLFdBQVcsQ0E2UDNCLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNyQyxRQUFJLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQztHQUNyQjtBQUNELFNBQU8sSUFBSSxDQUFDO0NBQ2I7O0FBRUQsU0FBUyxpQkFBaUIsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRTtBQUN6RSxNQUFJLEVBQUUsQ0FBQyxTQUFTLEVBQUU7QUFDaEIsUUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDO0FBQ2YsUUFBSSxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsTUFBTSxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQzVGLFNBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO0dBQzNCO0FBQ0QsU0FBTyxJQUFJLENBQUM7Q0FDYjs7Ozs7Ozs7QUMzUUQsU0FBUyxVQUFVLENBQUMsTUFBTSxFQUFFO0FBQzFCLE1BQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0NBQ3RCOztBQUVELFVBQVUsQ0FBQyxTQUFTLENBQUMsUUFBUSxHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLFlBQVc7QUFDdkUsU0FBTyxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztDQUN6QixDQUFDOztxQkFFYSxVQUFVOzs7Ozs7Ozs7Ozs7Ozs7QUNUekIsSUFBTSxNQUFNLEdBQUc7QUFDYixLQUFHLEVBQUUsT0FBTztBQUNaLEtBQUcsRUFBRSxNQUFNO0FBQ1gsS0FBRyxFQUFFLE1BQU07QUFDWCxLQUFHLEVBQUUsUUFBUTtBQUNiLEtBQUcsRUFBRSxRQUFRO0FBQ2IsS0FBRyxFQUFFLFFBQVE7QUFDYixLQUFHLEVBQUUsUUFBUTtDQUNkLENBQUM7O0FBRUYsSUFBTSxRQUFRLEdBQUcsWUFBWTtJQUN2QixRQUFRLEdBQUcsV0FBVyxDQUFDOztBQUU3QixTQUFTLFVBQVUsQ0FBQyxHQUFHLEVBQUU7QUFDdkIsU0FBTyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7Q0FDcEI7O0FBRU0sU0FBUyxNQUFNLENBQUMsR0FBRyxvQkFBb0I7QUFDNUMsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDekMsU0FBSyxJQUFJLEdBQUcsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUU7QUFDNUIsVUFBSSxNQUFNLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFO0FBQzNELFdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDOUI7S0FDRjtHQUNGOztBQUVELFNBQU8sR0FBRyxDQUFDO0NBQ1o7O0FBRU0sSUFBSSxRQUFRLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUM7Ozs7OztBQUtoRCxJQUFJLFVBQVUsR0FBRyxvQkFBUyxLQUFLLEVBQUU7QUFDL0IsU0FBTyxPQUFPLEtBQUssS0FBSyxVQUFVLENBQUM7Q0FDcEMsQ0FBQzs7O0FBR0YsSUFBSSxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDbkIsVUFJTSxVQUFVLEdBSmhCLFVBQVUsR0FBRyxVQUFTLEtBQUssRUFBRTtBQUMzQixXQUFPLE9BQU8sS0FBSyxLQUFLLFVBQVUsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLG1CQUFtQixDQUFDO0dBQ3BGLENBQUM7Q0FDSDtRQUNPLFVBQVUsR0FBVixVQUFVOzs7OztBQUlYLElBQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFPLElBQUksVUFBUyxLQUFLLEVBQUU7QUFDdEQsU0FBTyxBQUFDLEtBQUssSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEdBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7Q0FDakcsQ0FBQzs7Ozs7QUFHSyxTQUFTLE9BQU8sQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFO0FBQ3BDLE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDaEQsUUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssS0FBSyxFQUFFO0FBQ3RCLGFBQU8sQ0FBQyxDQUFDO0tBQ1Y7R0FDRjtBQUNELFNBQU8sQ0FBQyxDQUFDLENBQUM7Q0FDWDs7QUFHTSxTQUFTLGdCQUFnQixDQUFDLE1BQU0sRUFBRTtBQUN2QyxNQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsRUFBRTs7QUFFOUIsUUFBSSxNQUFNLElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRTtBQUMzQixhQUFPLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQztLQUN4QixNQUFNLElBQUksTUFBTSxJQUFJLElBQUksRUFBRTtBQUN6QixhQUFPLEVBQUUsQ0FBQztLQUNYLE1BQU0sSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUNsQixhQUFPLE1BQU0sR0FBRyxFQUFFLENBQUM7S0FDcEI7Ozs7O0FBS0QsVUFBTSxHQUFHLEVBQUUsR0FBRyxNQUFNLENBQUM7R0FDdEI7O0FBRUQsTUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7QUFBRSxXQUFPLE1BQU0sQ0FBQztHQUFFO0FBQzlDLFNBQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLENBQUM7Q0FDN0M7O0FBRU0sU0FBUyxPQUFPLENBQUMsS0FBSyxFQUFFO0FBQzdCLE1BQUksQ0FBQyxLQUFLLElBQUksS0FBSyxLQUFLLENBQUMsRUFBRTtBQUN6QixXQUFPLElBQUksQ0FBQztHQUNiLE1BQU0sSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7QUFDL0MsV0FBTyxJQUFJLENBQUM7R0FDYixNQUFNO0FBQ0wsV0FBTyxLQUFLLENBQUM7R0FDZDtDQUNGOztBQUVNLFNBQVMsV0FBVyxDQUFDLE1BQU0sRUFBRTtBQUNsQyxNQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQy9CLE9BQUssQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO0FBQ3ZCLFNBQU8sS0FBSyxDQUFDO0NBQ2Q7O0FBRU0sU0FBUyxXQUFXLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRTtBQUN2QyxRQUFNLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQztBQUNsQixTQUFPLE1BQU0sQ0FBQztDQUNmOztBQUVNLFNBQVMsaUJBQWlCLENBQUMsV0FBVyxFQUFFLEVBQUUsRUFBRTtBQUNqRCxTQUFPLENBQUMsV0FBVyxHQUFHLFdBQVcsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFBLEdBQUksRUFBRSxDQUFDO0NBQ3BEOzs7O0FDM0dEO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDblBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDamFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNuakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDelJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ25NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDblFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN0VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyoqXG4gKiDilojilojilojilojilojilojilZcgICDilojilojilojilojilojilojilZcgICDilojilojilojilojilojilojilZcgIOKWiOKWiOKWiOKWiOKWiOKWiOKVlyAgIOKWiOKWiOKWiOKWiOKWiOKVlyAg4paI4paI4pWXICAg4paI4paI4pWXIOKWiOKWiOKVl1xuICog4paI4paI4pWU4pWQ4pWQ4paI4paI4pWXIOKWiOKWiOKVlOKVkOKVkOKVkOKWiOKWiOKVlyDilojilojilZTilZDilZDilZDilojilojilZcg4paI4paI4pWU4pWQ4pWQ4paI4paI4pWXIOKWiOKWiOKVlOKVkOKVkOKWiOKWiOKVlyDilZrilojilojilZcg4paI4paI4pWU4pWdIOKWiOKWiOKVkVxuICog4paI4paI4pWRICDilojilojilZEg4paI4paI4pWRICAg4paI4paI4pWRIOKWiOKWiOKVkSAgIOKWiOKWiOKVkSDilojilojilojilojilojilojilZTilZ0g4paI4paI4paI4paI4paI4paI4paI4pWRICDilZrilojilojilojilojilZTilZ0gIOKWiOKWiOKVkVxuICog4paI4paI4pWRICDilojilojilZEg4paI4paI4pWRICAg4paI4paI4pWRIOKWiOKWiOKVkSAgIOKWiOKWiOKVkSDilojilojilZTilZDilZDilojilojilZcg4paI4paI4pWU4pWQ4pWQ4paI4paI4pWRICAg4pWa4paI4paI4pWU4pWdICAg4pWa4pWQ4pWdXG4gKiDilojilojilojilojilojilojilZTilZ0g4pWa4paI4paI4paI4paI4paI4paI4pWU4pWdIOKVmuKWiOKWiOKWiOKWiOKWiOKWiOKVlOKVnSDilojilojilZEgIOKWiOKWiOKVkSDilojilojilZEgIOKWiOKWiOKVkSAgICDilojilojilZEgICAg4paI4paI4pWXXG4gKiDilZrilZDilZDilZDilZDilZDilZ0gICDilZrilZDilZDilZDilZDilZDilZ0gICDilZrilZDilZDilZDilZDilZDilZ0gIOKVmuKVkOKVnSAg4pWa4pWQ4pWdIOKVmuKVkOKVnSAg4pWa4pWQ4pWdICAgIOKVmuKVkOKVnSAgICDilZrilZDilZ1cbiAqXG4gKiAg4paI4paI4paI4paI4paI4paI4pWXICDilojilojilojilojilojilZcgIOKWiOKWiOKVlyAgICAgIOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKVlyDilojilojilojilZcgICDilojilojilZcg4paI4paI4paI4paI4paI4paI4pWXICAg4paI4paI4paI4paI4paI4pWXICDilojilojilojilojilojilojilZdcbiAqIOKWiOKWiOKVlOKVkOKVkOKVkOKVkOKVnSDilojilojilZTilZDilZDilojilojilZcg4paI4paI4pWRICAgICAg4paI4paI4pWU4pWQ4pWQ4pWQ4pWQ4pWdIOKWiOKWiOKWiOKWiOKVlyAg4paI4paI4pWRIOKWiOKWiOKVlOKVkOKVkOKWiOKWiOKVlyDilojilojilZTilZDilZDilojilojilZcg4paI4paI4pWU4pWQ4pWQ4paI4paI4pWXXG4gKiDilojilojilZEgICAgICDilojilojilojilojilojilojilojilZEg4paI4paI4pWRICAgICAg4paI4paI4paI4paI4paI4pWXICAg4paI4paI4pWU4paI4paI4pWXIOKWiOKWiOKVkSDilojilojilZEgIOKWiOKWiOKVkSDilojilojilojilojilojilojilojilZEg4paI4paI4paI4paI4paI4paI4pWU4pWdXG4gKiDilojilojilZEgICAgICDilojilojilZTilZDilZDilojilojilZEg4paI4paI4pWRICAgICAg4paI4paI4pWU4pWQ4pWQ4pWdICAg4paI4paI4pWR4pWa4paI4paI4pWX4paI4paI4pWRIOKWiOKWiOKVkSAg4paI4paI4pWRIOKWiOKWiOKVlOKVkOKVkOKWiOKWiOKVkSDilojilojilZTilZDilZDilojilojilZdcbiAqIOKVmuKWiOKWiOKWiOKWiOKWiOKWiOKVlyDilojilojilZEgIOKWiOKWiOKVkSDilojilojilojilojilojilojilojilZcg4paI4paI4paI4paI4paI4paI4paI4pWXIOKWiOKWiOKVkSDilZrilojilojilojilojilZEg4paI4paI4paI4paI4paI4paI4pWU4pWdIOKWiOKWiOKVkSAg4paI4paI4pWRIOKWiOKWiOKVkSAg4paI4paI4pWRXG4gKiAg4pWa4pWQ4pWQ4pWQ4pWQ4pWQ4pWdIOKVmuKVkOKVnSAg4pWa4pWQ4pWdIOKVmuKVkOKVkOKVkOKVkOKVkOKVkOKVnSDilZrilZDilZDilZDilZDilZDilZDilZ0g4pWa4pWQ4pWdICDilZrilZDilZDilZDilZ0g4pWa4pWQ4pWQ4pWQ4pWQ4pWQ4pWdICDilZrilZDilZ0gIOKVmuKVkOKVnSDilZrilZDilZ0gIOKVmuKVkOKVnVxuICogQHZlcnNpb24gMC4xLjZcbiAqL1xuLyogZXNsaW50IHZhcnMtb24tdG9wOjAsIHN0cmljdDowICovXG5cbi8qKioqKioqKioqXG4gKiBDb21tb25cbiAqKioqKioqKioqL1xucmVxdWlyZSgnY29kZS1zbmlwcGV0Jyk7XG5yZXF1aXJlKCcuL3NyYy9qcy92aWV3L3RlbXBsYXRlL3JlZ2lzdGVySGVscGVycycpO1xudmFyIGRpcnR5ID0gcmVxdWlyZSgnLi9zcmMvanMvY29tbW9uL2RpcnR5Jyk7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuL3NyYy9qcy9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBhcnJheSA9IHJlcXVpcmUoJy4vc3JjL2pzL2NvbW1vbi9hcnJheScpO1xudmFyIGRvbWV2ZW50ID0gcmVxdWlyZSgnLi9zcmMvanMvY29tbW9uL2RvbWV2ZW50Jyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4vc3JjL2pzL2NvbW1vbi9kb211dGlsJyk7XG52YXIgQ29sbGVjaXRvbiA9IHJlcXVpcmUoJy4vc3JjL2pzL2NvbW1vbi9jb2xsZWN0aW9uJyk7XG52YXIgbW9kZWwgPSByZXF1aXJlKCcuL3NyYy9qcy9jb21tb24vbW9kZWwnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuL3NyYy9qcy9jb21tb24vY29tbW9uJyk7XG52YXIgcmVxQW5pbUZyYW1lID0gcmVxdWlyZSgnLi9zcmMvanMvY29tbW9uL3JlcUFuaW1GcmFtZScpO1xudmFyIEFKQVggPSByZXF1aXJlKCcuL3NyYy9qcy9jb21tb24vYWpheCcpO1xuXG4vKioqKioqKioqKlxuICogTW9kZWxzXG4gKioqKioqKioqKi9cbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vc3JjL2pzL2NvbW1vbi9wb2ludCcpO1xudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi9zcmMvanMvbW9kZWwvZXZlbnQnKTtcblxuLyoqKioqKioqKipcbiAqIFZpZXdzXG4gKioqKioqKioqKi9cbnZhciBWaWV3ID0gcmVxdWlyZSgnLi9zcmMvanMvdmlldy92aWV3Jyk7XG52YXIgTW9udGhXZWVrID0gcmVxdWlyZSgnLi9zcmMvanMvdmlldy9tb250aHdlZWsnKTtcblxudmFyIFdlZWsgPSByZXF1aXJlKCcuL3NyYy9qcy92aWV3L3dlZWsvd2VlaycpO1xudmFyIERheU5hbWUgPSByZXF1aXJlKCcuL3NyYy9qcy92aWV3L3dlZWsvZGF5bmFtZScpO1xudmFyIFRpbWVHcmlkID0gcmVxdWlyZSgnLi9zcmMvanMvdmlldy93ZWVrL3RpbWVHcmlkJyk7XG52YXIgVGltZSA9IHJlcXVpcmUoJy4vc3JjL2pzL3ZpZXcvd2Vlay90aW1lJyk7XG5cblxuLyoqKioqKioqKipcbiAqIFZpZXcgTW9kZWxzXG4gKioqKioqKioqKi9cbnZhciBFdmVudFZpZXdNb2RlbCA9IHJlcXVpcmUoJy4vc3JjL2pzL21vZGVsL3ZpZXdNb2RlbC9ldmVudCcpO1xuXG4vKioqKioqKioqKlxuICogSGFuZGxlcnNcbiAqKioqKioqKioqL1xudmFyIERyYWcgPSByZXF1aXJlKCcuL3NyYy9qcy9oYW5kbGVyL2RyYWcnKTtcbnZhciBUaW1lQ29yZSA9IHJlcXVpcmUoJy4vc3JjL2pzL2hhbmRsZXIvdGltZS9jb3JlJyk7XG52YXIgVGltZUNsaWNrID0gcmVxdWlyZSgnLi9zcmMvanMvaGFuZGxlci90aW1lL2NsaWNrJyk7XG52YXIgVGltZUNyZWF0aW9uID0gcmVxdWlyZSgnLi9zcmMvanMvaGFuZGxlci90aW1lL2NyZWF0aW9uJyk7XG52YXIgVGltZUNyZWF0aW9uR3VpZGUgPSByZXF1aXJlKCcuL3NyYy9qcy9oYW5kbGVyL3RpbWUvY3JlYXRpb25HdWlkZScpO1xudmFyIFRpbWVNb3ZlID0gcmVxdWlyZSgnLi9zcmMvanMvaGFuZGxlci90aW1lL21vdmUnKTtcbnZhciBUaW1lTW92ZUd1aWRlID0gcmVxdWlyZSgnLi9zcmMvanMvaGFuZGxlci90aW1lL21vdmVHdWlkZScpO1xudmFyIFRpbWVSZXNpemUgPSByZXF1aXJlKCcuL3NyYy9qcy9oYW5kbGVyL3RpbWUvcmVzaXplJyk7XG52YXIgVGltZVJlc2l6ZUd1aWRlID0gcmVxdWlyZSgnLi9zcmMvanMvaGFuZGxlci90aW1lL3Jlc2l6ZUd1aWRlJyk7XG5cbnZhciBBbGxkYXlDb3JlID0gcmVxdWlyZSgnLi9zcmMvanMvaGFuZGxlci9hbGxkYXkvY29yZScpO1xudmFyIEFsbGRheUNsaWNrID0gcmVxdWlyZSgnLi9zcmMvanMvaGFuZGxlci9hbGxkYXkvY2xpY2snKTtcbnZhciBBbGxkYXlDcmVhdGlvbiA9IHJlcXVpcmUoJy4vc3JjL2pzL2hhbmRsZXIvYWxsZGF5L2NyZWF0aW9uJyk7XG52YXIgQWxsZGF5Q3JlYXRpb25HdWlkZSA9IHJlcXVpcmUoJy4vc3JjL2pzL2hhbmRsZXIvYWxsZGF5L2NyZWF0aW9uR3VpZGUnKTtcbnZhciBBbGxkYXlNb3ZlID0gcmVxdWlyZSgnLi9zcmMvanMvaGFuZGxlci9hbGxkYXkvbW92ZScpO1xudmFyIEFsbGRheU1vdmVHdWlkZSA9IHJlcXVpcmUoJy4vc3JjL2pzL2hhbmRsZXIvYWxsZGF5L21vdmVHdWlkZScpO1xudmFyIEFsbGRheVJlc2l6ZSA9IHJlcXVpcmUoJy4vc3JjL2pzL2hhbmRsZXIvYWxsZGF5L3Jlc2l6ZScpO1xudmFyIEFsbGRheVJlc2l6ZUd1aWRlID0gcmVxdWlyZSgnLi9zcmMvanMvaGFuZGxlci9hbGxkYXkvcmVzaXplR3VpZGUnKTtcblxuLyoqKioqKioqKipcbiAqIEZhY3RvcnlcbiAqKioqKioqKioqL1xudmFyIGNvbnRyb2xsZXJGYWN0b3J5ID0gcmVxdWlyZSgnLi9zcmMvanMvZmFjdG9yeS9jb250cm9sbGVyJyk7XG5cbi8qKioqKioqKioqXG4gKiBTRVJWSUNFIE1PRFVMRVxuICoqKioqKioqKiovXG52YXIgTWluaUNhbGVuZGFyID0gcmVxdWlyZSgnLi9zcmMvanMvZG9vcmF5L3ZpZXcvbWluaWNhbGVuZGFyJyk7XG52YXIgRG9vcmF5RXZlbnQgPSByZXF1aXJlKCcuL3NyYy9qcy9kb29yYXkvbW9kZWwvZXZlbnQnKTtcbnZhciBEb29yYXlDb250cm9sbGVyID0gcmVxdWlyZSgnLi9zcmMvanMvZG9vcmF5L2NvbnRyb2xsZXIvYmFzZScpO1xudmFyIFRhc2tWaWV3ID0gcmVxdWlyZSgnLi9zcmMvanMvZG9vcmF5L3ZpZXcvdGFza3ZpZXcnKTtcbnZhciBNaWxlc3RvbmVDbGljayA9IHJlcXVpcmUoJy4vc3JjL2pzL2Rvb3JheS9oYW5kbGVyL21pbGVzdG9uZUNsaWNrJyk7XG52YXIgVGFza0NsaWNrID0gcmVxdWlyZSgnLi9zcmMvanMvZG9vcmF5L2hhbmRsZXIvdGFza0NsaWNrJyk7XG5cbi8qKiBAbmFtZXNwYWNlIG5lLmRvb3JheS5jYWxlbmRhciAqL1xuXG5nbG9iYWwubmUudXRpbC5kZWZpbmVOYW1lc3BhY2UoJ25lLmRvb3JheS5jYWxlbmRhcicsIHtcbiAgICAvLyBjb21tb25cbiAgICBkaXJ0eTogZGlydHksXG4gICAgZGF0ZXRpbWU6IGRhdGV0aW1lLFxuICAgIGFycmF5OiBhcnJheSxcbiAgICBkb21ldmVudDogZG9tZXZlbnQsXG4gICAgZG9tdXRpbDogZG9tdXRpbCxcbiAgICBDb2xsZWN0aW9uOiBDb2xsZWNpdG9uLFxuICAgIG1vZGVsOiBtb2RlbCxcbiAgICBjb21tb246IGNvbW1vbixcbiAgICByZXFBbmltRnJhbWU6IHJlcUFuaW1GcmFtZSxcbiAgICBBSkFYOiBBSkFYLFxuICAgIFBvaW50OiBQb2ludCwgXG5cbiAgICAvLyBtb2RlbFxuICAgIEV2ZW50OiBFdmVudCxcbiAgICBFdmVudFZpZXdNb2RlbDogRXZlbnRWaWV3TW9kZWwsXG5cbiAgICAvLyB2aWV3XG4gICAgVmlldzogVmlldyxcbiAgICBXZWVrOiBXZWVrLFxuICAgIERheU5hbWU6IERheU5hbWUsXG4gICAgVGltZUdyaWQ6IFRpbWVHcmlkLFxuICAgIFRpbWU6IFRpbWUsXG4gICAgTW9udGhXZWVrOiBNb250aFdlZWssXG5cbiAgICAvLyBoYW5kbGVyLCBndWlkZVxuICAgIERyYWc6IERyYWcsXG5cbiAgICBUaW1lQ29yZTogVGltZUNvcmUsXG4gICAgVGltZUNsaWNrOiBUaW1lQ2xpY2ssXG4gICAgVGltZUNyZWF0aW9uOiBUaW1lQ3JlYXRpb24sXG4gICAgVGltZUNyZWF0aW9uR3VpZGU6IFRpbWVDcmVhdGlvbkd1aWRlLFxuICAgIFRpbWVNb3ZlOiBUaW1lTW92ZSxcbiAgICBUaW1lTW92ZUd1aWRlOiBUaW1lTW92ZUd1aWRlLFxuICAgIFRpbWVSZXNpemU6IFRpbWVSZXNpemUsXG4gICAgVGltZVJlc2l6ZUd1aWRlOiBUaW1lUmVzaXplR3VpZGUsXG5cbiAgICBBbGxkYXlDb3JlOiBBbGxkYXlDb3JlLFxuICAgIEFsbGRheUNsaWNrOiBBbGxkYXlDbGljayxcbiAgICBBbGxkYXlDcmVhdGlvbjogQWxsZGF5Q3JlYXRpb24sXG4gICAgQWxsZGF5Q3JlYXRpb25HdWlkZTogQWxsZGF5Q3JlYXRpb25HdWlkZSxcbiAgICBBbGxkYXlNb3ZlOiBBbGxkYXlNb3ZlLFxuICAgIEFsbGRheU1vdmVHdWlkZTogQWxsZGF5TW92ZUd1aWRlLFxuICAgIEFsbGRheVJlc2l6ZTogQWxsZGF5UmVzaXplLFxuICAgIEFsbGRheVJlc2l6ZUd1aWRlOiBBbGxkYXlSZXNpemVHdWlkZSxcblxuICAgIC8vIG9ubHkgZm9yIHRlc3RcbiAgICBDb250cm9sbGVyRmFjdG9yeTogY29udHJvbGxlckZhY3RvcnksXG5cbiAgICAvLyBzZXJ2aWNlIG1vZHVsZXNcbiAgICBEb29yYXlFdmVudDogRG9vcmF5RXZlbnQsXG4gICAgRG9vcmF5Q29udHJvbGxlcjogRG9vcmF5Q29udHJvbGxlcixcbiAgICBNaW5pQ2FsZW5kYXI6IE1pbmlDYWxlbmRhcixcbiAgICBUYXNrVmlldzogVGFza1ZpZXcsXG4gICAgTWlsZXN0b25lQ2xpY2s6IE1pbGVzdG9uZUNsaWNrLFxuICAgIFRhc2tDbGljazogVGFza0NsaWNrXG59KTtcblxuLyoqKioqKioqKipcbiAqIENhbGVuZGFyIEZhY3RvcnlcbiAqKioqKioqKioqL1xuXG52YXIgQ2FsZW5kYXIgPSByZXF1aXJlKCcuL3NyYy9qcy9mYWN0b3J5L2NhbGVuZGFyJyk7XG52YXIgU2VydmljZUNhbGVuZGFyID0gcmVxdWlyZSgnLi9zcmMvanMvZG9vcmF5L2ZhY3RvcnkvY2FsZW5kYXInKTtcblxuZ2xvYmFsLm5lLmRvb3JheS5jYWxlbmRhci5PcmlnaW5DYWxlbmRhciA9IGZ1bmN0aW9uIChvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICByZXR1cm4gbmV3IENhbGVuZGFyKG9wdGlvbnMsIGNvbnRhaW5lcik7XG59O1xuXG5nbG9iYWwubmUuZG9vcmF5LmNhbGVuZGFyLkNhbGVuZGFyID0gZnVuY3Rpb24ob3B0aW9ucywgY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG5ldyBTZXJ2aWNlQ2FsZW5kYXIob3B0aW9ucywgY29udGFpbmVyKTtcbn07XG5cbiIsIi8qIWNvZGUtc25pcHBldCB2MS4wLjQgfCBOSE4gRW50ZXJ0YWlubWVudCovXG4vKioqKioqKioqKlxuICogYXJyYXkuanNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBtb2R1bGUgaGFzIHNvbWUgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBhcnJheS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8aml1bmcua2FuZ0BuaG5lbnQuY29tPlxuICogQGRlcGVuZGVuY3kgdHlwZS5qc1xuICovXG5cbihmdW5jdGlvbihuZSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBpZiAoIW5lKSB7XG4gICAgICAgIG5lID0gd2luZG93Lm5lID0ge307XG4gICAgfVxuICAgIGlmICghbmUudXRpbCkge1xuICAgICAgICBuZS51dGlsID0gd2luZG93Lm5lLnV0aWwgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgYXBzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0b3BcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcFxuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIHZhciBhcnIgPSBuZS51dGlsLnJhbmdlKDUpO1xuICAgICAqICAgY29uc29sZS5sb2coYXJyKTsgLy8gWzAsMSwyLDMsNF1cbiAgICAgKlxuICAgICAqICAgYXJyID0gbmUudXRpbC5yYW5nZSgxLCA1KTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGFycik7IC8vIFsxLDIsMyw0XVxuICAgICAqXG4gICAgICogICBhcnIgPSBuZS51dGlsLnJhbmdlKDIsIDEwLCAyKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGFycik7IC8vIFsyLDQsNiw4XVxuICAgICAqXG4gICAgICogICBhcnIgPSBuZS51dGlsLnJhbmdlKDEwLCAyLCAtMik7XG4gICAgICogICBjb25zb2xlLmxvZyhhcnIpOyAvLyBbMTAsOCw2LDRdXG4gICAgICovXG4gICAgdmFyIHJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICAgICAgdmFyIGFyciA9IFtdLFxuICAgICAgICAgICAgZmxhZztcblxuICAgICAgICBpZiAobmUudXRpbC5pc1VuZGVmaW5lZChzdG9wKSkge1xuICAgICAgICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBzdGVwID0gc3RlcCB8fCAxO1xuICAgICAgICBmbGFnID0gc3RlcCA8IDAgPyAtMSA6IDE7XG4gICAgICAgIHN0b3AgKj0gZmxhZztcblxuICAgICAgICBmb3IoOyBzdGFydCAqIGZsYWcgPCBzdG9wOyBzdGFydCArPSBzdGVwKSB7XG4gICAgICAgICAgICBhcnIucHVzaChzdGFydCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9XG4gICAgICogQG1lbWJlcm9mIG5lLnV0aWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgdmFyIHJlc3VsdCA9IG5lLnV0aWwuemlwKFsxLCAyLCAzXSwgWydhJywgJ2InLCdjJ10sIFt0cnVlLCBmYWxzZSwgdHJ1ZV0pO1xuICAgICAqXG4gICAgICogICBjb25zb2xlLmxvZyhyZXN1bHRbMF0pOyAvLyBbMSwgJ2EnLCB0cnVlXVxuICAgICAqICAgY29uc29sZS5sb2cocmVzdWx0WzFdKTsgLy8gWzIsICdiJywgZmFsc2VdXG4gICAgICogICBjb25zb2xlLmxvZyhyZXN1bHRbMl0pOyAvLyBbMywgJ2MnLCB0cnVlXVxuICAgICAqL1xuICAgIHZhciB6aXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFycjJkID0gYXBzLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIG5lLnV0aWwuZm9yRWFjaChhcnIyZCwgZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgICAgICBuZS51dGlsLmZvckVhY2goYXJyLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdFtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIG5lLnV0aWwucmFuZ2UgPSByYW5nZTtcbiAgICBuZS51dGlsLnppcCA9IHppcDtcbn0pKHdpbmRvdy5uZSk7XG4vKioqKioqKioqKlxuICogYnJvd3Nlci5qc1xuICoqKioqKioqKiovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIG1vZHVsZSBkZXRlY3RzIHRoZSBraW5kIG9mIHdlbGwta25vd24gYnJvd3NlciBhbmQgdmVyc2lvbi5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZTAyNDJAbmhuZW50LmNvbT5cbiAqIEBuYW1lc3BhY2UgbmUudXRpbFxuICovXG5cbihmdW5jdGlvbihuZSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIW5lKSB7XG4gICAgICAgIG5lID0gd2luZG93Lm5lID0ge307XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghbmUudXRpbCkge1xuICAgICAgICBuZS51dGlsID0gd2luZG93Lm5lLnV0aWwgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG9iamVjdCBoYXMgYW4gaW5mb3JtYXRpb24gdGhhdCBpbmRpY2F0ZSB0aGUga2luZCBvZiBicm93c2VyLjxicj5cbiAgICAgKiBUaGUgbGlzdCBiZWxvdyBpcyBhIGRldGVjdGFibGUgYnJvd3NlciBsaXN0LlxuICAgICAqICAtIGllNyB+IGllMTFcbiAgICAgKiAgLSBjaHJvbWVcbiAgICAgKiAgLSBmaXJlZm94XG4gICAgICogIC0gc2FmYXJpXG4gICAgICogQG1lbWJlcm9mIG5lLnV0aWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBuZS51dGlsLmJyb3dzZXIuY2hyb21lID09PSB0cnVlOyAgICAvLyBjaHJvbWVcbiAgICAgKiAgbmUudXRpbC5icm93c2VyLmZpcmVmb3ggPT09IHRydWU7ICAgIC8vIGZpcmVmb3hcbiAgICAgKiAgbmUudXRpbC5icm93c2VyLnNhZmFyaSA9PT0gdHJ1ZTsgICAgLy8gc2FmYXJpXG4gICAgICogIG5lLnV0aWwuYnJvd3Nlci5tc2llID09PSB0cnVlOyAgICAvLyBJRVxuICAgICAqICBuZS51dGlsLmJyb3dzZXIub3RoZXIgPT09IHRydWU7ICAgIC8vIG90aGVyIGJyb3dzZXJcbiAgICAgKiAgbmUudXRpbC5icm93c2VyLnZlcnNpb247ICAgIC8vIGJyb3dzZXIgdmVyc2lvblxuICAgICAqL1xuICAgIHZhciBicm93c2VyID0ge1xuICAgICAgICBjaHJvbWU6IGZhbHNlLFxuICAgICAgICBmaXJlZm94OiBmYWxzZSxcbiAgICAgICAgc2FmYXJpOiBmYWxzZSxcbiAgICAgICAgbXNpZTogZmFsc2UsXG4gICAgICAgIG90aGVyczogZmFsc2UsXG4gICAgICAgIHZlcnNpb246IDBcbiAgICB9O1xuXG4gICAgdmFyIG5hdiA9IHdpbmRvdy5uYXZpZ2F0b3IsXG4gICAgICAgIGFwcE5hbWUgPSBuYXYuYXBwTmFtZS5yZXBsYWNlKC9cXHMvZywgJ18nKSxcbiAgICAgICAgdXNlckFnZW50ID0gbmF2LnVzZXJBZ2VudDtcblxuICAgIHZhciBySUUgPSAvTVNJRVxccyhbMC05XStbLjAtOV0qKS8sXG4gICAgICAgIHJJRTExID0gL1RyaWRlbnQuKnJ2OjExXFwuLyxcbiAgICAgICAgdmVyc2lvblJlZ2V4ID0ge1xuICAgICAgICAgICAgJ2ZpcmVmb3gnOiAvRmlyZWZveFxcLyhcXGQrKVxcLi8sXG4gICAgICAgICAgICAnY2hyb21lJzogL0Nocm9tZVxcLyhcXGQrKVxcLi8sXG4gICAgICAgICAgICAnc2FmYXJpJzogL1ZlcnNpb25cXC8oW1xcZFxcLl0rKVxcc1NhZmFyaVxcLyhcXGQrKS9cbiAgICAgICAgfTtcblxuICAgIHZhciBrZXksIHRtcDtcblxuICAgIHZhciBkZXRlY3RvciA9IHtcbiAgICAgICAgJ01pY3Jvc29mdF9JbnRlcm5ldF9FeHBsb3Jlcic6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gaWU4IH4gaWUxMFxuICAgICAgICAgICAgYnJvd3Nlci5tc2llID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyb3dzZXIudmVyc2lvbiA9IHBhcnNlRmxvYXQodXNlckFnZW50Lm1hdGNoKHJJRSlbMV0pO1xuICAgICAgICB9LFxuICAgICAgICAnTmV0c2NhcGUnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkZXRlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAocklFMTEuZXhlYyh1c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICAgICAgYnJvd3Nlci5tc2llID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicm93c2VyLnZlcnNpb24gPSAxMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gdmVyc2lvblJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uUmVnZXguaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gdXNlckFnZW50Lm1hdGNoKHZlcnNpb25SZWdleFtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXAgJiYgdG1wLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicm93c2VyW2tleV0gPSBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci52ZXJzaW9uID0gcGFyc2VGbG9hdCh0bXBbMV0gfHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRldGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgYnJvd3Nlci5vdGhlcnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGRldGVjdG9yW2FwcE5hbWVdKCk7XG4gICAgbmUudXRpbC5icm93c2VyID0gYnJvd3Nlcjtcbn0pKHdpbmRvdy5uZSk7XG5cbi8qKioqKioqKioqXG4gKiBjb2xsZWN0aW9uLmpzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgbW9kdWxlIGhhcyBzb21lIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgb2JqZWN0IGFzIGNvbGxlY3Rpb24uXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGUwMjQyQG5obmVudC5jb20+XG4gKiBAZGVwZW5kZW5jeSB0eXBlLmpzLCBvYmplY3QuanNcbiAqL1xuXG4oZnVuY3Rpb24obmUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKCFuZSkge1xuICAgICAgICBuZSA9IHdpbmRvdy5uZSA9IHt9O1xuICAgIH1cbiAgICBpZiAoIW5lLnV0aWwpIHtcbiAgICAgICAgbmUudXRpbCA9IHdpbmRvdy5uZS51dGlsID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyB2YXJpYWJsZSBzYXZlcyB3aGV0aGVyIHRoZSAnaW5kZXhPZicgbWV0aG9kIGlzIGluIEFycmF5LnByb3RvdHlwZSBvciBub3QuPGJyPlxuICAgICAqIEFuZCBpdCB3aWxsIGJlIGNoZWNrZWQgb25seSBvbmNlIHdoZW4gdGhlIHBhZ2UgaXMgbG9hZGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHZhciBoYXNJbmRleE9mID0gISFBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIG9uY2UgZm9yIGVhY2ggZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheShvciBBcnJheS1saWtlIG9iamVjdCkgaW4gYXNjZW5kaW5nIG9yZGVyLjxicj5cbiAgICAgKiBJZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSwgdGhlIGxvb3Agd2lsbCBiZSBzdG9wcGVkLjxicj5cbiAgICAgKiBDYWxsYmFjayBmdW5jdGlvbihpdGVyYXRlZSkgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAgLSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnRcbiAgICAgKiAgLSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnRcbiAgICAgKiAgLSBUaGUgYXJyYXkob3IgQXJyYXktbGlrZSBvYmplY3QpIGJlaW5nIHRyYXZlcnNlZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyciBUaGUgYXJyYXkob3IgQXJyYXktbGlrZSBvYmplY3QpIHRoYXQgd2lsbCBiZSB0cmF2ZXJzZWRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ29udGV4dCh0aGlzKSBvZiBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgdmFyIHN1bSA9IDA7XG4gICAgICpcbiAgICAgKiAgZm9yRWFjaEFycmF5KFsxLDIsM10sIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgKiAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgKiAgIH0pO1xuICAgICAqICBhbGVydChzdW0pOyAvLyA2XG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFyciwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICAgIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgbnVsbDtcblxuICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChpdGVyYXRlZS5jYWxsKGNvbnRleHQsIGFycltpbmRleF0sIGluZGV4LCBhcnIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBvbmNlIGZvciBlYWNoIHByb3BlcnR5IG9mIG9iamVjdCB3aGljaCBhY3R1YWxseSBleGlzdC48YnI+XG4gICAgICogSWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UsIHRoZSBsb29wIHdpbGwgYmUgc3RvcHBlZC48YnI+XG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb24oaXRlcmF0ZWUpIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogIC0gVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqICAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqICAtIFRoZSBvYmplY3QgYmVpbmcgdHJhdmVyc2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRoYXQgd2lsbCBiZSB0cmF2ZXJzZWRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSAgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQodGhpcykgb2YgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciBzdW0gPSAwO1xuICAgICAqXG4gICAgICogIGZvckVhY2hPd25Qcm9wZXJ0aWVzKHthOjEsYjoyLGM6M30sIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgKiAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgKiAgfSk7XG4gICAgICogIGFsZXJ0KHN1bSk7IC8vIDZcbiAgICAgKiovXG4gICAgZnVuY3Rpb24gZm9yRWFjaE93blByb3BlcnRpZXMob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICB2YXIga2V5O1xuXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IG51bGw7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlcmF0ZWUuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBvbmNlIGZvciBlYWNoIHByb3BlcnR5IG9mIG9iamVjdChvciBlbGVtZW50IG9mIGFycmF5KSB3aGljaCBhY3R1YWxseSBleGlzdC48YnI+XG4gICAgICogSWYgdGhlIG9iamVjdCBpcyBBcnJheS1saWtlIG9iamVjdChleC1hcmd1bWVudHMgb2JqZWN0KSwgSXQgbmVlZHMgdG8gdHJhbnNmb3JtIHRvIEFycmF5LihzZWUgJ2V4Micgb2YgZXhhbXBsZSkuPGJyPlxuICAgICAqIElmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIGZhbHNlLCB0aGUgbG9vcCB3aWxsIGJlIHN0b3BwZWQuPGJyPlxuICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uKGl0ZXJhdGVlKSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICAtIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkob3IgVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50KVxuICAgICAqICAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eShvciBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQpXG4gICAgICogIC0gVGhlIG9iamVjdCBiZWluZyB0cmF2ZXJzZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIHRyYXZlcnNlZFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0KHRoaXMpIG9mIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG5lLnV0aWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAvL2V4MVxuICAgICAqICB2YXIgc3VtID0gMDtcbiAgICAgKlxuICAgICAqICBmb3JFYWNoKFsxLDIsM10sIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgKiAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgKiAgfSk7XG4gICAgICogIGFsZXJ0KHN1bSk7IC8vIDZcbiAgICAgKlxuICAgICAqICAvL2V4MiAtIEluIGNhc2Ugb2YgQXJyYXktbGlrZSBvYmplY3RcbiAgICAgKiAgZnVuY3Rpb24gc3VtKCl7XG4gICAgICogICAgICB2YXIgZmFjdG9ycyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICogICAgICBmb3JFYWNoKGZhY3RvcnMsIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgKiAgICAgICAgICAgLy8uLi4uLi5cbiAgICAgKiAgICAgIH0pO1xuICAgICAqICB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaChvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChuZS51dGlsLmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgbmUudXRpbC5mb3JFYWNoQXJyYXkob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZS51dGlsLmZvckVhY2hPd25Qcm9wZXJ0aWVzKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gb25jZSBmb3IgZWFjaCBlbGVtZW50IGluIGFuIGFycmF5LCBpbiBvcmRlciwgYW5kIGNvbnN0cnVjdHMgYSBuZXcgYXJyYXkgZnJvbSB0aGUgcmVzdWx0cy48YnI+XG4gICAgICogSWYgdGhlIG9iamVjdCBpcyBBcnJheS1saWtlIG9iamVjdChleC1hcmd1bWVudHMgb2JqZWN0KSwgSXQgbmVlZHMgdG8gdHJhbnNmb3JtIHRvIEFycmF5LihzZWUgJ2V4Micgb2YgZm9yRWFjaCBleGFtcGxlKTxicj5cbiAgICAgKiBDYWxsYmFjayBmdW5jdGlvbihpdGVyYXRlZSkgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAgLSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5KG9yIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudClcbiAgICAgKiAgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkob3IgVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50KVxuICAgICAqICAtIFRoZSBvYmplY3QgYmVpbmcgdHJhdmVyc2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRoYXQgd2lsbCBiZSB0cmF2ZXJzZWRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ29udGV4dCh0aGlzKSBvZiBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgY29tcG9zZWQgb2YgcmV0dXJuZWQgdmFsdWVzIGZyb20gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciByZXN1bHQgPSBtYXAoWzAsMSwyLDNdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgICAgcmV0dXJuIHZhbHVlICsgMTtcbiAgICAgKiAgfSk7XG4gICAgICpcbiAgICAgKiAgYWxlcnQocmVzdWx0KTsgIC8vIDEsMiwzLDRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmVzdWx0QXJyYXkgPSBbXTtcblxuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBudWxsO1xuXG4gICAgICAgIG5lLnV0aWwuZm9yRWFjaChvYmosIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVzdWx0QXJyYXkucHVzaChpdGVyYXRlZS5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdEFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIG9uY2UgZm9yIGVhY2ggZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheShvciBBcnJheS1saWtlIG9iamVjdCBvciBwbGFpbiBvYmplY3QpLjxicj5cbiAgICAgKiBJZiB0aGUgb2JqZWN0IGlzIEFycmF5LWxpa2Ugb2JqZWN0KGV4LWFyZ3VtZW50cyBvYmplY3QpLCBJdCBuZWVkcyB0byB0cmFuc2Zvcm0gdG8gQXJyYXkuKHNlZSAnZXgyJyBvZiBmb3JFYWNoIGV4YW1wbGUpPGJyPlxuICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uKGl0ZXJhdGVlKSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gICAgICogIC0gVGhlIHByZXZpb3VzVmFsdWVcbiAgICAgKiAgLSBUaGUgY3VycmVudFZhbHVlXG4gICAgICogIC0gVGhlIGluZGV4XG4gICAgICogIC0gVGhlIG9iamVjdCBiZWluZyB0cmF2ZXJzZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIHRyYXZlcnNlZFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0KHRoaXMpIG9mIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMgeyp9IFRoZSByZXN1bHQgdmFsdWVcbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciByZXN1bHQgPSByZWR1Y2UoWzAsMSwyLDNdLCBmdW5jdGlvbihzdG9yZWQsIHZhbHVlKSB7XG4gICAgICogICAgICByZXR1cm4gc3RvcmVkICsgdmFsdWU7XG4gICAgICogIH0pO1xuICAgICAqXG4gICAgICogIGFsZXJ0KHJlc3VsdCk7IC8vIDZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2Uob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICB2YXIga2V5cyxcbiAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgIHN0b3JlO1xuXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IG51bGw7XG5cbiAgICAgICAgaWYgKCFuZS51dGlsLmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAga2V5cyA9IG5lLnV0aWwua2V5cyhvYmopO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0ga2V5cyA/IGtleXMubGVuZ3RoIDogb2JqLmxlbmd0aDtcblxuICAgICAgICBzdG9yZSA9IG9ialtrZXlzID8ga2V5c1tpbmRleCsrXSA6IGluZGV4KytdO1xuXG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgc3RvcmUgPSBpdGVyYXRlZS5jYWxsKGNvbnRleHQsIHN0b3JlLCBvYmpba2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXhdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdG9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIHRoZSBBcnJheS1saWtlIG9iamVjdCB0byBBcnJheS48YnI+XG4gICAgICogSW4gbG93IElFIChiZWxvdyA4KSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwgaXMgbm90IHBlcmZlY3QuIFNvLCB0cnktY2F0Y2ggc3RhdGVtZW50IGlzIHVzZWQuXG4gICAgICogQHBhcmFtIHsqfSBhcnJheUxpa2UgQXJyYXktbGlrZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXlcbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciBhcnJheUxpa2UgPSB7XG4gICAgICogICAgICAwOiAnb25lJyxcbiAgICAgKiAgICAgIDE6ICd0d28nLFxuICAgICAqICAgICAgMjogJ3RocmVlJyxcbiAgICAgKiAgICAgIDM6ICdmb3VyJyxcbiAgICAgKiAgICAgIGxlbmd0aDogNFxuICAgICAqICB9O1xuICAgICAqICB2YXIgcmVzdWx0ID0gdG9BcnJheShhcnJheUxpa2UpO1xuICAgICAqXG4gICAgICogIGFsZXJ0KHJlc3VsdCBpbnN0YW5jZW9mIEFycmF5KTsgLy8gdHJ1ZVxuICAgICAqICBhbGVydChyZXN1bHQpOyAvLyBvbmUsdHdvLHRocmVlLGZvdXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0FycmF5KGFycmF5TGlrZSkge1xuICAgICAgICB2YXIgYXJyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXJyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXJyID0gW107XG4gICAgICAgICAgICBmb3JFYWNoQXJyYXkoYXJyYXlMaWtlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGFycmF5IG9yIHBsYWluIG9iamVjdCB3aXRoIGFsbCBlbGVtZW50cyhvciBwcm9wZXJ0aWVzKSB0aGF0IHBhc3MgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLjxicj5cbiAgICAgKiBDYWxsYmFjayBmdW5jdGlvbihpdGVyYXRlZSkgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAgLSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5KG9yIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudClcbiAgICAgKiAgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkob3IgVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50KVxuICAgICAqICAtIFRoZSBvYmplY3QgYmVpbmcgdHJhdmVyc2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QocGxhaW4gb2JqZWN0IG9yIEFycmF5KSB0aGF0IHdpbGwgYmUgdHJhdmVyc2VkXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQodGhpcykgb2YgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBwbGFpbiBvYmplY3Qgb3IgQXJyYXlcbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciByZXN1bHQxID0gZmlsdGVyKFswLDEsMiwzXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICAgIHJldHVybiAodmFsdWUgJSAyID09PSAwKTtcbiAgICAgKiAgfSk7XG4gICAgICogIGFsZXJ0KHJlc3VsdDEpOyAvLyAwLDJcbiAgICAgKlxuICAgICAqICB2YXIgcmVzdWx0MiA9IGZpbHRlcih7YSA6IDEsIGI6IDIsIGM6IDN9LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgICAgcmV0dXJuICh2YWx1ZSAlIDIgIT09IDApO1xuICAgICAqICB9KTtcbiAgICAgKiAgYWxlcnQocmVzdWx0Mi5hKTsgLy8gMVxuICAgICAqICBhbGVydChyZXN1bHQyLmIpOyAvLyB1bmRlZmluZWRcbiAgICAgKiAgYWxlcnQocmVzdWx0Mi5jKTsgLy8gM1xuICAgICAqL1xuICAgIHZhciBmaWx0ZXIgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgICBhZGQ7XG5cbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgbnVsbDtcblxuICAgICAgICBpZiAoIW5lLnV0aWwuaXNPYmplY3Qob2JqKSB8fCAhbmUudXRpbC5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwYXJhbWV0ZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZS51dGlsLmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBhZGQgPSBmdW5jdGlvbihyZXN1bHQsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhcmdzWzBdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGFkZCA9IGZ1bmN0aW9uKHJlc3VsdCwgYXJncykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFthcmdzWzFdXSA9IGFyZ3NbMF07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgbmUudXRpbC5mb3JFYWNoKG9iaiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoaXRlcmF0ZWUuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgIGFkZChyZXN1bHQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNvbnRleHQpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIGFycmF5IGZyb20gc3RhcnQgaW5kZXgoZGVmYXVsdCAwKSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuPGJyPlxuICAgICAqIEl0IGNvbXBhcmVzIHNlYXJjaEVsZW1lbnQgdG8gZWxlbWVudHMgb2YgdGhlIEFycmF5IHVzaW5nIHN0cmljdCBlcXVhbGl0eSAodGhlIHNhbWUgbWV0aG9kIHVzZWQgYnkgdGhlID09PSwgb3IgdHJpcGxlLWVxdWFscywgb3BlcmF0b3IpLlxuICAgICAqIEBwYXJhbSB7Kn0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBBcnJheSB0aGF0IHdpbGwgYmUgdHJhdmVyc2VkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IFN0YXJ0IGluZGV4IGluIGFycmF5IGZvciBzZWFyY2hpbmcgKGRlZmF1bHQgMClcbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIEZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICB2YXIgYXJyID0gWydvbmUnLCAndHdvJywgJ3RocmVlJywgJ2ZvdXInXSxcbiAgICAgKiAgICAgICBpZHgxLFxuICAgICAqICAgICAgIGlkeDI7XG4gICAgICpcbiAgICAgKiAgIGlkeDEgPSBuZS51dGlsLmluQXJyYXkoJ29uZScsIGFyciwgMyk7XG4gICAgICogICBhbGVydChpZHgxKTsgLy8gLTFcbiAgICAgKlxuICAgICAqICAgaWR4MiA9IG5lLnV0aWwuaW5BcnJheSgnb25lJywgYXJyKTtcbiAgICAgKiAgIGFsZXJ0KGlkeDIpOyAvLyAwXG4gICAgICovXG4gICAgdmFyIGluQXJyYXkgPSBmdW5jdGlvbihzZWFyY2hFbGVtZW50LCBhcnJheSwgc3RhcnRJbmRleCkge1xuICAgICAgICBpZiAoIW5lLnV0aWwuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNJbmRleE9mKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnJheSwgc2VhcmNoRWxlbWVudCwgc3RhcnRJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgICAvLyBzZXQgc3RhcnRJbmRleFxuICAgICAgICBpZiAobmUudXRpbC5pc1VuZGVmaW5lZChzdGFydEluZGV4KSkge1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnRJbmRleCA+PSBsZW5ndGggfHwgc3RhcnRJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNlYXJjaFxuICAgICAgICBmb3IgKGkgPSBzdGFydEluZGV4OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJheVtpXSA9PT0gc2VhcmNoRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBmZXRjaGluZyBhIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyIHRhcmdldCBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBwcm9wZXJ0eSBwcm9wZXJ0eSBuYW1lXG4gICAgICogQG1lbWJlcm9mIG5lLnV0aWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgIHZhciBvYmpBcnIgPSBbXG4gICAgICogICAgICAgICB7J2FiYyc6IDEsICdkZWYnOiAyLCAnZ2hpJzogM30sXG4gICAgICogICAgICAgICB7J2FiYyc6IDQsICdkZWYnOiA1LCAnZ2hpJzogNn0sXG4gICAgICogICAgICAgICB7J2FiYyc6IDcsICdkZWYnOiA4LCAnZ2hpJzogOX1cbiAgICAgKiAgICAgICBdLFxuICAgICAqICAgICAgIGFycjJkID0gW1xuICAgICAqICAgICAgICAgWzEsIDIsIDNdLFxuICAgICAqICAgICAgICAgWzQsIDUsIDZdLFxuICAgICAqICAgICAgICAgWzcsIDgsIDldXG4gICAgICogICAgICAgXSxcbiAgICAgKiAgICAgICByZXN1bHQ7XG4gICAgICpcbiAgICAgKiAgIHJlc3VsdCA9IG5lLnV0aWwucGx1Y2sob2JqQXJyLCAnYWJjJyk7XG4gICAgICogICBjb25zb2xlLmxvZyhyZXN1bHQpIC8vIFsxLCA0LCA3XVxuICAgICAqXG4gICAgICogICByZXN1bHQgPSBuZS51dGlsLnBsdWNrKGFycjJkLCAyKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHJlc3VsdCkgLy8gWzMsIDYsIDldXG4gICAgICovXG4gICAgdmFyIHBsdWNrID0gZnVuY3Rpb24oYXJyLCBwcm9wZXJ0eSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmUudXRpbC5tYXAoYXJyLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbVtwcm9wZXJ0eV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBuZS51dGlsLmZvckVhY2hPd25Qcm9wZXJ0aWVzID0gZm9yRWFjaE93blByb3BlcnRpZXM7XG4gICAgbmUudXRpbC5mb3JFYWNoQXJyYXkgPSBmb3JFYWNoQXJyYXk7XG4gICAgbmUudXRpbC5mb3JFYWNoID0gZm9yRWFjaDtcbiAgICBuZS51dGlsLnRvQXJyYXkgPSB0b0FycmF5O1xuICAgIG5lLnV0aWwubWFwID0gbWFwO1xuICAgIG5lLnV0aWwucmVkdWNlID0gcmVkdWNlO1xuICAgIG5lLnV0aWwuZmlsdGVyID0gZmlsdGVyO1xuICAgIG5lLnV0aWwuaW5BcnJheSA9IGluQXJyYXk7XG4gICAgbmUudXRpbC5wbHVjayA9IHBsdWNrO1xuXG59KSh3aW5kb3cubmUpO1xuXG4vKioqKioqKioqKlxuICogY3VzdG9tRXZlbnQuanNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqICBUaGlzIG1vZHVsZSBwcm92aWRlcyBzb21lIGZ1bmN0aW9ucyBmb3IgY3VzdG9tIGV2ZW50cy48YnI+XG4gKiAgQW5kIGl0IGlzIGltcGxlbWVudGVkIGluIHRoZSBvYnNlcnZlciBkZXNpZ24gcGF0dGVybi5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZTAyNDJAbmhuZW50LmNvbT5cbiAqIEBkZXBlbmRlbmN5IHR5cGUuanMsIGNvbGxlY3Rpb24uanMgb2JqZWN0LmpzXG4gKi9cblxuKGZ1bmN0aW9uKG5lKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghbmUpIHtcbiAgICAgICAgbmUgPSB3aW5kb3cubmUgPSB7fTtcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIW5lLnV0aWwpIHtcbiAgICAgICAgbmUudXRpbCA9IHdpbmRvdy5uZS51dGlsID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSB1bml0IG9mIGV2ZW50IGhhbmRsZXIgaXRlbS5cbiAgICAgKiBAaWdub3JlXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gaGFuZGxlckl0ZW1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBmbiAtIGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcHJvcGVydHkgeyp9IGN0eCAtIGNvbnRleHQgb2YgZXZlbnQgaGFuZGxlclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBkYXRhIHN0cnVjdHVyZSBmb3Igc3RvcmluZyBoYW5kbGVySXRlbXMgYm91bmQgd2l0aCBhIHNwZWNpZmljIGNvbnRleHRcbiAgICAgKiAgYW5kIGlzIGEgdW5pdCBpdGVtIG9mIGN0eEV2ZW50cy48YnI+XG4gICAgICogSGFuZGxlcnMgaW4gdGhpcyBpdGVtLCB3aWxsIGJlIGV4ZWN1dGVkIHdpdGggc2FtZSBldmVudC5cbiAgICAgKiBAaWdub3JlXG4gICAgICogQHR5cGVkZWYge09iamVjdC48c3RyaW5nLCBoYW5kbGVySXRlbT59IGN0eEV2ZW50c0l0ZW1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBjdHhFdmVudHNJdGVtID0ge1xuICAgICAqICAgICAgMV8xOiB7XG4gICAgICogICAgICAgICAgZm46IGZ1bmN0aW9uKCl7Li4ufSxcbiAgICAgKiAgICAgICAgICBjdHg6IGNvbnRleHQxXG4gICAgICogICAgICB9LFxuICAgICAqICAgICAgMl8xOiB7XG4gICAgICogICAgICAgICAgZm46IGZ1bmN0aW9uKCl7Li4ufSxcbiAgICAgKiAgICAgICAgICBjdHg6IGNvbnRleHQxXG4gICAgICogICAgICB9XG4gICAgICogIH1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZGF0YSBzdHJ1Y3R1cmUgZm9yIHN0b3JpbmcgY3R4RXZlbnRzSXRlbSBhbmQgbGVuZ3RoIGZvciBlYWNoIGV2ZW50KG9yIGV2ZW50IG5hbWUpLlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0LjxzdHJpbmcsIChjdHhFdmVudHNJdGVtfG51bWJlcik+fSBjdHhFdmVudHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBjdHhFdmVudHMgPSB7XG4gICAgICogICAgICBldmVudE5hbWUxX2lkeDoge1xuICAgICAqICAgICAgICAgIDFfMToge1xuICAgICAqICAgICAgICAgICAgICBmbjogZnVuY3Rpb24oKXsuLi59LFxuICAgICAqICAgICAgICAgICAgICBjdHg6IGNvbnRleHQxXG4gICAgICogICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgICAyXzE6IHtcbiAgICAgKiAgICAgICAgICAgICAgZm46IGZ1bmN0aW9uKCl7Li4ufSxcbiAgICAgKiAgICAgICAgICAgICAgY3R4OiBjb250ZXh0MVxuICAgICAqICAgICAgICAgIH1cbiAgICAgKiAgICAgIH0sXG4gICAgICogICAgICBldmVudE5hbWUxX2xlbjogMixcbiAgICAgKiAgICAgIGV2ZW50TmFtZTJfaWR4OiB7XG4gICAgICogICAgICAgICAgM18yOiB7XG4gICAgICogICAgICAgICAgICAgIGZuOiBmdW5jdGlvbigpey4uLn0sXG4gICAgICogICAgICAgICAgICAgIGN0eDogY29udGV4dDJcbiAgICAgKiAgICAgICAgICB9LFxuICAgICAqICAgICAgICAgIDRfMjoge1xuICAgICAqICAgICAgICAgICAgICBmbjogZnVuY3Rpb24oKXsuLi59LFxuICAgICAqICAgICAgICAgICAgICBjdHg6IGNvbnRleHQyXG4gICAgICogICAgICAgICAgfVxuICAgICAqICAgICAgfSxcbiAgICAgKiAgICAgIGV2ZW50TmFtZTJfbGVuOiAyXG4gICAgICogIH07XG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnRzKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FjaGluZyBhIGRhdGEgc3RydWN0dXJlIHRoYXQgaGFzIG5vcm1hbCBldmVudCBoYW5kbGVycyB3aGljaCBhcmUgbm90IGJvdW5kIHdpdGggYSBzcGVjaWZpYyBjb250ZXh0LlxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0LjxzdHJpbmcsIGhhbmRsZXJJdGVtW10+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZXZlbnRzID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FjaGluZyBhIHtjdHhFdmVudHN9XG4gICAgICAgICAqIEB0eXBlIHtjdHhFdmVudHN9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jdHhFdmVudHMgPSBudWxsO1xuICAgIH1cblxuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiBzdGF0aWNcbiAgICAgKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIFVzZSBmb3IgbWFraW5nIGEgY29uc3RydWN0b3IgdG8gYmUgYWJsZSB0byBkbyBDdXN0b21FdmVudCdzIGZ1bmN0aW9ucy5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIC0gQ29uc3RydWN0b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBmdW5jdGlvbiBNb2RlbCgpIHtcbiAgICAgKiAgICAgIHRoaXMubmFtZSA9ICcnO1xuICAgICAqICB9XG4gICAgICogIG5lLnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKE1vZGVsKTtcbiAgICAgKlxuICAgICAqICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoKTtcbiAgICAgKiAgbW9kZWwub24oJ2NoYW5nZScsIGZ1bmN0aW9uKCkgeyB0aGlzLm5hbWUgPSAnbW9kZWwnOyB9LCB0aGlzKTtcbiAgICAgKiAgbW9kZWwuZmlyZSgnY2hhbmdlJyk7XG4gICAgICogIGFsZXJ0KG1vZGVsLm5hbWUpOyAvLyAnbW9kZWwnO1xuICAgICAqL1xuICAgIEN1c3RvbUV2ZW50cy5taXhpbiA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgbmUudXRpbC5leHRlbmQoZnVuYy5wcm90b3R5cGUsIEN1c3RvbUV2ZW50cy5wcm90b3R5cGUpO1xuICAgIH07XG5cbiAgICAvKioqKioqKioqKlxuICAgICAqIHByaXZhdGVcbiAgICAgKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIFdvcmsgc2ltaWxhcmx5IHRvIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKCksXG4gICAgICogIGhvd2V2ZXIgZG9lcyBBcnJheS5wcm90b3R5cGUuc3BsaWNlKCkgYWRkaXRpb25hbGx5Ljxicj5cbiAgICAgKiBDYWxsYmFjayhpdGVyYXRlZSkgZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICAgICAqICAtIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudFxuICAgICAqICAtIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudFxuICAgICAqICAtIFRoZSBhcnJheSBiZWluZyB0cmF2ZXJzZWRcbiAgICAgKiAgLSBBIHNwZWNpYWwgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBkZWNyZWFzZXMgdGhlIGxlbmd0aCBvZiBhcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyciAtIEFycmF5IHRoYXQgd2lsbCBiZSB0cmF2ZXJzZWRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICovXG4gICAgQ3VzdG9tRXZlbnRzLnByb3RvdHlwZS5fZm9yRWFjaEFycmF5U3BsaWNlID0gZnVuY3Rpb24oYXJyLCBpdGVyYXRlZSkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGxlbixcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICBkZWNyZWFzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgbGVuIC09IDE7XG4gICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAoIW5lLnV0aWwuaXNFeGlzdHkoYXJyKSB8fCAhbmUudXRpbC5pc0FycmF5KGFycikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGFycltpXTtcblxuICAgICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZW0sIGksIGFyciwgZGVjcmVhc2UpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKioqKioqKioqKlxuICAgICAqIGNvbnRleHQgZXZlbnQgaGFuZGxlclxuICAgICAqKioqKioqKioqL1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBjdHhFdmVudHNJdGVtLjxicj5cbiAgICAgKiBDYWxsYmFjayBmdW5jdGlvbihpdGVyYXRlZSkgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAgLSB7Y3R4RXZlbnRzSXRlbX0gQSB1bml0IGl0ZW0gb2YgY3R4RXZlbnRzXG4gICAgICogIC0ge3N0cmluZ30gQSBrZXkgKGV4IC0gJ2V2ZW50TmFtZV9pZHgnIG9yICdldmVudE5hbWVfbGVuJylcbiAgICAgKiAgLSB7Y3R4RXZlbnRzfSBBIGN0eEV2ZW50cyBiZWluZyB0cmF2ZXJzZWRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDdXN0b21FdmVudHMucHJvdG90eXBlLl9lYWNoQ3R4RXZlbnRzID0gZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2N0eEV2ZW50cztcbiAgICAgICAgbmUudXRpbC5mb3JFYWNoT3duUHJvcGVydGllcyhldmVudHMsIGl0ZXJhdGVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgY2FsbGJhY2sgb25jZVxuICAgICAqICBmb3IgZWFjaCBoYW5kbGVyIGl0ZW0gdGhhdCBpcyB2YWx1ZSBvZiB0aGUga2V5IGluY2x1ZGluZyBhIHNwZWNpZmljIHN0cmluZyg9aWQsIGFyZ3VtZW50c1sxXSkuPGJyPlxuICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uKGl0ZXJhdGVlKSBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czpcbiAgICAgKiAgLSBoYW5kbGVySXRlbVxuICAgICAqICAtIGhhbmRsZXJJdGVtSWRcbiAgICAgKiBAcGFyYW0ge2N0eEV2ZW50c0l0ZW19IGN0eEV2ZW50c0l0ZW0gLSBBIGRhdGEgc3RydWN0dXJlIHN0b3JpbmcgaGFuZGxlckl0ZW1zLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIEFuIGlkIG9mIGhhbmRsZXIgZm9yIHNlYXJjaGluZ1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEN1c3RvbUV2ZW50cy5wcm90b3R5cGUuX2VhY2hDdHhIYW5kbGVySXRlbUJ5Q29udGFpbklkID0gZnVuY3Rpb24oY3R4RXZlbnRzSXRlbSwgaWQsIGl0ZXJhdGVlKSB7XG4gICAgICAgIG5lLnV0aWwuZm9yRWFjaE93blByb3BlcnRpZXMoY3R4RXZlbnRzSXRlbSwgZnVuY3Rpb24oaGFuZGxlckl0ZW0sIGhhbmRsZXJJdGVtSWQpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVySXRlbUlkLmluZGV4T2YoaWQpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRlZShoYW5kbGVySXRlbSwgaGFuZGxlckl0ZW1JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBjYWxsYmFjayBvbmNlXG4gICAgICogIGZvciBlYWNoIGNhc2Ugb2Ygd2hlbiB0aGUgcHJvdmlkZWQgaGFuZGxlcihhcmd1bWVudHNbMF0pIGlzIGVxdWFsIHRvIGEgaGFuZGxlciBpbiBjdHhFdmVudHNJdGVtLjxicj5cbiAgICAgKiBDYWxsYmFjayBmdW5jdGlvbihpdGVyYXRlZSkgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICAgICAqICAtIGhhbmRsZXJJdGVtXG4gICAgICogIC0gaGFuZGxlckl0ZW1JZFxuICAgICAqICAtIGN0eEV2ZW50c0l0ZW1cbiAgICAgKiAgLSBldmVudEtleSwgQSBOYW1lIG9mIGN1c3RvbSBldmVudCAoZXggLSAnZXZlbnROYW1lX2lkeCcpXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIEV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDdXN0b21FdmVudHMucHJvdG90eXBlLl9lYWNoQ3R4RXZlbnRCeUhhbmRsZXIgPSBmdW5jdGlvbihoYW5kbGVyLCBpdGVyYXRlZSkge1xuICAgICAgICB2YXIgaGFuZGxlcklkID0gbmUudXRpbC5zdGFtcChoYW5kbGVyKSxcbiAgICAgICAgICAgIGVhY2hCeUlkID0gdGhpcy5fZWFjaEN0eEhhbmRsZXJJdGVtQnlDb250YWluSWQ7XG5cbiAgICAgICAgdGhpcy5fZWFjaEN0eEV2ZW50cyhmdW5jdGlvbihjdHhFdmVudHNJdGVtLCBldmVudEtleSkge1xuICAgICAgICAgICAgZWFjaEJ5SWQoY3R4RXZlbnRzSXRlbSwgaGFuZGxlcklkLCBmdW5jdGlvbihoYW5kbGVySXRlbSwgaGFuZGxlckl0ZW1JZCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdGVlKGhhbmRsZXJJdGVtLCBoYW5kbGVySXRlbUlkLCBjdHhFdmVudHNJdGVtLCBldmVudEtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIGNhbGxiYWNrIG9uY2VcbiAgICAgKiAgZm9yIGVhY2ggY2FzZSBvZiB3aGVuIHRoZSBwcm92aWRlZCBjb250ZXh0KGFyZ3VtZW50c1swXSkgaXMgZXF1YWwgdG8gYSBjb250ZXh0IGluIGN0eEV2ZW50c0l0ZW0uPGJyPlxuICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uKGl0ZXJhdGVlKSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gICAgICogIC0gaGFuZGxlckl0ZW1cbiAgICAgKiAgLSBoYW5kbGVySXRlbUlkXG4gICAgICogIC0gY3R4RXZlbnRzSXRlbVxuICAgICAqICAtIGV2ZW50S2V5LCBBIE5hbWUgb2YgY3VzdG9tIGV2ZW50IHdpdGggcG9zdGZpeCAoZXggLSAnZXZlbnROYW1lX2lkeCcpXG4gICAgICogQHBhcmFtIHsqfSBjb250ZXh0IC0gQ29udGV4dCBmb3Igc2VhcmNoaW5nXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgLSBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ3VzdG9tRXZlbnRzLnByb3RvdHlwZS5fZWFjaEN0eEV2ZW50QnlDb250ZXh0ID0gZnVuY3Rpb24oY29udGV4dCwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGNvbnRleHRJZCA9IG5lLnV0aWwuc3RhbXAoY29udGV4dCksXG4gICAgICAgICAgICBlYWNoQnlJZCA9IHRoaXMuX2VhY2hDdHhIYW5kbGVySXRlbUJ5Q29udGFpbklkO1xuXG4gICAgICAgIHRoaXMuX2VhY2hDdHhFdmVudHMoZnVuY3Rpb24oY3R4RXZlbnRzSXRlbSwgZXZlbnRLZXkpIHtcbiAgICAgICAgICAgIGVhY2hCeUlkKGN0eEV2ZW50c0l0ZW0sIGNvbnRleHRJZCwgZnVuY3Rpb24oaGFuZGxlckl0ZW0sIGhhbmRsZXJJdGVtSWQpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRlZShoYW5kbGVySXRlbSwgaGFuZGxlckl0ZW1JZCwgY3R4RXZlbnRzSXRlbSwgZXZlbnRLZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBjYWxsYmFjayBvbmNlIGZvciBlYWNoIGhhbmRsZXIgb2YgY3R4RXZlbnRzSXRlbSBvZiB0aGUgcHJvdmlkZWQgZXZlbnROYW1lKGFyZ3VtZW50c1swXSkuPGJyPlxuICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uKGl0ZXJhdGVlKSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gICAgICogIC0gaGFuZGxlckl0ZW1cbiAgICAgKiAgLSBoYW5kbGVySXRlbUlkXG4gICAgICogIC0gY3R4RXZlbnRzSXRlbVxuICAgICAqICAtIGV2ZW50S2V5LCBBIE5hbWUgb2YgY3VzdG9tIGV2ZW50IHdpdGggcG9zdGZpeCAoZXggLSAnZXZlbnROYW1lX2lkeCcpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIEN1c3RvbSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgLSBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ3VzdG9tRXZlbnRzLnByb3RvdHlwZS5fZWFjaEN0eEV2ZW50QnlFdmVudE5hbWUgPSBmdW5jdGlvbihldmVudE5hbWUsIGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghdGhpcy5fY3R4RXZlbnRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5ID0gdGhpcy5fZ2V0Q3R4S2V5KGV2ZW50TmFtZSksXG4gICAgICAgICAgICBjdHhFdmVudHNJdGVtID0gdGhpcy5fY3R4RXZlbnRzW2tleV0sXG4gICAgICAgICAgICBhcmdzO1xuXG4gICAgICAgIG5lLnV0aWwuZm9yRWFjaE93blByb3BlcnRpZXMoY3R4RXZlbnRzSXRlbSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGFyZ3MucHVzaChrZXkpO1xuICAgICAgICAgICAgaXRlcmF0ZWUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKioqKioqKioqKlxuICAgICAqIG5vcm1hbCBldmVudCBoYW5kbGVyXG4gICAgICoqKioqKioqKiovXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBjYWxsYmFjayBvbmNlXG4gICAgICogIGZvciBlYWNoIGhhbmRsZXIgaW4gaW5zdGFuY2UgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIGhhbmRsZXIoYXJndW1lbnRzWzBdKS48YnI+XG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb24oaXRlcmF0ZWUpIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czpcbiAgICAgKiAgLSBoYW5kbGVySXRlbVxuICAgICAqICAtIGluZGV4IG9mIGhhbmRsZXJJdGVtIGFycmF5XG4gICAgICogIC0gZXZlbnRMaXN0IGJ5IGhhbmRsZXJcbiAgICAgKiAgLSBldmVudEtleSwgQSBOYW1lIG9mIGN1c3RvbSBldmVudCB3aXRoIHBvc3RmaXggKGV4IC0gJ2V2ZW50TmFtZV9pZHgnKVxuICAgICAqICAtIGRlY3JlYXNlLCBBIHNwZWNpYWwgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBkZWNyZWFzZXMgdGhlIGxlbmd0aCBvZiBhcnJheS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gQSBoYW5kbGVyIGZvciBzZWFyY2hpbmdcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDdXN0b21FdmVudHMucHJvdG90eXBlLl9lYWNoRXZlbnRCeUhhbmRsZXIgPSBmdW5jdGlvbihoYW5kbGVyLCBpdGVyYXRlZSkge1xuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzLFxuICAgICAgICAgICAgZm9yRWFjaEFycmF5RGVjcmVhc2UgPSB0aGlzLl9mb3JFYWNoQXJyYXlTcGxpY2UsXG4gICAgICAgICAgICBpZHggPSAwO1xuXG4gICAgICAgIG5lLnV0aWwuZm9yRWFjaE93blByb3BlcnRpZXMoZXZlbnRzLCBmdW5jdGlvbihldmVudExpc3QsIGV2ZW50S2V5KSB7XG4gICAgICAgICAgICBmb3JFYWNoQXJyYXlEZWNyZWFzZShldmVudExpc3QsIGZ1bmN0aW9uKGhhbmRsZXJJdGVtLCBpbmRleCwgZXZlbnRMaXN0LCBkZWNyZWFzZSkge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVySXRlbS5mbiA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlZShoYW5kbGVySXRlbSwgaWR4LCBldmVudExpc3QsIGV2ZW50S2V5LCBkZWNyZWFzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBoYW5kbGVyIG9mIG5vcm1hbCBldmVudHMgb2YgdGhlIHByb3ZpZGVkIGV2ZW50TmFtZS48YnI+XG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb24oaXRlcmF0ZWUpIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAgICAgKiAgLSBoYW5kbGVyXG4gICAgICogIC0gaW5kZXggb2YgaGFuZGxlci1saXN0XG4gICAgICogIC0gaGFuZGxlci1saXN0XG4gICAgICogIC0gZGVjcmVhc2UsIEEgc3BlY2lhbCBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGRlY3JlYXNlcyB0aGUgbGVuZ3RoIG9mIGFycmF5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIEN1c3RvbSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgLSBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ3VzdG9tRXZlbnRzLnByb3RvdHlwZS5fZWFjaEV2ZW50QnlFdmVudE5hbWUgPSBmdW5jdGlvbihldmVudE5hbWUsIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBldmVudHM7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tldmVudE5hbWVdO1xuICAgICAgICBpZiAoIW5lLnV0aWwuaXNFeGlzdHkoZXZlbnRzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZm9yRWFjaEFycmF5U3BsaWNlKGV2ZW50cywgaXRlcmF0ZWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcga2V5IGZvciBzYXZpbmcgYSBoYW5kbGVyIHdpdGggYSBjb250ZXh0IGluIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBBIGV2ZW50IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBLZXlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEN1c3RvbUV2ZW50cy5wcm90b3R5cGUuX2dldEN0eEtleSA9IGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICByZXR1cm4gZXZlbnROYW1lICsgJ19pZHgnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcga2V5IGZvciBzYXZpbmcgbGVuZ3RoIG9mIGhhbmRsZXJzIGluIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBBIGV2ZW50IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBLZXlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEN1c3RvbUV2ZW50cy5wcm90b3R5cGUuX2dldEN0eExlbktleSA9IGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICByZXR1cm4gZXZlbnROYW1lICsgJ19sZW4nO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcga2V5IGZvciBzdG9yaW5nIHRvIGN0eEV2ZW50c0l0ZW0uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBBIGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0geyp9IGN0eCBBIGNvbnRleHQgaW4gaGFuZGxlclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEtleVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ3VzdG9tRXZlbnRzLnByb3RvdHlwZS5fZ2V0SGFuZGxlcktleSA9IGZ1bmN0aW9uKGZ1bmMsIGN0eCkge1xuICAgICAgICByZXR1cm4gbmUudXRpbC5zdGFtcChmdW5jKSArICdfJyArIG5lLnV0aWwuc3RhbXAoY3R4KTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGxlbmd0aCBvZiBoYW5kbGVycyBpbiBjdHhFdmVudHNJdGVtLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZW5LZXkgLSBBIGtleSBmb3Igc2F2aW5nIHRoZSBsZW5ndGggb2YgaGFuZGxlcnMgaW4gYHRoaXMuX2N0eEV2ZW50c2BcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhbmdlIC0gQSB2YXJpYXRpb24gdmFsdWUgb2YgbGVuZ3RoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDdXN0b21FdmVudHMucHJvdG90eXBlLl9zZXRDdHhMZW4gPSBmdW5jdGlvbihsZW5LZXksIGNoYW5nZSkge1xuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5fY3R4RXZlbnRzO1xuXG4gICAgICAgIGlmICghbmUudXRpbC5pc0V4aXN0eShldmVudHNbbGVuS2V5XSkpIHtcbiAgICAgICAgICAgIGV2ZW50c1tsZW5LZXldID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50c1tsZW5LZXldICs9IGNoYW5nZTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBTdG9yZSBhIHtoYW5kbGVySXRlbX0gdG8gaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIEN1c3RvbSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIHsqfSBjb250ZXh0IC0gQ29udGV4dCBmb3IgYmluZGluZ1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSBIYW5kbGVyIGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDdXN0b21FdmVudHMucHJvdG90eXBlLl9hZGRDdHhFdmVudCA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgY29udGV4dCwgaGFuZGxlcikge1xuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5fY3R4RXZlbnRzLFxuICAgICAgICAgICAga2V5ID0gdGhpcy5fZ2V0Q3R4S2V5KGV2ZW50TmFtZSksXG4gICAgICAgICAgICBldmVudDtcblxuICAgICAgICBpZiAoIW5lLnV0aWwuaXNFeGlzdHkoZXZlbnRzKSkge1xuICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5fY3R4RXZlbnRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBldmVudCA9IGV2ZW50c1trZXldO1xuICAgICAgICBpZiAoIW5lLnV0aWwuaXNFeGlzdHkoZXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudCA9IGV2ZW50c1trZXldID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuS2V5ID0gdGhpcy5fZ2V0Q3R4TGVuS2V5KGV2ZW50TmFtZSksXG4gICAgICAgICAgICBoYW5kbGVySXRlbUlkID0gdGhpcy5fZ2V0SGFuZGxlcktleShoYW5kbGVyLCBjb250ZXh0KTtcblxuICAgICAgICBldmVudFtoYW5kbGVySXRlbUlkXSA9IHtcbiAgICAgICAgICAgIGZuOiBoYW5kbGVyLFxuICAgICAgICAgICAgY3R4OiBjb250ZXh0XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fc2V0Q3R4TGVuKGxlbktleSwgKzEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZSBhIGV2ZW50IGhhbmRsZXIgd2l0aG91dCBjb250ZXh0IHRvIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBDdXN0b20gZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSBIYW5kbGVyIGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDdXN0b21FdmVudHMucHJvdG90eXBlLl9hZGROb3JtYWxFdmVudCA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzLFxuICAgICAgICAgICAgZXZlbnQ7XG5cbiAgICAgICAgaWYgKCFuZS51dGlsLmlzRXhpc3R5KGV2ZW50cykpIHtcbiAgICAgICAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQgPSBldmVudHNbZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKCFuZS51dGlsLmlzRXhpc3R5KGV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQgPSBldmVudHNbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQucHVzaCh7IGZuOiBoYW5kbGVyIH0pO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFRha2UgdGhlIGV2ZW50IGhhbmRsZXIgb2ZmIGJ5IGhhbmRsZXIoYXJndW1lbnRzWzBdKVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSBIYW5kbGVyIGZvciBvZmZpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEN1c3RvbUV2ZW50cy5wcm90b3R5cGUuX29mZkJ5SGFuZGxlciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGN0eEV2ZW50cyA9IHRoaXMuX2N0eEV2ZW50cyxcbiAgICAgICAgICAgIGxlbktleTtcblxuICAgICAgICB0aGlzLl9lYWNoQ3R4RXZlbnRCeUhhbmRsZXIoaGFuZGxlciwgZnVuY3Rpb24oaGFuZGxlckl0ZW0sIGhhbklkLCBjdHhJdGVtcywgZXZlbnRLZXkpIHtcbiAgICAgICAgICAgIGxlbktleSA9IGV2ZW50S2V5LnJlcGxhY2UoJ19pZHgnLCAnX2xlbicpO1xuICAgICAgICAgICAgZGVsZXRlIGN0eEl0ZW1zW2hhbklkXTtcbiAgICAgICAgICAgIGN0eEV2ZW50c1tsZW5LZXldIC09IDE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2VhY2hFdmVudEJ5SGFuZGxlcihoYW5kbGVyLCBmdW5jdGlvbihoYW5kbGVySXRlbSwgaW5kZXgsIGl0ZW1zLCBldmVudEtleSwgZGVjcmVhc2UpIHtcbiAgICAgICAgICAgIGl0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBkZWNyZWFzZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGFrZSB0aGUgZXZlbnQgaGFuZGxlciBvZmYgYnkgY29udGV4dCB3aXRoIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHQgLSBDb250ZXh0XG4gICAgICogQHBhcmFtIHsoc3RyaW5nfGZ1bmN0aW9uKX0gW2V2ZW50TmFtZV0gLSBDdXN0b20gZXZlbnQgbmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ3VzdG9tRXZlbnRzLnByb3RvdHlwZS5fb2ZmQnlDb250ZXh0ID0gZnVuY3Rpb24oY29udGV4dCwgZXZlbnROYW1lKSB7XG4gICAgICAgIHZhciBjdHhFdmVudHMgPSB0aGlzLl9jdHhFdmVudHMsXG4gICAgICAgICAgICBoYXNBcmdzID0gbmUudXRpbC5pc0V4aXN0eShldmVudE5hbWUpLFxuICAgICAgICAgICAgbWF0Y2hFdmVudE5hbWUsXG4gICAgICAgICAgICBtYXRjaEhhbmRsZXIsXG4gICAgICAgICAgICBsZW5LZXk7XG5cbiAgICAgICAgdGhpcy5fZWFjaEN0eEV2ZW50QnlDb250ZXh0KGNvbnRleHQsIGZ1bmN0aW9uKGhhbmRsZXJJdGVtLCBoYW5JZCwgY3R4SXRlbXMsIGV2ZW50S2V5KSB7XG4gICAgICAgICAgICBsZW5LZXkgPSBldmVudEtleS5yZXBsYWNlKCdfaWR4JywgJ19sZW4nKTtcblxuICAgICAgICAgICAgbWF0Y2hFdmVudE5hbWUgPSBoYXNBcmdzICYmIG5lLnV0aWwuaXNTdHJpbmcoZXZlbnROYW1lKSAmJiBldmVudEtleS5pbmRleE9mKGV2ZW50TmFtZSkgPiAtMTtcbiAgICAgICAgICAgIG1hdGNoSGFuZGxlciA9IGhhc0FyZ3MgJiYgbmUudXRpbC5pc0Z1bmN0aW9uKGV2ZW50TmFtZSkgJiYgaGFuZGxlckl0ZW0uZm4gPT09IGV2ZW50TmFtZTtcblxuICAgICAgICAgICAgaWYgKCFoYXNBcmdzIHx8IChtYXRjaEV2ZW50TmFtZSB8fCBtYXRjaEhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGN0eEl0ZW1zW2hhbklkXTtcbiAgICAgICAgICAgICAgICBjdHhFdmVudHNbbGVuS2V5XSAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGFrZSB0aGUgZXZlbnQgaGFuZGxlciBvZmYgYnkgZXZlbnQgbmFtZSB3aXRoIGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gQ3VzdG9tIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaGFuZGxlcl0gLSBFdmVudCBoYW5kbGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDdXN0b21FdmVudHMucHJvdG90eXBlLl9vZmZCeUV2ZW50TmFtZSA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICB2YXIgY3R4RXZlbnRzID0gdGhpcy5fY3R4RXZlbnRzLFxuICAgICAgICAgICAgaGFzSGFuZGxlciA9IG5lLnV0aWwuaXNFeGlzdHkoaGFuZGxlciksXG4gICAgICAgICAgICBsZW5LZXk7XG5cbiAgICAgICAgdGhpcy5fZWFjaEN0eEV2ZW50QnlFdmVudE5hbWUoZXZlbnROYW1lLCBmdW5jdGlvbihoYW5kbGVySXRlbSwgaGFuSWQsIGN0eEl0ZW1zLCBldmVudEtleSkge1xuICAgICAgICAgICAgbGVuS2V5ID0gZXZlbnRLZXkucmVwbGFjZSgnX2lkeCcsICdfbGVuJyk7XG4gICAgICAgICAgICBpZiAoIWhhc0hhbmRsZXIgfHwgKGhhc0hhbmRsZXIgJiYgaGFuZGxlckl0ZW0uZm4gPT09IGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGN0eEl0ZW1zW2hhbklkXTtcbiAgICAgICAgICAgICAgICBjdHhFdmVudHNbbGVuS2V5XSAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9lYWNoRXZlbnRCeUV2ZW50TmFtZShldmVudE5hbWUsIGZ1bmN0aW9uKGhhbmRsZXJJdGVtLCBpbmRleCwgaXRlbXMsIGRlY3JlYXNlKSB7XG4gICAgICAgICAgICBpZiAoIWhhc0hhbmRsZXIgfHwgKGhhc0hhbmRsZXIgJiYgaGFuZGxlckl0ZW0uZm4gPT09IGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgaXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBkZWNyZWFzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH07XG5cbiAgICAvKioqKioqKioqKlxuICAgICAqIHB1YmxpY1xuICAgICAqKioqKioqKioqL1xuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIHRoZSBldmVudCBoYW5kbGVyIHdpdGggZXZlbnQgbmFtZSBhbmQgY29udGV4dC5cbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8e25hbWU6c3RyaW5nLCBoYW5kbGVyOmZ1bmN0aW9ufSl9IGV2ZW50TmFtZSAtIEN1c3RvbSBldmVudCBuYW1lIG9yIGFuIG9iamVjdCB7ZXZlbnROYW1lOiBoYW5kbGVyfVxuICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9ufCopfSBbaGFuZGxlcl0gLSBIYW5kbGVyIGZ1bmN0aW9uIG9yIGNvbnRleHRcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XSAtIENvbnRleHQgZm9yIGJpbmRpbmdcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAvLyAxLiBCYXNpY1xuICAgICAqICBjdXN0b21FdmVudC5vbignb25sb2FkJywgaGFuZGxlcik7XG4gICAgICpcbiAgICAgKiAgLy8gMi4gV2l0aCBjb250ZXh0XG4gICAgICogIGN1c3RvbUV2ZW50Lm9uKCdvbmxvYWQnLCBoYW5kbGVyLCBteU9iaik7XG4gICAgICpcbiAgICAgKiAgLy8gMy4gQXR0YWNoIHdpdGggYW4gb2JqZWN0XG4gICAgICogIGN1c3RvbUV2ZW50Lm9uKHtcbiAgICAgKiAgICAncGxheSc6IGhhbmRsZXIsXG4gICAgICogICAgJ3BhdXNlJzogaGFuZGxlcjJcbiAgICAgKiAgfSk7XG4gICAgICpcbiAgICAgKiAgLy8gNC4gQXR0YWNoIHdpdGggYW4gb2JqZWN0IHdpdGggY29udGV4dFxuICAgICAqICBjdXN0b21FdmVudC5vbih7XG4gICAgICogICAgJ3BsYXknOiBoYW5kbGVyXG4gICAgICogIH0sIG15T2JqKTtcbiAgICAgKi9cbiAgICBDdXN0b21FdmVudHMucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnROYW1lLCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBldmVudE5hbWVMaXN0O1xuXG4gICAgICAgIGlmIChuZS51dGlsLmlzT2JqZWN0KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgIC8vIHtldmVudE5hbWU6IGhhbmRsZXJ9XG4gICAgICAgICAgICBjb250ZXh0ID0gaGFuZGxlcjtcbiAgICAgICAgICAgIG5lLnV0aWwuZm9yRWFjaE93blByb3BlcnRpZXMoZXZlbnROYW1lLCBmdW5jdGlvbihoYW5kbGVyLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgIHRoaXMub24obmFtZSwgaGFuZGxlciwgY29udGV4dCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChuZS51dGlsLmlzU3RyaW5nKGV2ZW50TmFtZSkgJiYgZXZlbnROYW1lLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICAgICAgICAvLyBwcm9jZXNzaW5nIG9mIG11bHRpcGxlIGV2ZW50cyBieSBzcGxpdCBldmVudCBuYW1lXG4gICAgICAgICAgICBldmVudE5hbWVMaXN0ID0gZXZlbnROYW1lLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBuZS51dGlsLmZvckVhY2hBcnJheShldmVudE5hbWVMaXN0LCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbihuYW1lLCBoYW5kbGVyLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN0eElkO1xuXG4gICAgICAgIGlmIChuZS51dGlsLmlzRXhpc3R5KGNvbnRleHQpKSB7XG4gICAgICAgICAgICBjdHhJZCA9IG5lLnV0aWwuc3RhbXAoY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmUudXRpbC5pc0V4aXN0eShjdHhJZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEN0eEV2ZW50KGV2ZW50TmFtZSwgY29udGV4dCwgaGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hZGROb3JtYWxFdmVudChldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERldGFjaCB0aGUgZXZlbnQgaGFuZGxlci5cbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8e25hbWU6c3RyaW5nLCBoYW5kbGVyOmZ1bmN0aW9ufSl9IGV2ZW50TmFtZSAtIEN1c3RvbSBldmVudCBuYW1lIG9yIGFuIG9iamVjdCB7ZXZlbnROYW1lOiBoYW5kbGVyfVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtoYW5kbGVyXSBIYW5kbGVyIGZ1bmN0aW9uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyAxLiBvZmYgYnkgY29udGV4dFxuICAgICAqIGN1c3RvbUV2ZW50Lm9mZihteU9iaik7XG4gICAgICpcbiAgICAgKiAvLyAyLiBvZmYgYnkgZXZlbnQgbmFtZVxuICAgICAqIGN1c3RvbUV2ZW50Lm9mZignb25sb2FkJyk7XG4gICAgICpcbiAgICAgKiAvLyAzLiBvZmYgYnkgaGFuZGxlclxuICAgICAqIGN1c3RvbUV2ZW50Lm9mZihoYW5kbGVyKTtcbiAgICAgKlxuICAgICAqIC8vIDQuIG9mZiBieSBldmVudCBuYW1lIGFuZCBoYW5kbGVyXG4gICAgICogY3VzdG9tRXZlbnQub2ZmKCdwbGF5JywgaGFuZGxlcik7XG4gICAgICpcbiAgICAgKiAvLyA1LiBvZmYgYnkgY29udGV4dCBhbmQgaGFuZGxlclxuICAgICAqIGN1c3RvbUV2ZW50Lm9mZihteU9iaiwgaGFuZGxlcik7XG4gICAgICpcbiAgICAgKiAvLyA2LiBvZmYgYnkgY29udGV4dCBhbmQgZXZlbnQgbmFtZVxuICAgICAqIGN1c3RvbUV2ZW50Lm9mZihteU9iaiwgJ29ubG9hZCcpO1xuICAgICAqXG4gICAgICogLy8gNy4gb2ZmIGJ5IGFuIE9iamVjdC48c3RyaW5nLCBmdW5jdGlvbj4gdGhhdCBpcyB7ZXZlbnROYW1lOiBoYW5kbGVyfVxuICAgICAqIGN1c3RvbUV2ZW50Lm9mZih7XG4gICAgICogICAncGxheSc6IGhhbmRsZXIsXG4gICAgICogICAncGF1c2UnOiBoYW5kbGVyMlxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gOC4gb2ZmIHRoZSBhbGwgZXZlbnRzXG4gICAgICogY3VzdG9tRXZlbnQub2ZmKCk7XG4gICAgICovXG4gICAgQ3VzdG9tRXZlbnRzLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyA4LiBvZmYgdGhlIGFsbCBldmVudHNcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9jdHhFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5lLnV0aWwuaXNGdW5jdGlvbihldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAvLyAzLiBvZmYgYnkgaGFuZGxlclxuICAgICAgICAgICAgdGhpcy5fb2ZmQnlIYW5kbGVyKGV2ZW50TmFtZSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChuZS51dGlsLmlzT2JqZWN0KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChuZS51dGlsLmhhc1N0YW1wKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvLyAxLCA1LCA2IG9mZiBieSBjb250ZXh0XG4gICAgICAgICAgICAgICAgdGhpcy5fb2ZmQnlDb250ZXh0KGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIDQuIG9mZiBieSBhbiBPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+XG4gICAgICAgICAgICAgICAgbmUudXRpbC5mb3JFYWNoT3duUHJvcGVydGllcyhldmVudE5hbWUsIGZ1bmN0aW9uKGhhbmRsZXIsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYobmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIDIsIDQgb2ZmIGJ5IGV2ZW50IG5hbWVcbiAgICAgICAgICAgIHRoaXMuX29mZkJ5RXZlbnROYW1lKGV2ZW50TmFtZSwgaGFuZGxlcik7XG5cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBjb3VudCBvZiBldmVudHMgcmVnaXN0ZXJlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gQ3VzdG9tIGV2ZW50IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBDdXN0b21FdmVudHMucHJvdG90eXBlLmdldExpc3RlbmVyTGVuZ3RoID0gZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICAgIHZhciBjdHhFdmVudHMgPSB0aGlzLl9jdHhFdmVudHMsXG4gICAgICAgICAgICBldmVudHMgPSB0aGlzLl9ldmVudHMsXG4gICAgICAgICAgICBleGlzdHkgPSBuZS51dGlsLmlzRXhpc3R5LFxuICAgICAgICAgICAgbGVuS2V5ID0gdGhpcy5fZ2V0Q3R4TGVuS2V5KGV2ZW50TmFtZSk7XG5cbiAgICAgICAgdmFyIG5vcm1hbCA9IChleGlzdHkoZXZlbnRzKSAmJiBuZS51dGlsLmlzQXJyYXkoZXZlbnRzW2V2ZW50TmFtZV0pKSA/IGV2ZW50c1tldmVudE5hbWVdLmxlbmd0aCA6IDAsXG4gICAgICAgICAgICBjdHggPSAoZXhpc3R5KGN0eEV2ZW50cykgJiYgZXhpc3R5KGN0eEV2ZW50c1tsZW5LZXldKSkgPyBjdHhFdmVudHNbbGVuS2V5XSA6IDA7XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbCArIGN0eDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHdoZXRoZXIgYXQgbGVhc3Qgb25lIG9mIHRoZSBoYW5kbGVycyBpcyByZWdpc3RlcmVkIGluIHRoZSBnaXZlbiBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBDdXN0b20gZXZlbnQgbmFtZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBJcyB0aGVyZSBhdCBsZWFzdCBvbmUgaGFuZGxlciBpbiBldmVudCBuYW1lP1xuICAgICAqL1xuICAgIEN1c3RvbUV2ZW50cy5wcm90b3R5cGUuaGFzTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGlzdGVuZXJMZW5ndGgoZXZlbnROYW1lKSA+IDA7XG4gICAgfTtcblxuXG5cbiAgICAvKipcbiAgICAgKiBGaXJlIGEgZXZlbnQgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBvZiBvcGVyYXRpb24gJ2Jvb2xlYW4gQU5EJyB3aXRoIGFsbCBsaXN0ZW5lcidzIHJlc3VsdHMuPGJyPlxuICAgICAqIFNvLCBJdCBpcyBkaWZmZXJlbnQgZnJvbSB7QGxpbmsgQ3VzdG9tRXZlbnRzI2ZpcmV9Ljxicj5cbiAgICAgKiBJbiBzZXJ2aWNlIGNvZGUsXG4gICAgICogIHVzZSB0aGlzIGFzIGEgYmVmb3JlIGV2ZW50IGluIGNvbXBvbmVudCBsZXZlbCB1c3VhbGx5IGZvciBub3RpZnlpbmcgdGhhdCB0aGUgZXZlbnQgaXMgY2FuY2VsYWJsZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gQ3VzdG9tIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0gey4uLip9IGRhdGEgLSBEYXRhIGZvciBldmVudFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgcmVzdWx0IG9mIG9wZXJhdGlvbiAnYm9vbGVhbiBBTkQnXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgaWYgKHRoaXMuaW52b2tlKCdiZWZvcmVab29tJykpIHsgICAgLy8gY2hlY2sgdGhlIHJlc3VsdCBvZiAnYmVmb3JlWm9vbSdcbiAgICAgKiAgICAgIC8vIGlmIHRydWUsXG4gICAgICogICAgICAvLyBkb1NvbWV0aGluZ1xuICAgICAqICB9XG4gICAgICpcbiAgICAgKiAgLy8gSW4gc2VydmljZSBjb2RlLFxuICAgICAqICBtYXAub24oe1xuICAgICAqICAgICAgJ2JlZm9yZVpvb20nOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICBpZiAodGhhdC5kaXNhYmxlZCAmJiB0aGlzLmdldFN0YXRlKCkpIHsgICAgLy8gSXQgc2hvdWxkIGNhbmNlbCB0aGUgJ3pvb20nIGV2ZW50IGJ5IHNvbWUgY29uZGl0aW9ucy5cbiAgICAgKiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAqICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgICAgIH1cbiAgICAgKiAgfSk7XG4gICAgICovXG4gICAgQ3VzdG9tRXZlbnRzLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbihldmVudE5hbWUsIGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0xpc3RlbmVyKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgICAgICAgZXhpc3R5ID0gbmUudXRpbC5pc0V4aXN0eTtcblxuICAgICAgICB0aGlzLl9lYWNoRXZlbnRCeUV2ZW50TmFtZShldmVudE5hbWUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChleGlzdHkoaXRlbSkgJiYgaXRlbS5mbi5hcHBseShzZWxmLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fZWFjaEN0eEV2ZW50QnlFdmVudE5hbWUoZXZlbnROYW1lLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoZXhpc3R5KGl0ZW0pICYmIGl0ZW0uZm4uYXBwbHkoaXRlbS5jdHgsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlIGEgZXZlbnQgYnkgZXZlbnQgbmFtZSB3aXRoIGRhdGEuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIEN1c3RvbSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIHsuLi4qfSBkYXRhIC0gRGF0YSBmb3IgZXZlbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBpbnN0YW5jZS5vbignbW92ZScsIGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuICAgICAqICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgKiAgfSk7XG4gICAgICogIGluc3RhbmNlLmZpcmUoJ21vdmUnLCAnbGVmdCcpO1xuICAgICAqL1xuICAgIEN1c3RvbUV2ZW50cy5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZGF0YSkge1xuICAgICAgICB0aGlzLmludm9rZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGEgb25lLXNob3QgZXZlbnQuXG4gICAgICogQHBhcmFtIHsob2JqZWN0fHN0cmluZyl9IGV2ZW50TmFtZSAtIEN1c3RvbSBldmVudCBuYW1lIG9yIGFuIG9iamVjdCB7ZXZlbnROYW1lOiBoYW5kbGVyfVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gSGFuZGxlciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdIC0gQ29udGV4dCBmb3IgYmluZGluZ1xuICAgICAqL1xuICAgIEN1c3RvbUV2ZW50cy5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZm4sIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIGlmIChuZS51dGlsLmlzT2JqZWN0KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgIG5lLnV0aWwuZm9yRWFjaE93blByb3BlcnRpZXMoZXZlbnROYW1lLCBmdW5jdGlvbihoYW5kbGVyLCBldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoZXZlbnROYW1lLCBoYW5kbGVyLCBmbik7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25jZUhhbmRsZXIoKSB7XG4gICAgICAgICAgICBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhhdC5vZmYoZXZlbnROYW1lLCBvbmNlSGFuZGxlciwgY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uKGV2ZW50TmFtZSwgb25jZUhhbmRsZXIsIGNvbnRleHQpO1xuICAgIH07XG5cbiAgICBuZS51dGlsLkN1c3RvbUV2ZW50cyA9IEN1c3RvbUV2ZW50cztcblxufSkod2luZG93Lm5lKTtcblxuLyoqKioqKioqKipcbiAqIGRlZmluZUNsYXNzLmpzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiAgVGhpcyBtb2R1bGUgcHJvdmlkZXMgYSBmdW5jdGlvbiB0byBtYWtlIGEgY29uc3RydWN0b3IgdGhhdCBjYW4gaW5oZXJpdCBmcm9tIHRoZSBvdGhlciBjb25zdHJ1Y3RvcnMgbGlrZSB0aGUgQ0xBU1MgZWFzaWx5LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxlMDI0MkBuaG5lbnQuY29tPlxuICogQGRlcGVuZGVuY3kgaW5oZXJpdGFuY2UuanMsIG9iamVjdC5qc1xuICovXG5cbihmdW5jdGlvbihuZSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIW5lKSB7XG4gICAgICAgIG5lID0gd2luZG93Lm5lID0ge307XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghbmUudXRpbCkge1xuICAgICAgICBuZS51dGlsID0gd2luZG93Lm5lLnV0aWwgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwIGEgY29uc3RydWN0b3IgdG8gYmUgZGVmaW5lZCBhbmQgdG8gaW5oZXJpdCBmcm9tIHRoZSBvdGhlciBjb25zdHJ1Y3RvcnNcbiAgICAgKiBAcGFyYW0geyp9IFtwYXJlbnRdIFBhcmVudCBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBNZW1iZXJzIG9mIGNvbnN0cnVjdG9yXG4gICAgICogIEBwYXJhbSB7RnVuY3Rpb259IHByb3BzLmluaXQgSW5pdGlhbGl6YXRpb24gbWV0aG9kXG4gICAgICogIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMuc3RhdGljXSBTdGF0aWMgbWVtYmVycyBvZiBjb25zdHJ1Y3RvclxuICAgICAqIEByZXR1cm5zIHsqfSBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgdmFyIFBhcmVudCA9IGRlZmluZUNsYXNzKHtcbiAgICAgKiAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgIHRoaXMubmFtZSA9ICdtYWRlIGJ5IGRlZic7XG4gICAgICogICAgICB9LFxuICAgICAqICAgICAgbWV0aG9kOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICAvLy4uY2FuIGRvIHNvbWV0aGluZyB3aXRoIHRoaXNcbiAgICAgKiAgICAgIH0sXG4gICAgICogICAgICBzdGF0aWM6IHtcbiAgICAgKiAgICAgICAgICBzdGF0aWNNZXRob2Q6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgICAgICAgLy8uLmRvIHNvbWV0aGluZ1xuICAgICAqICAgICAgICAgIH1cbiAgICAgKiAgICAgIH1cbiAgICAgKiAgfSk7XG4gICAgICpcbiAgICAgKiAgdmFyIENoaWxkID0gZGVmaW5lQ2xhc3MoUGFyZW50LCB7XG4gICAgICogICAgICBtZXRob2QyOiBmdW5jdGlvbigpIHt9XG4gICAgICogIH0pO1xuICAgICAqXG4gICAgICogIFBhcmVudC5zdGF0aWNNZXRob2QoKTtcbiAgICAgKlxuICAgICAqICB2YXIgcGFyZW50SW5zdGFuY2UgPSBuZXcgUGFyZW50KCk7XG4gICAgICogIGNvbnNvbGUubG9nKHBhcmVudEluc3RhbmNlLm5hbWUpOyAvL21hZGUgYnkgZGVmXG4gICAgICogIHBhcmVudEluc3RhbmNlLnN0YXRpY01ldGhvZCgpOyAvLyBFcnJvclxuICAgICAqXG4gICAgICogIHZhciBjaGlsZEluc3RhbmNlID0gbmV3IENoaWxkKCk7XG4gICAgICogIGNoaWxkSW5zdGFuY2UubWV0aG9kKCk7XG4gICAgICogIGNoaWxkSW5zdGFuY2UubWV0aG9kMigpO1xuICAgICAqL1xuICAgIG5lLnV0aWwuZGVmaW5lQ2xhc3MgPSBmdW5jdGlvbihwYXJlbnQsIHByb3BzKSB7XG4gICAgICAgIHZhciBvYmo7XG5cbiAgICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICAgICAgcHJvcHMgPSBwYXJlbnQ7XG4gICAgICAgICAgICBwYXJlbnQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gcHJvcHMuaW5pdCB8fCBmdW5jdGlvbigpe307XG5cbiAgICAgICAgaWYocGFyZW50KSB7XG4gICAgICAgICAgICBuZS51dGlsLmluaGVyaXQob2JqLCBwYXJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCdzdGF0aWMnKSkge1xuICAgICAgICAgICAgbmUudXRpbC5leHRlbmQob2JqLCBwcm9wcy5zdGF0aWMpO1xuICAgICAgICAgICAgZGVsZXRlIHByb3BzLnN0YXRpYztcbiAgICAgICAgfVxuXG4gICAgICAgIG5lLnV0aWwuZXh0ZW5kKG9iai5wcm90b3R5cGUsIHByb3BzKTtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbn0pKHdpbmRvdy5uZSk7XG5cbi8qKioqKioqKioqXG4gKiBkZWZpbmVNb2R1bGUuanNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGVmaW5lIG1vZHVsZVxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxlMDI0MkBuaG5lbnQuY29tPlxuICogQGRlcGVuZGVuY3kgdHlwZS5qcywgZGVmaW5lTmFtZXNwYWNlLmpzXG4gKi9cbihmdW5jdGlvbihuZSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIW5lKSB7XG4gICAgICAgIG5lID0gd2luZG93Lm5lID0ge307XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghbmUudXRpbCkge1xuICAgICAgICBuZS51dGlsID0gd2luZG93Lm5lLnV0aWwgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgdXRpbCA9IG5lLnV0aWwsXG4gICAgICAgIElOSVRJQUxJWkFUSU9OX01FVEhPRF9OQU1FID0gJ2luaXRpYWxpemUnO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lIG1vZHVsZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lc3BhY2UgLSBOYW1lc3BhY2Ugb2YgbW9kdWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZURlZmluaXRpb24gLSBPYmplY3QgbGl0ZXJhbCBmb3IgbW9kdWxlXG4gICAgICogQHJldHVybnMge09iamVjdH0gRGVmaW5lZCBtb2R1bGVcbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIHZhciBteU1vZHVsZSA9IG5lLnV0aWwuZGVmaW5lTW9kdWxlKCdtb2R1bGVzLm15TW9kdWxlJywge1xuICAgICAqICAgICAgICAgIG5hbWU6ICdqb2huJyxcbiAgICAgKiAgICAgICAgICBtZXNzYWdlOiAnJyxcbiAgICAgKiAgICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gJ2hlbGxvIHdvcmxkJztcbiAgICAgKiAgICAgICAgICB9LFxuICAgICAqICAgICAgICAgIGdldE1lc3NhZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgJzogJyArIHRoaXMubWVzc2FnZVxuICAgICAqICAgICAgICAgIH1cbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiAgICAgY29uc29sZS5sb2cobXlNb2R1bGUuZ2V0TWVzc2FnZSgpKTsgIC8vICdqb2huOiBoZWxsbyB3b3JsZCc7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHdpbmRvdy5tb2R1bGVzLm15TW9kdWxlLmdldE1lc3NhZ2UoKSk7ICAgLy8gJ2pvaG46IGhlbGxvIHdvcmxkJztcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZpbmVNb2R1bGUobmFtZXNwYWNlLCBtb2R1bGVEZWZpbml0aW9uKSB7XG4gICAgICAgIHZhciBiYXNlID0gbW9kdWxlRGVmaW5pdGlvbiB8fCB7fTtcblxuICAgICAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKGJhc2VbSU5JVElBTElaQVRJT05fTUVUSE9EX05BTUVdKSkge1xuICAgICAgICAgICAgYmFzZVtJTklUSUFMSVpBVElPTl9NRVRIT0RfTkFNRV0oKTtcbiAgICAgICAgICAgIGRlbGV0ZSBiYXNlW0lOSVRJQUxJWkFUSU9OX01FVEhPRF9OQU1FXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1dGlsLmRlZmluZU5hbWVzcGFjZShuYW1lc3BhY2UsIGJhc2UsIHRydWUpO1xuICAgIH1cbiAgICBuZS51dGlsLmRlZmluZU1vZHVsZSA9IGRlZmluZU1vZHVsZTtcbn0pKHdpbmRvdy5uZSk7XG5cbi8qKioqKioqKioqXG4gKiBkZWZpbmVOYW1lc3BhY2UuanNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGVmaW5lIG5hbWVzcGFjZVxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxlMDI0MkBuaG5lbnQuY29tPlxuICogQGRlcGVuZGVuY3kgaW5oZXJpdGFuY2UuanMsIG9iamVjdC5qcywgY29sbGVjdGlvbi5qc1xuICovXG4oZnVuY3Rpb24obmUpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIW5lKSB7XG4gICAgICAgIG5lID0gd2luZG93Lm5lID0ge307XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghbmUudXRpbCkge1xuICAgICAgICBuZS51dGlsID0gd2luZG93Lm5lLnV0aWwgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgbmFtZXNwYWNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBNb2R1bGUgbmFtZVxuICAgICAqIEBwYXJhbSB7KG9iamVjdHxmdW5jdGlvbil9IHByb3BzIC0gQSBzZXQgb2YgbW9kdWxlcyBvciBvbmUgbW9kdWxlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc092ZXJyaWRlIGZsYWcgLSBXaGF0IGlmIG1vZHVsZSBhbHJlYWR5IGRlZmluZSwgb3ZlcnJpZGUgb3Igbm90XG4gICAgICogQHJldHVybnMgeyhvYmplY3R8ZnVuY3Rpb24pfSBEZWZpbmVkIG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgbmVDb21wID0gZGVmaW5lTmFtZXNwYWNlKCduZS5jb21wb25lbnQnKTtcbiAgICAgKiBuZUNvbXAubGlzdE1lbnUgPSBuZS51dGlsLmRlZmluZUNsYXNzKHtcbiAgICAgKiAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgIC8vIGNvZGVcbiAgICAgKiAgICAgIH1cbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICB2YXIgZGVmaW5lTmFtZXNwYWNlID0gZnVuY3Rpb24obmFtZSwgcHJvcHMsIGlzT3ZlcnJpZGUpIHtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIGxhc3RzcGFjZSxcbiAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgIG1vZHVsZSA9IGdldE5hbWVzcGFjZShuYW1lKTtcblxuICAgICAgICBpZiAoIWlzT3ZlcnJpZGUgJiYgaXNWYWxpZFR5cGUobW9kdWxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWVzcGFjZSA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgbGFzdHNwYWNlID0gbmFtZXNwYWNlLnBvcCgpO1xuICAgICAgICBuYW1lc3BhY2UudW5zaGlmdCh3aW5kb3cpO1xuXG4gICAgICAgIHJlc3VsdCA9IG5lLnV0aWwucmVkdWNlKG5hbWVzcGFjZSwgZnVuY3Rpb24ob2JqLCBuYW1lKSB7XG4gICAgICAgICAgICBvYmpbbmFtZV0gPSBvYmpbbmFtZV0gfHwge307XG4gICAgICAgICAgICByZXR1cm4gb2JqW25hbWVdO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXN1bHRbbGFzdHNwYWNlXSA9IGlzVmFsaWRUeXBlKHByb3BzKSA/IHByb3BzIDoge307XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFtsYXN0c3BhY2VdO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBuYW1lc3BhY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHZhciBnZXROYW1lc3BhY2UgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBuYW1lc3BhY2UsXG4gICAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgICAgbmFtZXNwYWNlID0gbmFtZS5zcGxpdCgnLicpO1xuICAgICAgICBuYW1lc3BhY2UudW5zaGlmdCh3aW5kb3cpO1xuXG4gICAgICAgIHJlc3VsdCA9IG5lLnV0aWwucmVkdWNlKG5hbWVzcGFjZSwgZnVuY3Rpb24ob2JqLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIG9ialtuYW1lXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHZhbGlkIHR5cGVcbiAgICAgKiBAcGFyYW0geyp9IG1vZHVsZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHZhciBpc1ZhbGlkVHlwZSA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICByZXR1cm4gKG5lLnV0aWwuaXNPYmplY3QobW9kdWxlKSB8fCBuZS51dGlsLmlzRnVuY3Rpb24obW9kdWxlKSk7XG4gICAgfTtcblxuICAgIG5lLnV0aWwuZGVmaW5lTmFtZXNwYWNlID0gZGVmaW5lTmFtZXNwYWNlO1xuXG59KSh3aW5kb3cubmUpO1xuLyoqKioqKioqKipcbiAqIGVudW0uanNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBtb2R1bGUgcHJvdmlkZXMgYSBFbnVtIENvbnN0cnVjdG9yLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxlMDI0MkBuaG5lbnQuY29tPlxuICogQGRlcGVuZGVuY3kgdHlwZSwgY29sbGVjdGlvbi5qc1xuICovXG5cbihmdW5jdGlvbihuZSkge1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKCFuZSkge1xuICAgIG5lID0gd2luZG93Lm5lID0ge307XG59XG5pZiAoIW5lLnV0aWwpIHtcbiAgICBuZS51dGlsID0gd2luZG93Lm5lLnV0aWwgPSB7fTtcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBkZWZpbmVQcm9wZXJ0eSgpIG1ldGhvZCBpcyBzdXBwb3J0ZWQuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xudmFyIGlzU3VwcG9ydERlZmluZWRQcm9wZXJ0eSA9IChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHt9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSgpKTtcblxuLyoqXG4gKiBBIHVuaXF1ZSB2YWx1ZSBvZiBhIGNvbnN0YW50LlxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIGVudW1WYWx1ZSA9IDA7XG5cbi8qKlxuICogTWFrZSBhIGNvbnN0YW50LWxpc3QgdGhhdCBoYXMgdW5pcXVlIHZhbHVlcy48YnI+XG4gKiBJbiBtb2Rlcm4gYnJvd3NlcnMgKGV4Y2VwdCBJRTggYW5kIGxvd2VyKSw8YnI+XG4gKiAgYSB2YWx1ZSBkZWZpbmVkIG9uY2UgY2FuIG5vdCBiZSBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7Li4uc3RyaW5nIHwgc3RyaW5nW119IGl0ZW1MaXN0IENvbnN0YW50LWxpc3QgKEFuIGFycmF5IG9mIHN0cmluZyBpcyBhdmFpbGFibGUpXG4gKiBAZXhwb3J0cyBFbnVtXG4gKiBAY29uc3RydWN0b3JcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIG5lLnV0aWxcbiAqIEBleGFtcGxlc1xuICogIC8vY3JlYXRlXG4gKiAgdmFyIE1ZRU5VTSA9IG5ldyBFbnVtKCdUWVBFMScsICdUWVBFMicpO1xuICogIHZhciBNWUVOVU0yID0gbmV3IEVudW0oWydUWVBFMScsICdUWVBFMiddKTtcbiAqXG4gKiAgLy91c2FnZVxuICogIGlmICh2YWx1ZSA9PT0gTVlFTlVNLlRZUEUxKSB7XG4gKiAgICAgICAuLi4uXG4gKiAgfVxuICpcbiAqICAvL2FkZCAoSWYgYSBkdXBsaWNhdGUgbmFtZSBpcyBpbnB1dHRlZCwgd2lsbCBiZSBkaXNyZWdhcmRlZC4pXG4gKiAgTVlFTlVNLnNldCgnVFlQRTMnLCAnVFlQRTQnKTtcbiAqXG4gKiAgLy9nZXQgbmFtZSBvZiBhIGNvbnN0YW50IGJ5IGEgdmFsdWVcbiAqICBNWUVOVU0uZ2V0TmFtZShNWUVOVU0uVFlQRTEpOyAvLyAnVFlQRTEn7J20IOumrO2EtOuQnOuLpC5cbiAqXG4gKiAgLy8gSW4gbW9kZXJuIGJyb3dzZXJzIChleGNlcHQgSUU4IGFuZCBsb3dlciksIGEgdmFsdWUgY2FuIG5vdCBiZSBjaGFuZ2VkIGluIGNvbnN0YW50cy5cbiAqICB2YXIgb3JpZ2luYWxWYWx1ZSA9IE1ZRU5VTS5UWVBFMTtcbiAqICBNWUVOVU0uVFlQRTEgPSAxMjM0OyAvLyBtYXliZSBUeXBlRXJyb3JcbiAqICBNWUVOVU0uVFlQRTEgPT09IG9yaWdpbmFsVmFsdWU7IC8vIHRydWVcbiAqXG4gKiovXG5mdW5jdGlvbiBFbnVtKGl0ZW1MaXN0KSB7XG4gICAgaWYgKGl0ZW1MaXN0KSB7XG4gICAgICAgIHRoaXMuc2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxufVxuXG4vKipcbiAqIERlZmluZSBhIGNvbnN0YW50cy1saXN0XG4gKiBAcGFyYW0gey4uLnN0cmluZ3wgc3RyaW5nW119IGl0ZW1MaXN0IENvbnN0YW50LWxpc3QgKEFuIGFycmF5IG9mIHN0cmluZyBpcyBhdmFpbGFibGUpXG4gKi9cbkVudW0ucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGl0ZW1MaXN0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKCFuZS51dGlsLmlzQXJyYXkoaXRlbUxpc3QpKSB7XG4gICAgICAgIGl0ZW1MaXN0ID0gbmUudXRpbC50b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgbmUudXRpbC5mb3JFYWNoKGl0ZW1MaXN0LCBmdW5jdGlvbiBpdGVtTGlzdEl0ZXJhdGVlKGl0ZW0pIHtcbiAgICAgICAgc2VsZi5fYWRkSXRlbShpdGVtKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGEga2V5IG9mIHRoZSBjb25zdGFudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBBIHZhbHVlIG9mIHRoZSBjb25zdGFudC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBLZXkgb2YgdGhlIGNvbnN0YW50LlxuICovXG5FbnVtLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgZm91bmRlZEtleSxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBuZS51dGlsLmZvckVhY2godGhpcywgZnVuY3Rpb24oaXRlbVZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHNlbGYuX2lzRW51bUl0ZW0oa2V5KSAmJiB2YWx1ZSA9PT0gaXRlbVZhbHVlKSB7XG4gICAgICAgICAgICBmb3VuZGVkS2V5ID0ga2V5O1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZm91bmRlZEtleTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgY29uc3RhbnQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ29uc3RhbnQgbmFtZS4gKEl0IHdpbGwgYmUgYSBrZXkgb2YgYSBjb25zdGFudClcbiAqL1xuRW51bS5wcm90b3R5cGUuX2FkZEl0ZW0gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHZhbHVlO1xuXG4gICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5fbWFrZUVudW1WYWx1ZSgpO1xuXG4gICAgICAgIGlmIChpc1N1cHBvcnREZWZpbmVkUHJvcGVydHkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm4gYSB1bmlxdWUgdmFsdWUgZm9yIGFzc2lnbmluZyB0byBhIGNvbnN0YW50LlxuICogQHByaXZhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEEgdW5pcXVlIHZhbHVlXG4gKi9cbkVudW0ucHJvdG90eXBlLl9tYWtlRW51bVZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlO1xuXG4gICAgdmFsdWUgPSBlbnVtVmFsdWU7XG4gICAgZW51bVZhbHVlICs9IDE7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgY29uc3RhbnQgZnJvbSB0aGUgZ2l2ZW4ga2V5IGlzIGluIGluc3RhbmNlIG9yIG5vdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBBIGNvbnN0YW50IGtleVxuICogQHJldHVybnMge2Jvb2xlYW59IFJlc3VsdFxuICogQHByaXZhdGVcbiAqL1xuRW51bS5wcm90b3R5cGUuX2lzRW51bUl0ZW0gPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gbmUudXRpbC5pc051bWJlcih0aGlzW2tleV0pO1xufTtcblxubmUudXRpbC5FbnVtID0gRW51bTtcblxufSkod2luZG93Lm5lKTtcblxuLyoqKioqKioqKipcbiAqIGV4TWFwLmpzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiAgSW1wbGVtZW50cyB0aGUgRXhNYXAgKEV4dGVuZGVkIE1hcCkgb2JqZWN0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxlMDI0MkBuaG5lbnQuY29tPlxuICogQGRlcGVuZGVuY3kgTWFwLmpzLCBjb2xsZWN0aW9uLmpzXG4gKi9cblxuKGZ1bmN0aW9uKG5lKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFuZSkge1xuICAgICAgICBuZSA9IHdpbmRvdy5uZSA9IHt9O1xuICAgIH1cbiAgICBpZiAoIW5lLnV0aWwpIHtcbiAgICAgICAgbmUudXRpbCA9IHdpbmRvdy5uZS51dGlsID0ge307XG4gICAgfVxuXG4gICAgLy8gQ2FjaGluZyBuZS51dGlsIGZvciBwZXJmb3JtYW5jZSBlbmhhbmNpbmdcbiAgICB2YXIgdXRpbCA9IG5lLnV0aWwsXG4gICAgICAgIG1hcEFQSXNGb3JSZWFkID0gWydnZXQnLCAnaGFzJywgJ2ZvckVhY2gnLCAna2V5cycsICd2YWx1ZXMnLCAnZW50cmllcyddLFxuICAgICAgICBtYXBBUElzRm9yRGVsZXRlID0gWydkZWxldGUnLCAnY2xlYXInXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBFeE1hcCBvYmplY3QgaXMgRXh0ZW5kZWQgVmVyc2lvbiBvZiB0aGUgbmUudXRpbC5NYXAgb2JqZWN0Ljxicj5cbiAgICAgKiBhbmQgYWRkZWQgc29tZSB1c2VmdWwgZmVhdHVyZSB0byBtYWtlIGl0IGVhc3kgdG8gbWFuYWdlIHRoZSBNYXAgb2JqZWN0LlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGluaXREYXRhIC0gQXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzICgyLWVsZW1lbnQgQXJyYXlzKS5cbiAgICAgKiAgICAgIEVhY2gga2V5LXZhbHVlIHBhaXIgd2lsbCBiZSBhZGRlZCB0byB0aGUgbmV3IE1hcFxuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXhNYXAoaW5pdERhdGEpIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IHV0aWwuTWFwKGluaXREYXRhKTtcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5fbWFwLnNpemU7XG4gICAgfVxuXG4gICAgdXRpbC5mb3JFYWNoQXJyYXkobWFwQVBJc0ZvclJlYWQsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgRXhNYXAucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwW25hbWVdLmFwcGx5KHRoaXMuX21hcCwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIHV0aWwuZm9yRWFjaEFycmF5KG1hcEFQSXNGb3JEZWxldGUsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgRXhNYXAucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fbWFwW25hbWVdLmFwcGx5KHRoaXMuX21hcCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuX21hcC5zaXplO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIEV4TWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbWFwLnNldC5hcHBseSh0aGlzLl9tYXAsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuX21hcC5zaXplO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBhbGwgb2YgdGhlIGtleS12YWx1ZSBwYWlycyBpbiB0aGUgc3BlY2lmaWVkIG9iamVjdCB0byB0aGUgTWFwIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9iamVjdCAtIFBsYWluIG9iamVjdCB0aGF0IGhhcyBhIGtleS12YWx1ZSBwYWlyXG4gICAgICovXG4gICAgRXhNYXAucHJvdG90eXBlLnNldE9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB1dGlsLmZvckVhY2hPd25Qcm9wZXJ0aWVzKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBlbGVtZW50cyBhc3NvY2lhdGVkIHdpdGgga2V5cyBpbiB0aGUgc3BlY2lmaWVkIGFycmF5LlxuICAgICAqIEBwYXJhbSAge0FycmF5fSBrZXlzIC0gQXJyYXkgdGhhdCBjb250YWlucyBrZXlzIG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZVxuICAgICAqL1xuICAgIEV4TWFwLnByb3RvdHlwZS5kZWxldGVCeUtleXMgPSBmdW5jdGlvbihrZXlzKSB7XG4gICAgICAgIHV0aWwuZm9yRWFjaEFycmF5KGtleXMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdGhpc1snZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgYWxsIG9mIHRoZSBrZXktdmFsdWUgcGFpcnMgaW4gdGhlIHNwZWNpZmllZCBNYXAgb2JqZWN0IHRvIHRoaXMgTWFwIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtNYXB9IG1hcCAtIE1hcCBvYmplY3QgdG8gYmUgbWVyZ2VkIGludG8gdGhpcyBNYXAgb2JqZWN0XG4gICAgICovXG4gICAgRXhNYXAucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTG9va3MgdGhyb3VnaCBlYWNoIGtleS12YWx1ZSBwYWlyIGluIHRoZSBtYXAgYW5kIHJldHVybnMgdGhlIG5ldyBFeE1hcCBvYmplY3Qgb2ZcbiAgICAgKiBhbGwga2V5LXZhbHVlIHBhaXJzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBwcmVkaWNhdGUgLSBGdW5jdGlvbiB0byB0ZXN0IGVhY2gga2V5LXZhbHVlIHBhaXIgb2YgdGhlIE1hcCBvYmplY3QuPGJyPlxuICAgICAqICAgICAgSW52b2tlZCB3aXRoIGFyZ3VtZW50cyAodmFsdWUsIGtleSkuIFJldHVybiB0cnVlIHRvIGtlZXAgdGhlIGVsZW1lbnQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcmV0dXJuIHtFeE1hcH0gQSBuZXcgRXhNYXAgb2JqZWN0XG4gICAgICovXG4gICAgRXhNYXAucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgZmlsdGVyZWQgPSBuZXcgRXhNYXAoKTtcblxuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkO1xuICAgIH07XG5cbiAgICB1dGlsLkV4TWFwID0gRXhNYXA7XG59KSh3aW5kb3cubmUpO1xuXG4vKioqKioqKioqKlxuICogZm9ybWF0RGF0ZS5qc1xuICoqKioqKioqKiovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIG1vZHVsZSBoYXMgYSBmdW5jdGlvbiBmb3IgZGF0ZSBmb3JtYXQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGUwMjQyQG5obmVudC5jb20+XG4gKiBAZGVwZW5kZW5jeSB0eXBlLmpzXG4gKi9cblxuKGZ1bmN0aW9uKG5lKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHRva2VucyA9IC9bXFxcXF0qWVlZWXxbXFxcXF0qWVl8W1xcXFxdKk1NTU18W1xcXFxdKk1NTXxbXFxcXF0qTU18W1xcXFxdKk18W1xcXFxdKkREfFtcXFxcXSpEfFtcXFxcXSpISHxbXFxcXF0qSHxbXFxcXF0qQS9naSxcbiAgICAgICAgTU9OVEhfU1RSID0gW1wiSW52YWxpZCBtb250aFwiLCBcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxuICAgICAgICBNT05USF9EQVlTID0gWzAsIDMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdLFxuICAgICAgICByZXBsYWNlTWFwID0ge1xuICAgICAgICAgICAgTTogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIoZGF0ZS5tb250aCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTU06IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGggPSBkYXRlLm1vbnRoO1xuICAgICAgICAgICAgICAgIHJldHVybiAoTnVtYmVyKG1vbnRoKSA8IDEwKSA/ICcwJyArIG1vbnRoIDogbW9udGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTU1NOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1PTlRIX1NUUltOdW1iZXIoZGF0ZS5tb250aCldLnN1YnN0cigwLCAzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBNTU1NOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1PTlRIX1NUUltOdW1iZXIoZGF0ZS5tb250aCldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEQ6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKGRhdGUuZGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZDogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlTWFwLkQoZGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgREQ6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF5SW5Nb250aCA9IGRhdGUuZGF0ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKE51bWJlcihkYXlJbk1vbnRoKSA8IDEwKSA/ICcwJyArIGRheUluTW9udGggOiBkYXlJbk1vbnRoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRkOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VNYXAuREQoZGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgWVk6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKGRhdGUueWVhcikgJSAxMDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeXk6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZU1hcC5ZWShkYXRlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBZWVlZOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9ICcyMCcsXG4gICAgICAgICAgICAgICAgICAgIHllYXIgPSBkYXRlLnllYXI7XG4gICAgICAgICAgICAgICAgaWYgKHllYXIgPiA2OSAmJiB5ZWFyIDwgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9ICcxOSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoTnVtYmVyKHllYXIpIDwgMTAwKSA/IHByZWZpeCArIFN0cmluZyh5ZWFyKSA6IHllYXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeXl5eTogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlTWFwLllZWVkoZGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQTogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlLm1lcmlkaWFuO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGE6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZS5tZXJpZGlhbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhoOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhvdXIgPSBkYXRlLmhvdXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChOdW1iZXIoaG91cikgPCAxMCkgPyAnMCcgKyBob3VyIDogaG91cjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBISDogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlTWFwLmhoKGRhdGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGg6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKE51bWJlcihkYXRlLmhvdXIpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBIOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VNYXAuaChkYXRlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhOdW1iZXIoZGF0ZS5taW51dGUpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtbTogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBtaW51dGUgPSBkYXRlLm1pbnV0ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKE51bWJlcihtaW51dGUpIDwgMTApID8gJzAnICsgbWludXRlIDogbWludXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFuZSkge1xuICAgICAgICBuZSA9IHdpbmRvdy5uZSA9IHt9O1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIW5lLnV0aWwpIHtcbiAgICAgICAgbmUudXRpbCA9IHdpbmRvdy5uZS51dGlsID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGVzIGFyZSB2YWxpZCBkYXRlIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geWVhciAtIFllYXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbW9udGggLSBNb250aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRlIC0gRGF5IGluIG1vbnRoLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBJcyB2YWxpZD9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1ZhbGlkRGF0ZSh5ZWFyLCBtb250aCwgZGF0ZSkge1xuICAgICAgICB2YXIgaXNWYWxpZFllYXIsXG4gICAgICAgICAgICBpc1ZhbGlkTW9udGgsXG4gICAgICAgICAgICBpc1ZhbGlkLFxuICAgICAgICAgICAgbGFzdERheUluTW9udGg7XG5cbiAgICAgICAgeWVhciA9IE51bWJlcih5ZWFyKTtcbiAgICAgICAgbW9udGggPSBOdW1iZXIobW9udGgpO1xuICAgICAgICBkYXRlID0gTnVtYmVyKGRhdGUpO1xuXG4gICAgICAgIGlzVmFsaWRZZWFyID0gKHllYXIgPiAtMSAmJiB5ZWFyIDwgMTAwKSB8fCAoeWVhciA+IDE5NjkpICYmICh5ZWFyIDwgMjA3MCk7XG4gICAgICAgIGlzVmFsaWRNb250aCA9IChtb250aCA+IDApICYmIChtb250aCA8IDEzKTtcblxuICAgICAgICBpZiAoIWlzVmFsaWRZZWFyIHx8ICFpc1ZhbGlkTW9udGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3REYXlJbk1vbnRoID0gTU9OVEhfREFZU1ttb250aF07XG4gICAgICAgIGlmIChtb250aCA9PT0gMiAmJiB5ZWFyICUgNCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxhc3REYXlJbk1vbnRoID0gMjk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpc1ZhbGlkID0gKGRhdGUgPiAwKSAmJiAoZGF0ZSA8PSBsYXN0RGF5SW5Nb250aCk7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHN0cmluZyB0aGF0IHRyYW5zZm9ybWVkIGZyb20gdGhlIGdpdmVuIGZvcm0gYW5kIGRhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm0gLSBEYXRlIGZvcm1cbiAgICAgKiBAcGFyYW0ge0RhdGV8T2JqZWN0fSBkYXRlIC0gRGF0ZSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxzdHJpbmd9IEEgdHJhbnNmb3JtZWQgc3RyaW5nIG9yIGZhbHNlLlxuICAgICAqIEBtZW1iZXJPZiBuZS51dGlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgLy8ga2V5ICAgICAgICAgfCBTaG9ydGhhbmRcbiAgICAgKiAgLy8gLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogIC8vIHllYXJzICAgICAgIHwgWVkgLyBZWVlZIC8geXkgLyB5eXl5XG4gICAgICogIC8vIG1vbnRocyhuKSAgIHwgTSAvIE1NXG4gICAgICogIC8vIG1vbnRocyhzdHIpIHwgTU1NIC8gTU1NTVxuICAgICAqICAvLyBkYXlzICAgICAgICB8IEQgLyBERCAvIGQgLyBkZFxuICAgICAqICAvLyBob3VycyAgICAgICB8IEggLyBISCAvIGggLyBoaFxuICAgICAqICAvLyBtaW51dGVzICAgICB8IG0gLyBtbVxuICAgICAqICAvLyBBTS9QTSAgICAgICB8IEEgLyBhXG4gICAgICpcbiAgICAgKiAgdmFyIGRhdGVTdHIxID0gZm9ybWF0RGF0ZSgneXl5eS1NTS1kZCcsIHtcbiAgICAgKiAgICAgIHllYXI6IDIwMTQsXG4gICAgICogICAgICBtb250aDogMTIsXG4gICAgICogICAgICBkYXRlOiAxMlxuICAgICAqICB9KTtcbiAgICAgKiAgYWxlcnQoZGF0ZVN0cjEpOyAvLyAnMjAxNC0xMi0xMidcbiAgICAgKlxuICAgICAqICB2YXIgZGF0ZVN0cjIgPSBmb3JtYXREYXRlKCdNTU0gREQgWVlZWSBISDptbScsIHtcbiAgICAgKiAgICAgIHllYXI6IDE5OTksXG4gICAgICogICAgICBtb250aDogOSxcbiAgICAgKiAgICAgIGRhdGU6IDksXG4gICAgICogICAgICBob3VyOiAwLFxuICAgICAqICAgICAgbWludXRlOiAyXG4gICAgICogIH0pXG4gICAgICogIGFsZXJ0KGRhdGVTdHIyKTsgLy8gJ1NlcCAwOSAxOTk5IDAwOjAyJ1xuICAgICAqXG4gICAgICogIHZhciBkdCA9IG5ldyBEYXRlKDIwMTAsIDIsIDEzKSxcbiAgICAgKiAgICAgIGRhdGVTdHIzID0gZm9ybWF0RGF0ZSgneXl5eeuFhCBN7JuUIGRk7J28JywgZHQpO1xuICAgICAqXG4gICAgICogIGFsZXJ0KGRhdGVTdHIzKTsgLy8gJzIwMTDrhYQgM+yblCAxM+ydvCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JtYXREYXRlKGZvcm0sIGRhdGUpIHtcbiAgICAgICAgdmFyIG1lcmlkaWFuLFxuICAgICAgICAgICAgbkRhdGUsXG4gICAgICAgICAgICByZXN1bHRTdHI7XG5cbiAgICAgICAgaWYgKG5lLnV0aWwuaXNEYXRlKGRhdGUpKSB7XG4gICAgICAgICAgICBuRGF0ZSA9IHtcbiAgICAgICAgICAgICAgICB5ZWFyOiBkYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICAgICAgbW9udGg6IGRhdGUuZ2V0TW9udGgoKSArIDEsXG4gICAgICAgICAgICAgICAgZGF0ZTogZGF0ZS5nZXREYXRlKCksXG4gICAgICAgICAgICAgICAgaG91cjogZGF0ZS5nZXRIb3VycygpLFxuICAgICAgICAgICAgICAgIG1pbnV0ZTogZGF0ZS5nZXRNaW51dGVzKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuRGF0ZSA9IHtcbiAgICAgICAgICAgICAgICB5ZWFyOiBkYXRlLnllYXIsXG4gICAgICAgICAgICAgICAgbW9udGg6IGRhdGUubW9udGgsXG4gICAgICAgICAgICAgICAgZGF0ZTogZGF0ZS5kYXRlLFxuICAgICAgICAgICAgICAgIGhvdXI6IGRhdGUuaG91cixcbiAgICAgICAgICAgICAgICBtaW51dGU6IGRhdGUubWludXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkRGF0ZShuRGF0ZS55ZWFyLCBuRGF0ZS5tb250aCwgbkRhdGUuZGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5EYXRlLm1lcmlkaWFuID0gJyc7XG4gICAgICAgIGlmICgvW15cXFxcXVthQV1cXGIvZy50ZXN0KGZvcm0pKSB7XG4gICAgICAgICAgICBtZXJpZGlhbiA9IChuRGF0ZS5ob3VyID4gMTIpID8gJ1BNJyA6ICdBTSc7XG4gICAgICAgICAgICBuRGF0ZS5ob3VyICU9IDEyO1xuICAgICAgICAgICAgbkRhdGUubWVyaWRpYW4gPSBtZXJpZGlhbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdFN0ciA9IGZvcm0ucmVwbGFjZSh0b2tlbnMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKCdcXFxcJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXkucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlTWFwW2tleV0obkRhdGUpIHx8ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFN0cjtcbiAgICB9XG5cbiAgICBuZS51dGlsLmZvcm1hdERhdGUgPSBmb3JtYXREYXRlO1xufSkod2luZG93Lm5lKTtcblxuXG4vKioqKioqKioqKlxuICogZnVuYy5qc1xuICoqKioqKioqKiovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIG1vZHVsZSBwcm92aWRlcyBhIGJpbmQoKSBmdW5jdGlvbiBmb3IgY29udGV4dCBiaW5kaW5nLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxlMDI0MkBuaG5lbnQuY29tPlxuICovXG5cbihmdW5jdGlvbihuZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghbmUpIHtcbiAgICAgICAgbmUgPSB3aW5kb3cubmUgPSB7fTtcbiAgICB9XG4gICAgaWYgKCFuZS51dGlsKSB7XG4gICAgICAgIG5lLnV0aWwgPSB3aW5kb3cubmUudXRpbCA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaGFzIGl0cyB0aGlzIGtleXdvcmQgc2V0IHRvIHRoZSBwcm92aWRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBBIG9yaWdpbmFsIGZ1bmN0aW9uIGJlZm9yZSBiaW5kaW5nXG4gICAgICogQHBhcmFtIHsqfSBvYmogY29udGV4dCBvZiBmdW5jdGlvbiBpbiBhcmd1bWVudHNbMF1cbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbigpfSBBIG5ldyBib3VuZCBmdW5jdGlvbiB3aXRoIGNvbnRleHQgdGhhdCBpcyBpbiBhcmd1bWVudHNbMV1cbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmQoZm4sIG9iaikge1xuICAgICAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgICAgICAgaWYgKGZuLmJpbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBmbi5iaW5kLmFwcGx5KGZuLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MubGVuZ3RoID8gYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6IGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbmUudXRpbC5iaW5kID0gYmluZDtcblxufSkod2luZG93Lm5lKTtcblxuLyoqKioqKioqKipcbiAqIGhhc2hNYXAuanNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBtb2R1bGUgcHJvdmlkZXMgdGhlIEhhc2hNYXAgY29uc3RydWN0b3IuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGUwMjQyQG5obmVudC5jb20+XG4gKiBAZGVwZW5kZW5jeSB0eXBlLCBjb2xsZWN0aW9uLmpzXG4gKi9cblxuKGZ1bmN0aW9uKG5lKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFuZSkge1xuICAgICAgICBuZSA9IHdpbmRvdy5uZSA9IHt9O1xuICAgIH1cbiAgICBpZiAoIW5lLnV0aWwpIHtcbiAgICAgICAgbmUudXRpbCA9IHdpbmRvdy5uZS51dGlsID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxsIHRoZSBkYXRhIGluIGhhc2hNYXAgYmVnaW4gd2l0aCBfTUFQREFUQVBSRUZJWDtcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdmFyIF9NQVBEQVRBUFJFRklYID0gJ8OlJztcblxuICAgIC8qKlxuICAgICAqIEhhc2hNYXAgY2FuIGhhbmRsZSB0aGUga2V5LXZhbHVlIHBhaXJzLjxicj5cbiAgICAgKiBDYXV0aW9uOjxicj5cbiAgICAgKiAgSGFzaE1hcCBpbnN0YW5jZSBoYXMgYSBsZW5ndGggcHJvcGVydHkgYnV0IGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBBcnJheS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29ial0gQSBpbml0aWFsIGRhdGEgZm9yIGNyZWF0aW9uLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgdmFyIGhtID0gbmV3IG5lLnV0aWwuSGFzaE1hcCh7XG4gICAgICogICAgICAnbXlkYXRhJzoge1xuICAgICAqICAgICAgICAgICAnaGVsbG8nOiAnaW1maW5lJ1xuICAgICAqICAgICAgIH0sXG4gICAgICogICAgICAnd2hhdCc6ICd0aW1lJ1xuICAgICAqICB9KTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIYXNoTWFwKG9iaikge1xuICAgICAgICAvKipcbiAgICAgICAgICogc2l6ZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T2JqZWN0KG9iaik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBkYXRhIGZyb20gdGhlIGdpdmVuIGtleSB3aXRoIHZhbHVlIG9yIHRoZSBnaXZlbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBrZXkgQSBzdHJpbmcgb3Igb2JqZWN0IGZvciBrZXlcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZV0gQSBkYXRhXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgdmFyIGhtID0gbmV3IEhhc2hNYXAoKTtcbiAgICAgKlxuICAgICAqICBobS5zZXQoJ2tleScsICd2YWx1ZScpO1xuICAgICAqICBobS5zZXQoe1xuICAgICAqICAgICAgJ2tleTEnOiAnZGF0YTEnLFxuICAgICAqICAgICAgJ2tleTInOiAnZGF0YTInXG4gICAgICogIH0pO1xuICAgICAqL1xuICAgIEhhc2hNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdGhpcy5zZXRLZXlWYWx1ZShrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T2JqZWN0KGtleSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGEgZGF0YSBmcm9tIHRoZSBnaXZlbiBrZXkgd2l0aCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEEgc3RyaW5nIGZvciBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEEgZGF0YVxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciBobSA9IG5ldyBIYXNoTWFwKCk7XG4gICAgICogIGhtLnNldEtleVZhbHVlKCdrZXknLCAndmFsdWUnKTtcbiAgICAgKi9cbiAgICBIYXNoTWFwLnByb3RvdHlwZS5zZXRLZXlWYWx1ZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbdGhpcy5lbmNvZGVLZXkoa2V5KV0gPSB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGEgZGF0YSBmcm9tIHRoZSBnaXZlbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBBIG9iamVjdCBmb3IgZGF0YVxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciBobSA9IG5ldyBIYXNoTWFwKCk7XG4gICAgICpcbiAgICAgKiAgaG0uc2V0T2JqZWN0KHtcbiAgICAgKiAgICAgICdrZXkxJzogJ2RhdGExJyxcbiAgICAgKiAgICAgICdrZXkyJzogJ2RhdGEyJ1xuICAgICAqICB9KTtcbiAgICAgKi9cbiAgICBIYXNoTWFwLnByb3RvdHlwZS5zZXRPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIG5lLnV0aWwuZm9yRWFjaE93blByb3BlcnRpZXMob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBzZWxmLnNldEtleVZhbHVlKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWVyZ2Ugd2l0aCB0aGUgZ2l2ZW4gYW5vdGhlciBoYXNoTWFwLlxuICAgICAqIEBwYXJhbSB7SGFzaE1hcH0gaGFzaE1hcCBBbm90aGVyIGhhc2hNYXAgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBIYXNoTWFwLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKGhhc2hNYXApIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGhhc2hNYXAuZWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBzZWxmLnNldEtleVZhbHVlKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlIHRoZSBnaXZlbiBrZXkgZm9yIGhhc2hNYXAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBBIHN0cmluZyBmb3Iga2V5XG4gICAgICogQHJldHVybnMge3N0cmluZ30gQSBlbmNvZGVkIGtleVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSGFzaE1hcC5wcm90b3R5cGUuZW5jb2RlS2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBfTUFQREFUQVBSRUZJWCArIGtleTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlIHRoZSBnaXZlbiBrZXkgaW4gaGFzaE1hcC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEEgc3RyaW5nIGZvciBrZXlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBBIGRlY29kZWQga2V5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBIYXNoTWFwLnByb3RvdHlwZS5kZWNvZGVLZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGRlY29kZWRLZXkgPSBrZXkuc3BsaXQoX01BUERBVEFQUkVGSVgpO1xuICAgICAgICByZXR1cm4gZGVjb2RlZEtleVtkZWNvZGVkS2V5Lmxlbmd0aC0xXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBrZXkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBBIHN0cmluZyBmb3Iga2V5XG4gICAgICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSBmcm9tIGEga2V5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgdmFyIGhtID0gbmV3IEhhc2hNYXAoKTtcbiAgICAgKiAgaG0uc2V0KCdrZXknLCAndmFsdWUnKTtcbiAgICAgKlxuICAgICAqICBobS5nZXQoJ2tleScpIC8vIHZhbHVlXG4gICAgICovXG4gICAgSGFzaE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzW3RoaXMuZW5jb2RlS2V5KGtleSldO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGUgZXhpc3RlbmNlIG9mIGEgdmFsdWUgZnJvbSB0aGUga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgQSBzdHJpbmcgZm9yIGtleVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBJbmRpY2F0aW5nIHdoZXRoZXIgYSB2YWx1ZSBleGlzdHMgb3Igbm90LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciBobSA9IG5ldyBIYXNoTWFwKCk7XG4gICAgICogIGhtLnNldCgna2V5JywgJ3ZhbHVlJyk7XG4gICAgICpcbiAgICAgKiAgaG0uaGFzKCdrZXknKSAvLyB0cnVlXG4gICAgICovXG4gICAgSGFzaE1hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc093blByb3BlcnR5KHRoaXMuZW5jb2RlS2V5KGtleSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBkYXRhKGtleS12YWx1ZSBwYWlycykgZnJvbSB0aGUgZ2l2ZW4ga2V5IG9yIHRoZSBnaXZlbiBrZXktbGlzdC5cbiAgICAgKiBAcGFyYW0gey4uLnN0cmluZ3xzdHJpbmdbXX0ga2V5IEEgc3RyaW5nIGZvciBrZXlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHN0cmluZ1tdfSBBIHJlbW92ZWQgZGF0YVxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciBobSA9IG5ldyBIYXNoTWFwKCk7XG4gICAgICogIGhtLnNldCgna2V5JywgJ3ZhbHVlJyk7XG4gICAgICogIGhtLnNldCgna2V5MicsICd2YWx1ZScpO1xuICAgICAqXG4gICAgICogIC8vZXgxXG4gICAgICogIGhtLnJlbW92ZSgna2V5Jyk7XG4gICAgICpcbiAgICAgKiAgLy9leDJcbiAgICAgKiAgaG0ucmVtb3ZlKCdrZXknLCAna2V5MicpO1xuICAgICAqXG4gICAgICogIC8vZXgzXG4gICAgICogIGhtLnJlbW92ZShbJ2tleScsICdrZXkyJ10pO1xuICAgICAqL1xuICAgIEhhc2hNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGtleSA9IG5lLnV0aWwudG9BcnJheShhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5lLnV0aWwuaXNBcnJheShrZXkpID8gdGhpcy5yZW1vdmVCeUtleUFycmF5KGtleSkgOiB0aGlzLnJlbW92ZUJ5S2V5KGtleSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBkYXRhKGtleS12YWx1ZSBwYWlyKSBmcm9tIHRoZSBnaXZlbiBrZXkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBBIHN0cmluZyBmb3Iga2V5XG4gICAgICogQHJldHVybnMgeyp8bnVsbH0gQSByZW1vdmVkIGRhdGFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICB2YXIgaG0gPSBuZXcgSGFzaE1hcCgpO1xuICAgICAqICBobS5zZXQoJ2tleScsICd2YWx1ZScpO1xuICAgICAqXG4gICAgICogIGhtLnJlbW92ZUJ5S2V5KCdrZXknKVxuICAgICAqL1xuICAgIEhhc2hNYXAucHJvdG90eXBlLnJlbW92ZUJ5S2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5oYXMoa2V5KSA/IHRoaXMuZ2V0KGtleSkgOiBudWxsO1xuXG4gICAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpc1t0aGlzLmVuY29kZUtleShrZXkpXTtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgZGF0YShrZXktdmFsdWUgcGFpcnMpIGZyb20gdGhlIGdpdmVuIGtleS1saXN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGtleUFycmF5IEFuIGFycmF5IG9mIGtleXNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IEEgcmVtb3ZlZCBkYXRhXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgdmFyIGhtID0gbmV3IEhhc2hNYXAoKTtcbiAgICAgKiAgaG0uc2V0KCdrZXknLCAndmFsdWUnKTtcbiAgICAgKiAgaG0uc2V0KCdrZXkyJywgJ3ZhbHVlJyk7XG4gICAgICpcbiAgICAgKiAgaG0ucmVtb3ZlQnlLZXlBcnJheShbJ2tleScsICdrZXkyJ10pO1xuICAgICAqL1xuICAgIEhhc2hNYXAucHJvdG90eXBlLnJlbW92ZUJ5S2V5QXJyYXkgPSBmdW5jdGlvbihrZXlBcnJheSkge1xuICAgICAgICB2YXIgZGF0YSA9IFtdLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgbmUudXRpbC5mb3JFYWNoKGtleUFycmF5LCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGRhdGEucHVzaChzZWxmLnJlbW92ZUJ5S2V5KGtleSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCB0aGUgZGF0YVxuICAgICAqL1xuICAgIEhhc2hNYXAucHJvdG90eXBlLnJlbW92ZUFsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIHNlbGYucmVtb3ZlKGtleSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBvbmNlIGZvciBlYWNoIGFsbCB0aGUgZGF0YS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciBobSA9IG5ldyBIYXNoTWFwKCk7XG4gICAgICogIGhtLnNldCgna2V5JywgJ3ZhbHVlJyk7XG4gICAgICogIGhtLnNldCgna2V5MicsICd2YWx1ZScpO1xuICAgICAqXG4gICAgICogIGhtLmVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgICAgLy9kbyBzb21ldGhpbmcuLi5cbiAgICAgKiAgfSk7XG4gICAgICovXG4gICAgSGFzaE1hcC5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGZsYWc7XG5cbiAgICAgICAgbmUudXRpbC5mb3JFYWNoT3duUHJvcGVydGllcyh0aGlzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5LmNoYXJBdCgwKSA9PT0gX01BUERBVEFQUkVGSVgpIHtcbiAgICAgICAgICAgICAgICBmbGFnID0gaXRlcmF0ZWUodmFsdWUsIHNlbGYuZGVjb2RlS2V5KGtleSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmxhZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUga2V5LWxpc3Qgc3RvcmVkLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQSBrZXktbGlzdFxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciBobSA9IG5ldyBIYXNoTWFwKCk7XG4gICAgICogIGhtLnNldCgna2V5JywgJ3ZhbHVlJyk7XG4gICAgICogIGhtLnNldCgna2V5MicsICd2YWx1ZScpO1xuICAgICAqXG4gICAgICogIGhtLmtleXMoKTsgIC8vWydrZXknLCAna2V5MicpO1xuICAgICAqL1xuICAgIEhhc2hNYXAucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goc2VsZi5kZWNvZGVLZXkoa2V5KSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXb3JrIHNpbWlsYXJseSB0byBBcnJheS5wcm90b3R5cGUubWFwKCkuPGJyPlxuICAgICAqIEl0IGV4ZWN1dGVzIHRoZSBwcm92aWRlZCBjYWxsYmFjayB0aGF0IGNoZWNrcyBjb25kaXRpb25zIG9uY2UgZm9yIGVhY2ggZWxlbWVudCBvZiBoYXNoTWFwLDxicj5cbiAgICAgKiAgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgaGF2aW5nIGVsZW1lbnRzIHNhdGlzZnlpbmcgdGhlIGNvbmRpdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25kaXRpb24gQSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBjb25kaXRpb25zXG4gICAgICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBoYXZpbmcgZWxlbWVudHMgc2F0aXNmeWluZyB0aGUgY29uZGl0aW9uc1xuICAgICAqIEBleGFtcGxlXG4gICAgICogIC8vZXgxXG4gICAgICogIHZhciBobSA9IG5ldyBIYXNoTWFwKCk7XG4gICAgICogIGhtLnNldCgna2V5JywgJ3ZhbHVlJyk7XG4gICAgICogIGhtLnNldCgna2V5MicsICd2YWx1ZScpO1xuICAgICAqXG4gICAgICogIGhtLmZpbmQoZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgICAgcmV0dXJuIGtleSA9PT0gJ2tleTInO1xuICAgICAqICB9KTsgLy8gWyd2YWx1ZSddXG4gICAgICpcbiAgICAgKiAgLy9leDJcbiAgICAgKiAgdmFyIGhtID0gbmV3IEhhc2hNYXAoe1xuICAgICAqICAgICAgJ215b2JqMSc6IHtcbiAgICAgKiAgICAgICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgICAqICAgICAgIH0sXG4gICAgICogICAgICAnbXlib2JqMic6IHtcbiAgICAgKiAgICAgICAgICAgdmlzaWJsZTogZmFsc2VcbiAgICAgKiAgICAgICB9XG4gICAgICogIH0pO1xuICAgICAqXG4gICAgICogIGhtLmZpbmQoZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICAgKiAgICAgIHJldHVybiBvYmoudmlzaWJsZSA9PT0gdHJ1ZTtcbiAgICAgKiAgfSk7IC8vIFt7dmlzaWJsZTogdHJ1ZX1dO1xuICAgICAqL1xuICAgIEhhc2hNYXAucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihjb25kaXRpb24pIHtcbiAgICAgICAgdmFyIGZvdW5kcyA9IFtdO1xuXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgZm91bmRzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZm91bmRzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgQXJyYXkgaGF2aW5nIGFsbCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBoYXZpbmcgYWxsIHZhbHVlc1xuICAgICAqL1xuICAgIEhhc2hNYXAucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgbmUudXRpbC5IYXNoTWFwID0gSGFzaE1hcDtcblxufSkod2luZG93Lm5lKTtcblxuLyoqKioqKioqKipcbiAqIGluaGVyaXRhbmNlLmpzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgbW9kdWxlIHByb3ZpZGVzIHNvbWUgc2ltcGxlIGZ1bmN0aW9uIGZvciBpbmhlcml0YW5jZS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZTAyNDJAbmhuZW50LmNvbT5cbiAqL1xuXG4oZnVuY3Rpb24obmUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFuZSkge1xuICAgICAgICBuZSA9IHdpbmRvdy5uZSA9IHt9O1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIW5lLnV0aWwpIHtcbiAgICAgICAgbmUudXRpbCA9IHdpbmRvdy5uZS51dGlsID0ge307XG4gICAgfVxuXG5cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIHByb3RvdHlwZSBvYmplY3QgYW5kIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGlzIG9iamVjdCB3aWxsIGJlIGEgcHJvdG90eXBlIG9mIHRoZSBuZXdseS1jcmVhdGVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICogQG1lbWJlcm9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVPYmplY3QoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEYoKSB7fVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIEYucHJvdG90eXBlID0gb2JqO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZSBhIHNpbXBsZSBpbmhlcml0YW5jZSBpbiBwcm90b3R5cGUtb3JpZW50ZWQuXG4gICAgICogQ2F1dGlvbiA6XG4gICAgICogIERvbid0IG92ZXJ3cml0ZSB0aGUgcHJvdG90eXBlIG9mIGNoaWxkIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gc3ViVHlwZSBDaGlsZCBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyVHlwZSBQYXJlbnQgY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICogIC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuICAgICAqICBmdW5jdGlvbiBBbmltYWwobGVnKSB7XG4gICAgICogICAgICB0aGlzLmxlZyA9IGxlZztcbiAgICAgKiAgfVxuICAgICAqXG4gICAgICogIEFuaW1hbC5wcm90b3R5cGUuZ3Jvd2wgPSBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgIC8vIC4uLlxuICAgICAqICB9O1xuICAgICAqXG4gICAgICogIC8vIENoaWxkIGNvbnN0cnVjdG9yXG4gICAgICogIGZ1bmN0aW9uIFBlcnNvbihuYW1lKSB7XG4gICAgICogICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAqICB9XG4gICAgICpcbiAgICAgKiAgLy8gSW5oZXJpdGFuY2VcbiAgICAgKiAgY29yZS5pbmhlcml0KFBlcnNvbiwgQW5pbWFsKTtcbiAgICAgKlxuICAgICAqICAvLyBBZnRlciB0aGlzIGluaGVyaXRhbmNlLCBwbGVhc2UgdXNlIG9ubHkgdGhlIGV4dGVuZGluZyBvZiBwcm9wZXJ0eS5cbiAgICAgKiAgLy8gRG8gbm90IG92ZXJ3cml0ZSBwcm90b3R5cGUuXG4gICAgICogIFBlcnNvbi5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuICAgICAqICAgICAgLy8gLi4uXG4gICAgICogIH07XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5oZXJpdChzdWJUeXBlLCBzdXBlclR5cGUpIHtcbiAgICAgICAgdmFyIHByb3RvdHlwZSA9IG5lLnV0aWwuY3JlYXRlT2JqZWN0KHN1cGVyVHlwZS5wcm90b3R5cGUpO1xuICAgICAgICBwcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJUeXBlO1xuICAgICAgICBzdWJUeXBlLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB9XG5cbiAgICBuZS51dGlsLmNyZWF0ZU9iamVjdCA9IGNyZWF0ZU9iamVjdCgpO1xuICAgIG5lLnV0aWwuaW5oZXJpdCA9IGluaGVyaXQ7XG5cbn0pKHdpbmRvdy5uZSk7XG5cbi8qKioqKioqKioqXG4gKiBtYXAuanNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqICBJbXBsZW1lbnRzIHRoZSBNYXAgb2JqZWN0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxlMDI0MkBuaG5lbnQuY29tPlxuICogQGRlcGVuZGVuY3kgdHlwZS5qcywgY29sbGVjdGlvbi5qc1xuICovXG5cbihmdW5jdGlvbihuZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghbmUpIHtcbiAgICAgICAgbmUgPSB3aW5kb3cubmUgPSB7fTtcbiAgICB9XG4gICAgaWYgKCFuZS51dGlsKSB7XG4gICAgICAgIG5lLnV0aWwgPSB3aW5kb3cubmUudXRpbCA9IHt9O1xuICAgIH1cblxuXG4gICAgLy8gQ2FjaGluZyBuZS51dGlsIGZvciBwZXJmb3JtYW5jZSBlbmhhbmNpbmdcbiAgICB2YXIgdXRpbCA9IG5lLnV0aWwsXG5cbiAgICAvKipcbiAgICAgKiBVc2luZyB1bmRlZmluZWQgZm9yIGEga2V5IGNhbiBiZSBhbWJpZ3VvdXMgaWYgdGhlcmUncyBkZWxldGVkIGl0ZW0gaW4gdGhlIGFycmF5LDxicj5cbiAgICAgKiB3aGljaCBpcyBhbHNvIHVuZGVmaW5lZCB3aGVuIGFjY2Vzc2VkIGJ5IGluZGV4Ljxicj5cbiAgICAgKiBTbyB1c2UgdGhpcyB1bmlxdWUgb2JqZWN0IGFzIGFuIHVuZGVmaW5lZCBrZXkgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbSBkZWxldGVkIGtleXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICBfS0VZX0ZPUl9VTkRFRklORUQgPSB7fSxcblxuICAgIC8qKlxuICAgICAqIEZvciB1c2luZyBOYU4gYXMgYSBrZXksIHVzZSB0aGlzIHVuaXF1ZSBvYmplY3QgYXMgYSBOYU4ga2V5Ljxicj5cbiAgICAgKiBUaGlzIG1ha2VzIGl0IGVhc2llciBhbmQgZmFzdGVyIHRvIGNvbXBhcmUgYW4gb2JqZWN0IHdpdGggZWFjaCBrZXlzIGluIHRoZSBhcnJheTxicj5cbiAgICAgKiB0aHJvdWdoIG5vIGV4Y2VwdGlvbmFsIGNvbWFwcmluZyBmb3IgTmFOLlxuICAgICAqL1xuICAgIF9LRVlfRk9SX05BTiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3Igb2YgTWFwSXRlcmF0b3I8YnI+XG4gICAgICogQ3JlYXRlcyBpdGVyYXRvciBvYmplY3Qgd2l0aCBuZXcga2V5d29yZC5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0ga2V5cyAtIFRoZSBhcnJheSBvZiBrZXlzIGluIHRoZSBtYXBcbiAgICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gdmFsdWVHZXR0ZXIgLSBGdW5jdGlvbiB0aGF0IHJldHVybnMgY2VydGFpbiB2YWx1ZSxcbiAgICAgKiAgICAgIHRha2luZyBrZXkgYW5kIGtleUluZGV4IGFzIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXBJdGVyYXRvcihrZXlzLCB2YWx1ZUdldHRlcikge1xuICAgICAgICB0aGlzLl9rZXlzID0ga2V5cztcbiAgICAgICAgdGhpcy5fdmFsdWVHZXR0ZXIgPSB2YWx1ZUdldHRlcjtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdGhpcy5fa2V5cy5sZW5ndGg7XG4gICAgICAgIHRoaXMuX2luZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBvZiBJdGVyYXRvciBwcm90b2NvbC5cbiAgICAgKiBAcmV0dXJuIHt7ZG9uZTogYm9vbGVhbiwgdmFsdWU6ICp9fSBPYmplY3QgdGhhdCBjb250YWlucyBkb25lKGJvb2xlYW4pIGFuZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgIHRoaXMuX2luZGV4ICs9IDE7XG4gICAgICAgfSB3aGlsZSAodXRpbC5pc1VuZGVmaW5lZCh0aGlzLl9rZXlzW3RoaXMuX2luZGV4XSkgJiYgdGhpcy5faW5kZXggPCB0aGlzLl9sZW5ndGgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pbmRleCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgICAgIGRhdGEuZG9uZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGRhdGEudmFsdWUgPSB0aGlzLl92YWx1ZUdldHRlcih0aGlzLl9rZXlzW3RoaXMuX2luZGV4XSwgdGhpcy5faW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgTWFwIG9iamVjdCBpbXBsZW1lbnRzIHRoZSBFUzYgTWFwIHNwZWNpZmljYXRpb24gYXMgY2xvc2VseSBhcyBwb3NzaWJsZS48YnI+XG4gICAgICogRm9yIHVzaW5nIG9iamVjdHMgYW5kIHByaW1pdGl2ZSB2YWx1ZXMgYXMga2V5cywgdGhpcyBvYmplY3QgdXNlcyBhcnJheSBpbnRlcm5hbGx5Ljxicj5cbiAgICAgKiBTbyBpZiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgZ2V0KCksIHNldCgpLCBoYXMoKSwgZGVsZXRlKCkgd2lsbCBvcGVyYXRlcyBpbiBPKG4pLDxicj5cbiAgICAgKiBhbmQgaXQgY2FuIGNhdXNlIHBlcmZvcm1hbmNlIGlzc3VlcyB3aXRoIGEgbGFyZ2UgZGF0YXNldC5cbiAgICAgKlxuICAgICAqIEZlYXR1cmVzIGxpc3RlZCBiZWxvdyBhcmUgbm90IHN1cHBvcnRlZC4gKGNhbid0IGJlIGltcGxlbnRlZCB3aXRob3V0IG5hdGl2ZSBzdXBwb3J0KVxuICAgICAqIC0gTWFwIG9iamVjdCBpcyBpdGVyYWJsZTxicj5cbiAgICAgKiAtIEl0ZXJhYmxlIG9iamVjdCBjYW4gYmUgdXNlZCBhcyBhbiBhcmd1bWVudCBvZiBjb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogSWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgZnVsbCBpbXBsZW1lbnRhdGlvbiBvZiBFUzYgTWFwIHNwZWNpZmljYXRpb24sIG5hdGl2ZSBNYXAgb2JlamN0XG4gICAgICogd2lsbCBiZSB1c2VkIGludGVybmFsbHkuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGluaXREYXRhIC0gQXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzICgyLWVsZW1lbnQgQXJyYXlzKS5cbiAgICAgKiAgICAgIEVhY2gga2V5LXZhbHVlIHBhaXIgd2lsbCBiZSBhZGRlZCB0byB0aGUgbmV3IE1hcFxuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFwKGluaXREYXRhKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlc0ZvclN0cmluZyA9IHt9O1xuICAgICAgICB0aGlzLl92YWx1ZXNGb3JJbmRleCA9IHt9O1xuICAgICAgICB0aGlzLl9rZXlzID0gW107XG5cbiAgICAgICAgaWYgKGluaXREYXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRJbml0RGF0YShpbml0RGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhbGwgZWxlbWVudHMgaW4gdGhlIGluaXREYXRhIHRvIHRoZSBNYXAgb2JqZWN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGluaXREYXRhIC0gQXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCB0byB0aGUgTWFwIG9iamVjdFxuICAgICAqL1xuICAgIE1hcC5wcm90b3R5cGUuX3NldEluaXREYXRhID0gZnVuY3Rpb24oaW5pdERhdGEpIHtcbiAgICAgICAgaWYgKCF1dGlsLmlzQXJyYXkoaW5pdERhdGEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgQXJyYXkgaXMgc3VwcG9ydGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuZm9yRWFjaEFycmF5KGluaXREYXRhLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgICAgICB0aGlzLnNldChwYWlyWzBdLCBwYWlyWzFdKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIE5hTi48YnI+XG4gICAgICogRm9yIHVuc2luZyBOYU4gYXMgYSBrZXksIHVzZSB0aGlzIG1ldGhvZCB0byB0ZXN0IGVxdWFsaXR5IG9mIE5hTjxicj5cbiAgICAgKiBiZWNhdXNlID09PSBvcGVyYXRvciBkb2Vzbid0IHdvcmsgZm9yIE5hTi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBBbnkgb2JqZWN0IHRvIGJlIHRlc3RlZFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgTmFOLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgTWFwLnByb3RvdHlwZS5faXNOYU4gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gdmFsdWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBzcGVjaWZpZWQga2V5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7Kn0ga2V5IC0gVGhlIGtleSBvYmplY3QgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgc3BlY2lmaWVkIGtleVxuICAgICAqL1xuICAgIE1hcC5wcm90b3R5cGUuX2dldEtleUluZGV4ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAtMSxcbiAgICAgICAgICAgIHZhbHVlO1xuXG4gICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fdmFsdWVzRm9yU3RyaW5nW2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS5rZXlJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHV0aWwuaW5BcnJheShrZXksIHRoaXMuX2tleXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIGtleSBvZiB0aGUgc3BlY2lmaWVkIGtleS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAgeyp9IGtleSAtIGtleVxuICAgICAqIEByZXR1cm4geyp9IE9yaWdpbmFsIGtleVxuICAgICAqL1xuICAgIE1hcC5wcm90b3R5cGUuX2dldE9yaWdpbktleSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgb3JpZ2luS2V5ID0ga2V5O1xuICAgICAgICBpZiAoa2V5ID09PSBfS0VZX0ZPUl9VTkRFRklORUQpIHtcbiAgICAgICAgICAgIG9yaWdpbktleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IF9LRVlfRk9SX05BTikge1xuICAgICAgICAgICAgb3JpZ2luS2V5ID0gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW5LZXk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVuaXF1ZSBrZXkgb2YgdGhlIHNwZWNpZmllZCBrZXkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHsqfSBrZXkgLSBrZXlcbiAgICAgKiBAcmV0dXJuIHsqfSBVbmlxdWUga2V5XG4gICAgICovXG4gICAgTWFwLnByb3RvdHlwZS5fZ2V0VW5pcXVlS2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciB1bmlxdWVLZXkgPSBrZXk7XG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGtleSkpIHtcbiAgICAgICAgICAgIHVuaXF1ZUtleSA9IF9LRVlfRk9SX1VOREVGSU5FRDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc05hTihrZXkpKSB7XG4gICAgICAgICAgICB1bmlxdWVLZXkgPSBfS0VZX0ZPUl9OQU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuaXF1ZUtleTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2JqZWN0IG9mIHRoZSBzcGVjaWZpZWQga2V5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7Kn0ga2V5IC0gVGhlIGtleSBvZiB0aGUgdmFsdWUgb2JqZWN0IHRvIGJlIHJldHVybmVkXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBrZXlJbmRleCAtIFRoZSBpbmRleCBvZiB0aGUga2V5XG4gICAgICogQHJldHVybiB7e2tleUluZGV4OiBudW1iZXIsIG9yaWdpbjogKn19IFZhbHVlIG9iamVjdFxuICAgICAqL1xuICAgIE1hcC5wcm90b3R5cGUuX2dldFZhbHVlT2JqZWN0ID0gZnVuY3Rpb24oa2V5LCBrZXlJbmRleCkge1xuICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzRm9yU3RyaW5nW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChrZXlJbmRleCkpIHtcbiAgICAgICAgICAgICAgICBrZXlJbmRleCA9IHRoaXMuX2dldEtleUluZGV4KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXNGb3JJbmRleFtrZXlJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBrZXkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHsqfSBrZXkgLSBUaGUga2V5IG9mIHRoZSB2YWx1ZSBvYmplY3QgdG8gYmUgcmV0dXJuZWRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGtleUluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBrZXlcbiAgICAgKiBAcmV0dXJuIHsqfSBPcmlnaW5hbCB2YWx1ZVxuICAgICAqL1xuICAgIE1hcC5wcm90b3R5cGUuX2dldE9yaWdpblZhbHVlID0gZnVuY3Rpb24oa2V5LCBrZXlJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VmFsdWVPYmplY3Qoa2V5LCBrZXlJbmRleCkub3JpZ2luO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGtleS12YWx1ZSBwYWlyIG9mIHRoZSBzcGVjaWZpZWQga2V5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7Kn0ga2V5IC0gVGhlIGtleSBvZiB0aGUgdmFsdWUgb2JqZWN0IHRvIGJlIHJldHVybmVkXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBrZXlJbmRleCAtIFRoZSBpbmRleCBvZiB0aGUga2V5XG4gICAgICogQHJldHVybiB7QXJyYXl9IEtleS12YWx1ZSBQYWlyXG4gICAgICovXG4gICAgTWFwLnByb3RvdHlwZS5fZ2V0S2V5VmFsdWVQYWlyID0gZnVuY3Rpb24oa2V5LCBrZXlJbmRleCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuX2dldE9yaWdpbktleShrZXkpLCB0aGlzLl9nZXRPcmlnaW5WYWx1ZShrZXksIGtleUluZGV4KV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHdyYXBwZXIgb2JqZWN0IG9mIG9yaWdpbmFsIHZhbHVlIHRoYXQgY29udGFpbnMgYSBrZXkgaW5kZXhcbiAgICAgKiBhbmQgcmV0dXJucyBpdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAge3R5cGV9IG9yaWdpbiAtIE9yaWdpbmFsIHZhbHVlXG4gICAgICogQHBhcmFtICB7dHlwZX0ga2V5SW5kZXggLSBJbmRleCBvZiB0aGUga2V5XG4gICAgICogQHJldHVybiB7e2tleUluZGV4OiBudW1iZXIsIG9yaWdpbjogKn19IFZhbHVlIG9iamVjdFxuICAgICAqL1xuICAgIE1hcC5wcm90b3R5cGUuX2NyZWF0ZVZhbHVlT2JqZWN0ID0gZnVuY3Rpb24ob3JpZ2luLCBrZXlJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5SW5kZXg6IGtleUluZGV4LFxuICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW5cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgZm9yIHRoZSBrZXkgaW4gdGhlIE1hcCBvYmplY3QuXG4gICAgICogQHBhcmFtICB7Kn0ga2V5IC0gVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byBhZGQgdG8gdGhlIE1hcCBvYmplY3RcbiAgICAgKiBAcGFyYW0gIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCB0byBhZGQgdG8gdGhlIE1hcCBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtNYXB9IFRoZSBNYXAgb2JqZWN0XG4gICAgICovXG4gICAgTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciB1bmlxdWVLZXkgPSB0aGlzLl9nZXRVbmlxdWVLZXkoa2V5KSxcbiAgICAgICAgICAgIGtleUluZGV4ID0gdGhpcy5fZ2V0S2V5SW5kZXgodW5pcXVlS2V5KSxcbiAgICAgICAgICAgIHZhbHVlT2JqZWN0O1xuXG4gICAgICAgIGlmIChrZXlJbmRleCA8IDApIHtcbiAgICAgICAgICAgIGtleUluZGV4ID0gdGhpcy5fa2V5cy5wdXNoKHVuaXF1ZUtleSkgLSAxO1xuICAgICAgICAgICAgdGhpcy5zaXplICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVPYmplY3QgPSB0aGlzLl9jcmVhdGVWYWx1ZU9iamVjdCh2YWx1ZSwga2V5SW5kZXgpO1xuXG4gICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlc0ZvclN0cmluZ1trZXldID0gdmFsdWVPYmplY3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNGb3JJbmRleFtrZXlJbmRleF0gPSB2YWx1ZU9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB0byB0aGUga2V5LCBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm9uZS5cbiAgICAgKiBAcGFyYW0gIHsqfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJldHVyblxuICAgICAqIEByZXR1cm4geyp9IEVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5XG4gICAgICovXG4gICAgTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIHVuaXF1ZUtleSA9IHRoaXMuX2dldFVuaXF1ZUtleShrZXkpLFxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9nZXRWYWx1ZU9iamVjdCh1bmlxdWVLZXkpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5vcmlnaW47XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgSXRlcmF0b3Igb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGtleXMgZm9yIGVhY2ggZWxlbWVudFxuICAgICAqIGluIHRoZSBNYXAgb2JqZWN0IGluIGluc2VydGlvbiBvcmRlci5cbiAgICAgKiBAcmV0dXJuIHtJdGVyYXRvcn0gQSBuZXcgSXRlcmF0b3Igb2JqZWN0XG4gICAgICovXG4gICAgTWFwLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcy5fa2V5cywgdXRpbC5iaW5kKHRoaXMuX2dldE9yaWdpbktleSwgdGhpcykpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSB2YWx1ZXMgZm9yIGVhY2ggZWxlbWVudFxuICAgICAqIGluIHRoZSBNYXAgb2JqZWN0IGluIGluc2VydGlvbiBvcmRlci5cbiAgICAgKiBAcmV0dXJuIHtJdGVyYXRvcn0gQSBuZXcgSXRlcmF0b3Igb2JqZWN0XG4gICAgICovXG4gICAgTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLl9rZXlzLCB1dGlsLmJpbmQodGhpcy5fZ2V0T3JpZ2luVmFsdWUsIHRoaXMpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgW2tleSwgdmFsdWVdIHBhaXJzXG4gICAgICogZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgTWFwIG9iamVjdCBpbiBpbnNlcnRpb24gb3JkZXIuXG4gICAgICogQHJldHVybiB7SXRlcmF0b3J9IEEgbmV3IEl0ZXJhdG9yIG9iamVjdFxuICAgICAqL1xuICAgIE1hcC5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMuX2tleXMsIHV0aWwuYmluZCh0aGlzLl9nZXRLZXlWYWx1ZVBhaXIsIHRoaXMpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gYXNzZXJ0aW5nIHdoZXRoZXIgYSB2YWx1ZSBoYXMgYmVlbiBhc3NvY2lhdGVkIHRvIHRoZSBrZXlcbiAgICAgKiBpbiB0aGUgTWFwIG9iamVjdCBvciBub3QuXG4gICAgICogQHBhcmFtICB7Kn0ga2V5IC0gVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byB0ZXN0IGZvciBwcmVzZW5jZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IGV4aXN0cztcbiAgICAgKiAgICAgICAgICBPdGhlcndpc2UgZmFsc2VcbiAgICAgKi9cbiAgICBNYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9nZXRWYWx1ZU9iamVjdChrZXkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBmcm9tIGEgTWFwIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyp9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlXG4gICAgICovXG4gICAgIC8vIGNhbm5vdCB1c2UgcmVzZXJ2ZWQga2V5d29yZCBhcyBhIHByb3BlcnR5IG5hbWUgaW4gSUU4IGFuZCB1bmRlci5cbiAgICBNYXAucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIga2V5SW5kZXg7XG5cbiAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlc0ZvclN0cmluZ1trZXldKSB7XG4gICAgICAgICAgICAgICAga2V5SW5kZXggPSB0aGlzLl92YWx1ZXNGb3JTdHJpbmdba2V5XS5rZXlJbmRleDtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fdmFsdWVzRm9yU3RyaW5nW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXlJbmRleCA9IHRoaXMuX2dldEtleUluZGV4KGtleSk7XG4gICAgICAgICAgICBpZiAoa2V5SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl92YWx1ZXNGb3JJbmRleFtrZXlJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2tleXNba2V5SW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5zaXplIC09IDE7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIHBlciBlYWNoIGtleS92YWx1ZSBwYWlyIGluIHRoZSBNYXAgb2JqZWN0LFxuICAgICAqIGluIGluc2VydGlvbiBvcmRlci5cbiAgICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gIHt0aGlzQXJnfSB0aGlzQXJnIC0gVmFsdWUgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBNYXAucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICB0aGlzQXJnID0gdGhpc0FyZyB8fCB0aGlzO1xuICAgICAgICB1dGlsLmZvckVhY2hBcnJheSh0aGlzLl9rZXlzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLl9nZXRWYWx1ZU9iamVjdChrZXkpLm9yaWdpbiwga2V5LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYSBNYXAgb2JqZWN0LlxuICAgICAqL1xuICAgIE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgTWFwLmNhbGwodGhpcyk7XG4gICAgfTtcblxuICAgIC8vIFVzZSBuYXRpdmUgTWFwIG9iamVjdCBpZiBleGlzdHMuXG4gICAgLy8gQnV0IG9ubHkgbGF0ZXN0IHZlcnNpb25zIG9mIENocm9tZSBhbmQgRmlyZWZveCBzdXBwb3J0IGZ1bGwgaW1wbGVtZW50YXRpb24uXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYnJvd3NlciA9IHV0aWwuYnJvd3NlcjtcbiAgICAgICAgaWYgKHdpbmRvdy5NYXAgJiYgKFxuICAgICAgICAgICAgKGJyb3dzZXIuZmlyZWZveCAmJiBicm93c2VyLnZlcnNpb24gPj0gMzcpIHx8XG4gICAgICAgICAgICAoYnJvd3Nlci5jaHJvbWUgJiYgYnJvd3Nlci52ZXJzaW9uID49IDQyKSApKSB7XG4gICAgICAgICAgICBNYXAgPSB3aW5kb3cuTWFwO1xuICAgICAgICB9XG4gICAgfSkoKTtcblxuICAgIHV0aWwuTWFwID0gTWFwO1xufSkod2luZG93Lm5lKTtcblxuLyoqKioqKioqKipcbiAqIG9iamVjdC5qc1xuICoqKioqKioqKiovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIG1vZHVsZSBoYXMgc29tZSBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGEgcGxhaW4gb2JqZWN0LCBqc29uLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxlMDI0MkBuaG5lbnQuY29tPlxuICogQGRlcGVuZGVuY3kgdHlwZS5qcywgY29sbGVjdGlvbi5qc1xuICovXG5cbihmdW5jdGlvbihuZSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIW5lKSB7XG4gICAgICAgIG5lID0gd2luZG93Lm5lID0ge307XG4gICAgfVxuICAgIGlmICghbmUudXRpbCkge1xuICAgICAgICBuZS51dGlsID0gd2luZG93Lm5lLnV0aWwgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgdGhlIHRhcmdldCBvYmplY3QgZnJvbSBvdGhlciBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBPYmplY3QgdGhhdCB3aWxsIGJlIGV4dGVuZGVkXG4gICAgICogQHBhcmFtIHsuLi5vYmplY3R9IG9iamVjdHMgLSBPYmplY3RzIGFzIHNvdXJjZXNcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEV4dGVuZGVkIG9iamVjdFxuICAgICAqIEBtZW1iZXJPZiBuZS51dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgb2JqZWN0cykge1xuICAgICAgICB2YXIgc291cmNlLFxuICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgIGhhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGxlbjtcblxuICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAocHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBsYXN0IGlkIG9mIHN0YW1wXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB2YXIgbGFzdElkID0gMDtcblxuICAgIC8qKlxuICAgICAqIEFzc2lnbiBhIHVuaXF1ZSBpZCB0byBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gT2JqZWN0IHRoYXQgd2lsbCBiZSBhc3NpZ25lZCBpZC5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFN0YW1wZWQgaWRcbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YW1wKG9iaikge1xuICAgICAgICBvYmouX19mZV9pZCA9IG9iai5fX2ZlX2lkIHx8ICsrbGFzdElkO1xuICAgICAgICByZXR1cm4gb2JqLl9fZmVfaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmVyaWZ5IHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIHN0YW1wZWQgaWQgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc1N0YW1wKG9iaikge1xuICAgICAgICByZXR1cm4gbmUudXRpbC5pc0V4aXN0eShuZS51dGlsLnBpY2sob2JqLCAnX19mZV9pZCcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgbGFzdCBpZCBvZiBzdGFtcFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc2V0TGFzdElkKCkge1xuICAgICAgICBsYXN0SWQgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGtleS1saXN0KGFycmF5KSBvZiBhIGdpdmVuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSBPYmplY3QgZnJvbSB3aGljaCBhIGtleS1saXN0IHdpbGwgYmUgZXh0cmFjdGVkXG4gICAgICogQHJldHVybnMge0FycmF5fSBBIGtleS1saXN0KGFycmF5KVxuICAgICAqIEBtZW1iZXJPZiBuZS51dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXSxcbiAgICAgICAgICAgIGtleTtcblxuICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBlcXVhbGl0eSBmb3IgbXVsdGlwbGUgb2JqZWN0cyhqc29uT2JqZWN0cykuPGJyPlxuICAgICAqICBTZWUge0BsaW5rIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA2ODgzNC9vYmplY3QtY29tcGFyaXNvbi1pbi1qYXZhc2NyaXB0fVxuICAgICAqIEBwYXJhbSB7Li4ub2JqZWN0fSBvYmplY3QgLSBNdWx0aXBsZSBvYmplY3RzIGZvciBjb21wYXJpbmcuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gRXF1YWxpdHlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogIHZhciBqc29uT2JqMSA9IHtuYW1lOidtaWxrJywgcHJpY2U6IDEwMDB9LFxuICAgICAqICAgICAganNvbk9iajIgPSB7bmFtZTonbWlsaycsIHByaWNlOiAxMDAwfSxcbiAgICAgKiAgICAgIGpzb25PYmozID0ge25hbWU6J21pbGsnLCBwcmljZTogMTAwMH07XG4gICAgICpcbiAgICAgKiAgbmUudXRpbC5jb21wYXJlSlNPTihqc29uT2JqMSwganNvbk9iajIsIGpzb25PYmozKTsgICAvLyB0cnVlXG4gICAgICpcbiAgICAgKlxuICAgICAqICB2YXIganNvbk9iajQgPSB7bmFtZTonbWlsaycsIHByaWNlOiAxMDAwfSxcbiAgICAgKiAgICAgIGpzb25PYmo1ID0ge25hbWU6J2JlZXInLCBwcmljZTogMzAwMH07XG4gICAgICpcbiAgICAgKiAgICAgIG5lLnV0aWwuY29tcGFyZUpTT04oanNvbk9iajQsIGpzb25PYmo1KTsgLy8gZmFsc2VcblxuICAgICAqIEBtZW1iZXJPZiBuZS51dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFyZUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHZhciBsZWZ0Q2hhaW4sXG4gICAgICAgICAgICByaWdodENoYWluLFxuICAgICAgICAgICAgYXJnc0xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlzU2FtZU9iamVjdCh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgcDtcblxuICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhhdCBOYU4gPT09IE5hTiByZXR1cm5zIGZhbHNlXG4gICAgICAgICAgICAvLyBhbmQgaXNOYU4odW5kZWZpbmVkKSByZXR1cm5zIHRydWVcbiAgICAgICAgICAgIGlmIChpc05hTih4KSAmJlxuICAgICAgICAgICAgICAgIGlzTmFOKHkpICYmXG4gICAgICAgICAgICAgICAgbmUudXRpbC5pc051bWJlcih4KSAmJlxuICAgICAgICAgICAgICAgIG5lLnV0aWwuaXNOdW1iZXIoeSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29tcGFyZSBwcmltaXRpdmVzIGFuZCBmdW5jdGlvbnMuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBib3RoIGFyZ3VtZW50cyBsaW5rIHRvIHRoZSBzYW1lIG9iamVjdC5cbiAgICAgICAgICAgIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHN0ZXAgd2hlbiBjb21wYXJpbmcgcHJvdG90eXBlc1xuICAgICAgICAgICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV29ya3MgaW4gY2FzZSB3aGVuIGZ1bmN0aW9ucyBhcmUgY3JlYXRlZCBpbiBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIC8vIENvbXBhcmluZyBkYXRlcyBpcyBhIGNvbW1vbiBzY2VuYXJpby4gQW5vdGhlciBidWlsdC1pbnM/XG4gICAgICAgICAgICAvLyBXZSBjYW4gZXZlbiBoYW5kbGUgZnVuY3Rpb25zIHBhc3NlZCBhY3Jvc3MgaWZyYW1lc1xuICAgICAgICAgICAgaWYgKChuZS51dGlsLmlzRnVuY3Rpb24oeCkgJiYgbmUudXRpbC5pc0Z1bmN0aW9uKHkpKSB8fFxuICAgICAgICAgICAgICAgICh4IGluc3RhbmNlb2YgRGF0ZSAmJiB5IGluc3RhbmNlb2YgRGF0ZSkgfHxcbiAgICAgICAgICAgICAgICAoeCBpbnN0YW5jZW9mIFJlZ0V4cCAmJiB5IGluc3RhbmNlb2YgUmVnRXhwKSB8fFxuICAgICAgICAgICAgICAgICh4IGluc3RhbmNlb2YgU3RyaW5nICYmIHkgaW5zdGFuY2VvZiBTdHJpbmcpIHx8XG4gICAgICAgICAgICAgICAgKHggaW5zdGFuY2VvZiBOdW1iZXIgJiYgeSBpbnN0YW5jZW9mIE51bWJlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geC50b1N0cmluZygpID09PSB5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEF0IGxhc3QgY2hlY2tpbmcgcHJvdG90eXBlcyBhcyBnb29kIGEgd2UgY2FuXG4gICAgICAgICAgICBpZiAoISh4IGluc3RhbmNlb2YgT2JqZWN0ICYmIHkgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeC5pc1Byb3RvdHlwZU9mKHkpIHx8XG4gICAgICAgICAgICAgICAgeS5pc1Byb3RvdHlwZU9mKHgpIHx8XG4gICAgICAgICAgICAgICAgeC5jb25zdHJ1Y3RvciAhPT0geS5jb25zdHJ1Y3RvciB8fFxuICAgICAgICAgICAgICAgIHgucHJvdG90eXBlICE9PSB5LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGluZmluaXRpdmUgbGlua2luZyBsb29wc1xuICAgICAgICAgICAgaWYgKG5lLnV0aWwuaW5BcnJheSh4LCBsZWZ0Q2hhaW4pID4gLTEgfHxcbiAgICAgICAgICAgICAgICBuZS51dGlsLmluQXJyYXkoeSwgcmlnaHRDaGFpbikgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUXVpY2sgY2hlY2tpbmcgb2Ygb25lIG9iamVjdCBiZWVpbmcgYSBzdWJzZXQgb2YgYW5vdGhlci5cbiAgICAgICAgICAgIGZvciAocCBpbiB5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHkuaGFzT3duUHJvcGVydHkocCkgIT09IHguaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgeVtwXSAhPT0gdHlwZW9mIHhbcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9UaGlzIGZvciBsb29wIGV4ZWN1dGVzIGNvbXBhcmluZyB3aXRoIGhhc093blByb3BlcnR5KCkgYW5kIHR5cGVvZiBmb3IgZWFjaCBwcm9wZXJ0eSBpbiAneCcgb2JqZWN0LFxuICAgICAgICAgICAgLy9hbmQgdmVyaWZ5aW5nIGVxdWFsaXR5IGZvciB4W3Byb3BlcnR5XSBhbmQgeVtwcm9wZXJ0eV0uXG4gICAgICAgICAgICBmb3IgKHAgaW4geCkge1xuICAgICAgICAgICAgICAgIGlmICh5Lmhhc093blByb3BlcnR5KHApICE9PSB4Lmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHlbcF0gIT09IHR5cGVvZiB4W3BdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHhbcF0pID09PSAnb2JqZWN0JyB8fCB0eXBlb2YoeFtwXSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdENoYWluLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q2hhaW4ucHVzaCh5KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU2FtZU9iamVjdCh4W3BdLCB5W3BdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGVmdENoYWluLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICByaWdodENoYWluLnBvcCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeFtwXSAhPT0geVtwXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzTGVuIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJnc0xlbjsgaSsrKSB7XG4gICAgICAgICAgICBsZWZ0Q2hhaW4gPSBbXTtcbiAgICAgICAgICAgIHJpZ2h0Q2hhaW4gPSBbXTtcblxuICAgICAgICAgICAgaWYgKCFpc1NhbWVPYmplY3QoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYSBuZXN0ZWQgaXRlbSBmcm9tIHRoZSBnaXZlbiBvYmplY3QvYXJyYXlcbiAgICAgKiBAcGFyYW0ge29iamVjdHxBcnJheX0gb2JqIC0gT2JqZWN0IGZvciByZXRyaWV2aW5nXG4gICAgICogQHBhcmFtIHsuLi5zdHJpbmd8bnVtYmVyfSBwYXRocyAtIFBhdGhzIG9mIHByb3BlcnR5XG4gICAgICogQHJldHVybnMgeyp9IFZhbHVlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgdmFyIG9iaiA9IHtcbiAgICAgKiAgICAgICdrZXkxJzogMSxcbiAgICAgKiAgICAgICduZXN0ZWQnIDoge1xuICAgICAqICAgICAgICAgICdrZXkxJzogMTEsXG4gICAgICogICAgICAgICAgJ25lc3RlZCc6IHtcbiAgICAgKiAgICAgICAgICAgICAgJ2tleTEnOiAyMVxuICAgICAqICAgICAgICAgIH1cbiAgICAgKiAgICAgIH1cbiAgICAgKiAgfTtcbiAgICAgKiAgbmUudXRpbC5waWNrKG9iaiwgJ25lc3RlZCcsICduZXN0ZWQnLCAna2V5MScpOyAvLyAyMVxuICAgICAqICBuZS51dGlsLnBpY2sob2JqLCAnbmVzdGVkJywgJ25lc3RlZCcsICdrZXkyJyk7IC8vIHVuZGVmaW5lZFxuICAgICAqXG4gICAgICogIHZhciBhcnIgPSBbJ2EnLCAnYicsICdjJ107XG4gICAgICogIG5lLnV0aWwucGljayhhcnIsIDEpOyAvLyAnYidcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrKG9iaiwgcGF0aHMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICB0YXJnZXQgPSBhcmdzWzBdLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgICBpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W2FyZ3NbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZS51dGlsLmV4dGVuZCA9IGV4dGVuZDtcbiAgICBuZS51dGlsLnN0YW1wID0gc3RhbXA7XG4gICAgbmUudXRpbC5oYXNTdGFtcCA9IGhhc1N0YW1wO1xuICAgIG5lLnV0aWwuX3Jlc2V0TGFzdElkID0gcmVzZXRMYXN0SWQ7XG4gICAgbmUudXRpbC5rZXlzID0gT2JqZWN0LmtleXMgfHwga2V5cztcbiAgICBuZS51dGlsLmNvbXBhcmVKU09OID0gY29tcGFyZUpTT047XG4gICAgbmUudXRpbC5waWNrID0gcGljaztcbn0pKHdpbmRvdy5uZSk7XG5cbi8qKioqKioqKioqXG4gKiBzdHJpbmcuanNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBtb2R1bGUgaGFzIHNvbWUgZnVuY3Rpb25zIGZvciBoYW5kbGluZyB0aGUgc3RyaW5nLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxlMDI0MkBuaG5lbnQuY29tPlxuICovXG5cbihmdW5jdGlvbihuZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICghbmUpIHtcbiAgICAgICAgbmUgPSB3aW5kb3cubmUgPSB7fTtcbiAgICB9XG4gICAgaWYgKCFuZS51dGlsKSB7XG4gICAgICAgIG5lLnV0aWwgPSB3aW5kb3cubmUudXRpbCA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSB0aGUgZ2l2ZW4gSFRNTCBFbnRpdHkgc3RyaW5nIGludG8gcGxhaW4gc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGh0bWxFbnRpdHkgLSBIVE1MIEVudGl0eSB0eXBlIHN0cmluZ1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUGxhaW4gc3RyaW5nXG4gICAgICogQG1lbWJlcm9mIG5lLnV0aWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICB2YXIgaHRtbEVudGl0eVN0cmluZyA9IFwiQSAmIzM5O3F1b3RlJiMzOTsgaXMgJmx0O2ImZ3Q7Ym9sZCZsdDsvYiZndDtcIlxuICAgICAqICB2YXIgcmVzdWx0ID0gZGVjb2RlSFRNTEVudGl0eShodG1sRW50aXR5U3RyaW5nKTsgLy9cIkEgJ3F1b3RlJyBpcyA8Yj5ib2xkPC9iPlwiXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVjb2RlSFRNTEVudGl0eShodG1sRW50aXR5KSB7XG4gICAgICAgIHZhciBlbnRpdGllcyA9IHsnJnF1b3Q7JyA6ICdcIicsICcmYW1wOycgOiAnJicsICcmbHQ7JyA6ICc8JywgJyZndDsnIDogJz4nLCAnJiMzOTsnIDogJ1xcJycsICcmbmJzcDsnIDogJyAnfTtcbiAgICAgICAgcmV0dXJuIGh0bWxFbnRpdHkucmVwbGFjZSgvJmFtcDt8Jmx0O3wmZ3Q7fCZxdW90O3wmIzM5O3wmbmJzcDsvZywgZnVuY3Rpb24obTApIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRpdGllc1ttMF0gPyBlbnRpdGllc1ttMF0gOiBtMDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIHRoZSBnaXZlbiBzdHJpbmcgaW50byBIVE1MIEVudGl0eSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaHRtbCAtIFN0cmluZyBmb3IgZW5jb2RpbmdcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IEhUTUwgRW50aXR5XG4gICAgICogQG1lbWJlcm9mIG5lLnV0aWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICB2YXIgaHRtbEVudGl0eVN0cmluZyA9IFwiPHNjcmlwdD4gYWxlcnQoJ3Rlc3QnKTs8L3NjcmlwdD48YSBocmVmPSd0ZXN0Jz5cIjtcbiAgICAgKiAgdmFyIHJlc3VsdCA9IGVuY29kZUhUTUxFbnRpdHkoaHRtbEVudGl0eVN0cmluZyk7IC8vXCImbHQ7c2NyaXB0Jmd0OyBhbGVydCgmIzM5O3Rlc3QmIzM5Oyk7Jmx0Oy9zY3JpcHQmZ3Q7Jmx0O2EgaHJlZj0mIzM5O3Rlc3QmIzM5OyZndDtcIlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuY29kZUhUTUxFbnRpdHkoaHRtbCkge1xuICAgICAgICB2YXIgZW50aXRpZXMgPSB7J1wiJzogJ3F1b3QnLCAnJic6ICdhbXAnLCAnPCc6ICdsdCcsICc+JzogJ2d0JywgJ1xcJyc6ICcjMzknfTtcbiAgICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZSgvWzw+JlwiJ10vZywgZnVuY3Rpb24obTApIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRpdGllc1ttMF0gPyAnJicgKyBlbnRpdGllc1ttMF0gKyAnOycgOiBtMDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHdoZXRoZXIgdGhlIHN0cmluZyBjYXBhYmxlIHRvIHRyYW5zZm9ybSBpbnRvIHBsYWluIHN0cmluZyBpcyBpbiB0aGUgZ2l2ZW4gc3RyaW5nIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gICAgICogQG1lbWJlcm9mIG5lLnV0aWxcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc0VuY29kYWJsZVN0cmluZyhzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIC9bPD4mXCInXS8udGVzdChzdHJpbmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBkdXBsaWNhdGUgY2hhcnRlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmFuZFN0cjEgVGhlIG9wZXJhbmQgc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhbmRTdHIyIFRoZSBvcGVyYW5kIHN0cmluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1lbWJlcm9mIG5lLnV0aWxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbmUudXRpbC5nZXREdXBsaWNhdGVkQ2hhcignZmUgZGV2JywgJ25obiBlbnRlcnRhaW5tZW50Jyk7XG4gICAgICogPT4gJ2UnXG4gICAgICogbmUudXRpbC5nZXREdXBsaWNhdGVkQ2hhcignZmRzYScsICdhc2RmJyk7XG4gICAgICogPT4gJ2FzZGYnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RHVwbGljYXRlZENoYXIob3BlcmFuZFN0cjEsIG9wZXJhbmRTdHIyKSB7XG4gICAgICAgIHZhciBkdXBsLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBsZW4gPSBvcGVyYW5kU3RyMS5sZW5ndGgsXG4gICAgICAgICAgICBwb29sID0ge307XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAga2V5ID0gb3BlcmFuZFN0cjEuY2hhckF0KGkpO1xuICAgICAgICAgICAgcG9vbFtrZXldID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG9wZXJhbmRTdHIyLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBrZXkgPSBvcGVyYW5kU3RyMi5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZihwb29sW2tleV0pIHtcbiAgICAgICAgICAgICAgICBwb29sW2tleV0gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBvb2wgPSBuZS51dGlsLmZpbHRlcihwb29sLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbSA+IDE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBvb2wgPSBuZS51dGlsLmtleXMocG9vbCkuc29ydCgpO1xuICAgICAgICBkdXBsID0gcG9vbC5qb2luKCcnKTtcblxuICAgICAgICByZXR1cm4gZHVwbDtcbiAgICB9XG5cbiAgICBuZS51dGlsLmRlY29kZUhUTUxFbnRpdHkgPSBkZWNvZGVIVE1MRW50aXR5O1xuICAgIG5lLnV0aWwuZW5jb2RlSFRNTEVudGl0eSA9IGVuY29kZUhUTUxFbnRpdHk7XG4gICAgbmUudXRpbC5oYXNFbmNvZGFibGVTdHJpbmcgPSBoYXNFbmNvZGFibGVTdHJpbmc7XG4gICAgbmUudXRpbC5nZXREdXBsaWNhdGVkQ2hhciA9IGdldER1cGxpY2F0ZWRDaGFyO1xuXG59KSh3aW5kb3cubmUpO1xuXG4vKioqKioqKioqKlxuICogdHJpY2tzLmpzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGNvbGxlY3Rpb25zIG9mIHNvbWUgdGVjaG5pYyBtZXRob2RzLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxlMDI0Mi5uaG5lbnQuY29tPlxuICovXG5cbi8qKiBAbmFtZXNwYWNlIG5lICovXG4vKiogQG5hbWVzcGFjZSBuZS51dGlsICovXG5cbihmdW5jdGlvbihuZSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgYXBzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFuZSkge1xuICAgICAgICBuZSA9IHdpbmRvdy5uZSA9IHt9O1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIW5lLnV0aWwpIHtcbiAgICAgICAgbmUudXRpbCA9IHdpbmRvdy5uZS51dGlsID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBmbiB1bnRpbCBhZnRlciBkZWxheSBtaWxsaXNlY29uZHMgaGFzIGVsYXBzZWRcbiAgICAgKiBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdWNlZCBmdW5jdGlvbiB3YXMgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheVxuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9ufSBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNvbWVNZXRob2RUb0ludm9rZURlYm91bmNlZCgpIHt9XG4gICAgICpcbiAgICAgKiB2YXIgZGVib3VuY2VkID0gbmUudXRpbC5kZWJvdW5jZShzb21lTWV0aG9kVG9JbnZva2VEZWJvdW5jZWQsIDMwMCk7XG4gICAgICpcbiAgICAgKiAvLyBpbnZva2UgcmVwZWF0ZWRseVxuICAgICAqIGRlYm91bmNlZCgpO1xuICAgICAqIGRlYm91bmNlZCgpO1xuICAgICAqIGRlYm91bmNlZCgpO1xuICAgICAqIGRlYm91bmNlZCgpO1xuICAgICAqIGRlYm91bmNlZCgpO1xuICAgICAqIGRlYm91bmNlZCgpOyAgICAvLyBsYXN0IGludm9rZSBvZiBkZWJvdW5jZWQoKVxuICAgICAqXG4gICAgICogLy8gaW52b2tlIHNvbWVNZXRob2RUb0ludm9rZURlYm91bmNlZCgpIGFmdGVyIDMwMCBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZm4sIGRlbGF5KSB7XG4gICAgICAgIHZhciB0aW1lcixcbiAgICAgICAgICAgIGFyZ3M7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVsYXkgPSBkZWxheSB8fCAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRpbWVzdGFtcFxuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZnJvbSBKYW4uIDE5NzAgMDA6MDA6MDAgKEdNVClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gICAgICAgIHJldHVybiArKG5ldyBEYXRlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgZm4gYXQgbW9zdCBvbmNlIHBlciBldmVyeSBpbnRlcnZhbCBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHVzZSB0aGlzIHRocm90dGxlIHNob3J0IHRpbWUgcmVwZWF0ZWRseSBpbnZva2luZyBmdW5jdGlvbnMuIChlLmcgTW91c2VNb3ZlLCBSZXNpemUgLi4uKVxuICAgICAqXG4gICAgICogaWYgeW91IG5lZWQgcmV1c2UgdGhyb3R0bGVkIG1ldGhvZC4geW91IG11c3QgcmVtb3ZlIHNsdWdzIChlLmcuIGZsYWcgdmFyaWFibGUpIHJlbGF0ZWQgd2l0aCB0aHJvdHRsaW5nLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIGZ1bmN0aW9uIHRvIHRocm90dGxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtpbnRlcnZhbD0wXSB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAgICAgKiBAbWVtYmVyb2YgbmUudXRpbFxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn0gdGhyb3R0bGVkIGZ1bmN0aW9uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNvbWVNZXRob2RUb0ludm9rZVRocm90dGxlZCgpIHt9XG4gICAgICpcbiAgICAgKiB2YXIgdGhyb3R0bGVkID0gbmUudXRpbC50aHJvdHRsZShzb21lTWV0aG9kVG9JbnZva2VUaHJvdHRsZWQsIDMwMCk7XG4gICAgICpcbiAgICAgKiAvLyBpbnZva2UgcmVwZWF0ZWRseVxuICAgICAqIHRocm90dGxlZCgpOyAgICAvLyBpbnZva2UgKGxlYWRpbmcpXG4gICAgICogdGhyb3R0bGVkKCk7XG4gICAgICogdGhyb3R0bGVkKCk7ICAgIC8vIGludm9rZSAobmVhciAzMDAgbWlsbGlzZWNvbmRzKVxuICAgICAqIHRocm90dGxlZCgpO1xuICAgICAqIHRocm90dGxlZCgpO1xuICAgICAqIHRocm90dGxlZCgpOyAgICAvLyBpbnZva2UgKG5lYXIgNjAwIG1pbGxpc2Vjb25kcylcbiAgICAgKiAvLyAuLi5cbiAgICAgKiAvLyBpbnZva2UgKHRyYWlsaW5nKVxuICAgICAqXG4gICAgICogLy8gaWYgeW91IG5lZWQgcmV1c2UgdGhyb3R0bGVkIG1ldGhvZC4gdGhlbiBpbnZva2UgcmVzZXQoKVxuICAgICAqIHRocm90dGxlZC5yZXNldCgpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZuLCBpbnRlcnZhbCkge1xuICAgICAgICB2YXIgYmFzZSxcbiAgICAgICAgICAgIF90aW1lc3RhbXAgPSBuZS51dGlsLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIGRlYm91bmNlZCxcbiAgICAgICAgICAgIGlzTGVhZGluZyA9IHRydWUsXG4gICAgICAgICAgICBzdGFtcCxcbiAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICB0aWNrID0gZnVuY3Rpb24oX2FyZ3MpIHtcbiAgICAgICAgICAgICAgICBmbi5hcHBseShudWxsLCBfYXJncyk7XG4gICAgICAgICAgICAgICAgYmFzZSA9IG51bGw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGludGVydmFsID0gaW50ZXJ2YWwgfHwgMDtcblxuICAgICAgICBkZWJvdW5jZWQgPSBuZS51dGlsLmRlYm91bmNlKHRpY2ssIGludGVydmFsKTtcblxuICAgICAgICBmdW5jdGlvbiB0aHJvdHRsZWQoKSB7XG4gICAgICAgICAgICBhcmdzID0gYXBzLmNhbGwoYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKGlzTGVhZGluZykge1xuICAgICAgICAgICAgICAgIHRpY2soYXJncyk7XG4gICAgICAgICAgICAgICAgaXNMZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGFtcCA9IF90aW1lc3RhbXAoKTtcblxuICAgICAgICAgICAgYmFzZSA9IGJhc2UgfHwgc3RhbXA7XG5cbiAgICAgICAgICAgIGRlYm91bmNlZCgpO1xuXG4gICAgICAgICAgICBpZiAoKHN0YW1wIC0gYmFzZSkgPj0gaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICB0aWNrKGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICBpc0xlYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYmFzZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdHRsZWQucmVzZXQgPSByZXNldDtcbiAgICAgICAgcmV0dXJuIHRocm90dGxlZDtcbiAgICB9XG5cbiAgICBuZS51dGlsLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICBuZS51dGlsLmRlYm91bmNlID0gZGVib3VuY2U7XG4gICAgbmUudXRpbC50aHJvdHRsZSA9IHRocm90dGxlO1xufSkod2luZG93Lm5lKTtcblxuXG4vKioqKioqKioqKlxuICogdHlwZS5qc1xuICoqKioqKioqKiovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIG1vZHVsZSBwcm92aWRlcyBzb21lIGZ1bmN0aW9ucyB0byBjaGVjayB0aGUgdHlwZSBvZiB2YXJpYWJsZVxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxlMDI0MkBuaG5lbnQuY29tPlxuICogQGRlcGVuZGVuY3kgY29sbGVjdGlvbi5qc1xuICovXG5cbihmdW5jdGlvbihuZSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIW5lKSB7XG4gICAgICAgIG5lID0gd2luZG93Lm5lID0ge307XG4gICAgfVxuICAgIGlmICghbmUudXRpbCkge1xuICAgICAgICBuZS51dGlsID0gd2luZG93Lm5lLnV0aWwgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBleGlzdGluZyBvciBub3QuPGJyPlxuICAgICAqICBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgbm90IG51bGwgYW5kIG5vdCB1bmRlZmluZWQsIHJldHVybnMgdHJ1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHBhcmFtIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBJcyBleGlzdHk/XG4gICAgICogQG1lbWJlck9mIG5lLnV0aWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBuZS51dGlsLmlzRXhpc3R5KCcnKTsgLy90cnVlXG4gICAgICogIG5lLnV0aWwuaXNFeGlzdHkoMCk7IC8vdHJ1ZVxuICAgICAqICBuZS51dGlsLmlzRXhpc3R5KFtdKTsgLy90cnVlXG4gICAgICogIG5lLnV0aWwuaXNFeGlzdHkoe30pOyAvL3RydWVcbiAgICAgKiAgbmUudXRpbC5pc0V4aXN0eShudWxsKTsgLy9mYWxzZVxuICAgICAqICBuZS51dGlsLmlzRXhpc3R5KHVuZGVmaW5lZCk7IC8vZmFsc2VcbiAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXhpc3R5KHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBwYXJhbSAhPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCBvciBub3QuPGJyPlxuICAgICAqICBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgdW5kZWZpbmVkLCByZXR1cm5zIHRydWUuXG4gICAgICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IElzIHVuZGVmaW5lZD9cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgbnVsbCBvciBub3QuPGJyPlxuICAgICAqICBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUoYXJndW1lbnRzWzBdKSBpcyBudWxsLCByZXR1cm5zIHRydWUuXG4gICAgICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IElzIG51bGw/XG4gICAgICogQG1lbWJlck9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgdHJ1dGh5IG9yIG5vdC48YnI+XG4gICAgICogIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBub3QgbnVsbCBvciBub3QgdW5kZWZpbmVkIG9yIG5vdCBmYWxzZSwgcmV0dXJucyB0cnVlLjxicj5cbiAgICAgKiAgKEl0IHJlZ2FyZHMgMCBhcyB0cnVlKVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIHRydXRoeT9cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVHJ1dGh5KG9iaikge1xuICAgICAgICByZXR1cm4gaXNFeGlzdHkob2JqKSAmJiBvYmogIT09IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGZhbHN5IG9yIG5vdC48YnI+XG4gICAgICogIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBmYWxzZSwgcmV0dXJucyB0cnVlLlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGZhbHN5P1xuICAgICAqIEBtZW1iZXJPZiBuZS51dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGYWxzeShvYmopIHtcbiAgICAgICAgcmV0dXJuICFpc1RydXRoeShvYmopO1xuICAgIH1cblxuXG4gICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFuIGFyZ3VtZW50cyBvYmplY3Qgb3Igbm90Ljxicj5cbiAgICAgKiAgSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFuIGFyZ3VtZW50cyBvYmplY3QsIHJldHVybiB0cnVlLlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGFyZ3VtZW50cz9cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iaikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gaXNFeGlzdHkob2JqKSAmJlxuICAgICAgICAgICAgKCh0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nKSB8fCAhIW9iai5jYWxsZWUpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYW4gaW5zdGFuY2Ugb2YgQXJyYXkgb3Igbm90Ljxicj5cbiAgICAgKiAgSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFuIGluc3RhbmNlIG9mIEFycmF5LCByZXR1cm4gdHJ1ZS5cbiAgICAgKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBhcnJheSBpbnN0YW5jZT9cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBBcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBvYmplY3Qgb3Igbm90Ljxicj5cbiAgICAgKiAgSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFuIG9iamVjdCwgcmV0dXJuIHRydWUuXG4gICAgICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgb2JqZWN0P1xuICAgICAqIEBtZW1iZXJPZiBuZS51dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb24gb3Igbm90Ljxicj5cbiAgICAgKiAgSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb24sIHJldHVybiB0cnVlLlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGZ1bmN0aW9uP1xuICAgICAqIEBtZW1iZXJPZiBuZS51dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgbnVtYmVyIG9yIG5vdC48YnI+XG4gICAgICogIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIG51bWJlciwgcmV0dXJuIHRydWUuXG4gICAgICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgbnVtYmVyP1xuICAgICAqIEBtZW1iZXJPZiBuZS51dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBOdW1iZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBzdHJpbmcgb3Igbm90Ljxicj5cbiAgICAgKiAgSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgc3RyaW5nLCByZXR1cm4gdHJ1ZS5cbiAgICAgKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBzdHJpbmc/XG4gICAgICogQG1lbWJlck9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8IG9iaiBpbnN0YW5jZW9mIFN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGJvb2xlYW4gb3Igbm90Ljxicj5cbiAgICAgKiAgSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgYm9vbGVhbiwgcmV0dXJuIHRydWUuXG4gICAgICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgYm9vbGVhbj9cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbihvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdib29sZWFuJyB8fCBvYmogaW5zdGFuY2VvZiBCb29sZWFuO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYW4gaW5zdGFuY2Ugb2YgQXJyYXkgb3Igbm90Ljxicj5cbiAgICAgKiAgSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFuIGluc3RhbmNlIG9mIEFycmF5LCByZXR1cm4gdHJ1ZS48YnI+XG4gICAgICogIChJdCBpcyB1c2VkIGZvciBtdWx0aXBsZSBmcmFtZSBlbnZpcm9ubWVudHMpXG4gICAgICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgYW4gaW5zdGFuY2Ugb2YgYXJyYXk/XG4gICAgICogQG1lbWJlck9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5U2FmZShvYmopIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uIG9yIG5vdC48YnI+XG4gICAgICogIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uLCByZXR1cm4gdHJ1ZS48YnI+XG4gICAgICogIChJdCBpcyB1c2VkIGZvciBtdWx0aXBsZSBmcmFtZSBlbnZpcm9ubWVudHMpXG4gICAgICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgYSBmdW5jdGlvbj9cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb25TYWZlKG9iaikge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgbnVtYmVyIG9yIG5vdC48YnI+XG4gICAgICogIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIG51bWJlciwgcmV0dXJuIHRydWUuPGJyPlxuICAgICAqICAoSXQgaXMgdXNlZCBmb3IgbXVsdGlwbGUgZnJhbWUgZW52aXJvbm1lbnRzKVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGEgbnVtYmVyP1xuICAgICAqIEBtZW1iZXJPZiBuZS51dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXJTYWZlKG9iaikge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBOdW1iZXJdJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIHN0cmluZyBvciBub3QuPGJyPlxuICAgICAqICBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBzdHJpbmcsIHJldHVybiB0cnVlLjxicj5cbiAgICAgKiAgKEl0IGlzIHVzZWQgZm9yIG11bHRpcGxlIGZyYW1lIGVudmlyb25tZW50cylcbiAgICAgKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBhIHN0cmluZz9cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nU2FmZShvYmopIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBib29sZWFuIG9yIG5vdC48YnI+XG4gICAgICogIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGJvb2xlYW4sIHJldHVybiB0cnVlLjxicj5cbiAgICAgKiAgKEl0IGlzIHVzZWQgZm9yIG11bHRpcGxlIGZyYW1lIGVudmlyb25tZW50cylcbiAgICAgKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBhIGJvb2xlYW4/XG4gICAgICogQG1lbWJlck9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW5TYWZlKG9iaikge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBpbnN0YW5jZSBvZiBIVE1MTm9kZSBvciBub3QuPGJyPlxuICAgICAqICBJZiB0aGUgZ2l2ZW4gdmFyaWFibGVzIGlzIGEgaW5zdGFuY2Ugb2YgSFRNTE5vZGUsIHJldHVybiB0cnVlLlxuICAgICAqIEBwYXJhbSB7Kn0gaHRtbCAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBIVE1MTm9kZSA/XG4gICAgICogQG1lbWJlck9mIG5lLnV0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0hUTUxOb2RlKGh0bWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZihIVE1MRWxlbWVudCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gKGh0bWwgJiYgKGh0bWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCAhIWh0bWwubm9kZVR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISEoaHRtbCAmJiBodG1sLm5vZGVUeXBlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIEhUTUwgdGFnIG9yIG5vdC48YnI+XG4gICAgICogIElmIHRoZSBnaXZlbiB2YXJpYWJsZXMgaXMgYSBIVE1MIHRhZywgcmV0dXJuIHRydWUuXG4gICAgICogQHBhcmFtIHsqfSBodG1sIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IElzIEhUTUwgdGFnP1xuICAgICAqIEBtZW1iZXJPZiBuZS51dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNIVE1MVGFnKGh0bWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZihIVE1MRWxlbWVudCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gKGh0bWwgJiYgKGh0bWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIShodG1sICYmIGh0bWwubm9kZVR5cGUgJiYgaHRtbC5ub2RlVHlwZSA9PT0gMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgZW1wdHkobnVsbCwgdW5kZWZpbmVkLCBvciBlbXB0eSBhcnJheSwgZW1wdHkgb2JqZWN0KSBvciBub3QuPGJyPlxuICAgICAqICBJZiB0aGUgZ2l2ZW4gdmFyaWFibGVzIGlzIGVtcHR5LCByZXR1cm4gdHJ1ZS5cbiAgICAgKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBlbXB0eT9cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gICAgICAgIHZhciBoYXNLZXkgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIWlzRXhpc3R5KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzU3RyaW5nKG9iaikgJiYgb2JqID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNBcnJheShvYmopIHx8IGlzQXJndW1lbnRzKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0KG9iaikgJiYgIWlzRnVuY3Rpb24ob2JqKSkge1xuICAgICAgICAgICAgbmUudXRpbC5mb3JFYWNoT3duUHJvcGVydGllcyhvYmosIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGhhc0tleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAhaGFzS2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBub3QgZW1wdHkobm90IG51bGwsIG5vdCB1bmRlZmluZWQsIG9yIG5vdCBlbXB0eSBhcnJheSwgbm90IGVtcHR5IG9iamVjdCkgb3Igbm90Ljxicj5cbiAgICAgKiAgSWYgdGhlIGdpdmVuIHZhcmlhYmxlcyBpcyBub3QgZW1wdHksIHJldHVybiB0cnVlLlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIG5vdCBlbXB0eT9cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTm90RW1wdHkob2JqKSB7XG4gICAgICAgIHJldHVybiAhaXNFbXB0eShvYmopO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFuIGluc3RhbmNlIG9mIERhdGUgb3Igbm90Ljxicj5cbiAgICAgKiAgSWYgdGhlIGdpdmVuIHZhcmlhYmxlcyBpcyBhbiBpbnN0YW5jZSBvZiBEYXRlLCByZXR1cm4gdHJ1ZS5cbiAgICAgKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZT9cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRGF0ZShvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIERhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZSBvciBub3QuPGJyPlxuICAgICAqICBJZiB0aGUgZ2l2ZW4gdmFyaWFibGVzIGlzIGFuIGluc3RhbmNlIG9mIERhdGUsIHJldHVybiB0cnVlLjxicj5cbiAgICAgKiAgKEl0IGlzIHVzZWQgZm9yIG11bHRpcGxlIGZyYW1lIGVudmlyb25tZW50cylcbiAgICAgKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZT9cbiAgICAgKiBAbWVtYmVyT2YgbmUudXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRGF0ZVNhZmUob2JqKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJztcbiAgICB9XG5cblxuICAgIG5lLnV0aWwuaXNFeGlzdHkgPSBpc0V4aXN0eTtcbiAgICBuZS51dGlsLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgbmUudXRpbC5pc051bGwgPSBpc051bGw7XG4gICAgbmUudXRpbC5pc1RydXRoeSA9IGlzVHJ1dGh5O1xuICAgIG5lLnV0aWwuaXNGYWxzeSA9IGlzRmFsc3k7XG4gICAgbmUudXRpbC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIG5lLnV0aWwuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgaXNBcnJheTtcbiAgICBuZS51dGlsLmlzQXJyYXlTYWZlID0gQXJyYXkuaXNBcnJheSB8fCBpc0FycmF5U2FmZTtcbiAgICBuZS51dGlsLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgbmUudXRpbC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBuZS51dGlsLmlzRnVuY3Rpb25TYWZlID0gaXNGdW5jdGlvblNhZmU7XG4gICAgbmUudXRpbC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIG5lLnV0aWwuaXNOdW1iZXJTYWZlID0gaXNOdW1iZXJTYWZlO1xuICAgIG5lLnV0aWwuaXNEYXRlID0gaXNEYXRlO1xuICAgIG5lLnV0aWwuaXNEYXRlU2FmZSA9IGlzRGF0ZVNhZmU7XG4gICAgbmUudXRpbC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgIG5lLnV0aWwuaXNTdHJpbmdTYWZlID0gaXNTdHJpbmdTYWZlO1xuICAgIG5lLnV0aWwuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIG5lLnV0aWwuaXNCb29sZWFuU2FmZSA9IGlzQm9vbGVhblNhZmU7XG4gICAgbmUudXRpbC5pc0hUTUxOb2RlID0gaXNIVE1MTm9kZTtcbiAgICBuZS51dGlsLmlzSFRNTFRhZyA9IGlzSFRNTFRhZztcbiAgICBuZS51dGlsLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgIG5lLnV0aWwuaXNOb3RFbXB0eSA9IGlzTm90RW1wdHk7XG5cbn0pKHdpbmRvdy5uZSk7XG5cbi8qKioqKioqKioqXG4gKiB3aW5kb3cuanNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBtb2R1bGUgaGFzIHNvbWUgbWV0aG9kcyBmb3IgaGFuZGxpbmcgcG9wdXAtd2luZG93XG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGUwMjQyQG5obmVudC5jb20+XG4gKiBAZGVwZW5kZW5jeSBicm93c2VyLmpzLCB0eXBlLmpzLCBvYmplY3QuanMsIGNvbGxlY3Rpb24uanMsIGZ1bmMuanMsIHdpbmRvdy5qc1xuICovXG5cbihmdW5jdGlvbihuZSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBpZiAoIW5lKSB7XG4gICAgICAgIG5lID0gd2luZG93Lm5lID0ge307XG4gICAgfVxuICAgIGlmICghbmUudXRpbCkge1xuICAgICAgICBuZS51dGlsID0gd2luZG93Lm5lLnV0aWwgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgcG9wdXBfaWQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUG9wdXAgbWFuYWdlbWVudCBjbGFzc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBuZS51dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gUG9wdXAoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhY2hpbmcgdGhlIHdpbmRvdy1jb250ZXh0cyBvZiBvcGVuZWQgcG9wdXBzXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZW5lZFBvcHVwID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIElFNywgYW4gZXJyb3Igb2NjdXJzIHdoZW4gdGhlIGNsb3NlV2l0aFBhcmVudCBwcm9wZXJ0eSBhdHRhY2hlcyB0byB3aW5kb3cgb2JqZWN0Ljxicj5cbiAgICAgICAgICogU28sIEl0IGlzIGZvciBzYXZpbmcgdGhlIHZhbHVlIG9mIGNsb3NlV2l0aFBhcmVudCBpbnN0ZWFkIG9mIGF0dGFjaGluZyB0byB3aW5kb3cgb2JqZWN0LlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZVdpdGhQYXJlbnRQb3B1cCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb3N0IGRhdGEgYnJpZGdlIGZvciBJRTExIHBvcHVwXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvc3REYXRhQnJpZGdlVXJsID0gJyc7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiBwdWJsaWMgbWV0aG9kc1xuICAgICAqKioqKioqKioqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBvcHVwLWxpc3QgYWRtaW5pc3RlcmVkIGJ5IGN1cnJlbnQgd2luZG93LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIHBvcHVwLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHBvcHVwIHdpbmRvdyBsaXN0IG9iamVjdFxuICAgICAqL1xuICAgIFBvcHVwLnByb3RvdHlwZS5nZXRQb3B1cExpc3QgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIHRhcmdldDtcbiAgICAgICAgaWYgKG5lLnV0aWwuaXNFeGlzdHkoa2V5KSkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5vcGVuZWRQb3B1cFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5vcGVuZWRQb3B1cDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHBvcHVwXG4gICAgICogQ2F1dGlvbjpcbiAgICAgKiAgSW4gSUUxMSwgd2hlbiB0cmFuc2ZlciBkYXRhIHRvIHBvcHVwIGJ5IFBPU1QsIG11c3Qgc2V0IHRoZSBwb3N0RGF0YUJyaWRnZVVybC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBwb3B1cCB1cmxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucG9wdXBOYW1lXSAtIEtleSBvZiBwb3B1cCB3aW5kb3cuPGJyPlxuICAgICAqICAgICAgSWYgdGhlIGtleSBpcyBzZXQsIHdoZW4geW91IHRyeSB0byBvcGVuIGJ5IHRoaXMga2V5LCB0aGUgcG9wdXAgb2YgdGhpcyBrZXkgaXMgZm9jdXNlZC48YnI+XG4gICAgICogICAgICBPciBlbHNlIGEgbmV3IHBvcHVwIHdpbmRvdyBoYXZpbmcgdGhpcyBrZXkgaXMgb3BlbmVkLlxuICAgICAqXG4gICAgICogICAgIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wb3B1cE9wdGlvblN0cj1cIlwiXSAtIE9wdGlvbiBzdHJpbmcgb2YgcG9wdXAgd2luZG93PGJyPlxuICAgICAqICAgICAgSXQgaXMgc2FtZSB3aXRoIHRoZSB0aGlyZCBwYXJhbWV0ZXIgb2Ygd2luZG93Lm9wZW4oKSBtZXRob2QuPGJyPlxuICAgICAqICAgICAgU2VlIHtAbGluayBodHRwOi8vd3d3Lnczc2Nob29scy5jb20vanNyZWYvbWV0X3dpbl9vcGVuLmFzcH1cbiAgICAgKlxuICAgICAqICAgICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsb3NlV2l0aFBhcmVudD10cnVlXSAtIElzIGNsb3NlZCB3aGVuIHBhcmVudCB3aW5kb3cgY2xvc2VkP1xuICAgICAqXG4gICAgICogICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudXNlUmVsb2FkPWZhbHNlXSAtIFRoaXMgcHJvcGVydHkgaW5kaWNhdGVzIHdoZXRoZXIgcmVsb2FkIHRoZSBwb3B1cCBvciBub3QuPGJyPlxuICAgICAqICAgICAgSWYgdHJ1ZSwgdGhlIHBvcHVwIHdpbGwgYmUgcmVsb2FkZWQgd2hlbiB5b3UgdHJ5IHRvIHJlLW9wZW4gdGhlIHBvcHVwIHRoYXQgaGFzIGJlZW4gb3BlbmVkLjxicj5cbiAgICAgKiAgICAgIFdoZW4gdHJhbnNtaXQgdGhlIFBPU1QtZGF0YSwgc29tZSBicm93c2VycyBhbGVydCBhIG1lc3NhZ2UgZm9yIGNvbmZpcm1pbmcgd2hldGhlciByZXRyYW5zbWl0IG9yIG5vdC5cbiAgICAgKlxuICAgICAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucG9zdERhdGFCcmlkZ2VVcmw9JyddIC0gVXNlIHRoaXMgdXJsIHRvIGF2b2lkIGEgY2VydGFpbiBidWcgb2NjdXJpbmcgd2hlbiB0cmFuc21pdHRpbmcgUE9TVCBkYXRhIHRvIHRoZSBwb3B1cCBpbiBJRTExLjxicj5cbiAgICAgKiAgICAgIFRoaXMgc3BlY2lmaWMgYnVnZ3kgc2l0dWF0aW9uIGlzIGtub3duIHRvIGhhcHBlbiBiZWNhdXNlIElFMTEgdHJpZXMgdG8gb3BlbiB0aGUgcmVxdWVzdGVkIHVybCBub3QgaW4gYSBuZXcgcG9wdXAgd2luZG93IGFzIGludGVuZGVkLCBidXQgaW4gYSBuZXcgdGFiLjxicj5cbiAgICAgKiAgICAgIFNlZSB7QGxpbmsgaHR0cDovL3dpa2kubmhuZW50LmNvbS9wYWdlcy92aWV3cGFnZS5hY3Rpb24/cGFnZUlkPTI0MDU2Mjg0NH1cbiAgICAgKlxuICAgICAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWV0aG9kPWdldF0gLSBUaGUgbWV0aG9kIG9mIHRyYW5zbWlzc2lvbiB3aGVuIHRoZSBmb3JtLWRhdGEgaXMgdHJhbnNtaXR0ZWQgdG8gcG9wdXAtd2luZG93LlxuICAgICAqXG4gICAgICogICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wYXJhbT1udWxsXSAtIFVzaW5nIGFzIHBhcmFtZXRlcnMgZm9yIHRyYW5zbWlzc2lvbiB3aGVuIHRoZSBmb3JtLWRhdGEgaXMgdHJhbnNtaXR0ZWQgdG8gcG9wdXAtd2luZG93LlxuICAgICAqL1xuICAgIFBvcHVwLnByb3RvdHlwZS5vcGVuUG9wdXAgPSBmdW5jdGlvbih1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG5lLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIHBvcHVwTmFtZTogJ3BvcHVwXycgKyBwb3B1cF9pZCArICdfJyArICgrbmV3IERhdGUoKSksXG4gICAgICAgICAgICBwb3B1cE9wdGlvblN0cjogJycsXG4gICAgICAgICAgICB1c2VSZWxvYWQ6IHRydWUsXG4gICAgICAgICAgICBjbG9zZVdpdGhQYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICBtZXRob2Q6ICdnZXQnLFxuICAgICAgICAgICAgcGFyYW06IHt9XG4gICAgICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gb3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKTtcblxuICAgICAgICB0aGlzLnBvc3REYXRhQnJpZGdlVXJsID0gb3B0aW9ucy5wb3N0RGF0YUJyaWRnZVVybCB8fCB0aGlzLnBvc3REYXRhQnJpZGdlVXJsO1xuXG4gICAgICAgIHZhciBwb3B1cCxcbiAgICAgICAgICAgIGZvcm1FbGVtZW50LFxuICAgICAgICAgICAgdXNlSUVQb3N0QnJpZGdlID0gb3B0aW9ucy5tZXRob2QgPT09ICdQT1NUJyAmJiBvcHRpb25zLnBhcmFtICYmXG4gICAgICAgICAgICAgICAgbmUudXRpbC5icm93c2VyLm1zaWUgJiYgbmUudXRpbC5icm93c2VyLnZlcnNpb24gPT09IDExO1xuXG4gICAgICAgIGlmICghbmUudXRpbC5pc0V4aXN0eSh1cmwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcHVwI29wZW4oKSDtjJ3sl4UgVVJM7J20IOyeheugpeuQmOyngCDslYrslZjsirXri4jri6QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcHVwX2lkICs9IDE7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogSW4gZm9ybS1kYXRhIHRyYW5zbWlzc2lvblxuICAgICAgICAgKiAxLiBDcmVhdGUgYSBmb3JtIGJlZm9yZSBvcGVuaW5nIGEgcG9wdXAuXG4gICAgICAgICAqIDIuIFRyYW5zbWl0IHRoZSBmb3JtLWRhdGEuXG4gICAgICAgICAqIDMuIFJlbW92ZSB0aGUgZm9ybSBhZnRlciB0cmFuc21pc3Npb24uXG4gICAgICAgICAqL1xuICAgICAgICBpZiAob3B0aW9ucy5wYXJhbSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgICAgIHVybCA9IHVybCArICgvXFw/Ly50ZXN0KHVybCkgPyAnJicgOiAnPycpICsgdGhpcy5fcGFyYW1ldGVyaXplKG9wdGlvbnMucGFyYW0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm1ldGhvZCA9PT0gJ1BPU1QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1c2VJRVBvc3RCcmlkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybUVsZW1lbnQgPSB0aGlzLmNyZWF0ZUZvcm0odXJsLCBvcHRpb25zLnBhcmFtLCBvcHRpb25zLm1ldGhvZCwgb3B0aW9ucy5wb3B1cE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSAnYWJvdXQ6YmxhbmsnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBvcHVwID0gdGhpcy5vcGVuZWRQb3B1cFtvcHRpb25zLnBvcHVwTmFtZV07XG5cbiAgICAgICAgaWYgKCFuZS51dGlsLmlzRXhpc3R5KHBvcHVwKSkge1xuICAgICAgICAgICAgdGhpcy5vcGVuZWRQb3B1cFtvcHRpb25zLnBvcHVwTmFtZV0gPSBwb3B1cCA9IHRoaXMuX29wZW4odXNlSUVQb3N0QnJpZGdlLCBvcHRpb25zLnBhcmFtLFxuICAgICAgICAgICAgICAgIHVybCwgb3B0aW9ucy5wb3B1cE5hbWUsIG9wdGlvbnMucG9wdXBPcHRpb25TdHIpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocG9wdXAuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuZWRQb3B1cFtvcHRpb25zLnBvcHVwTmFtZV0gPSBwb3B1cCA9IHRoaXMuX29wZW4odXNlSUVQb3N0QnJpZGdlLCBvcHRpb25zLnBhcmFtLFxuICAgICAgICAgICAgICAgICAgICB1cmwsIG9wdGlvbnMucG9wdXBOYW1lLCBvcHRpb25zLnBvcHVwT3B0aW9uU3RyKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy51c2VSZWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wdXAubG9jYXRpb24ucmVwbGFjZSh1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3B1cC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbG9zZVdpdGhQYXJlbnRQb3B1cFtvcHRpb25zLnBvcHVwTmFtZV0gPSBvcHRpb25zLmNsb3NlV2l0aFBhcmVudDtcblxuICAgICAgICBpZiAoIXBvcHVwIHx8IHBvcHVwLmNsb3NlZCB8fCBuZS51dGlsLmlzVW5kZWZpbmVkKHBvcHVwLmNsb3NlZCkpIHtcbiAgICAgICAgICAgIGFsZXJ0KCfruIzrnbzsmrDsoIDsl5Ag7Yyd7JeF7J2EIOunieuKlCDquLDriqXsnbQg7Zmc7ISx7ZmUIOyDge2DnOydtOq4sCDrlYzrrLjsl5Ag7ISc67mE7IqkIOydtOyaqeyXkCDrrLjsoJzqsIAg7J6I7J2EIOyImCDsnojsirXri4jri6QuIO2VtOuLuSDquLDriqXsnYQg67mE7Zmc7ISx7ZmUIO2VtCDso7zshLjsmpQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnBhcmFtICYmIG9wdGlvbnMubWV0aG9kID09PSAnUE9TVCcgJiYgIXVzZUlFUG9zdEJyaWRnZSkge1xuICAgICAgICAgICAgaWYgKHBvcHVwKSB7XG4gICAgICAgICAgICAgICAgZm9ybUVsZW1lbnQuc3VibWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybUVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGZvcm1FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZm9ybUVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93Lm9udW5sb2FkID0gbmUudXRpbC5iaW5kKHRoaXMuY2xvc2VBbGxQb3B1cCwgdGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBwb3B1cFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBCZWZvcmVVbmxvYWRdIC0gSWYgdHJ1ZSwgdGhlICd3aW5kb3cub251bmxvYWQnIHdpbGwgYmUgbnVsbCBhbmQgc2tpcCB1bmxvYWQgZXZlbnQuXG4gICAgICogQHBhcmFtIHtXaW5kb3d9IFtwb3B1cF0gLSBXaW5kb3ctY29udGV4dCBvZiBwb3B1cCBmb3IgY2xvc2luZy4gSWYgb21pdCB0aGlzLCBjdXJyZW50IHdpbmRvdy1jb250ZXh0IHdpbGwgYmUgY2xvc2VkLlxuICAgICAqL1xuICAgIFBvcHVwLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKHNraXBCZWZvcmVVbmxvYWQsIHBvcHVwKSB7XG4gICAgICAgIHNraXBCZWZvcmVVbmxvYWQgPSBuZS51dGlsLmlzRXhpc3R5KHNraXBCZWZvcmVVbmxvYWQpID8gc2tpcEJlZm9yZVVubG9hZCA6IGZhbHNlO1xuXG4gICAgICAgIHZhciB0YXJnZXQgPSBwb3B1cCB8fCB3aW5kb3c7XG5cbiAgICAgICAgaWYgKHNraXBCZWZvcmVVbmxvYWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5vbnVubG9hZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRhcmdldC5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRhcmdldC5vcGVuZXIgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgICAgICAgIHRhcmdldC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsb3NlIGFsbCB0aGUgcG9wdXBzIGluIGN1cnJlbnQgd2luZG93LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xvc2VXaXRoUGFyZW50IC0gSWYgdHJ1ZSwgcG9wdXBzIGhhdmluZyB0aGUgY2xvc2VXaXRoUGFyZW50UG9wdXAgcHJvcGVydHkgYXMgdHJ1ZSB3aWxsIGJlIGNsb3NlZC5cbiAgICAgKi9cbiAgICBQb3B1cC5wcm90b3R5cGUuY2xvc2VBbGxQb3B1cCA9IGZ1bmN0aW9uKGNsb3NlV2l0aFBhcmVudCkge1xuICAgICAgICB2YXIgaGFzQXJnID0gbmUudXRpbC5pc0V4aXN0eShjbG9zZVdpdGhQYXJlbnQpO1xuXG4gICAgICAgIG5lLnV0aWwuZm9yRWFjaE93blByb3BlcnRpZXModGhpcy5vcGVuZWRQb3B1cCwgZnVuY3Rpb24ocG9wdXAsIGtleSkge1xuICAgICAgICAgICAgaWYgKChoYXNBcmcgJiYgdGhpcy5jbG9zZVdpdGhQYXJlbnRQb3B1cFtrZXldKSB8fCAhaGFzQXJnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZShmYWxzZSwgcG9wdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGUob3IgZm9jdXMpIHRoZSBwb3B1cCBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcG9wdXBOYW1lIC0gTmFtZSBvZiBwb3B1cCBmb3IgYWN0aXZhdGlvblxuICAgICAqL1xuICAgIFBvcHVwLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uKHBvcHVwTmFtZSkge1xuICAgICAgICB0aGlzLmdldFBvcHVwTGlzdChwb3B1cE5hbWUpLmZvY3VzKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBvYmplY3QgbWFkZSBvZiBwYXJzaW5nIHRoZSBxdWVyeSBzdHJpbmcuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgaGF2aW5nIHNvbWUgaW5mb3JtYXRpb24gb2YgdGhlIHF1ZXJ5IHN0cmluZy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBvcHVwLnByb3RvdHlwZS5wYXJzZVF1ZXJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWFyY2gsXG4gICAgICAgICAgICBwYWlyLFxuICAgICAgICAgICAgcGFyYW0gPSB7fTtcblxuICAgICAgICBzZWFyY2ggPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgbmUudXRpbC5mb3JFYWNoQXJyYXkoc2VhcmNoLnNwbGl0KCcmJyksIGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgICAgIHBhaXIgPSBwYXJ0LnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICBwYXJhbVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGhpZGRlbiBmb3JtIGZyb20gdGhlIGdpdmVuIGFyZ3VtZW50cyBhbmQgcmV0dXJuIHRoaXMgZm9ybS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uIC0gVVJMIGZvciBmb3JtIHRyYW5zbWlzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gLSBEYXRhIGZvciBmb3JtIHRyYW5zbWlzc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0aG9kXSAtIE1ldGhvZCBvZiB0cmFuc21pc3Npb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gLSBUYXJnZXQgb2YgdHJhbnNtaXNzaW9uXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2NvbnRhaW5lcl0gLSBDb250YWluZXIgZWxlbWVudCBvZiBmb3JtLlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gRm9ybSBlbGVtZW50XG4gICAgICovXG4gICAgUG9wdXAucHJvdG90eXBlLmNyZWF0ZUZvcm0gPSBmdW5jdGlvbihhY3Rpb24sIGRhdGEsIG1ldGhvZCwgdGFyZ2V0LCBjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyksXG4gICAgICAgICAgICBpbnB1dDtcblxuICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgZG9jdW1lbnQuYm9keTtcblxuICAgICAgICBmb3JtLm1ldGhvZCA9IG1ldGhvZCB8fCAnUE9TVCc7XG4gICAgICAgIGZvcm0uYWN0aW9uID0gYWN0aW9uIHx8ICcnO1xuICAgICAgICBmb3JtLnRhcmdldCA9IHRhcmdldCB8fCAnJztcbiAgICAgICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgIG5lLnV0aWwuZm9yRWFjaE93blByb3BlcnRpZXMoZGF0YSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgaW5wdXQubmFtZSA9IGtleTtcbiAgICAgICAgICAgIGlucHV0LnR5cGUgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBmb3JtLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGZvcm0pO1xuXG4gICAgICAgIHJldHVybiBmb3JtO1xuICAgIH07XG5cbiAgICAvKioqKioqKioqKlxuICAgICAqIHByaXZhdGUgbWV0aG9kc1xuICAgICAqKioqKioqKioqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIHF1ZXJ5IHN0cmluZyBtYWRlIGJ5IHBhcnNpbmcgdGhlIGdpdmVuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBBbiBvYmplY3QgdGhhdCBoYXMgaW5mb3JtYXRpb24gZm9yIHF1ZXJ5IHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gUXVlcnkgc3RyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQb3B1cC5wcm90b3R5cGUuX3BhcmFtZXRlcml6ZSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgcXVlcnkgPSBbXTtcblxuICAgICAgICBuZS51dGlsLmZvckVhY2hPd25Qcm9wZXJ0aWVzKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgcXVlcnkucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcXVlcnkuam9pbignJicpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHBvcHVwXG4gICAgICogQHBhcmFtIHtib29sZWFufSB1c2VJRVBvc3RCcmlkZ2UgLSBBIHN3aXRjaCBvcHRpb24gd2hldGhlciB0byB1c2UgYWx0ZXJuYXRpdmUgb2YgdG9zc2luZyBQT1NUIGRhdGEgdG8gdGhlIHBvcHVwIHdpbmRvdyBpbiBJRTExXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtIC0gQSBkYXRhIGZvciB0b3NzaW5nIHRvIHBvcHVwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFBvcHVwIHVybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwb3B1cE5hbWUgLSBQb3B1cCBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvblN0ciAtIFNldHRpbmcgZm9yIHBvcHVwLCBleCkgJ3dpZHRoPTY0MCxoZWlnaHQ9MzIwLHNjcm9sbGJhcnM9eWVzJ1xuICAgICAqIEByZXR1cm5zIHtXaW5kb3d9IFdpbmRvdyBjb250ZXh0IG9mIHBvcHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQb3B1cC5wcm90b3R5cGUuX29wZW4gPSBmdW5jdGlvbih1c2VJRVBvc3RCcmlkZ2UsIHBhcmFtLCB1cmwsIHBvcHVwTmFtZSwgb3B0aW9uU3RyKSB7XG4gICAgICAgIHZhciBwb3B1cDtcblxuICAgICAgICBpZiAodXNlSUVQb3N0QnJpZGdlKSB7XG4gICAgICAgICAgICB1cmwgPSB0aGlzLnBvc3REYXRhQnJpZGdlVXJsICsgJz9zdG9yYWdlS2V5PScgKyBlbmNvZGVVUklDb21wb25lbnQocG9wdXBOYW1lKSArXG4gICAgICAgICAgICAnJnJlZGlyZWN0VXJsPScgKyBlbmNvZGVVUklDb21wb25lbnQodXJsKTtcbiAgICAgICAgICAgIGlmICghd2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgICAgIGFsZXJ0KCdJRTEx67iM65287Jqw7KCA7J2YIOusuOygnOuhnCDsnbjtlbQg7J20IOq4sOuKpeydgCDruIzrnbzsmrDsoIDsnZggTG9jYWxTdG9yYWdlIOq4sOuKpeydhCDtmZzshLHtmZQg7ZWY7IWU7JW8IOydtOyaqe2VmOyLpCDsiJgg7J6I7Iq164uI64ukJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHBvcHVwTmFtZSk7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0ocG9wdXBOYW1lLCBKU09OLnN0cmluZ2lmeShwYXJhbSkpO1xuXG4gICAgICAgICAgICAgICAgcG9wdXAgPSB3aW5kb3cub3Blbih1cmwsIHBvcHVwTmFtZSwgb3B0aW9uU3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcHVwID0gd2luZG93Lm9wZW4odXJsLCBwb3B1cE5hbWUsIG9wdGlvblN0cik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9wdXA7XG4gICAgfTtcblxuICAgIG5lLnV0aWwucG9wdXAgPSBuZXcgUG9wdXAoKTtcblxufSkod2luZG93Lm5lKTtcbiIsImltcG9ydCAqIGFzIGJhc2UgZnJvbSAnLi9oYW5kbGViYXJzL2Jhc2UnO1xuXG4vLyBFYWNoIG9mIHRoZXNlIGF1Z21lbnQgdGhlIEhhbmRsZWJhcnMgb2JqZWN0LiBObyBuZWVkIHRvIHNldHVwIGhlcmUuXG4vLyAoVGhpcyBpcyBkb25lIHRvIGVhc2lseSBzaGFyZSBjb2RlIGJldHdlZW4gY29tbW9uanMgYW5kIGJyb3dzZSBlbnZzKVxuaW1wb3J0IFNhZmVTdHJpbmcgZnJvbSAnLi9oYW5kbGViYXJzL3NhZmUtc3RyaW5nJztcbmltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi9oYW5kbGViYXJzL2V4Y2VwdGlvbic7XG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tICcuL2hhbmRsZWJhcnMvdXRpbHMnO1xuaW1wb3J0ICogYXMgcnVudGltZSBmcm9tICcuL2hhbmRsZWJhcnMvcnVudGltZSc7XG5cbmltcG9ydCBub0NvbmZsaWN0IGZyb20gJy4vaGFuZGxlYmFycy9uby1jb25mbGljdCc7XG5cbi8vIEZvciBjb21wYXRpYmlsaXR5IGFuZCB1c2FnZSBvdXRzaWRlIG9mIG1vZHVsZSBzeXN0ZW1zLCBtYWtlIHRoZSBIYW5kbGViYXJzIG9iamVjdCBhIG5hbWVzcGFjZVxuZnVuY3Rpb24gY3JlYXRlKCkge1xuICBsZXQgaGIgPSBuZXcgYmFzZS5IYW5kbGViYXJzRW52aXJvbm1lbnQoKTtcblxuICBVdGlscy5leHRlbmQoaGIsIGJhc2UpO1xuICBoYi5TYWZlU3RyaW5nID0gU2FmZVN0cmluZztcbiAgaGIuRXhjZXB0aW9uID0gRXhjZXB0aW9uO1xuICBoYi5VdGlscyA9IFV0aWxzO1xuICBoYi5lc2NhcGVFeHByZXNzaW9uID0gVXRpbHMuZXNjYXBlRXhwcmVzc2lvbjtcblxuICBoYi5WTSA9IHJ1bnRpbWU7XG4gIGhiLnRlbXBsYXRlID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHJldHVybiBydW50aW1lLnRlbXBsYXRlKHNwZWMsIGhiKTtcbiAgfTtcblxuICByZXR1cm4gaGI7XG59XG5cbmxldCBpbnN0ID0gY3JlYXRlKCk7XG5pbnN0LmNyZWF0ZSA9IGNyZWF0ZTtcblxubm9Db25mbGljdChpbnN0KTtcblxuaW5zdFsnZGVmYXVsdCddID0gaW5zdDtcblxuZXhwb3J0IGRlZmF1bHQgaW5zdDtcbiIsImltcG9ydCB7Y3JlYXRlRnJhbWUsIGV4dGVuZCwgdG9TdHJpbmd9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuL2V4Y2VwdGlvbic7XG5pbXBvcnQge3JlZ2lzdGVyRGVmYXVsdEhlbHBlcnN9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQge3JlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnN9IGZyb20gJy4vZGVjb3JhdG9ycyc7XG5pbXBvcnQgbG9nZ2VyIGZyb20gJy4vbG9nZ2VyJztcblxuZXhwb3J0IGNvbnN0IFZFUlNJT04gPSAnNC4wLjMnO1xuZXhwb3J0IGNvbnN0IENPTVBJTEVSX1JFVklTSU9OID0gNztcblxuZXhwb3J0IGNvbnN0IFJFVklTSU9OX0NIQU5HRVMgPSB7XG4gIDE6ICc8PSAxLjAucmMuMicsIC8vIDEuMC5yYy4yIGlzIGFjdHVhbGx5IHJldjIgYnV0IGRvZXNuJ3QgcmVwb3J0IGl0XG4gIDI6ICc9PSAxLjAuMC1yYy4zJyxcbiAgMzogJz09IDEuMC4wLXJjLjQnLFxuICA0OiAnPT0gMS54LngnLFxuICA1OiAnPT0gMi4wLjAtYWxwaGEueCcsXG4gIDY6ICc+PSAyLjAuMC1iZXRhLjEnLFxuICA3OiAnPj0gNC4wLjAnXG59O1xuXG5jb25zdCBvYmplY3RUeXBlID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBIYW5kbGViYXJzRW52aXJvbm1lbnQoaGVscGVycywgcGFydGlhbHMsIGRlY29yYXRvcnMpIHtcbiAgdGhpcy5oZWxwZXJzID0gaGVscGVycyB8fCB7fTtcbiAgdGhpcy5wYXJ0aWFscyA9IHBhcnRpYWxzIHx8IHt9O1xuICB0aGlzLmRlY29yYXRvcnMgPSBkZWNvcmF0b3JzIHx8IHt9O1xuXG4gIHJlZ2lzdGVyRGVmYXVsdEhlbHBlcnModGhpcyk7XG4gIHJlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnModGhpcyk7XG59XG5cbkhhbmRsZWJhcnNFbnZpcm9ubWVudC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBIYW5kbGViYXJzRW52aXJvbm1lbnQsXG5cbiAgbG9nZ2VyOiBsb2dnZXIsXG4gIGxvZzogbG9nZ2VyLmxvZyxcblxuICByZWdpc3RlckhlbHBlcjogZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgaWYgKGZuKSB7IHRocm93IG5ldyBFeGNlcHRpb24oJ0FyZyBub3Qgc3VwcG9ydGVkIHdpdGggbXVsdGlwbGUgaGVscGVycycpOyB9XG4gICAgICBleHRlbmQodGhpcy5oZWxwZXJzLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWxwZXJzW25hbWVdID0gZm47XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVySGVscGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuaGVscGVyc1tuYW1lXTtcbiAgfSxcblxuICByZWdpc3RlclBhcnRpYWw6IGZ1bmN0aW9uKG5hbWUsIHBhcnRpYWwpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgZXh0ZW5kKHRoaXMucGFydGlhbHMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHBhcnRpYWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ0F0dGVtcHRpbmcgdG8gcmVnaXN0ZXIgYSBwYXJ0aWFsIGFzIHVuZGVmaW5lZCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJ0aWFsc1tuYW1lXSA9IHBhcnRpYWw7XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVyUGFydGlhbDogZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLnBhcnRpYWxzW25hbWVdO1xuICB9LFxuXG4gIHJlZ2lzdGVyRGVjb3JhdG9yOiBmdW5jdGlvbihuYW1lLCBmbikge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG4gICAgICBpZiAoZm4pIHsgdGhyb3cgbmV3IEV4Y2VwdGlvbignQXJnIG5vdCBzdXBwb3J0ZWQgd2l0aCBtdWx0aXBsZSBkZWNvcmF0b3JzJyk7IH1cbiAgICAgIGV4dGVuZCh0aGlzLmRlY29yYXRvcnMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlY29yYXRvcnNbbmFtZV0gPSBmbjtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXJEZWNvcmF0b3I6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5kZWNvcmF0b3JzW25hbWVdO1xuICB9XG59O1xuXG5leHBvcnQgbGV0IGxvZyA9IGxvZ2dlci5sb2c7XG5cbmV4cG9ydCB7Y3JlYXRlRnJhbWUsIGxvZ2dlcn07XG4iLCJpbXBvcnQgcmVnaXN0ZXJJbmxpbmUgZnJvbSAnLi9kZWNvcmF0b3JzL2lubGluZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzKGluc3RhbmNlKSB7XG4gIHJlZ2lzdGVySW5saW5lKGluc3RhbmNlKTtcbn1cblxuIiwiaW1wb3J0IHtleHRlbmR9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJEZWNvcmF0b3IoJ2lubGluZScsIGZ1bmN0aW9uKGZuLCBwcm9wcywgY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgbGV0IHJldCA9IGZuO1xuICAgIGlmICghcHJvcHMucGFydGlhbHMpIHtcbiAgICAgIHByb3BzLnBhcnRpYWxzID0ge307XG4gICAgICByZXQgPSBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwYXJ0aWFscyBzdGFjayBmcmFtZSBwcmlvciB0byBleGVjLlxuICAgICAgICBsZXQgb3JpZ2luYWwgPSBjb250YWluZXIucGFydGlhbHM7XG4gICAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IGV4dGVuZCh7fSwgb3JpZ2luYWwsIHByb3BzLnBhcnRpYWxzKTtcbiAgICAgICAgbGV0IHJldCA9IGZuKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBvcmlnaW5hbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcHJvcHMucGFydGlhbHNbb3B0aW9ucy5hcmdzWzBdXSA9IG9wdGlvbnMuZm47XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cbiIsIlxuY29uc3QgZXJyb3JQcm9wcyA9IFsnZGVzY3JpcHRpb24nLCAnZmlsZU5hbWUnLCAnbGluZU51bWJlcicsICdtZXNzYWdlJywgJ25hbWUnLCAnbnVtYmVyJywgJ3N0YWNrJ107XG5cbmZ1bmN0aW9uIEV4Y2VwdGlvbihtZXNzYWdlLCBub2RlKSB7XG4gIGxldCBsb2MgPSBub2RlICYmIG5vZGUubG9jLFxuICAgICAgbGluZSxcbiAgICAgIGNvbHVtbjtcbiAgaWYgKGxvYykge1xuICAgIGxpbmUgPSBsb2Muc3RhcnQubGluZTtcbiAgICBjb2x1bW4gPSBsb2Muc3RhcnQuY29sdW1uO1xuXG4gICAgbWVzc2FnZSArPSAnIC0gJyArIGxpbmUgKyAnOicgKyBjb2x1bW47XG4gIH1cblxuICBsZXQgdG1wID0gRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG5cbiAgLy8gVW5mb3J0dW5hdGVseSBlcnJvcnMgYXJlIG5vdCBlbnVtZXJhYmxlIGluIENocm9tZSAoYXQgbGVhc3QpLCBzbyBgZm9yIHByb3AgaW4gdG1wYCBkb2Vzbid0IHdvcmsuXG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGVycm9yUHJvcHMubGVuZ3RoOyBpZHgrKykge1xuICAgIHRoaXNbZXJyb3JQcm9wc1tpZHhdXSA9IHRtcFtlcnJvclByb3BzW2lkeF1dO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRXhjZXB0aW9uKTtcbiAgfVxuXG4gIGlmIChsb2MpIHtcbiAgICB0aGlzLmxpbmVOdW1iZXIgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICB9XG59XG5cbkV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblxuZXhwb3J0IGRlZmF1bHQgRXhjZXB0aW9uO1xuIiwiaW1wb3J0IHJlZ2lzdGVyQmxvY2tIZWxwZXJNaXNzaW5nIGZyb20gJy4vaGVscGVycy9ibG9jay1oZWxwZXItbWlzc2luZyc7XG5pbXBvcnQgcmVnaXN0ZXJFYWNoIGZyb20gJy4vaGVscGVycy9lYWNoJztcbmltcG9ydCByZWdpc3RlckhlbHBlck1pc3NpbmcgZnJvbSAnLi9oZWxwZXJzL2hlbHBlci1taXNzaW5nJztcbmltcG9ydCByZWdpc3RlcklmIGZyb20gJy4vaGVscGVycy9pZic7XG5pbXBvcnQgcmVnaXN0ZXJMb2cgZnJvbSAnLi9oZWxwZXJzL2xvZyc7XG5pbXBvcnQgcmVnaXN0ZXJMb29rdXAgZnJvbSAnLi9oZWxwZXJzL2xvb2t1cCc7XG5pbXBvcnQgcmVnaXN0ZXJXaXRoIGZyb20gJy4vaGVscGVycy93aXRoJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdEhlbHBlcnMoaW5zdGFuY2UpIHtcbiAgcmVnaXN0ZXJCbG9ja0hlbHBlck1pc3NpbmcoaW5zdGFuY2UpO1xuICByZWdpc3RlckVhY2goaW5zdGFuY2UpO1xuICByZWdpc3RlckhlbHBlck1pc3NpbmcoaW5zdGFuY2UpO1xuICByZWdpc3RlcklmKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJMb2coaW5zdGFuY2UpO1xuICByZWdpc3Rlckxvb2t1cChpbnN0YW5jZSk7XG4gIHJlZ2lzdGVyV2l0aChpbnN0YW5jZSk7XG59XG4iLCJpbXBvcnQge2FwcGVuZENvbnRleHRQYXRoLCBjcmVhdGVGcmFtZSwgaXNBcnJheX0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignYmxvY2tIZWxwZXJNaXNzaW5nJywgZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgIGxldCBpbnZlcnNlID0gb3B0aW9ucy5pbnZlcnNlLFxuICAgICAgICBmbiA9IG9wdGlvbnMuZm47XG5cbiAgICBpZiAoY29udGV4dCA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGZuKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoY29udGV4dCA9PT0gZmFsc2UgfHwgY29udGV4dCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gaW52ZXJzZSh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoY29udGV4dCkpIHtcbiAgICAgIGlmIChjb250ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaWRzKSB7XG4gICAgICAgICAgb3B0aW9ucy5pZHMgPSBbb3B0aW9ucy5uYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5oZWxwZXJzLmVhY2goY29udGV4dCwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW52ZXJzZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlkcykge1xuICAgICAgICBsZXQgZGF0YSA9IGNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XG4gICAgICAgIGRhdGEuY29udGV4dFBhdGggPSBhcHBlbmRDb250ZXh0UGF0aChvcHRpb25zLmRhdGEuY29udGV4dFBhdGgsIG9wdGlvbnMubmFtZSk7XG4gICAgICAgIG9wdGlvbnMgPSB7ZGF0YTogZGF0YX07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbihjb250ZXh0LCBvcHRpb25zKTtcbiAgICB9XG4gIH0pO1xufVxuIiwiaW1wb3J0IHthcHBlbmRDb250ZXh0UGF0aCwgYmxvY2tQYXJhbXMsIGNyZWF0ZUZyYW1lLCBpc0FycmF5LCBpc0Z1bmN0aW9ufSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4uL2V4Y2VwdGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdlYWNoJywgZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignTXVzdCBwYXNzIGl0ZXJhdG9yIHRvICNlYWNoJyk7XG4gICAgfVxuXG4gICAgbGV0IGZuID0gb3B0aW9ucy5mbixcbiAgICAgICAgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIHJldCA9ICcnLFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb250ZXh0UGF0aDtcblxuICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcbiAgICAgIGNvbnRleHRQYXRoID0gYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLmlkc1swXSkgKyAnLic7XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24oY29udGV4dCkpIHsgY29udGV4dCA9IGNvbnRleHQuY2FsbCh0aGlzKTsgfVxuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgZGF0YSA9IGNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhlY0l0ZXJhdGlvbihmaWVsZCwgaW5kZXgsIGxhc3QpIHtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGRhdGEua2V5ID0gZmllbGQ7XG4gICAgICAgIGRhdGEuaW5kZXggPSBpbmRleDtcbiAgICAgICAgZGF0YS5maXJzdCA9IGluZGV4ID09PSAwO1xuICAgICAgICBkYXRhLmxhc3QgPSAhIWxhc3Q7XG5cbiAgICAgICAgaWYgKGNvbnRleHRQYXRoKSB7XG4gICAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IGNvbnRleHRQYXRoICsgZmllbGQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0ID0gcmV0ICsgZm4oY29udGV4dFtmaWVsZF0sIHtcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgYmxvY2tQYXJhbXM6IGJsb2NrUGFyYW1zKFtjb250ZXh0W2ZpZWxkXSwgZmllbGRdLCBbY29udGV4dFBhdGggKyBmaWVsZCwgbnVsbF0pXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dCAmJiB0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChpc0FycmF5KGNvbnRleHQpKSB7XG4gICAgICAgIGZvciAobGV0IGogPSBjb250ZXh0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgIGlmIChpIGluIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGV4ZWNJdGVyYXRpb24oaSwgaSwgaSA9PT0gY29udGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBwcmlvcktleTtcblxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIC8vIFdlJ3JlIHJ1bm5pbmcgdGhlIGl0ZXJhdGlvbnMgb25lIHN0ZXAgb3V0IG9mIHN5bmMgc28gd2UgY2FuIGRldGVjdFxuICAgICAgICAgICAgLy8gdGhlIGxhc3QgaXRlcmF0aW9uIHdpdGhvdXQgaGF2ZSB0byBzY2FuIHRoZSBvYmplY3QgdHdpY2UgYW5kIGNyZWF0ZVxuICAgICAgICAgICAgLy8gYW4gaXRlcm1lZGlhdGUga2V5cyBhcnJheS5cbiAgICAgICAgICAgIGlmIChwcmlvcktleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGV4ZWNJdGVyYXRpb24ocHJpb3JLZXksIGkgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByaW9yS2V5ID0ga2V5O1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJpb3JLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGV4ZWNJdGVyYXRpb24ocHJpb3JLZXksIGkgLSAxLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICByZXQgPSBpbnZlcnNlKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufVxuIiwiaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuLi9leGNlcHRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignaGVscGVyTWlzc2luZycsIGZ1bmN0aW9uKC8qIFthcmdzLCBdb3B0aW9ucyAqLykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBBIG1pc3NpbmcgZmllbGQgaW4gYSB7e2Zvb319IGNvbnN0cnVjdC5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNvbWVvbmUgaXMgYWN0dWFsbHkgdHJ5aW5nIHRvIGNhbGwgc29tZXRoaW5nLCBibG93IHVwLlxuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignTWlzc2luZyBoZWxwZXI6IFwiJyArIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0ubmFtZSArICdcIicpO1xuICAgIH1cbiAgfSk7XG59XG4iLCJpbXBvcnQge2lzRW1wdHksIGlzRnVuY3Rpb259IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2lmJywgZnVuY3Rpb24oY29uZGl0aW9uYWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihjb25kaXRpb25hbCkpIHsgY29uZGl0aW9uYWwgPSBjb25kaXRpb25hbC5jYWxsKHRoaXMpOyB9XG5cbiAgICAvLyBEZWZhdWx0IGJlaGF2aW9yIGlzIHRvIHJlbmRlciB0aGUgcG9zaXRpdmUgcGF0aCBpZiB0aGUgdmFsdWUgaXMgdHJ1dGh5IGFuZCBub3QgZW1wdHkuXG4gICAgLy8gVGhlIGBpbmNsdWRlWmVyb2Agb3B0aW9uIG1heSBiZSBzZXQgdG8gdHJlYXQgdGhlIGNvbmR0aW9uYWwgYXMgcHVyZWx5IG5vdCBlbXB0eSBiYXNlZCBvbiB0aGVcbiAgICAvLyBiZWhhdmlvciBvZiBpc0VtcHR5LiBFZmZlY3RpdmVseSB0aGlzIGRldGVybWluZXMgaWYgMCBpcyBoYW5kbGVkIGJ5IHRoZSBwb3NpdGl2ZSBwYXRoIG9yIG5lZ2F0aXZlLlxuICAgIGlmICgoIW9wdGlvbnMuaGFzaC5pbmNsdWRlWmVybyAmJiAhY29uZGl0aW9uYWwpIHx8IGlzRW1wdHkoY29uZGl0aW9uYWwpKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5mbih0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCd1bmxlc3MnLCBmdW5jdGlvbihjb25kaXRpb25hbCwgb3B0aW9ucykge1xuICAgIHJldHVybiBpbnN0YW5jZS5oZWxwZXJzWydpZiddLmNhbGwodGhpcywgY29uZGl0aW9uYWwsIHtmbjogb3B0aW9ucy5pbnZlcnNlLCBpbnZlcnNlOiBvcHRpb25zLmZuLCBoYXNoOiBvcHRpb25zLmhhc2h9KTtcbiAgfSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignbG9nJywgZnVuY3Rpb24oLyogbWVzc2FnZSwgb3B0aW9ucyAqLykge1xuICAgIGxldCBhcmdzID0gW3VuZGVmaW5lZF0sXG4gICAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgbGV0IGxldmVsID0gMTtcbiAgICBpZiAob3B0aW9ucy5oYXNoLmxldmVsICE9IG51bGwpIHtcbiAgICAgIGxldmVsID0gb3B0aW9ucy5oYXNoLmxldmVsO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuZGF0YS5sZXZlbCAhPSBudWxsKSB7XG4gICAgICBsZXZlbCA9IG9wdGlvbnMuZGF0YS5sZXZlbDtcbiAgICB9XG4gICAgYXJnc1swXSA9IGxldmVsO1xuXG4gICAgaW5zdGFuY2UubG9nKC4uLiBhcmdzKTtcbiAgfSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignbG9va3VwJywgZnVuY3Rpb24ob2JqLCBmaWVsZCkge1xuICAgIHJldHVybiBvYmogJiYgb2JqW2ZpZWxkXTtcbiAgfSk7XG59XG4iLCJpbXBvcnQge2FwcGVuZENvbnRleHRQYXRoLCBibG9ja1BhcmFtcywgY3JlYXRlRnJhbWUsIGlzRW1wdHksIGlzRnVuY3Rpb259IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ3dpdGgnLCBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oY29udGV4dCkpIHsgY29udGV4dCA9IGNvbnRleHQuY2FsbCh0aGlzKTsgfVxuXG4gICAgbGV0IGZuID0gb3B0aW9ucy5mbjtcblxuICAgIGlmICghaXNFbXB0eShjb250ZXh0KSkge1xuICAgICAgbGV0IGRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG4gICAgICAgIGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLmlkc1swXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbihjb250ZXh0LCB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyhbY29udGV4dF0sIFtkYXRhICYmIGRhdGEuY29udGV4dFBhdGhdKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgfVxuICB9KTtcbn1cbiIsImltcG9ydCB7aW5kZXhPZn0gZnJvbSAnLi91dGlscyc7XG5cbmxldCBsb2dnZXIgPSB7XG4gIG1ldGhvZE1hcDogWydkZWJ1ZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InXSxcbiAgbGV2ZWw6ICdpbmZvJyxcblxuICAvLyBNYXBzIGEgZ2l2ZW4gbGV2ZWwgdmFsdWUgdG8gdGhlIGBtZXRob2RNYXBgIGluZGV4ZXMgYWJvdmUuXG4gIGxvb2t1cExldmVsOiBmdW5jdGlvbihsZXZlbCkge1xuICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgbGV2ZWxNYXAgPSBpbmRleE9mKGxvZ2dlci5tZXRob2RNYXAsIGxldmVsLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKGxldmVsTWFwID49IDApIHtcbiAgICAgICAgbGV2ZWwgPSBsZXZlbE1hcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsID0gcGFyc2VJbnQobGV2ZWwsIDEwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGV2ZWw7XG4gIH0sXG5cbiAgLy8gQ2FuIGJlIG92ZXJyaWRkZW4gaW4gdGhlIGhvc3QgZW52aXJvbm1lbnRcbiAgbG9nOiBmdW5jdGlvbihsZXZlbCwgLi4ubWVzc2FnZSkge1xuICAgIGxldmVsID0gbG9nZ2VyLmxvb2t1cExldmVsKGxldmVsKTtcblxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbG9nZ2VyLmxvb2t1cExldmVsKGxvZ2dlci5sZXZlbCkgPD0gbGV2ZWwpIHtcbiAgICAgIGxldCBtZXRob2QgPSBsb2dnZXIubWV0aG9kTWFwW2xldmVsXTtcbiAgICAgIGlmICghY29uc29sZVttZXRob2RdKSB7ICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAgIG1ldGhvZCA9ICdsb2cnO1xuICAgICAgfVxuICAgICAgY29uc29sZVttZXRob2RdKC4uLm1lc3NhZ2UpOyAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGxvZ2dlcjtcbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKEhhbmRsZWJhcnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgbGV0IHJvb3QgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdyxcbiAgICAgICRIYW5kbGViYXJzID0gcm9vdC5IYW5kbGViYXJzO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBIYW5kbGViYXJzLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAocm9vdC5IYW5kbGViYXJzID09PSBIYW5kbGViYXJzKSB7XG4gICAgICByb290LkhhbmRsZWJhcnMgPSAkSGFuZGxlYmFycztcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgKiBhcyBVdGlscyBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi9leGNlcHRpb24nO1xuaW1wb3J0IHsgQ09NUElMRVJfUkVWSVNJT04sIFJFVklTSU9OX0NIQU5HRVMsIGNyZWF0ZUZyYW1lIH0gZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmV2aXNpb24oY29tcGlsZXJJbmZvKSB7XG4gIGNvbnN0IGNvbXBpbGVyUmV2aXNpb24gPSBjb21waWxlckluZm8gJiYgY29tcGlsZXJJbmZvWzBdIHx8IDEsXG4gICAgICAgIGN1cnJlbnRSZXZpc2lvbiA9IENPTVBJTEVSX1JFVklTSU9OO1xuXG4gIGlmIChjb21waWxlclJldmlzaW9uICE9PSBjdXJyZW50UmV2aXNpb24pIHtcbiAgICBpZiAoY29tcGlsZXJSZXZpc2lvbiA8IGN1cnJlbnRSZXZpc2lvbikge1xuICAgICAgY29uc3QgcnVudGltZVZlcnNpb25zID0gUkVWSVNJT05fQ0hBTkdFU1tjdXJyZW50UmV2aXNpb25dLFxuICAgICAgICAgICAgY29tcGlsZXJWZXJzaW9ucyA9IFJFVklTSU9OX0NIQU5HRVNbY29tcGlsZXJSZXZpc2lvbl07XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdUZW1wbGF0ZSB3YXMgcHJlY29tcGlsZWQgd2l0aCBhbiBvbGRlciB2ZXJzaW9uIG9mIEhhbmRsZWJhcnMgdGhhbiB0aGUgY3VycmVudCBydW50aW1lLiAnICtcbiAgICAgICAgICAgICdQbGVhc2UgdXBkYXRlIHlvdXIgcHJlY29tcGlsZXIgdG8gYSBuZXdlciB2ZXJzaW9uICgnICsgcnVudGltZVZlcnNpb25zICsgJykgb3IgZG93bmdyYWRlIHlvdXIgcnVudGltZSB0byBhbiBvbGRlciB2ZXJzaW9uICgnICsgY29tcGlsZXJWZXJzaW9ucyArICcpLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVc2UgdGhlIGVtYmVkZGVkIHZlcnNpb24gaW5mbyBzaW5jZSB0aGUgcnVudGltZSBkb2Vzbid0IGtub3cgYWJvdXQgdGhpcyByZXZpc2lvbiB5ZXRcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1RlbXBsYXRlIHdhcyBwcmVjb21waWxlZCB3aXRoIGEgbmV3ZXIgdmVyc2lvbiBvZiBIYW5kbGViYXJzIHRoYW4gdGhlIGN1cnJlbnQgcnVudGltZS4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIHVwZGF0ZSB5b3VyIHJ1bnRpbWUgdG8gYSBuZXdlciB2ZXJzaW9uICgnICsgY29tcGlsZXJJbmZvWzFdICsgJykuJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZSh0ZW1wbGF0ZVNwZWMsIGVudikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoIWVudikge1xuICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ05vIGVudmlyb25tZW50IHBhc3NlZCB0byB0ZW1wbGF0ZScpO1xuICB9XG4gIGlmICghdGVtcGxhdGVTcGVjIHx8ICF0ZW1wbGF0ZVNwZWMubWFpbikge1xuICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1Vua25vd24gdGVtcGxhdGUgb2JqZWN0OiAnICsgdHlwZW9mIHRlbXBsYXRlU3BlYyk7XG4gIH1cblxuICB0ZW1wbGF0ZVNwZWMubWFpbi5kZWNvcmF0b3IgPSB0ZW1wbGF0ZVNwZWMubWFpbl9kO1xuXG4gIC8vIE5vdGU6IFVzaW5nIGVudi5WTSByZWZlcmVuY2VzIHJhdGhlciB0aGFuIGxvY2FsIHZhciByZWZlcmVuY2VzIHRocm91Z2hvdXQgdGhpcyBzZWN0aW9uIHRvIGFsbG93XG4gIC8vIGZvciBleHRlcm5hbCB1c2VycyB0byBvdmVycmlkZSB0aGVzZSBhcyBwc3VlZG8tc3VwcG9ydGVkIEFQSXMuXG4gIGVudi5WTS5jaGVja1JldmlzaW9uKHRlbXBsYXRlU3BlYy5jb21waWxlcik7XG5cbiAgZnVuY3Rpb24gaW52b2tlUGFydGlhbFdyYXBwZXIocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmhhc2gpIHtcbiAgICAgIGNvbnRleHQgPSBVdGlscy5leHRlbmQoe30sIGNvbnRleHQsIG9wdGlvbnMuaGFzaCk7XG4gICAgICBpZiAob3B0aW9ucy5pZHMpIHtcbiAgICAgICAgb3B0aW9ucy5pZHNbMF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcnRpYWwgPSBlbnYuVk0ucmVzb2x2ZVBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKTtcbiAgICBsZXQgcmVzdWx0ID0gZW52LlZNLmludm9rZVBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKTtcblxuICAgIGlmIChyZXN1bHQgPT0gbnVsbCAmJiBlbnYuY29tcGlsZSkge1xuICAgICAgb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdID0gZW52LmNvbXBpbGUocGFydGlhbCwgdGVtcGxhdGVTcGVjLmNvbXBpbGVyT3B0aW9ucywgZW52KTtcbiAgICAgIHJlc3VsdCA9IG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXShjb250ZXh0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbmRlbnQpIHtcbiAgICAgICAgbGV0IGxpbmVzID0gcmVzdWx0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWxpbmVzW2ldICYmIGkgKyAxID09PSBsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaW5lc1tpXSA9IG9wdGlvbnMuaW5kZW50ICsgbGluZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbGluZXMuam9pbignXFxuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdUaGUgcGFydGlhbCAnICsgb3B0aW9ucy5uYW1lICsgJyBjb3VsZCBub3QgYmUgY29tcGlsZWQgd2hlbiBydW5uaW5nIGluIHJ1bnRpbWUtb25seSBtb2RlJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gSnVzdCBhZGQgd2F0ZXJcbiAgbGV0IGNvbnRhaW5lciA9IHtcbiAgICBzdHJpY3Q6IGZ1bmN0aW9uKG9iaiwgbmFtZSkge1xuICAgICAgaWYgKCEobmFtZSBpbiBvYmopKSB7XG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1wiJyArIG5hbWUgKyAnXCIgbm90IGRlZmluZWQgaW4gJyArIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqW25hbWVdO1xuICAgIH0sXG4gICAgbG9va3VwOiBmdW5jdGlvbihkZXB0aHMsIG5hbWUpIHtcbiAgICAgIGNvbnN0IGxlbiA9IGRlcHRocy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChkZXB0aHNbaV0gJiYgZGVwdGhzW2ldW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZGVwdGhzW2ldW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBsYW1iZGE6IGZ1bmN0aW9uKGN1cnJlbnQsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY3VycmVudCA9PT0gJ2Z1bmN0aW9uJyA/IGN1cnJlbnQuY2FsbChjb250ZXh0KSA6IGN1cnJlbnQ7XG4gICAgfSxcblxuICAgIGVzY2FwZUV4cHJlc3Npb246IFV0aWxzLmVzY2FwZUV4cHJlc3Npb24sXG4gICAgaW52b2tlUGFydGlhbDogaW52b2tlUGFydGlhbFdyYXBwZXIsXG5cbiAgICBmbjogZnVuY3Rpb24oaSkge1xuICAgICAgbGV0IHJldCA9IHRlbXBsYXRlU3BlY1tpXTtcbiAgICAgIHJldC5kZWNvcmF0b3IgPSB0ZW1wbGF0ZVNwZWNbaSArICdfZCddO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgcHJvZ3JhbXM6IFtdLFxuICAgIHByb2dyYW06IGZ1bmN0aW9uKGksIGRhdGEsIGRlY2xhcmVkQmxvY2tQYXJhbXMsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcbiAgICAgIGxldCBwcm9ncmFtV3JhcHBlciA9IHRoaXMucHJvZ3JhbXNbaV0sXG4gICAgICAgICAgZm4gPSB0aGlzLmZuKGkpO1xuICAgICAgaWYgKGRhdGEgfHwgZGVwdGhzIHx8IGJsb2NrUGFyYW1zIHx8IGRlY2xhcmVkQmxvY2tQYXJhbXMpIHtcbiAgICAgICAgcHJvZ3JhbVdyYXBwZXIgPSB3cmFwUHJvZ3JhbSh0aGlzLCBpLCBmbiwgZGF0YSwgZGVjbGFyZWRCbG9ja1BhcmFtcywgYmxvY2tQYXJhbXMsIGRlcHRocyk7XG4gICAgICB9IGVsc2UgaWYgKCFwcm9ncmFtV3JhcHBlcikge1xuICAgICAgICBwcm9ncmFtV3JhcHBlciA9IHRoaXMucHJvZ3JhbXNbaV0gPSB3cmFwUHJvZ3JhbSh0aGlzLCBpLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvZ3JhbVdyYXBwZXI7XG4gICAgfSxcblxuICAgIGRhdGE6IGZ1bmN0aW9uKHZhbHVlLCBkZXB0aCkge1xuICAgICAgd2hpbGUgKHZhbHVlICYmIGRlcHRoLS0pIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5fcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKHBhcmFtLCBjb21tb24pIHtcbiAgICAgIGxldCBvYmogPSBwYXJhbSB8fCBjb21tb247XG5cbiAgICAgIGlmIChwYXJhbSAmJiBjb21tb24gJiYgKHBhcmFtICE9PSBjb21tb24pKSB7XG4gICAgICAgIG9iaiA9IFV0aWxzLmV4dGVuZCh7fSwgY29tbW9uLCBwYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIG5vb3A6IGVudi5WTS5ub29wLFxuICAgIGNvbXBpbGVySW5mbzogdGVtcGxhdGVTcGVjLmNvbXBpbGVyXG4gIH07XG5cbiAgZnVuY3Rpb24gcmV0KGNvbnRleHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBkYXRhID0gb3B0aW9ucy5kYXRhO1xuXG4gICAgcmV0Ll9zZXR1cChvcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMucGFydGlhbCAmJiB0ZW1wbGF0ZVNwZWMudXNlRGF0YSkge1xuICAgICAgZGF0YSA9IGluaXREYXRhKGNvbnRleHQsIGRhdGEpO1xuICAgIH1cbiAgICBsZXQgZGVwdGhzLFxuICAgICAgICBibG9ja1BhcmFtcyA9IHRlbXBsYXRlU3BlYy51c2VCbG9ja1BhcmFtcyA/IFtdIDogdW5kZWZpbmVkO1xuICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlRGVwdGhzKSB7XG4gICAgICBpZiAob3B0aW9ucy5kZXB0aHMpIHtcbiAgICAgICAgZGVwdGhzID0gY29udGV4dCAhPT0gb3B0aW9ucy5kZXB0aHNbMF0gPyBbY29udGV4dF0uY29uY2F0KG9wdGlvbnMuZGVwdGhzKSA6IG9wdGlvbnMuZGVwdGhzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVwdGhzID0gW2NvbnRleHRdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1haW4oY29udGV4dC8qLCBvcHRpb25zKi8pIHtcbiAgICAgIHJldHVybiAnJyArIHRlbXBsYXRlU3BlYy5tYWluKGNvbnRhaW5lciwgY29udGV4dCwgY29udGFpbmVyLmhlbHBlcnMsIGNvbnRhaW5lci5wYXJ0aWFscywgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocyk7XG4gICAgfVxuICAgIG1haW4gPSBleGVjdXRlRGVjb3JhdG9ycyh0ZW1wbGF0ZVNwZWMubWFpbiwgbWFpbiwgY29udGFpbmVyLCBvcHRpb25zLmRlcHRocyB8fCBbXSwgZGF0YSwgYmxvY2tQYXJhbXMpO1xuICAgIHJldHVybiBtYWluKGNvbnRleHQsIG9wdGlvbnMpO1xuICB9XG4gIHJldC5pc1RvcCA9IHRydWU7XG5cbiAgcmV0Ll9zZXR1cCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMucGFydGlhbCkge1xuICAgICAgY29udGFpbmVyLmhlbHBlcnMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5oZWxwZXJzLCBlbnYuaGVscGVycyk7XG5cbiAgICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlUGFydGlhbCkge1xuICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5wYXJ0aWFscywgZW52LnBhcnRpYWxzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlUGFydGlhbCB8fCB0ZW1wbGF0ZVNwZWMudXNlRGVjb3JhdG9ycykge1xuICAgICAgICBjb250YWluZXIuZGVjb3JhdG9ycyA9IGNvbnRhaW5lci5tZXJnZShvcHRpb25zLmRlY29yYXRvcnMsIGVudi5kZWNvcmF0b3JzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyLmhlbHBlcnMgPSBvcHRpb25zLmhlbHBlcnM7XG4gICAgICBjb250YWluZXIucGFydGlhbHMgPSBvcHRpb25zLnBhcnRpYWxzO1xuICAgICAgY29udGFpbmVyLmRlY29yYXRvcnMgPSBvcHRpb25zLmRlY29yYXRvcnM7XG4gICAgfVxuICB9O1xuXG4gIHJldC5fY2hpbGQgPSBmdW5jdGlvbihpLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XG4gICAgaWYgKHRlbXBsYXRlU3BlYy51c2VCbG9ja1BhcmFtcyAmJiAhYmxvY2tQYXJhbXMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ211c3QgcGFzcyBibG9jayBwYXJhbXMnKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlU3BlYy51c2VEZXB0aHMgJiYgIWRlcHRocykge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignbXVzdCBwYXNzIHBhcmVudCBkZXB0aHMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcFByb2dyYW0oY29udGFpbmVyLCBpLCB0ZW1wbGF0ZVNwZWNbaV0sIGRhdGEsIDAsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICB9O1xuICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcFByb2dyYW0oY29udGFpbmVyLCBpLCBmbiwgZGF0YSwgZGVjbGFyZWRCbG9ja1BhcmFtcywgYmxvY2tQYXJhbXMsIGRlcHRocykge1xuICBmdW5jdGlvbiBwcm9nKGNvbnRleHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBjdXJyZW50RGVwdGhzID0gZGVwdGhzO1xuICAgIGlmIChkZXB0aHMgJiYgY29udGV4dCAhPT0gZGVwdGhzWzBdKSB7XG4gICAgICBjdXJyZW50RGVwdGhzID0gW2NvbnRleHRdLmNvbmNhdChkZXB0aHMpO1xuICAgIH1cblxuICAgIHJldHVybiBmbihjb250YWluZXIsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNvbnRhaW5lci5oZWxwZXJzLCBjb250YWluZXIucGFydGlhbHMsXG4gICAgICAgIG9wdGlvbnMuZGF0YSB8fCBkYXRhLFxuICAgICAgICBibG9ja1BhcmFtcyAmJiBbb3B0aW9ucy5ibG9ja1BhcmFtc10uY29uY2F0KGJsb2NrUGFyYW1zKSxcbiAgICAgICAgY3VycmVudERlcHRocyk7XG4gIH1cblxuICBwcm9nID0gZXhlY3V0ZURlY29yYXRvcnMoZm4sIHByb2csIGNvbnRhaW5lciwgZGVwdGhzLCBkYXRhLCBibG9ja1BhcmFtcyk7XG5cbiAgcHJvZy5wcm9ncmFtID0gaTtcbiAgcHJvZy5kZXB0aCA9IGRlcHRocyA/IGRlcHRocy5sZW5ndGggOiAwO1xuICBwcm9nLmJsb2NrUGFyYW1zID0gZGVjbGFyZWRCbG9ja1BhcmFtcyB8fCAwO1xuICByZXR1cm4gcHJvZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVQYXJ0aWFsKHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgaWYgKCFwYXJ0aWFsKSB7XG4gICAgaWYgKG9wdGlvbnMubmFtZSA9PT0gJ0BwYXJ0aWFsLWJsb2NrJykge1xuICAgICAgcGFydGlhbCA9IG9wdGlvbnMuZGF0YVsncGFydGlhbC1ibG9jayddO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0aWFsID0gb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdO1xuICAgIH1cbiAgfSBlbHNlIGlmICghcGFydGlhbC5jYWxsICYmICFvcHRpb25zLm5hbWUpIHtcbiAgICAvLyBUaGlzIGlzIGEgZHluYW1pYyBwYXJ0aWFsIHRoYXQgcmV0dXJuZWQgYSBzdHJpbmdcbiAgICBvcHRpb25zLm5hbWUgPSBwYXJ0aWFsO1xuICAgIHBhcnRpYWwgPSBvcHRpb25zLnBhcnRpYWxzW3BhcnRpYWxdO1xuICB9XG4gIHJldHVybiBwYXJ0aWFsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlUGFydGlhbChwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMucGFydGlhbCA9IHRydWU7XG4gIGlmIChvcHRpb25zLmlkcykge1xuICAgIG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCA9IG9wdGlvbnMuaWRzWzBdIHx8IG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aDtcbiAgfVxuXG4gIGxldCBwYXJ0aWFsQmxvY2s7XG4gIGlmIChvcHRpb25zLmZuICYmIG9wdGlvbnMuZm4gIT09IG5vb3ApIHtcbiAgICBvcHRpb25zLmRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgIHBhcnRpYWxCbG9jayA9IG9wdGlvbnMuZGF0YVsncGFydGlhbC1ibG9jayddID0gb3B0aW9ucy5mbjtcblxuICAgIGlmIChwYXJ0aWFsQmxvY2sucGFydGlhbHMpIHtcbiAgICAgIG9wdGlvbnMucGFydGlhbHMgPSBVdGlscy5leHRlbmQoe30sIG9wdGlvbnMucGFydGlhbHMsIHBhcnRpYWxCbG9jay5wYXJ0aWFscyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnRpYWwgPT09IHVuZGVmaW5lZCAmJiBwYXJ0aWFsQmxvY2spIHtcbiAgICBwYXJ0aWFsID0gcGFydGlhbEJsb2NrO1xuICB9XG5cbiAgaWYgKHBhcnRpYWwgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1RoZSBwYXJ0aWFsICcgKyBvcHRpb25zLm5hbWUgKyAnIGNvdWxkIG5vdCBiZSBmb3VuZCcpO1xuICB9IGVsc2UgaWYgKHBhcnRpYWwgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIHJldHVybiBwYXJ0aWFsKGNvbnRleHQsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkgeyByZXR1cm4gJyc7IH1cblxuZnVuY3Rpb24gaW5pdERhdGEoY29udGV4dCwgZGF0YSkge1xuICBpZiAoIWRhdGEgfHwgISgncm9vdCcgaW4gZGF0YSkpIHtcbiAgICBkYXRhID0gZGF0YSA/IGNyZWF0ZUZyYW1lKGRhdGEpIDoge307XG4gICAgZGF0YS5yb290ID0gY29udGV4dDtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZXhlY3V0ZURlY29yYXRvcnMoZm4sIHByb2csIGNvbnRhaW5lciwgZGVwdGhzLCBkYXRhLCBibG9ja1BhcmFtcykge1xuICBpZiAoZm4uZGVjb3JhdG9yKSB7XG4gICAgbGV0IHByb3BzID0ge307XG4gICAgcHJvZyA9IGZuLmRlY29yYXRvcihwcm9nLCBwcm9wcywgY29udGFpbmVyLCBkZXB0aHMgJiYgZGVwdGhzWzBdLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcbiAgICBVdGlscy5leHRlbmQocHJvZywgcHJvcHMpO1xuICB9XG4gIHJldHVybiBwcm9nO1xufVxuIiwiLy8gQnVpbGQgb3V0IG91ciBiYXNpYyBTYWZlU3RyaW5nIHR5cGVcbmZ1bmN0aW9uIFNhZmVTdHJpbmcoc3RyaW5nKSB7XG4gIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xufVxuXG5TYWZlU3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyA9IFNhZmVTdHJpbmcucHJvdG90eXBlLnRvSFRNTCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJycgKyB0aGlzLnN0cmluZztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNhZmVTdHJpbmc7XG4iLCJjb25zdCBlc2NhcGUgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmI3gyNzsnLFxuICAnYCc6ICcmI3g2MDsnLFxuICAnPSc6ICcmI3gzRDsnXG59O1xuXG5jb25zdCBiYWRDaGFycyA9IC9bJjw+XCInYD1dL2csXG4gICAgICBwb3NzaWJsZSA9IC9bJjw+XCInYD1dLztcblxuZnVuY3Rpb24gZXNjYXBlQ2hhcihjaHIpIHtcbiAgcmV0dXJuIGVzY2FwZVtjaHJdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKG9iaiAvKiAsIC4uLnNvdXJjZSAqLykge1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAobGV0IGtleSBpbiBhcmd1bWVudHNbaV0pIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJndW1lbnRzW2ldLCBrZXkpKSB7XG4gICAgICAgIG9ialtrZXldID0gYXJndW1lbnRzW2ldW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZXhwb3J0IGxldCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8vIFNvdXJjZWQgZnJvbSBsb2Rhc2hcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9sb2Rhc2gvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHRcbi8qIGVzbGludC1kaXNhYmxlIGZ1bmMtc3R5bGUgKi9cbmxldCBpc0Z1bmN0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn07XG4vLyBmYWxsYmFjayBmb3Igb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmlcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaXNGdW5jdGlvbigveC8pKSB7XG4gIGlzRnVuY3Rpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gIH07XG59XG5leHBvcnQge2lzRnVuY3Rpb259O1xuLyogZXNsaW50LWVuYWJsZSBmdW5jLXN0eWxlICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSA/IHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nIDogZmFsc2U7XG59O1xuXG4vLyBPbGRlciBJRSB2ZXJzaW9ucyBkbyBub3QgZGlyZWN0bHkgc3VwcG9ydCBpbmRleE9mIHNvIHdlIG11c3QgaW1wbGVtZW50IG91ciBvd24sIHNhZGx5LlxuZXhwb3J0IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUV4cHJlc3Npb24oc3RyaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGRvbid0IGVzY2FwZSBTYWZlU3RyaW5ncywgc2luY2UgdGhleSdyZSBhbHJlYWR5IHNhZmVcbiAgICBpZiAoc3RyaW5nICYmIHN0cmluZy50b0hUTUwpIHtcbiAgICAgIHJldHVybiBzdHJpbmcudG9IVE1MKCk7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZyArICcnO1xuICAgIH1cblxuICAgIC8vIEZvcmNlIGEgc3RyaW5nIGNvbnZlcnNpb24gYXMgdGhpcyB3aWxsIGJlIGRvbmUgYnkgdGhlIGFwcGVuZCByZWdhcmRsZXNzIGFuZFxuICAgIC8vIHRoZSByZWdleCB0ZXN0IHdpbGwgZG8gdGhpcyB0cmFuc3BhcmVudGx5IGJlaGluZCB0aGUgc2NlbmVzLCBjYXVzaW5nIGlzc3VlcyBpZlxuICAgIC8vIGFuIG9iamVjdCdzIHRvIHN0cmluZyBoYXMgZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGl0LlxuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nO1xuICB9XG5cbiAgaWYgKCFwb3NzaWJsZS50ZXN0KHN0cmluZykpIHsgcmV0dXJuIHN0cmluZzsgfVxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoYmFkQ2hhcnMsIGVzY2FwZUNoYXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcmFtZShvYmplY3QpIHtcbiAgbGV0IGZyYW1lID0gZXh0ZW5kKHt9LCBvYmplY3QpO1xuICBmcmFtZS5fcGFyZW50ID0gb2JqZWN0O1xuICByZXR1cm4gZnJhbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBibG9ja1BhcmFtcyhwYXJhbXMsIGlkcykge1xuICBwYXJhbXMucGF0aCA9IGlkcztcbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZENvbnRleHRQYXRoKGNvbnRleHRQYXRoLCBpZCkge1xuICByZXR1cm4gKGNvbnRleHRQYXRoID8gY29udGV4dFBhdGggKyAnLicgOiAnJykgKyBpZDtcbn1cbiIsIi8vIENyZWF0ZSBhIHNpbXBsZSBwYXRoIGFsaWFzIHRvIGFsbG93IGJyb3dzZXJpZnkgdG8gcmVzb2x2ZVxuLy8gdGhlIHJ1bnRpbWUgb24gYSBzdXBwb3J0ZWQgcGF0aC5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2Nqcy9oYW5kbGViYXJzLnJ1bnRpbWUnKVsnZGVmYXVsdCddO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaGFuZGxlYmFycy9ydW50aW1lXCIpW1wiZGVmYXVsdFwiXTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBNb2R1bGUgZm9yIGZ1bGwgbWFuYWdlbWVudCBvZiByZXF1ZXN0aW5nIEFKQVggZnJvbSBzZXJ2ZXIuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBBSkFYKCkge31cblxuQUpBWC5FUlJPUiA9IHtcbiAgICBOT1RfU1VQUE9SVDogJ+yCrOyaqe2VmOyLnOuKlCDruIzrnbzsmrDsoIDqsIAg7ISc67mE7IqkIOydtOyaqeyXkCDtlYTsmpTtlZwg7ZWE7IiYIOq4sOuKpeydhCDsp4Dsm5DtlZjsp4Ag7JWK7Iq164uI64ukLiDstZzsi6Ag67KE7KCE7J2YIOu4jOudvOyasOyggOulvCDsgqzsmqntlbQg7KO87IS47JqULidcbn07XG5cbi8qKioqKioqKioqXG4gKiBhamF4XG4gKioqKioqKioqKi9cblxuLyoqXG4gKiDruYTrj5nquLAg7JqU7LKt7J2EIOychO2VnCDqsJ3ssrTrpbwg66eM65Ok7Ja0IOuwmO2ZmO2VnOuLpFxuICogQHJldHVybiB7KFhNTEh0dHBSZXF1ZXN0fEFjdGl2ZVhPYmplY3QpfSDruYTrj5nquLAg7Ya17IugIOyngOybkCDqsJ3ssrRcbiAqL1xuQUpBWC5wcm90b3R5cGUuX2NyZWF0ZVhIUiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh1dGlsLmlzRXhpc3R5KHV0aWwucGljayh3aW5kb3csICdYTUxIdHRwUmVxdWVzdCcpKSkge1xuICAgICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzRXhpc3R5KHV0aWwucGljayh3aW5kb3csICdBY3RpdmVYT2JqZWN0JykpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgfVxuXG4gICAgd2luZG93LmFsZXJ0KEFKQVguRVJST1IuTk9UX1NVUFBPUlQpO1xufTtcblxuLyoqXG4gKiDtg4DsnoXsl5Ag65Sw6528IOuNsOydtO2EsOulvCDstpTqsIAg6rCA6rO17ZWc64ukXG4gKlxuICogVE9ETzog7ZiE7J6s64qUIEpTT07rjbDsnbTthLDrp4wg7LKY66as7KSR7J206rOgIO2VhOyalOyXkCDrlLDrnbwg64qY7Ja064KY7JW8IO2VnOuLpFxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFUeXBlIOuNsOydtO2EsCDtg4DsnoVcbiAqIEBwYXJhbSB7Kn0gZGF0YSDqsIDqs7XtlaAg642w7J207YSwXG4gKiBAcmV0dXJuIHsqfSDqsIDqs7XrkJwg642w7J207YSwXG4gKi9cbkFKQVgucHJvdG90eXBlLl9wcm9jZXNzUmF3RGF0YSA9IGZ1bmN0aW9uKGRhdGFUeXBlLCBkYXRhKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGE7XG4gICAgaWYgKGRhdGFUeXBlID09PSAnanNvbicpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGRhdGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBYSFLsnZgg7J2R64u1IOuNsOydtO2EsOulvCDsspjrpqztlZzri6RcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gYWpheOyYteyFmCDqsJ3ssrRcbiAqIEBwYXJhbSB7KFhNTEh0dHBSZXF1ZXN0fEFjdGl2ZVhPYmplY3QpfSB4aHIgLSDruYTrj5nquLAg7JqU7LKtIOqwneyytFxuICovXG5BSkFYLnByb3RvdHlwZS5fb25SZWFkeVN0YXRlQ2hhbmdlID0gZnVuY3Rpb24ob3B0aW9ucywgeGhyKSB7XG4gICAgdmFyIHN0YXR1cyxcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyO1xuXG4gICAgaWYgKHhoci5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB4aHIuc3RhdHVzO1xuXG4gICAgaWYgKChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCkgfHwgc3RhdHVzID09PSAzMDQpIHtcbiAgICAgICAgcmVzcG9uc2UgPSB0aGlzLl9wcm9jZXNzUmF3RGF0YShvcHRpb25zLmRhdGFUeXBlLCB4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgcmVzcG9uc2VIZWFkZXIgPSB1dGlsLnBpY2socmVzcG9uc2UsICdoZWFkZXInKTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlSGVhZGVyKSB7XG4gICAgICAgICAgICBvcHRpb25zLmVycm9yKCk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2VIZWFkZXIuaXNTdWNjZXNzZnVsKSB7XG4gICAgICAgICAgICBvcHRpb25zLnN1Y2Nlc3MocmVzcG9uc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucy5mYWlsKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RhdHVzICE9PSAwKSB7XG4gICAgICAgIG9wdGlvbnMuZXJyb3IoKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmNvbXBsZXRlKCk7XG59O1xuXG5cbi8qKlxuICogYWpheCDsmpTssq3snYQg7IiY7ZaJ7ZWc64ukLlxuICogXG4gKiDsmpTssq0g7YOA7J6F7JeQIOuUsOuluCDstpTqsIAg642w7J207YSwIOyymOumrOuKlCDrlLDroZwg7ZWY7KeAIOyViuycvOuvgOuhnCDsgqzsoITsl5Ag66+466asIOykgOu5hO2VtOyVvCDtlZzri6RcbiAqIOyYiOulvCDrk6TslrQsIGdldOyalOyyreydgCBRdWVyeVN0cmluZ+ycvOuhnCB1cmzsnYQg7ISk7KCV7ZW07JW8IO2VmOqzoCwgcG9zdOuTseydmCBkYXRh66W8IOyCrOyaqe2VmFxuICog64qUIOyalOyyreydgCDrr7jrpqwgc3RyaW5nZnnrkJwg6rCS7J2EIGRhdGHsmLXshZjsnLzroZwg7KCE64us7ZW07JW8IO2VnOuLpC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIGFqYXjsmpTssq0g7ZWgIHVybFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMg7Ji17IWYXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWV0aG9kPSdQT1NUJ10g7JqU7LKtIOyLnCDsgqzsmqntlaAgaHR0cCBtZXRob2RzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFzeW5jPXRydWVdIOu5hOuPmeq4sCDsmpTssq0g7IKs7JqpIOyXrOu2gFxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnR5cGU9J2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLTgnXSB0eXBlIO2XpOuNlCDqsJJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb250ZW50VHlwZT0nYXBwbGljYXRpb24vanNvbiddIENvbnRlbnQtVHlwZSDtl6TrjZQg6rCSXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGF0YVR5cGU9J2pzb24nXSDshJzrsoTsl5DshJwg7J2R64u167Cb6riwIOuwlOudvOuKlCDqsrDqs7zsnZgg7YOA7J6FXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0b2lucy5zdWNjZXNzXSAtIGlzU3VjY2Vzc2Z1bCB0cnVl7JeQIOuMgO2VnCDsvZzrsLFcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmZhaWxdIC0gaXNTdWNjZXNzZnVsIGZhbHNlIOyXkCDrjIDtlZwg7L2c67CxXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5lcnJvcl0g7JqU7LKt7JeQIOuMgO2VnCDsl5Drn6wg67Cc7IOdIOyLnCDsiJjtlontlaAg7L2c67CxXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5jb21wbGV0ZV0g7JqU7LKt7J20IOuBneuCrOydhCDrlYwgKOyEseqztSwg7Iuk7YyoIOyXrOu2gOyZgCDrrLTqtIApIOyImO2Wie2VmOuKlCDsvZzrsLFcbiAqIEBwYXJhbSB7Ym9sbGVhbn0gW29wdGlvbnMuY2FjaGU9dHJ1ZV0gLSBmYWxzZSDsnbwg6rK97JqwIHRpbWVzdGFtcCDtjIzrnbzrr7jthLDrpbwgdXJs7JeQIOu2meyXrCDsupDsi5zrpbwg66y07IucXG4gKi9cbkFKQVgucHJvdG90eXBlLmFqYXggPSBmdW5jdGlvbih1cmwsIG9wdGlvbnMpIHtcbiAgICB2YXIgeGhyLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzZXBhcmF0b3IsXG4gICAgICAgIGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLTgnLFxuICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgICAgZmFpbDogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBkYXRhID0gdXRpbC5waWNrKG9wdGlvbnMsICdkYXRhJyk7XG4gICAgaWYgKCFvcHRpb25zLmNhY2hlKSB7XG4gICAgICAgIHNlcGFyYXRvciA9IH51cmwuaW5kZXhPZignPycpID8gJyYnIDogJz8nO1xuICAgICAgICB1cmwgPSB1cmwgKyBzZXBhcmF0b3IgKyAnXz0nICsgKyhuZXcgRGF0ZSgpKTtcbiAgICB9XG5cbiAgICB4aHIgPSB0aGlzLl9jcmVhdGVYSFIoKTtcbiAgICB4aHIub3BlbihvcHRpb25zLm1ldGhvZCwgdXJsLCBvcHRpb25zLmFzeW5jKTtcbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcigndHlwZScsIG9wdGlvbnMudHlwZSk7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ2NvbnRlbnQtdHlwZScsIG9wdGlvbnMuY29udGVudFR5cGUpO1xuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB1dGlsLmJpbmQodGhpcy5fb25SZWFkeVN0YXRlQ2hhbmdlLCB0aGlzLCBvcHRpb25zLCB4aHIpO1xuICAgIHhoci5zZW5kKGRhdGEgPyBkYXRhIDogbnVsbCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFKQVg7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBVdGlsaXR5IG1vZHVsZSBmb3IgYXJyYXkgc29ydCwgYmluYXJ5IHNlYXJjaC5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi9jb21tb24vZGF0ZXRpbWUnKTtcblxuLyoqXG4gKiBBIG1vZHVsZSBmb3Igc29ydGluZyBhcnJheS5cbiAqIEBtb2R1bGUgYXJyYXlcbiAqL1xuXG4vKioqKioqKioqKlxuICogU2VhcmNoXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBzZWFyY2ggaXRlbSBpbmRleCB1c2luZyBiaW5hcnkgc2VhcmNoIGFsZ29yaXRobS5cbiAqXG4gKiB0aGUgYXJyYXkgbXVzdCBiZSBzb3J0ZWQuXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYXJyYXkgdG8gc2VhcmNoLlxuICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcnxib29sZWFuKX0gc2VhcmNoIHZhbHVlIHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtmbl0gaXRlcmF0ZWUgZm9yIHJldHJpZXZlIGVhY2ggZWxlbWVudCdzIHZhbHVlIHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjb21wYXJlXSBjb21wYXJlIGZ1bmN0aW9uIGZvciBzcGVjaWZpYyBzb3J0IHN0YXR1cy4gZGVmYXVsdCBpcyBzdHJpbmcgYXNjZW5kaW5nLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBpdGVtIGluZGV4IHNlYXJjaGVkLiByZXR1cm4gbmVnYXRpdmUgbnVtYmVyIHdoZW4gbm8gZXhpc3QgdGhhdCBpdGVtLlxuICogSXQgY2FuIHVzZSBpbnNlcnQgaW5kZXggYWZ0ZXIgTWF0aC5hYnMoKVxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyID0gWzEsIDMsIDcsIDExLCAxNSwgMjNdO1xuICpcbiAqIGZ1bmN0aW9uIHNvcnROdW1iZXIoYSwgYikge1xuICogICAgIHJldHVybiBhIC0gYjtcbiAqIH1cbiAqXG4gKiBic2VhcmNoKGFyciwgMTUsIG51bGwsIHNvcnROdW1iZXIpOyAgICAvLyA0XG4gKiBic2VhcmNoKGFyciwgMjEsIG51bGwsIHNvcnROdW1iZXIpOyAgICAvLyAtNVxuICpcbiAqIGFyci5zcGxpY2UoTWF0aC5hYnMoYnNlYXJjaChhcnIsIDIxLCBudWxsLCBzb3J0TnVtYmVyKSksIDAsIDIxKTtcbiAqIC8vIFsxLCAyLCA3LCAxMSwgMTUsIDIxLCAyM11cbiAqL1xuZnVuY3Rpb24gYnNlYXJjaChhcnIsIHNlYXJjaCwgZm4sIGNvbXBhcmUpIHtcbiAgICB2YXIgbWluSW5kZXggPSAwLFxuICAgICAgICBtYXhJbmRleCA9IGFyci5sZW5ndGggLSAxLFxuICAgICAgICBjdXJyZW50SW5kZXgsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBjb21wO1xuXG4gICAgY29tcGFyZSA9IGNvbXBhcmUgfHwgc3RyaW5nQVNDO1xuXG4gICAgd2hpbGUgKG1pbkluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCA9IChtaW5JbmRleCArIG1heEluZGV4KSAvIDIgfCAwOyAgICAvLyBNYXRoLmZsb29yXG4gICAgICAgIHZhbHVlID0gZm4gPyBmbihhcnJbY3VycmVudEluZGV4XSkgOiBhcnJbY3VycmVudEluZGV4XTtcbiAgICAgICAgY29tcCA9IGNvbXBhcmUodmFsdWUsIHNlYXJjaCk7XG5cbiAgICAgICAgaWYgKGNvbXAgPCAwKSB7XG4gICAgICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcCA+IDApIHtcbiAgICAgICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50SW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gfm1heEluZGV4O1xufVxuXG4vKioqKioqKioqKlxuICogQ29tcGFyZSBGdW5jdGlvbnNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIGNvbXBhcmUgZnVuY3Rpb24gZm9yIGFycmF5IHNvcnQuXG4gKlxuICogc29ydCBhcnJheSBieSBhc2NlbmRpbmcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGEgVGhlIGJvb2xlYW4gdG8gY29tcGFyZVxuICogQHBhcmFtIHtib29sZWFufSBiIFRoZSBib29sZWFuIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXN1bHQgb2YgY29tcGFyaXNvbi5cbiAqL1xuZnVuY3Rpb24gYm9vbGVhbkFTQyhhLCBiKSB7XG4gICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPyAtMSA6IDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuXG4vKipcbiAqIGNvbXBhcmUgZnVuY3Rpb24gZm9yIGFycmF5IHNvcnQuXG4gKlxuICogc29ydCBhcnJheSBieSBkZXNjZW5kaW5nLlxuICogQHBhcmFtIHtib29sZWFufSBhIFRoZSBib29sZWFuIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYiBUaGUgYm9vbGVhbiB0byBjb21wYXJlLlxuICogQHJldHVybnMge251bWJlcn0gUmVzdWx0IG9mIGNvbXBhcmlzb24uXG4gKi9cbmZ1bmN0aW9uIGJvb2xlYW5ERVNDKGEsIGIpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICByZXR1cm4gYSA/IDEgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogY29tcGFyZSBmdW5jdGlvbiBmb3IgYXJyYXkgc29ydC5cbiAqXG4gKiBzb3J0IGFycmF5IGJ5IG51bWJlciBhc2NlbmRpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0gX2EgVGhlIG51bWJlciB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IF9iIFRoZSBudW1iZXIgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJlc3VsdCBvZiBjb21wYXJpc29uLlxuICovXG5mdW5jdGlvbiBudW1iZXJBU0MoX2EsIF9iKSB7XG4gICAgdmFyIGEgPSArX2EsXG4gICAgICAgIGIgPSArX2I7XG5cbiAgICByZXR1cm4gYSAtIGI7XG59XG5cbi8qKlxuICogY29tcGFyZSBmdW5jdGlvbiBmb3IgYXJyYXkgc29ydC5cbiAqXG4gKiBzb3J0IGFycmF5IGJ5IG51bWJlciBkZXNjZW5kaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IF9hIFRoZSBudW1iZXIgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBfYiBUaGUgbnVtYmVyIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXN1bHQgb2YgY29tcGFyaXNvbi5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyREVTQyhfYSwgX2IpIHtcbiAgICB2YXIgYSA9ICtfYSxcbiAgICAgICAgYiA9ICtfYjtcblxuICAgIHJldHVybiBiIC0gYTtcbn1cblxuLyoqXG4gKiBjb21wYXJlIGZ1bmN0aW9uIGZvciBhcnJheSBzb3J0LlxuICpcbiAqIHNvcnQgYXJyYXkgYnkgc3RyaW5nIGFzY2VuZGluZ1xuICogQHBhcmFtIHtzdHJpbmd9IF9hIFRoZSBzdHJpbmcgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBfYiBUaGUgc3RyaW5nIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXN1bHQgb2YgY29tcGFyaXNvbi5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nQVNDKF9hLCBfYikge1xuICAgIHZhciBhID0gX2EgKyAnJyxcbiAgICAgICAgYiA9IF9iICsgJyc7XG5cbiAgICBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChhIDwgYikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogY29tcGFyZSBmdW5jdGlvbiBmb3IgYXJyYXkgc29ydC5cbiAqXG4gKiBzb3J0IGFycmF5IGJ5IHN0cmluZyBkZXNjZW5kaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gX2EgVGhlIHN0cmluZyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IF9iIFRoZSBzdHJpbmcgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJlc3VsdCBvZiBjb21wYXJpc29uLlxuICovXG5mdW5jdGlvbiBzdHJpbmdERVNDKF9hLCBfYikge1xuICAgIHZhciBhID0gX2EgKyAnJyxcbiAgICAgICAgYiA9IF9iICsgJyc7XG5cbiAgICBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogY29tcGFyZSBmdW5jdGlvbiBmb3IgYXJyYXkgc29ydC5cbiAqXG4gKiBzb3J0IGFycmF5IGJ5IHN0cmluZyBhc2NlbmRpbmcgd2l0aCBpZ25vcmUgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBfYSBUaGUgc3RyaW5nIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gX2IgVGhlIHN0cmluZyB0byBjb21wYXJlLlxuICogQHJldHVybnMge251bWJlcn0gUmVzdWx0IG9mIGNvbXBhcmlzb24uXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ0FTQ0lnbm9yZUNhc2UoX2EsIF9iKSB7XG4gICAgdmFyIGEgPSAoX2EgKyAnJykudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgYiA9IChfYiArICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xufVxuXG4vKipcbiAqIGNvbXBhcmUgZnVuY3Rpb24gZm9yIGFycmF5IHNvcnQuXG4gKlxuICogc29ydCBhcnJheSBieSBzdHJpbmcgZGVzY2VuZGluZyB3aXRoIGlnbm9yZSBjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IF9hIFRoZSBzdHJpbmcgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBfYiBUaGUgc3RyaW5nIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXN1bHQgb2YgY29tcGFyaXNvbi5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nREVTQ0lnbm9yZUNhc2UoX2EsIF9iKSB7XG4gICAgdmFyIGEgPSAoX2EgKyAnJykudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgYiA9IChfYiArICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xufVxuXG4vKipcbiAqIENvbXBhcmUgZXZlbnQgbW9kZWxzIGZvciBzb3J0LlxuICpcbiAqIDEuIGFsbCBkYXkgZXZlbnQgZmlyc3QuXG4gKiAyLiBlYXJseSBzdGFydHMuXG4gKiAzLiBsb25nZXN0IGR1cmF0aW9uLlxuICogNC4gZWFybHkgY3JlYXRlZC5cbiAqIEBwYXJhbSB7KEV2ZW50fEV2ZW50Vmlld01vZGVsKX0gYSBUaGUgb2JqZWN0IGV2ZW50IGluc3RhbmNlLlxuICogQHBhcmFtIHsoRXZlbnR8RXZlbnRWaWV3TW9kZWwpfSBiIFRoZSBvYmplY3QgZXZlbnQgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXN1bHQgb2YgY29tcGFyaXNvbi5cbiAqL1xuZnVuY3Rpb24gZXZlbnRBU0MoYSwgYikge1xuICAgIHZhciBkdXJhdGlvbkEsXG4gICAgICAgIGR1cmF0aW9uQixcbiAgICAgICAgYWxsRGF5Q29tcGFyZSxcbiAgICAgICAgc3RhcnRzQ29tcGFyZTtcblxuICAgIGEgPSBhLnZhbHVlT2YoKTtcbiAgICBiID0gYi52YWx1ZU9mKCk7XG5cbiAgICBhbGxEYXlDb21wYXJlID0gYm9vbGVhbkFTQyhhLmlzQWxsRGF5LCBiLmlzQWxsRGF5KTtcblxuICAgIGlmIChhbGxEYXlDb21wYXJlKSB7XG4gICAgICAgIHJldHVybiBhbGxEYXlDb21wYXJlO1xuICAgIH1cblxuICAgIHN0YXJ0c0NvbXBhcmUgPSBkYXRldGltZS5jb21wYXJlKGEuZ2V0U3RhcnRzKCksIGIuZ2V0U3RhcnRzKCkpO1xuXG4gICAgaWYgKHN0YXJ0c0NvbXBhcmUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0c0NvbXBhcmU7XG4gICAgfVxuXG4gICAgZHVyYXRpb25BID0gYS5kdXJhdGlvbigpLmdldFRpbWUoKTtcbiAgICBkdXJhdGlvbkIgPSBiLmR1cmF0aW9uKCkuZ2V0VGltZSgpO1xuXG4gICAgaWYgKGR1cmF0aW9uQSA8IGR1cmF0aW9uQikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGR1cmF0aW9uQSA+IGR1cmF0aW9uQikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWwuc3RhbXAoYSkgLSB1dGlsLnN0YW1wKGIpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGJzZWFyY2g6IGJzZWFyY2gsXG4gICAgY29tcGFyZToge1xuICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgYXNjOiBldmVudEFTQ1xuICAgICAgICB9LFxuICAgICAgICBib29sOiB7XG4gICAgICAgICAgICBhc2M6IGJvb2xlYW5BU0MsXG4gICAgICAgICAgICBkZXNjOiBib29sZWFuREVTQ1xuICAgICAgICB9LFxuICAgICAgICBudW06IHtcbiAgICAgICAgICAgIGFzYzogbnVtYmVyQVNDLFxuICAgICAgICAgICAgZGVzYzogbnVtYmVyREVTQ1xuICAgICAgICB9LFxuICAgICAgICBzdHI6IHtcbiAgICAgICAgICAgIGFzYzogc3RyaW5nQVNDLFxuICAgICAgICAgICAgZGVzYzogc3RyaW5nREVTQyxcbiAgICAgICAgICAgIGFzY0lnbm9yZUNhc2U6IHN0cmluZ0FTQ0lnbm9yZUNhc2UsXG4gICAgICAgICAgICBkZXNjSWdub3JlQ2FzZTogc3RyaW5nREVTQ0lnbm9yZUNhc2VcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBBZGQgYXV0b3Njcm9sbCBmZWF0dXJlIHRvIGVsZW1lbnRzIHRoYXQgcHJldmVudGVkIHRleHQgc2VsZWN0aW9uLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBkb21ldmVudCA9IHJlcXVpcmUoJy4uL2NvbW1vbi9kb21ldmVudCcpO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vY29tbW9uL3BvaW50Jyk7XG5cbnZhciBTQ1JPTExfSU5URVJWQUwgPSAzMDtcbnZhciBTQ1JPTExfTUFYID0gMTU7XG52YXIgU0NST0xMX0NMSUNLX0lOQ1JFQVNFRCA9IDI7ICAgIC8vIElF7JeQ7IScIOyKpO2BrOuhpCDrsJQg7YG066atIOyLnCDsi6TsoJwgVUkgcGl4ZWwg67O064ukIOuEk+qyjCDsnqHtnojripQg7ZiE7IOBIG9mZnNldC5cblxuLyoqXG4gKiBBZGQgYXV0b3Njcm9sbCBmZWF0dXJlIHRvIGVsZW1lbnRzIHRoYXQgcHJldmVudGVkIHRleHQgc2VsZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgLSBIVE1MRWxlbWVudCB0byBhZGQgYXV0b3Njcm9sbCBmZWF0dXJlcy5cbiAqL1xuZnVuY3Rpb24gQXV0b1Njcm9sbChjb250YWluZXIpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXV0b1Njcm9sbC5ESVJFQ1RJT059XG4gICAgICovXG4gICAgdGhpcy5fZGlyZWN0aW9uID0gQXV0b1Njcm9sbC5ESVJFQ1RJT04uSU5TSURFO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9vZmZzZXQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogaW50ZXJ2YWwgdG8gc2Nyb2xsaW5nXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9pbnRlcnZhbElEID0gMDtcblxuICAgIGRvbWV2ZW50Lm9uKGNvbnRhaW5lciwge1xuICAgICAgICAnbW91c2Vkb3duJzogdGhpcy5fb25Nb3VzZURvd25cbiAgICB9LCB0aGlzKTtcbn1cblxuLyoqXG4gKiBAZW51bVxuICovXG5BdXRvU2Nyb2xsLkRJUkVDVElPTiA9IHtcbiAgICBJTlNJREU6IDAsXG4gICAgVE9QOiAxLFxuICAgIFJJR0hUOiAyLFxuICAgIEJPVFRPTTogMyxcbiAgICBMRUZUOiA0XG59O1xuXG4vKipcbiAqIEluc3RhbmNlIGRlc3Ryb3kgbWV0aG9kLlxuICovXG5BdXRvU2Nyb2xsLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgZG9tZXZlbnQub2ZmKHRoaXMuY29udGFpbmVyLCB7XG4gICAgICAgICdtb3VzZWRvd24nOiB0aGlzLl9vbk1vdXNlRG93bixcbiAgICAgICAgJ21vdXNlbW92ZSc6IHRoaXMuX29uTW91c2VNb3ZlLFxuICAgICAgICAnbW91c2V1cCc6IHRoaXMuX29uTW91c2VVcFxuICAgIH0sIHRoaXMpO1xuXG4gICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJRCk7XG4gICAgdGhpcy5faW50ZXJ2YWxJRCA9IHRoaXMuX2RpcmVjdGlvbiA9IHRoaXMuY29udGFpbmVyID0gbnVsbDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIENsaWVudFJlY3QgYW5kIGNhbGN1bGF0ZSBlYWNoIHBvc2l0aW9uIG9mIGVkZ2VzLlxuICogQHBhcmFtIHtDbGllbnRSZWN0fSBjbGllbnRSZWN0IC0gQ2xpZW50UmVjdCBvYmplY3Qgb2YgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtvYmplY3R9IGVkZ2VzLlxuICovXG5BdXRvU2Nyb2xsLnByb3RvdHlwZS5fZ2V0RWRnZVBvc2l0aW9ucyA9IGZ1bmN0aW9uKGNsaWVudFJlY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IGNsaWVudFJlY3QudG9wLFxuICAgICAgICByaWdodDogY2xpZW50UmVjdC5sZWZ0ICsgY2xpZW50UmVjdC53aWR0aCxcbiAgICAgICAgYm90dG9tOiBjbGllbnRSZWN0LmJvdHRvbSxcbiAgICAgICAgbGVmdDogY2xpZW50UmVjdC5sZWZ0XG4gICAgfTtcbn07XG5cbi8qKlxuICogR2V0IGVsZW1lbnQgcmVhbCBzaXplIChcInJlYWwgc2l6ZVwiIC0+IHNpemUgd2l0aG91dCBzY3JvbGxiYXIpXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIGVsZW1lbnQgd2FudCB0byBrbm93IHJlYWwgc2l6ZSAoXCJyZWFsIHNpemVcIiAtPiBzaXplIHdpdGhvdXQgc2Nyb2xsYmFyKVxuICogQHJldHVybnMge251bWJlcltdfSByZWFsIHNpemUgW3dpZHRoLCBoZWlnaHRdXG4gKi9cbkF1dG9TY3JvbGwucHJvdG90eXBlLmdldFJlYWxTaXplID0gZnVuY3Rpb24oZWwpIHtcbiAgICB2YXIgY29tcHV0ZWQgPSBkb211dGlsLmdldENvbXB1dGVkU3R5bGUoZWwpLFxuICAgICAgICBib3JkZXIsXG4gICAgICAgIHBhZGRpbmc7XG5cbiAgICBib3JkZXIgPSBwYXJzZUZsb2F0KGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci10b3Atd2lkdGgnKSkgK1xuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci1ib3R0b20td2lkdGgnKSk7XG4gICAgcGFkZGluZyA9IHBhcnNlRmxvYXQoY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy10b3AnKSkgK1xuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctYm90dG9tJykpO1xuXG4gICAgcmV0dXJuIFtlbC5jbGllbnRXaWR0aCArIGJvcmRlciArIHBhZGRpbmcsIGVsLmNsaWVudEhlaWdodCArIGJvcmRlciArIHBhZGRpbmddO1xufTtcblxuLyoqXG4gKiBDaGVjayBzdXBwbGllZCBlbGVtZW50IGhhcyBzY3JvbGxiYXIuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIGVsZW1lbnQgd2FudCB0byBrbm93IGhhcyBzY3JvbGxiYXIuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbltdfSBoYXMgc2Nyb2xsYmFyPyBbaG9yaXpvbnRhbCwgdmVydGljYWxdXG4gKi9cbkF1dG9TY3JvbGwucHJvdG90eXBlLmhhc1Njcm9sbGJhciA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgdmFyIHJlYWxTaXplID0gdGhpcy5nZXRSZWFsU2l6ZShlbCk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgICBlbC5vZmZzZXRXaWR0aCA+IE1hdGguY2VpbChyZWFsU2l6ZVswXSksXG4gICAgICAgIGVsLm9mZnNldEhlaWdodCA+IE1hdGguY2VpbChyZWFsU2l6ZVsxXSlcbiAgICBdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIGVsZW1lbnQgd2FudCB0byBrbm93LlxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50IC0gbW91c2UgZXZlbnQgb2JqZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IG1vdXNlIHBvaW50ZXIgaXMgb24gdGhlIHNjcm9sbGJhcj9cbiAqL1xuQXV0b1Njcm9sbC5wcm90b3R5cGUuaXNPblNjcm9sbGJhciA9IGZ1bmN0aW9uKGVsLCBtb3VzZUV2ZW50KSB7XG4gICAgdmFyIHJlYWxTaXplID0gdGhpcy5nZXRSZWFsU2l6ZShlbCksXG4gICAgICAgIHBvcyA9IGRvbWV2ZW50LmdldE1vdXNlUG9zaXRpb24obW91c2VFdmVudCwgZWwpLFxuICAgICAgICBtb3VzZUluU2Nyb2xsYmFyID0gZmFsc2U7XG5cbiAgICBtb3VzZUluU2Nyb2xsYmFyID0gKHJlYWxTaXplWzBdIC0gU0NST0xMX0NMSUNLX0lOQ1JFQVNFRCA8IHBvc1swXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhbFNpemVbMV0gLSBTQ1JPTExfQ0xJQ0tfSU5DUkVBU0VEIDwgcG9zWzFdKTtcblxuICAgIHJldHVybiBtb3VzZUluU2Nyb2xsYmFyO1xufTtcblxuLyoqXG4gKiBNb3VzZURvd24gZXZlbnQgaGFuZGxlclxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZURvd25FdmVudCAtIG1vdXNlIGRvd24gZXZlbnRcbiAqL1xuQXV0b1Njcm9sbC5wcm90b3R5cGUuX29uTW91c2VEb3duID0gZnVuY3Rpb24obW91c2VEb3duRXZlbnQpIHtcbiAgICAvLyBvbmx5IHByaW1hcnkgYnV0dG9uIGNhbiBzdGFydCBkcmFnLlxuICAgIGlmIChkb21ldmVudC5nZXRNb3VzZUJ1dHRvbihtb3VzZURvd25FdmVudCkgIT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGRlYWN0aXZhdGUgYXV0b3Njcm9sbCBmZWF0dXJlIHdoZW4gbW91c2UgaXMgb24gdGhlIHNjcm9sbGJhci4gKElFKVxuICAgIGlmICh1dGlsLmJyb3dzZXIubXNpZSAmJiB0aGlzLmlzT25TY3JvbGxiYXIodGhpcy5jb250YWluZXIsIG1vdXNlRG93bkV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJRCk7XG4gICAgdGhpcy5faW50ZXJ2YWxJRCA9IHdpbmRvdy5zZXRJbnRlcnZhbCh1dGlsLmJpbmQodGhpcy5fb25UaWNrLCB0aGlzKSwgU0NST0xMX0lOVEVSVkFMKTtcblxuICAgIGRvbWV2ZW50Lm9uKGdsb2JhbCwge1xuICAgICAgICAnbW91c2Vtb3ZlJzogdGhpcy5fb25Nb3VzZU1vdmUsXG4gICAgICAgICdtb3VzZXVwJzogdGhpcy5fb25Nb3VzZVVwXG4gICAgfSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIE1vdXNlTW92ZSBldmVudCBoYW5kbGVyXG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IG1vdXNlRXZlbnQgLSBtb3VzZSBtb3ZlIGV2ZW50IG9iamVjdC5cbiAqL1xuQXV0b1Njcm9sbC5wcm90b3R5cGUuX29uTW91c2VNb3ZlID0gZnVuY3Rpb24obW91c2VFdmVudCkge1xuICAgIHZhciBlZGdlID0gdGhpcy5fZ2V0RWRnZVBvc2l0aW9ucyh0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksXG4gICAgICAgIHBvcyA9IFBvaW50Lm4oZG9tZXZlbnQuZ2V0TW91c2VQb3NpdGlvbihtb3VzZUV2ZW50KSk7XG5cbiAgICBpZiAocG9zLnkgPj0gZWRnZS50b3AgJiYgcG9zLnkgPD0gZWRnZS5ib3R0b20gJiZcbiAgICAgICAgcG9zLnggPj0gZWRnZS5sZWZ0ICYmIHBvcy54IDw9IGVkZ2UucmlnaHQpIHtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gQXV0b1Njcm9sbC5ESVJFQ1RJT04uSU5TSURFO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBvcy55IDwgZWRnZS50b3ApIHtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gQXV0b1Njcm9sbC5ESVJFQ1RJT04uVE9QO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBlZGdlLnRvcCAtIHBvcy55O1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBvcy55ID4gZWRnZS5ib3R0b20pIHtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gQXV0b1Njcm9sbC5ESVJFQ1RJT04uQk9UVE9NO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBwb3MueSAtIGVkZ2UuYm90dG9tO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBvcy54IDwgZWRnZS5sZWZ0KSB7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IEF1dG9TY3JvbGwuRElSRUNUSU9OLkxFRlQ7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IGVkZ2UubGVmdCAtIHBvcy54O1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZGlyZWN0aW9uID0gQXV0b1Njcm9sbC5ESVJFQ1RJT04uUklHSFQ7XG4gICAgdGhpcy5fb2Zmc2V0ID0gcG9zLnggLSBlZGdlLnJpZ2h0O1xuICAgIHJldHVybjtcbn07XG5cbi8qKlxuICogTW91c2VVcCBldmVudCBoYW5kbGVyLlxuICovXG5BdXRvU2Nyb2xsLnByb3RvdHlwZS5fb25Nb3VzZVVwID0gZnVuY3Rpb24oKSB7XG4gICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJRCk7XG4gICAgdGhpcy5faW50ZXJ2YWxJRCA9IDA7XG4gICAgdGhpcy5fZGlyZWN0aW9uID0gQXV0b1Njcm9sbC5ESVJFQ1RJT04uSU5TSURFO1xuICAgIHRoaXMuX29mZnNldCA9IDA7XG5cbiAgICBkb21ldmVudC5vZmYoZ2xvYmFsLCB7XG4gICAgICAgICdtb3VzZW1vdmUnOiB0aGlzLl9vbk1vdXNlTW92ZSxcbiAgICAgICAgJ21vdXNldXAnOiB0aGlzLl9vbk1vdXNlVXBcbiAgICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogSW50ZXJ2YWwgdGljayBldmVudCBoYW5kbGVyXG4gKi9cbkF1dG9TY3JvbGwucHJvdG90eXBlLl9vblRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZGlyZWN0aW9uLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGZhY3RvcjtcblxuICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICBmYWN0b3IgPSBNYXRoLm1pbih0aGlzLl9vZmZzZXQsIFNDUk9MTF9NQVgpO1xuXG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSBBdXRvU2Nyb2xsLkRJUkVDVElPTi5UT1A6XG4gICAgICAgICAgICBjb250YWluZXIuc2Nyb2xsVG9wIC09IGZhY3RvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEF1dG9TY3JvbGwuRElSRUNUSU9OLlJJR0hUOlxuICAgICAgICAgICAgY29udGFpbmVyLnNjcm9sbExlZnQgKz0gZmFjdG9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQXV0b1Njcm9sbC5ESVJFQ1RJT04uQk9UVE9NOlxuICAgICAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCArPSBmYWN0b3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnRhaW5lci5zY3JvbGxMZWZ0IC09IGZhY3RvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0b1Njcm9sbDtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbW1vbiBjb2xsZWN0aW9ucy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWwsXG4gICAgZm9yRWFjaFByb3AgPSB1dGlsLmZvckVhY2hPd25Qcm9wZXJ0aWVzLFxuICAgIGZvckVhY2hBcnIgPSB1dGlsLmZvckVhY2hBcnJheSxcbiAgICBpc0Z1bmMgPSB1dGlsLmlzRnVuY3Rpb24sXG4gICAgaXNPYmogPSB1dGlsLmlzT2JqZWN0O1xuXG52YXIgYXBzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vKipcbiAqIENvbW1vbiBjb2xsZWN0aW9uLlxuICpcbiAqIEl0IG5lZWQgZnVuY3Rpb24gZm9yIGdldCBtb2RlbCdzIHVuaXF1ZSBpZC5cbiAqXG4gKiBpZiB0aGUgZnVuY3Rpb24gaXMgbm90IHN1cHBsaWVkIHRoZW4gaXQgdXNlIGRlZmF1bHQgZnVuY3Rpb24ge0BsaW5rIENvbGxlY3Rpb24jZ2V0SXRlbUlEfVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZ2V0SXRlbUlERm5dIGZ1bmN0aW9uIGZvciBnZXQgbW9kZWwncyBpZC5cbiAqL1xuZnVuY3Rpb24gQ29sbGVjdGlvbihnZXRJdGVtSURGbikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtvYmplY3QuPHN0cmluZywgKj59XG4gICAgICovXG4gICAgdGhpcy5pdGVtcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICBpZiAoaXNGdW5jKGdldEl0ZW1JREZuKSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRJdGVtSUQgPSBnZXRJdGVtSURGbjtcbiAgICB9XG59XG5cbi8qKioqKioqKioqXG4gKiBzdGF0aWMgcHJvcHNcbiAqKioqKioqKioqL1xuXG5Db2xsZWN0aW9uLmZpbHRlciA9IHtcbiAgICAvKipcbiAgICAgKiByZXR1cm4gQU5EIG9wZXJhdGUgYWxsIG9mIGZ1bmN0aW9uJ3MgcmV0dXJuIHZhbHVlXG4gICAgICogQHBhcmFtIHthcnJheX0gYXJyIGZpbHRlcnNcbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJhbXNdIHN1cHBvcnQgZmlsdGVyIHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBBTkQgb3BlcmF0ZWQgdmFsdWVcbiAgICAgKi9cbiAgICBhbmQ6IGZ1bmN0aW9uKGFyciwgcGFyYW1zKSB7ICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgdmFyIGFyZ3MgPSBhcHMuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBjbnQgPSBhcnIubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgY250OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICghYXJyW2ldLmFwcGx5KG51bGwsIGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBPUiBvcGVyYXRlIGFsbCBvZiBmdW5jdGlvbidzIHJldHVybiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGFyciBmaWx0ZXJzXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFyYW1zXSBzdXBwb3J0IGZpbHRlciBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gT1Igb3BlcmF0ZWQgdmFsdWVcbiAgICAgKi9cbiAgICBvcjogZnVuY3Rpb24oYXJyLCBwYXJhbXMpIHsgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICB2YXIgYXJncyA9IGFwcy5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICB0bXAsXG4gICAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgICAgZm9yRWFjaEFycihhcnIsIGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICAgICAgdG1wID0gZmlsdGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IHx8IHRtcCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBNZXJnZSBzZXZlcmFsIGNvbGxlY3Rpb25zLlxuICpcbiAqIFlvdSBjYW5cXCd0IG1lcmdlIGNvbGxlY3Rpb25zIGRpZmZlcmVudCBfZ2V0RXZlbnRJRCBmdW5jdGlvbnMuIFRha2UgY2FzZSBvZiB1c2UuXG4gKiBAcGFyYW0gey4uLkNvbGxlY3Rpb259IGNvbGxlY3Rpb25zIGNvbGxlY3Rpb24gYXJndW1lbnRzIHRvIG1lcmdlXG4gKiBAcmV0dXJucyB7Q29sbGVjdGlvbn0gbWVyZ2VkIGNvbGxlY3Rpb24uXG4gKi9cbkNvbGxlY3Rpb24ubWVyZ2UgPSBmdW5jdGlvbihjb2xsZWN0aW9ucykgeyAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIGNvbHMgPSBhcHMuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICBuZXdJdGVtcyA9IHt9LFxuICAgICAgICBtZXJnZWQgPSBuZXcgQ29sbGVjdGlvbihjb2xzWzBdLmdldEl0ZW1JRCksXG4gICAgICAgIGV4dGVuZCA9IHV0aWwuZXh0ZW5kO1xuXG4gICAgZm9yRWFjaEFycihjb2xzLCBmdW5jdGlvbihjb2wpIHtcbiAgICAgICAgZXh0ZW5kKG5ld0l0ZW1zLCBjb2wuaXRlbXMpO1xuICAgIH0pO1xuXG4gICAgbWVyZ2VkLml0ZW1zID0gbmV3SXRlbXM7XG4gICAgbWVyZ2VkLmxlbmd0aCA9IHV0aWwua2V5cyhtZXJnZWQuaXRlbXMpLmxlbmd0aDtcblxuICAgIHJldHVybiBtZXJnZWQ7XG59O1xuXG4vKioqKioqKioqKlxuICogcHJvdG90eXBlIHByb3BzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBnZXQgbW9kZWwncyB1bmlxdWUgaWQuXG4gKiBAcGFyYW0ge29iamVjdH0gaXRlbSBtb2RlbCBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1vZGVsIHVuaXF1ZSBpZC5cbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0SXRlbUlEID0gZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBpdGVtLl9pZCArICcnO1xufTtcblxuLyoqXG4gKiBhZGQgbW9kZWxzLlxuICogQHBhcmFtIHsuLi4qfSBpdGVtIG1vZGVscyB0byBhZGQgdGhpcyBjb2xsZWN0aW9uLlxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgdmFyIGlkLFxuICAgICAgICBvd25JdGVtcztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3JFYWNoQXJyKGFwcy5jYWxsKGFyZ3VtZW50cyksIGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKG8pO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWQgPSB0aGlzLmdldEl0ZW1JRChpdGVtKTtcbiAgICBvd25JdGVtcyA9IHRoaXMuaXRlbXM7XG5cbiAgICBpZiAoIW93bkl0ZW1zW2lkXSkge1xuICAgICAgICB0aGlzLmxlbmd0aCArPSAxO1xuICAgIH1cbiAgICBvd25JdGVtc1tpZF0gPSBpdGVtO1xufTtcblxuLyoqXG4gKiByZW1vdmUgbW9kZWxzLlxuICogQHBhcmFtIHsuLi4ob2JqZWN0fHN0cmluZ3xudW1iZXIpfSBpZCBtb2RlbCBpbnN0YW5jZSBvciB1bmlxdWUgaWQgdG8gZGVsZXRlLlxuICogQHJldHVybnMge2FycmF5fSBkZWxldGVkIG1vZGVsIGxpc3QuXG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIHJlbW92ZWQgPSBbXSxcbiAgICAgICAgb3duSXRlbXMsXG4gICAgICAgIGl0ZW1Ub1JlbW92ZTtcblxuICAgIGlmICghdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJlbW92ZWQgPSB1dGlsLm1hcChhcHMuY2FsbChhcmd1bWVudHMpLCBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKGlkKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgb3duSXRlbXMgPSB0aGlzLml0ZW1zO1xuXG4gICAgaWYgKGlzT2JqKGlkKSkge1xuICAgICAgICBpZCA9IHRoaXMuZ2V0SXRlbUlEKGlkKTtcbiAgICB9XG5cbiAgICBpZiAoIW93bkl0ZW1zW2lkXSkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCAtPSAxO1xuICAgIGl0ZW1Ub1JlbW92ZSA9IG93bkl0ZW1zW2lkXTtcbiAgICBkZWxldGUgb3duSXRlbXNbaWRdO1xuXG4gICAgcmV0dXJuIGl0ZW1Ub1JlbW92ZTtcbn07XG5cbi8qKlxuICogcmVtb3ZlIGFsbCBtb2RlbHMgaW4gY29sbGVjdGlvbi5cbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLml0ZW1zID0ge307XG4gICAgdGhpcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBjaGVjayBjb2xsZWN0aW9uIGhhcyBzcGVjaWZpYyBtb2RlbC5cbiAqIEBwYXJhbSB7KG9iamVjdHxzdHJpbmd8bnVtYmVyfGZ1bmN0aW9uKX0gaWQgbW9kZWwgaW5zdGFuY2Ugb3IgaWQgb3IgZmlsdGVyIGZ1bmN0aW9uIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaXMgaGFzIG1vZGVsP1xuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihpZCkge1xuICAgIHZhciBpc0ZpbHRlcixcbiAgICAgICAgaGFzO1xuXG4gICAgaWYgKCF0aGlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaXNGaWx0ZXIgPSBpc0Z1bmMoaWQpO1xuICAgIGhhcyA9IGZhbHNlO1xuXG4gICAgaWYgKGlzRmlsdGVyKSB7XG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaWQoaXRlbSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBoYXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWQgPSBpc09iaihpZCkgPyB0aGlzLmdldEl0ZW1JRChpZCkgOiBpZDtcbiAgICAgICAgaGFzID0gdXRpbC5pc0V4aXN0eSh0aGlzLml0ZW1zW2lkXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhcztcbn07XG5cbi8qKlxuICogaW52b2tlIGNhbGxiYWNrIHdoZW4gbW9kZWwgZXhpc3QgaW4gY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXIpfSBpZCBtb2RlbCB1bmlxdWUgaWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiB0aGUgY2FsbGJhY2suXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XSBjYWxsYmFjayBjb250ZXh0LlxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5kb1doZW5IYXMgPSBmdW5jdGlvbihpZCwgZm4sIGNvbnRleHQpIHtcbiAgICB2YXIgaXRlbSA9IHRoaXMuaXRlbXNbaWRdO1xuXG4gICAgaWYgKCF1dGlsLmlzRXhpc3R5KGl0ZW0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmbi5jYWxsKGNvbnRleHQgfHwgdGhpcywgaXRlbSk7XG59O1xuXG4vKipcbiAqIFNlYXJjaCBtb2RlbC4gYW5kIHJldHVybiBuZXcgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZpbHRlciBmaWx0ZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7Q29sbGVjdGlvbn0gbmV3IGNvbGxlY3Rpb24gd2l0aCBmaWx0ZXJlZCBtb2RlbHMuXG4gKiBAZXhhbXBsZVxuICogY29sbGVjdGlvbi5maW5kKGZ1bmN0aW9uKGl0ZW0pIHtcbiAqICAgICByZXR1cm4gaXRlbS5lZGl0ZWQgPT09IHRydWU7XG4gKiB9KTtcbiAqXG4gKiBmdW5jdGlvbiBmaWx0ZXIxKGl0ZW0pIHtcbiAqICAgICByZXR1cm4gaXRlbS5lZGl0ZWQgPT09IGZhbHNlO1xuICogfVxuICpcbiAqIGZ1bmN0aW9uIGZpbHRlcjIoaXRlbSkge1xuICogICAgIHJldHVybiBpdGVtLmRpc2FibGVkID09PSBmYWxzZTtcbiAqIH1cbiAqXG4gKiBjb2xsZWN0aW9uLmZpbmQoZnVuY3Rpb24oaXRlbSkge1xuICogICAgIHJldHVybiBDb2xsZWN0aW9uLmZpbHRlci5hbmQoW2ZpbHRlcjEsIGZpbHRlcjJdLCBpdGVtKTtcbiAqIH0pO1xuICpcbiAqIGNvbGxlY3Rpb24uZmluZChmdW5jdGlvbihpdGVtKSB7XG4gKiAgICAgcmV0dXJuIENvbGxlY3Rpb24uZmlsdGVyLm9yKFtmaWx0ZXIxLCBmaWx0ZXIyXSwgaXRlbSk7XG4gKiB9KTtcbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciByZXN1bHQgPSBuZXcgQ29sbGVjdGlvbigpO1xuXG4gICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoJ2dldEl0ZW1JRCcpKSB7XG4gICAgICAgIHJlc3VsdC5nZXRJdGVtSUQgPSB0aGlzLmdldEl0ZW1JRDtcbiAgICB9XG5cbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpZiAoZmlsdGVyKGl0ZW0pID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBHcm91cCBlbGVtZW50IGJ5IHNwZWNpZmljIGtleSB2YWx1ZXMuXG4gKlxuICogaWYga2V5IHBhcmFtZXRlciBpcyBmdW5jdGlvbiB0aGVuIGludm9rZSBpdCBhbmQgdXNlIHJldHVybmVkIHZhbHVlLlxuICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcnxmdW5jdGlvbnxhcnJheSl9IGtleSBrZXkgcHJvcGVydHkgb3IgZ2V0dGVyIGZ1bmN0aW9uLiBpZiBzdHJpbmdbXSBzdXBwbGllZCwgY3JlYXRlIGVhY2ggY29sbGVjdGlvbiBiZWZvcmUgZ3JvdXBpbmcuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZ3JvdXBGdW5jXSAtIGZ1bmN0aW9uIHRoYXQgcmV0dXJuIGVhY2ggZ3JvdXAncyBrZXlcbiAqIEByZXR1cm5zIHtvYmplY3QuPHN0cmluZywgQ29sbGVjdGlvbj59IGdyb3VwZWQgb2JqZWN0XG4gKiBAZXhhbXBsZVxuICogXG4gKiAvLyBwYXNzIGBzdHJpbmdgLCBgbnVtYmVyYCwgYGJvb2xlYW5gIHR5cGUgdmFsdWUgdGhlbiBncm91cCBieSBwcm9wZXJ0eSB2YWx1ZS5cbiAqIGNvbGxlY3Rpb24uZ3JvdXBCeSgnZ2VuZGVyJyk7ICAgIC8vIGdyb3VwIGJ5ICdnZW5kZXInIHByb3BlcnR5IHZhbHVlLlxuICogY29sbGVjdGlvbi5ncm91cEJ5KDUwKTsgICAgICAgICAgLy8gZ3JvdXAgYnkgJzUwJyBwcm9wZXJ0eSB2YWx1ZS5cbiAqIFxuICogLy8gcGFzcyBgZnVuY3Rpb25gIHRoZW4gZ3JvdXAgYnkgcmV0dXJuIHZhbHVlLiBlYWNoIGludm9jYXRpb24gYGZ1bmN0aW9uYCBpcyBjYWxsZWQgd2l0aCBgKGl0ZW0pYC5cbiAqIGNvbGxlY3Rpb24uZ3JvdXBCeShmdW5jdGlvbihpdGVtKSB7XG4gKiAgICAgaWYgKGl0ZW0uc2NvcmUgPiA2MCkge1xuICogICAgICAgICByZXR1cm4gJ3Bhc3MnO1xuICogICAgIH1cbiAqICAgICByZXR1cm4gJ2ZhaWwnO1xuICogfSk7XG4gKlxuICogLy8gcGFzcyBgYXJyYXlgIHdpdGggZmlyc3QgYXJndW1lbnRzIHRoZW4gY3JlYXRlIGVhY2ggY29sbGVjdGlvbiBiZWZvcmUgZ3JvdXBpbmcuXG4gKiBjb2xsZWN0aW9uLmdyb3VwQnkoWydnbycsICdydWJ5JywgJ2phdmFzY3JpcHQnXSk7XG4gKiAvLyByZXN1bHQ6IHsgJ2dvJzogZW1wdHkgQ29sbGVjdGlvbiwgJ3J1YnknOiBlbXB0eSBDb2xsZWN0aW9uLCAnamF2YXNjcmlwdCc6IGVtcHR5IENvbGxlY3Rpb24gfVxuICpcbiAqIC8vIGNhbiBwYXNzIGBmdW5jdGlvbmAgd2l0aCBgYXJyYXlgIHRoZW4gZ3JvdXAgZWFjaCBlbGVtZW50cy5cbiAqIGNvbGxlY3Rpb24uZ3JvdXBCeShbJ2dvJywgJ3J1YnknLCAnamF2YXNjcmlwdCddLCBmdW5jdGlvbihpdGVtKSB7XG4gKiAgICAgaWYgKGl0ZW0uaXNGYXN0KSB7XG4gKiAgICAgICAgIHJldHVybiAnZ28nO1xuICogICAgIH1cbiAqXG4gKiAgICAgcmV0dXJuIGl0ZW0ubmFtZTtcbiAqIH0pO1xuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5ncm91cEJ5ID0gZnVuY3Rpb24oa2V5LCBncm91cEZ1bmMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sXG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIGJhc2VWYWx1ZSxcbiAgICAgICAgaXNGdW5jID0gdXRpbC5pc0Z1bmN0aW9uLFxuICAgICAgICBrZXlJc0Z1bmMgPSBpc0Z1bmMoa2V5KSxcbiAgICAgICAgZ2V0SXRlbUlERm4gPSB0aGlzLmdldEl0ZW1JRDtcblxuICAgIGlmICh1dGlsLmlzQXJyYXkoa2V5KSkge1xuICAgICAgICB1dGlsLmZvckVhY2hBcnJheShrZXksIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIHJlc3VsdFtrICsgJyddID0gbmV3IENvbGxlY3Rpb24oZ2V0SXRlbUlERm4pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWdyb3VwRnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleSA9IGdyb3VwRnVuYztcbiAgICAgICAga2V5SXNGdW5jID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpZiAoa2V5SXNGdW5jKSB7XG4gICAgICAgICAgICBiYXNlVmFsdWUgPSBrZXkoaXRlbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlVmFsdWUgPSBpdGVtW2tleV07XG5cbiAgICAgICAgICAgIGlmIChpc0Z1bmMoYmFzZVZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGJhc2VWYWx1ZSA9IGJhc2VWYWx1ZS5hcHBseShpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbGxlY3Rpb24gPSByZXN1bHRbYmFzZVZhbHVlXTtcblxuICAgICAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSByZXN1bHRbYmFzZVZhbHVlXSA9IG5ldyBDb2xsZWN0aW9uKGdldEl0ZW1JREZuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbGxlY3Rpb24uYWRkKGl0ZW0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmV0dXJuIHNpbmdsZSBpdGVtIGluIGNvbGxlY3Rpb24uXG4gKlxuICogUmV0dXJuZWQgaXRlbSBpcyBpbnNlcnRlZCBpbiB0aGlzIGNvbGxlY3Rpb24gZmlyc3RseS5cbiAqIEByZXR1cm5zIHtvYmplY3R9IGl0ZW0uXG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnNpbmdsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBzb3J0IGEgYmFzaXMgb2Ygc3VwcGxpZWQgY29tcGFyZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmVGdW5jdGlvbiBjb21wYXJlRnVuY3Rpb25cbiAqIEByZXR1cm5zIHthcnJheX0gc29ydGVkIGFycmF5LlxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24oY29tcGFyZUZ1bmN0aW9uKSB7XG4gICAgdmFyIGFyciA9IFtdO1xuXG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgYXJyLnB1c2goaXRlbSk7XG4gICAgfSk7XG5cbiAgICBpZiAoaXNGdW5jKGNvbXBhcmVGdW5jdGlvbikpIHtcbiAgICAgICAgYXJyID0gYXJyLnNvcnQoY29tcGFyZUZ1bmN0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gKiBpdGVyYXRlIGVhY2ggbW9kZWwgZWxlbWVudC5cbiAqXG4gKiB3aGVuIGl0ZXJhdGVlIHJldHVybiBmYWxzZSB0aGVuIGJyZWFrIHRoZSBsb29wLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgaXRlcmF0ZWUoaXRlbSwgaW5kZXgsIGl0ZW1zKVxuICogQHBhcmFtIHsqfSBbY29udGV4dF0gY29udGV4dFxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24oaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBmb3JFYWNoUHJvcCh0aGlzLml0ZW1zLCBpdGVyYXRlZSwgY29udGV4dCB8fCB0aGlzKTtcbn07XG5cbi8qKlxuICogcmV0dXJuIG5ldyBhcnJheSB3aXRoIGNvbGxlY3Rpb24gaXRlbXMuXG4gKiBAcmV0dXJucyB7YXJyYXl9IG5ldyBhcnJheS5cbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlsLm1hcCh0aGlzLml0ZW1zLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0aW9uO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgY29tbW9uL2dlbmVyYWwgdXRpbGl0aWVzLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2NvbGxlY3Rpb24nKTtcbnZhciBhcHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmZ1bmN0aW9uIGV2ZW50SURHZXR0ZXIoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuY2lkKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Li4uKn0gaW5pdEl0ZW1zIC0gaXRlbXMgdG8gYWRkIG5ld2x5IGNyZWF0ZWQgY29sbGVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Q29sbGVjdGlvbn0gbmV3IGNvbGxlY3Rpb24gZm9yIGV2ZW50IG1vZGVscy5cbiAgICAgKi9cbiAgICBjcmVhdGVFdmVudENvbGxlY3Rpb246IGZ1bmN0aW9uKGluaXRJdGVtcykgeyAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIHZhciBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oZXZlbnRJREdldHRlcik7XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uYWRkLmFwcGx5KGNvbGxlY3Rpb24sIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHJhdGlvIHZhbHVlLlxuICAgICAqXG4gICAgICogYSA6IGIgPSB5IDogWDtcbiAgICAgKlxuICAgICAqID1cbiAgICAgKlxuICAgICAqIFggPSAoYiAqIHkpIC8gYTtcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYSAtIGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYiAtIGJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHlcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSByYXRpbyB2YWx1ZVxuICAgICAqL1xuICAgIHJhdGlvOiBmdW5jdGlvbihhLCBiLCB5KSB7XG4gICAgICAgIC8vIGEgOiBiID0geSA6IHg7XG4gICAgICAgIHJldHVybiAoYiAqIHkpIC8gYTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBuZWFyZXN0IHZhbHVlIGZyb20gc3VwcGxpZWQgcGFyYW1zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHZhbHVlIHRvIGZpbmQuXG4gICAgICogQHBhcmFtIHthcnJheX0gbmVhcmVzdCAtIG5lYXJlc3QgYXJyYXkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gbmVhcmVzdCB2YWx1ZVxuICAgICAqL1xuICAgIG5lYXJlc3Q6IGZ1bmN0aW9uKHZhbHVlLCBuZWFyZXN0KSB7XG4gICAgICAgIHZhciBkaWZmID0gdXRpbC5tYXAobmVhcmVzdCwgZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh2YWx1ZSAtIHYpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBuZWFyZXN0SW5kZXggPSB1dGlsLmluQXJyYXkoTWF0aC5taW4uYXBwbHkobnVsbCwgZGlmZiksIGRpZmYpO1xuXG4gICAgICAgIHJldHVybiBuZWFyZXN0W25lYXJlc3RJbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHBpY2sgdmFsdWUgZnJvbSBvYmplY3QgdGhlbiByZXR1cm4gdXRpbGl0eSBvYmplY3QgdG8gdHJlYXQgaXQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIG9iamVjdCB0byBzZWFyY2ggc3VwcGxpZWQgcGF0aCBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0gey4uLnN0cmluZ30gcGF0aHMgLSByZXN0IHBhcmFtZXRlciB0aGF0IHN0cmluZyB2YWx1ZSB0byBzZWFyY2ggcHJvcGVydHkgaW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHBpY2sgb2JqZWN0LlxuICAgICAqL1xuICAgIHBpY2syOiBmdW5jdGlvbihvYmosIHBhdGhzKSB7ICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgdmFyIHJlc3VsdCA9IHV0aWwucGljay5hcHBseShudWxsLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgcGljaztcblxuICAgICAgICBwaWNrID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gcGlja2VkIHZhbHVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGludm9rZSBzdXBwbGllZCBmdW5jdGlvbiBpbiBwaWNrZWQgb2JqZWN0LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIHRoZSBjYWxsYmFjayBjb250ZXh0IGlzIHNldCBwaWNrZWQgb2JqZWN0LlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb259IGZuIC0gZnVuY3Rpb24gdG8gaW52b2tlIGluIHBpY2tlZCBvYmplY3QuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gcmVzdWx0IG9mIGludm9rZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhlbjogZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncztcblxuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7ICAgIC8vZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcHMuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcoZm4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodXRpbC5waWNrKHJlc3VsdCwgZm4pIHx8IGZ1bmN0aW9uKCkge30pLmFwcGx5KHJlc3VsdCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwocmVzdWx0LCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBwaWNrO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNaXhpbiBtZXRob2QuXG4gICAgICpcbiAgICAgKiAoZXh0ZW5kIG1ldGhvZHMgZXhjZXB0IHByb3BlcnR5IG5hbWUgJ21peGluJylcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZnJvbSAtIG1peGluIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdG8gLSBvYmplY3QgdG8gbWl4aW4uXG4gICAgICovXG4gICAgbWl4aW46IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gICAgICAgIHV0aWwuZXh0ZW5kKHRvLnByb3RvdHlwZSwgZnJvbSk7XG4gICAgfVxufTtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGRhdGV0aW1lIHV0aWxpdHkgbW9kdWxlXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsLFxuICAgIG9wdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbnZhciBkYXRlRm9ybWF0UnggPSAvXihcXGR7NH1bLXxcXC9dKlxcZHsyfVstfFxcL10qXFxkezJ9KVxccz8oXFxkezJ9OlxcZHsyfTpcXGR7Mn0pPyQvO1xuXG52YXIgZGF0ZXRpbWUsXG4gICAgdG9rZW5GdW5jO1xuXG52YXIgbWVtbyA9IHtcbiAgICBtaWxsaXNlY29uZHNUbzoge30sXG4gICAgbWlsbGlzZWNvbmRzRnJvbToge31cbn07XG5cbnRva2VuRnVuYyA9IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUgZGF0ZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gWVlZWU1NRERcbiAgICAgKi9cbiAgICAnWVlZWU1NREQnOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBkYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICBkYXRldGltZS5sZWFkaW5nWmVybyhkYXRlLmdldE1vbnRoKCkgKyAxLCAyKSxcbiAgICAgICAgICAgIGRhdGV0aW1lLmxlYWRpbmdaZXJvKGRhdGUuZ2V0RGF0ZSgpLCAyKVxuICAgICAgICBdLmpvaW4oJycpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlIGRhdGUgb2JqZWN0XG4gICAgICogQHJldHVybnMge3N0cmluZ30gZm91ciBkaWdpdCB5ZWFyIG51bWJlclxuICAgICAqL1xuICAgICdZWVlZJzogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpICsgJyc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBkYXRlIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHR3byBkaWdpdCBtb250aCBudW1iZXJcbiAgICAgKi9cbiAgICAnTU0nOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHJldHVybiBkYXRldGltZS5sZWFkaW5nWmVybyhkYXRlLmdldE1vbnRoKCkgKyAxLCAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlIGRhdGUgb2JqZWN0XG4gICAgICogQHJldHVybnMge3N0cmluZ30gdHdvIGRpZ2l0IGRhdGUgbnVtYmVyXG4gICAgICovXG4gICAgJ0REJzogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZXRpbWUubGVhZGluZ1plcm8oZGF0ZS5nZXREYXRlKCksIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUgZGF0ZSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBISDptbVxuICAgICAqL1xuICAgICdISDptbSc6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgdmFyIGhvdXIgPSBkYXRlLmdldEhvdXJzKCksXG4gICAgICAgICAgICBtaW51dGVzID0gZGF0ZS5nZXRNaW51dGVzKCk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGV0aW1lLmxlYWRpbmdaZXJvKGhvdXIsIDIpICsgJzonICtcbiAgICAgICAgICAgIGRhdGV0aW1lLmxlYWRpbmdaZXJvKG1pbnV0ZXMsIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBmb3JtYXQgdG8gbG9jYWwgZGF0ZVxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBkYXRlIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IDE5ODgtMDktMjVUMDk6MDA6MDArMDk6MDBcbiAgICAgKi9cbiAgICAnTE9DQUwnOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHZhciB0aW1lWm9uZU9mZnNldCA9IC1kYXRlLmdldFRpbWV6b25lT2Zmc2V0KCksXG4gICAgICAgICAgICBkaWZmID0gdGltZVpvbmVPZmZzZXQgPj0gMCA/ICcrJyA6ICctJyxcbiAgICAgICAgICAgIHBhZCA9IGZ1bmN0aW9uKG51bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRldGltZS5sZWFkaW5nWmVybyhudW0sIDIpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpIFxuICAgICAgICAgICAgKyAnLScgKyBwYWQoZGF0ZS5nZXRNb250aCgpICsgMSlcbiAgICAgICAgICAgICsgJy0nICsgcGFkKGRhdGUuZ2V0RGF0ZSgpKVxuICAgICAgICAgICAgKyAnVCcgKyBwYWQoZGF0ZS5nZXRIb3VycygpKVxuICAgICAgICAgICAgKyAnOicgKyBwYWQoZGF0ZS5nZXRNaW51dGVzKCkpIFxuICAgICAgICAgICAgKyAnOicgKyBwYWQoZGF0ZS5nZXRTZWNvbmRzKCkpIFxuICAgICAgICAgICAgKyBkaWZmICsgcGFkKHRpbWVab25lT2Zmc2V0IC8gNjApIFxuICAgICAgICAgICAgKyAnOicgKyBwYWQodGltZVpvbmVPZmZzZXQgJSA2MCk7XG4gICAgfVxufTtcblxuZGF0ZXRpbWUgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb25lIGRheS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIE1JTExJU0VDT05EU19QRVJfREFZOiA4NjQwMDAwMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9uZSBob3VyLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgTUlMTElTRUNPTkRTX1BFUl9IT1VSOiAzNjAwMDAwLFxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBtaWxsaXNlY29uZHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIHR5cGUgb2YgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSAtIGl0ZXJhdGVlIGZ1bmN0aW9uIHRvIHVzZSByZWR1Y2UuXG4gICAgICogQHJldHVybnMge251bWJlcn0gY29udmVydGVkIHZhbHVlLlxuICAgICAqL1xuICAgIF9jb252TWlsbGlzZWNvbmRzOiBmdW5jdGlvbih0eXBlLCB2YWx1ZSwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGNvbnYgPSBbNjAsIDYwLCAxMDAwXSxcbiAgICAgICAgICAgIGluZGV4ID0ge1xuICAgICAgICAgICAgICAgIGhvdXI6IDAsXG4gICAgICAgICAgICAgICAgbWludXRlczogMSxcbiAgICAgICAgICAgICAgICBzZWNvbmRzOiAyXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmICghKHR5cGUgaW4gaW5kZXgpIHx8IGdsb2JhbC5pc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1dGlsLnJlZHVjZShbdmFsdWVdLmNvbmNhdChjb252LnNsaWNlKGluZGV4W3R5cGVdKSksIGl0ZXJhdGVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBtaWxsaXNlY29uZHMgdmFsdWUgdG8gb3RoZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7dHlwZX0gdHlwZSBjb252ZXJ0IHRvIHR5cGUgd2FudCB0by4gc3VwcG9ydCBcImhvdXJcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiIG9ubHkuXG4gICAgICogQHBhcmFtIHt2YWx1ZX0gdmFsdWUgLSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGNvbnZlcnRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBtaWxsaXNlY29uZHNUbzogZnVuY3Rpb24odHlwZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gbWVtby5taWxsaXNlY29uZHNUbyxcbiAgICAgICAgICAgIGtleSA9IHR5cGUgKyB2YWx1ZTtcblxuICAgICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBjYWNoZVtrZXldID0gZGF0ZXRpbWUuX2NvbnZNaWxsaXNlY29uZHModHlwZSwgdmFsdWUsIGZ1bmN0aW9uKG1lbW8sIHYpIHtcbiAgICAgICAgICAgIHJldHVybiBtZW1vIC8gdjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNhY2hlW2tleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdmFsdWUgdG8gbWlsbGlzZWNvbmRzXG4gICAgICogQHBhcmFtIHt0eXBlfSB0eXBlIC0gdHlwZSBvZiBzdXBwbGllZCB2YWx1ZS4gc3VwcG9ydCBcImhvdXJcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiIG9ubHkuXG4gICAgICogQHBhcmFtIHt2YWx1ZX0gdmFsdWUgLSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGNvbnZlcnRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBtaWxsaXNlY29uZHNGcm9tOiBmdW5jdGlvbih0eXBlLCB2YWx1ZSkge1xuICAgICAgICB2YXIgY2FjaGUgPSBtZW1vLm1pbGxpc2Vjb25kc0Zyb20sXG4gICAgICAgICAgICBrZXkgPSB0eXBlICsgdmFsdWU7XG5cbiAgICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FjaGVba2V5XSA9IGRhdGV0aW1lLl9jb252TWlsbGlzZWNvbmRzKHR5cGUsIHZhbHVlLCBmdW5jdGlvbihtZW1vLCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gbWVtbyAqIHY7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjYWNoZVtrZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGRhdGUgYXJyYXkgZnJvbSBzdXBwbGllZCBwYXJhbXRlcnMuXG4gICAgICogQHBhcmFtIHtEYXRlfSBzdGFydCBTdGFydCBkYXRlLlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZW5kIEVuZCBkYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHVzZSBpbmNyZW1lbnQuXG4gICAgICogQHJldHVybnMge2FycmF5fSBEYXRlIGFycmF5LlxuICAgICAqL1xuICAgIHJhbmdlOiBmdW5jdGlvbihzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSBuZXcgRGF0ZShzdGFydC5nZXRUaW1lKCkpLFxuICAgICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgICAgd2hpbGUgKGN1cnNvciA8PSBlbmQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnNvcik7XG4gICAgICAgICAgICBjdXJzb3IgPSBuZXcgRGF0ZShjdXJzb3IuZ2V0VGltZSgpICsgc3RlcCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbG9uZSBzdXBwbGllZCBkYXRlLlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBkYXRlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7RGF0ZX0gQ2xvbmVkIGRhdGUgb2JqZWN0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZSB0d28gZGF0ZXMuXG4gICAgICpcbiAgICAgKiB3aGVuIGZpcnN0IGRhdGUgaXMgbGF0ZXN0IHRoZW4gc2Vjb25kcyB0aGVuIHJldHVybiAtMS5cbiAgICAgKlxuICAgICAqIHJldHVybiArMSByZXZlcnNlLCBhbmQgcmV0dXJuIDAgaXMgc2FtZS5cbiAgICAgKiBAcGFyYW0ge0RhdGV9IGQxIERhdGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtEYXRlfSBkMiBEYXRlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHJlc3VsdCBvZiBjb21wYXJlXG4gICAgICovXG4gICAgY29tcGFyZTogZnVuY3Rpb24oZDEsIGQyKSB7XG4gICAgICAgIHZhciBfZDEgPSBkMS5nZXRUaW1lKCksXG4gICAgICAgICAgICBfZDIgPSBkMi5nZXRUaW1lKCk7XG5cbiAgICAgICAgaWYgKF9kMSA8IF9kMikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKF9kMSA+IF9kMikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZDEgLSBkYXRlIG9uZVxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZDIgLSBkYXRlIHR3b1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBpcyB0d28gZGF0ZSBhcmUgc2FtZSB5ZWFyLCBtb250aD9cbiAgICAgKi9cbiAgICBpc1NhbWVNb250aDogZnVuY3Rpb24oZDEsIGQyKSB7XG4gICAgICAgIHJldHVybiAoZDEuZ2V0RnVsbFllYXIoKSA9PT0gZDIuZ2V0RnVsbFllYXIoKSAmJlxuICAgICAgICAgICAgICAgIGQxLmdldE1vbnRoKCkgPT09IGQyLmdldE1vbnRoKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGQxIC0gZGF0ZSBvbmVcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGQyIC0gZGF0ZSB0d29cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gaXMgdHdvIGRhdGUgYXJlIHNhbWUgeWVhciwgbW9udGgsIGRhdGU/XG4gICAgICovXG4gICAgaXNTYW1lRGF0ZTogZnVuY3Rpb24oZDEsIGQyKSB7XG4gICAgICAgIHZhciBzYW1lTW9udGggPSBkYXRldGltZS5pc1NhbWVNb250aChkMSwgZDIpO1xuICAgICAgICByZXR1cm4gc2FtZU1vbnRoICYmIChkMS5nZXREYXRlKCkgPT09IGQyLmdldERhdGUoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHN1cHBsaWVkIHBhcmFtZXRlciBpcyB2YWxpZCBkYXRlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyp9IGQgT2JqZWN0IHRvIHZhbGlkYXRlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXR1cm4gdHJ1ZSB3aGVuIHBhcmFtZXRlciBpcyB2YWxpZCBkYXRlIG9iamVjdC5cbiAgICAgKi9cbiAgICBpc1ZhbGlkOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIGlmIChvcHQuY2FsbChkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgICAgICAgICByZXR1cm4gIXdpbmRvdy5pc05hTihkLmdldFRpbWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IG5vbiBsb2NhbCBkYXRlIHRvIFVUQyBkYXRlLlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZCBEYXRlIHRvIGNvbnZlcnQgVVRDLlxuICAgICAqIEByZXR1cm5zIHtEYXRlfSBUaGUgVVRDIERhdGUuXG4gICAgICovXG4gICAgdG9VVEM6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIGwgPSBkLmdldFRpbWUoKSxcbiAgICAgICAgICAgIG9mZnNldCA9IGRhdGV0aW1lLm1pbGxpc2Vjb25kc0Zyb20oJ21pbnV0ZXMnLCBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShsICsgb2Zmc2V0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcGFkIGxlZnQgemVybyBjaGFyYWN0ZXJzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgbnVtYmVyIHZhbHVlIHRvIHBhZCB6ZXJvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggcGFkIGxlbmd0aCB0byB3YW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBhZGRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgbGVhZGluZ1plcm86IGZ1bmN0aW9uKG51bWJlciwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB6ZXJvID0gJycsXG4gICAgICAgICAgICBpID0gMDtcblxuICAgICAgICBpZiAoKG51bWJlciArICcnKS5sZW5ndGggPiBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBpIDwgKGxlbmd0aCAtIDEpOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHplcm8gKz0gJzAnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICh6ZXJvICsgbnVtYmVyKS5zbGljZShsZW5ndGggKiAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgZGF0ZSBzdHJpbmcgdG8gZGF0ZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBPbmx5IGxpc3RlZCBiZWxvdyBmb3JtYXRzIGF2YWxpYWJsZS5cbiAgICAgKlxuICAgICAqIC0gWVlZWU1NRERcbiAgICAgKiAtIFlZWVkvTU0vRERcbiAgICAgKiAtIFlZWVktTU0tRERcbiAgICAgKiAtIFlZWVkvTU0vREQgSEg6bW06U1NcbiAgICAgKiAtIFlZWVktTU0tREQgSEg6bW06U1NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgRm9ybWF0dGVkIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2ZpeE1vbnRoPS0xXSAtIG51bWJlciBmb3IgZml4IG1vbnRoIGNhbGN1bGF0aW5nLlxuICAgICAqIEByZXR1cm5zIHsoRGF0ZXxib29sZWFuKX0gQ29udmVydGVkIERhdGUgb2JqZWN0LiB3aGVuIHN1cHBsaWVkIHN0ciBpcyBub3QgYXZhaWxhYmxlIHRoZW4gcmV0dXJuIGZhbHNlLlxuICAgICAqL1xuICAgIHBhcnNlOiBmdW5jdGlvbihzdHIsIGZpeE1vbnRoKSB7XG4gICAgICAgIHZhciBzZXBhcmF0b3IsXG4gICAgICAgICAgICBtYXRjaGVzID0gc3RyLm1hdGNoKGRhdGVGb3JtYXRSeCksXG4gICAgICAgICAgICB5bWQsXG4gICAgICAgICAgICBobXM7XG5cbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQoZml4TW9udGgpKSB7XG4gICAgICAgICAgICBmaXhNb250aCA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDgpIHtcbiAgICAgICAgICAgIC8vIFlZWVkvTU0vRERcbiAgICAgICAgICAgIC8vIFlZWVktTU0tRERcbiAgICAgICAgICAgIC8vIFlZWVkvTU0vREQgSEg6bW06U1NcbiAgICAgICAgICAgIC8vIFlZWVktTU0tREQgSEg6bW06U1NcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IH5zdHIuaW5kZXhPZignLycpID8gJy8nIDogJy0nO1xuICAgICAgICAgICAgbWF0Y2hlcyA9IG1hdGNoZXMuc3BsaWNlKDEpO1xuXG4gICAgICAgICAgICB5bWQgPSBtYXRjaGVzWzBdLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgICAgICBobXMgPSBtYXRjaGVzWzFdID8gbWF0Y2hlc1sxXS5zcGxpdCgnOicpIDogWzAsIDAsIDBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gWVlZWU1NRERcbiAgICAgICAgICAgIG1hdGNoZXMgPSBtYXRjaGVzWzBdO1xuICAgICAgICAgICAgeW1kID0gW21hdGNoZXMuc3Vic3RyKDAsIDQpLCBtYXRjaGVzLnN1YnN0cig0LCAyKSwgbWF0Y2hlcy5zdWJzdHIoNiwgMildO1xuICAgICAgICAgICAgaG1zID0gWzAsIDAsIDBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCt5bWRbMF0sICt5bWRbMV0gKyBmaXhNb250aCwgK3ltZFsyXSwgK2htc1swXSwgK2htc1sxXSwgK2htc1syXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBkYXRlIG9iamVjdCBmcm9tIERhdGUuXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlIGRhdGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBEYXRlIG9iamVjdC5cbiAgICAgKi9cbiAgICByYXc6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHk6IGRhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICAgIE06IGRhdGUuZ2V0TW9udGgoKSxcbiAgICAgICAgICAgIGQ6IGRhdGUuZ2V0RGF0ZSgpLFxuICAgICAgICAgICAgaDogZGF0ZS5nZXRIb3VycygpLFxuICAgICAgICAgICAgbTogZGF0ZS5nZXRNaW51dGVzKCksXG4gICAgICAgICAgICBzOiBkYXRlLmdldFNlY29uZHMoKSxcbiAgICAgICAgICAgIG1zOiBkYXRlLmdldE1pbGxpc2Vjb25kcygpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiAwMDowMDowMCBzdXBwbGllZCBkYXRlLlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBkYXRlLlxuICAgICAqIEByZXR1cm5zIHtEYXRlfSBzdGFydCBkYXRlLlxuICAgICAqL1xuICAgIHN0YXJ0OiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHZhciBkID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO1xuICAgICAgICBkLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuXG4gICAgICAgIHJldHVybiBkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gMjM6NTk6NTkgc3VwcGxpZWQgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUgZGF0ZS5cbiAgICAgKiBAcmV0dXJucyB7RGF0ZX0gZW5kIGRhdGUuXG4gICAgICovXG4gICAgZW5kOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHZhciBkID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO1xuICAgICAgICBkLnNldEhvdXJzKDIzLCA1OSwgNTksIDApO1xuXG4gICAgICAgIHJldHVybiBkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gZm9ybWF0dGVkIHN0cmluZyBhcyBiYXNpcyBvZiBzdXBwbGllZCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBTdXBwb3J0ZWQgVG9rZW4gTGlzdHMuXG4gICAgICpcbiAgICAgKiAtIFlZWVkgPT4gMTk4OFxuICAgICAqIC0gTU0gPT4gMDEgfiAxMlxuICAgICAqIC0gREQgPT4gMDEgfiAzMVxuICAgICAqIC0gWVlZWU1NREQgPT4gMTk4ODA5MjVcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUgU3RyaW5nIHdhbnQgdG8gZm9ybWF0dGVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgZm9ybWF0IHN0ci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgRm9ybWF0dGVkIGRhdGUgc3RyaW5nLlxuICAgICAqL1xuICAgIGZvcm1hdDogZnVuY3Rpb24oZGF0ZSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBmb3JtYXQ7XG4gICAgICAgIHV0aWwuZm9yRWFjaE93blByb3BlcnRpZXModG9rZW5GdW5jLCBmdW5jdGlvbihjb252ZXJ0ZXIsIHRva2VuKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSh0b2tlbiwgY29udmVydGVyKGRhdGUpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIDItZGltZW5zaW9uYWwgYXJyYXkgbW9udGggY2FsZW5kYXJcbiAgICAgKlxuICAgICAqIGRhdGVzIHRoYXQgZGlmZmVyZW50IG1vbnRoIHdpdGggZ2l2ZW4gZGF0ZSBhcmUgbmVnYXRpdmUgdmFsdWVzXG4gICAgICogQHBhcmFtIHtEYXRlfSBtb250aCAtIGRhdGUgd2FudCB0byBjYWxjdWxhdGUgbW9udGggY2FsZW5kYXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0RGF5T2ZXZWVrPTBdIC0gc3RhcnQgZGF5IG9mIHdlZWtcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaXRlcmF0ZWVdIC0gaXRlcmF0ZWUgZm9yIGN1c3RvbWl6aW5nIGNhbGVuZGFyIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nW10+fSBjYWxlbmRhciAyZCBhcnJheVxuICAgICAqL1xuICAgIGFycjJkQ2FsZW5kYXI6IGZ1bmN0aW9uKG1vbnRoLCBzdGFydERheU9mV2VlaywgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIHdlZWtBcnIsXG4gICAgICAgICAgICBzdGFydHMsIGVuZHMsXG4gICAgICAgICAgICBzdGFydEluZGV4LCBlbmRJbmRleCxcbiAgICAgICAgICAgIGFmdGVyRGF0ZXMsXG4gICAgICAgICAgICBjdXJzb3IsIHdlZWssXG4gICAgICAgICAgICBjYWxlbmRhciA9IFtdO1xuXG4gICAgICAgIHN0YXJ0cyA9IG5ldyBEYXRlKG5ldyBEYXRlKCttb250aCkuc2V0RGF0ZSgxKSk7XG4gICAgICAgIGVuZHMgPSBuZXcgRGF0ZShuZXcgRGF0ZSgrc3RhcnRzKS5zZXRNb250aChzdGFydHMuZ2V0TW9udGgoKSArIDEpKTtcbiAgICAgICAgZW5kcyA9IG5ldyBEYXRlKG5ldyBEYXRlKCtlbmRzKS5zZXREYXRlKGVuZHMuZ2V0RGF0ZSgpIC0gMSkpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBkYXkgbnVtYmVyIGFycmF5IGJ5IHN0YXJ0RGF5T2ZXZWVrIG51bWJlclxuICAgICAgICAvLyA0IC0+IFs0LCA1LCA2LCAwLCAxLCAyLCAzXVxuICAgICAgICAvLyAyIC0+IFsyLCAzLCA0LCA1LCA2LCAwLCAxXVxuICAgICAgICB3ZWVrQXJyID0gdXRpbC5yYW5nZShzdGFydERheU9mV2VlaywgNykuY29uY2F0KHV0aWwucmFuZ2UoNykpLnNsaWNlKDAsIDcpO1xuICAgICAgICBzdGFydEluZGV4ID0gdXRpbC5pbkFycmF5KHN0YXJ0cy5nZXREYXkoKSwgd2Vla0Fycik7XG4gICAgICAgIGVuZEluZGV4ID0gdXRpbC5pbkFycmF5KGVuZHMuZ2V0RGF5KCksIHdlZWtBcnIpO1xuICAgICAgICAvLyBmcmVlIGRhdGVzIGFmdGVyIGxhc3QgZGF0ZSBvZiB0aGlzIG1vbnRoXG4gICAgICAgIGFmdGVyRGF0ZXMgPSA3IC0gKGVuZEluZGV4ICsgMSk7XG5cbiAgICAgICAgY3Vyc29yID0gbmV3IERhdGUobmV3IERhdGUoK3N0YXJ0cykuc2V0RGF0ZShzdGFydHMuZ2V0RGF0ZSgpIC0gc3RhcnRJbmRleCkpO1xuICAgICAgICAvLyBpdGVyYXRlZSBhbGwgZGF0ZXMgdG8gcmVuZGVyXG4gICAgICAgIHV0aWwuZm9yRWFjaEFycmF5KHV0aWwucmFuZ2Uoc3RhcnRJbmRleCArIGVuZHMuZ2V0RGF0ZSgpICsgYWZ0ZXJEYXRlcyksIGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgIHZhciBkYXRlO1xuXG4gICAgICAgICAgICBpZiAoIShpICUgNykpIHtcbiAgICAgICAgICAgICAgICAvLyBncm91cCBlYWNoIGRhdGUgYnkgd2Vla1xuICAgICAgICAgICAgICAgIHdlZWsgPSBjYWxlbmRhcltpIC8gN10gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKCtjdXJzb3IpO1xuICAgICAgICAgICAgZGF0ZSA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUoZGF0ZSkgOiBkYXRlO1xuICAgICAgICAgICAgd2Vlay5wdXNoKGRhdGUpO1xuXG4gICAgICAgICAgICAvLyBhZGQgZGF0ZVxuICAgICAgICAgICAgY3Vyc29yID0gbmV3IERhdGUoY3Vyc29yLnNldERhdGUoY3Vyc29yLmdldERhdGUoKSArIDEpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZGF0ZXRpbWU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJ0eSBmbGFnZ2luZyBtb2R1bGUgZm9yIG9iamVjdHMuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tbW9uID0gbmUudXRpbCxcbiAgICBleGlzdHkgPSBjb21tb24uaXNFeGlzdHksXG4gICAgcGljayA9IGNvbW1vbi5waWNrLFxuICAgIGlzRnVuYyA9IGNvbW1vbi5pc0Z1bmN0aW9uO1xuXG4vKipcbiAqIE1peGluIG1vZHVsZSBmb3IgZGlydHkgZmxhZ2dpbmcgb24gc3BlY2lmaWMgb2JqZWN0cy5cbiAqIEBtaXhpblxuICogQGV4YW1wbGVcbiAqIHZhciBvYmogPSB7IGhlbGxvOiAnZ29vZCcsIHRlc3Q6ICcxMjMnIH07XG4gKiBkaXJ0eS5taXhpbihvYmopO1xuICpcbiAqIG9iai5zZXQoJ2hlbGxvJywgJ3dvcmxkJyk7XG4gKiBvYmouaXNEaXJ0eSgpOyAgICAvLyB0cnVlXG4gKiBvYmouaXNQcm9wQ2hhbmdlZCgnaGVsbG8nKTsgICAgLy8gdHJ1ZVxuICogb2JqLmlzUHJvcENoYW5nZWQoJ3Rlc3QnKTsgICAgLy8gZmFsc2VcbiAqIG9iai5kaXJ0eShmYWxzZSk7XG4gKlxuICogb2JqLmlzRGlydHkoKTsgICAgLy8gZmFsc2VcbiAqIG9iai5pc1Byb3BDaGFuZ2VkKCdoZWxsbycpOyAgICAvLyBmYWxzZVxuICovXG52YXIgZGlydHkgPSB7XG4gICAgLyoqXG4gICAgICogU2V0IHByb3BlcnR5IHZhbHVlIHdpdGggZGlydHkgZmxhZ2dpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BOYW1lIFByb3BlcnR5IG5hbWUuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBQcm9wcnR5IHZhbHVlLlxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ocHJvcE5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBvcmlnaW5WYWx1ZSA9IHRoaXNbcHJvcE5hbWVdO1xuXG4gICAgICAgIGlmIChvcmlnaW5WYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jaGFuZ2VkKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNhdmUgY2hhbmdlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICogQG1lbWJlcm9mIGRpcnR5XG4gICAgICAgICAgICAgKiBAbmFtZSBfY2hhbmdlZFxuICAgICAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlZFtwcm9wTmFtZV0gPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXJ0eSBmbGFnXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAbmFtZSBfZGlydHlcbiAgICAgICAgICogQG1lbWJlcm9mIGRpcnR5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGRpcnR5IGZsYWcuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFByb3BlcnR5IGlzIGNoYW5nZWQuXG4gICAgICovXG4gICAgaXNEaXJ0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RpcnR5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgZGlydHkgZmxhZyBtYW51YWxseS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt0b0RpcnR5PXRydWVdIFRoaXMgd2lsbCBzZXQgZGlydHkgZmxhZyBkaXJlY3RseS5cbiAgICAgKi9cbiAgICBkaXJ0eTogZnVuY3Rpb24odG9EaXJ0eSkge1xuICAgICAgICB0b0RpcnR5ID0gZXhpc3R5KHRvRGlydHkpID8gdG9EaXJ0eSA6IHRydWU7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKCF0b0RpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRvRGlydHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBwcm9wZXJ0eSBzYWZldHkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lIFRoZSBuYW1lIG9mIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGRlbGV0ZVByb3A6IGZ1bmN0aW9uKHByb3BOYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzW3Byb3BOYW1lXTtcblxuICAgICAgICBpZiAodGhpcy5fY2hhbmdlZCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NoYW5nZWRbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoZSBjaGFuZ2VzIHdpdGggc3BlY2lmaWMgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lIFRoZSBuYW1lIG9mIHByb3BlcnR5IHlvdSB3YW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBJcyBwcm9wZXJ0eSBjaGFuZ2VkP1xuICAgICAqL1xuICAgIGlzUHJvcENoYW5nZWQ6IGZ1bmN0aW9uKHByb3BOYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2hhbmdlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZWRbcHJvcE5hbWVdID09PSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNaXhpbiB0byBzcGVjaWZpYyBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0byBtaXggdGhpcyBtb2R1bGUuXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTp1dGlsL2RpcnR5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBmdW5jdGlvbiBBbmltYWwoKSB7fVxuICAgICAqIGRpcnR5Lm1peGluKEFuaW1hbC5wcm90b3R5cGUpO1xuICAgICAqL1xuICAgIG1peGluOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgdmFyIG1ldGhvZEZpbHRlclIgPSAvKF5ffG1peGlufHdyYXApLztcblxuICAgICAgICBjb21tb24uZm9yRWFjaE93blByb3BlcnRpZXMoZGlydHksIGZ1bmN0aW9uKG8sIGspIHtcbiAgICAgICAgICAgIGlmICghbWV0aG9kRmlsdGVyUi50ZXN0KGspKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tdID0gZGlydHlba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXcmFwcGVyIG1ldGhvZCBmb3IgZGlydHkgZmxhZ2dpbmcuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2UgYWZ0ZXIgaW52b2tlZCBzcGVjaWZpYyBtZXRob2QgdGhhdCBhZGRlZCBieSB5b3UuXG4gICAgICpcbiAgICAgKiBUaGUgbWV0aG9kIHdhbnQgdG8gYWRkIGFyZSBtdXN0IGV4aXN0IGJlZm9yZSBhZGQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCBUYXJnZXQgb2JqZWN0IHRvIG1ldGhvZCB3cmFwLlxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xvYmplY3QpfSBtZXRob2ROYW1lXG4gICAgICogIE1ldGhvZCBuYW1lIHRvIHdyYXAgb3IgbWV0aG9kTmFtZTogZmxhZyBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZsYWc9dHJ1ZV1cbiAgICAgKiAgdGhpcyB3aWxsIHVzZWQgdG8gZmxhZ2dpbmcgYnkgZGlydHkgZmxhZ2dlciBhZnRlciBpbnZva2UgdGhlIG1ldGhvZHMgYWRkZWQgYnkgeW91LlxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6dXRpbC9kaXJ0eVxuICAgICAqIEBleGFtcGxlXG4gICAgICogZnVuY3Rpb24gQW5pbWFsKG5hbWUpIHtcbiAgICAgKiAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgKiB9XG4gICAgICogQW5pbWFsLnByb3RvdHlwZS5ncm93bCA9IGphc21pbmUuY3JlYXRlU3B5KCdncm93bCcpO1xuICAgICAqIEFuaW1hbC5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBkaXJ0eS5taXhpbihBbmltYWwucHJvdG90eXBlKTtcbiAgICAgKiAvLyBzaW5nbGVcbiAgICAgKiBkaXJ0eS53cmFwKEFuaW1hbC5wcm90b3R5cGUsICdncm93bCcsIHRydWUpO1xuICAgICAqIC8vIG11bHRpcGxlXG4gICAgICogZGlydHkud3JhcChBbmltYXAucHJvdG90eXBlLCB7XG4gICAgICogICAgIGdyb3dsOiB0cnVlLFxuICAgICAqICAgICB0ZXN0OiBmYWxzZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICovXG4gICAgd3JhcDogZnVuY3Rpb24odGFyZ2V0LCBtZXRob2ROYW1lLCBmbGFnKSB7XG4gICAgICAgIHZhciB3cmFwID0gZGlydHkud3JhcCxcbiAgICAgICAgICAgIGZuO1xuXG4gICAgICAgIGlmIChjb21tb24uaXNPYmplY3QobWV0aG9kTmFtZSkpIHtcbiAgICAgICAgICAgIGNvbW1vbi5mb3JFYWNoT3duUHJvcGVydGllcyhtZXRob2ROYW1lLCBmdW5jdGlvbihmbGFnLCBtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICAgICAgd3JhcCh0YXJnZXQsIG1ldGhvZE5hbWUsIGZsYWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmbGFnID0gZXhpc3R5KGZsYWcpID8gZmxhZyA6IHRydWU7XG5cbiAgICAgICAgaWYgKCF0YXJnZXQuX3dyYXBwZXIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gT3JpZ2luYWwgbWV0aG9kIHRvIHdyYXAuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZsYWdUb1NldCBUaGUgYm9vbGVhbiB2YWx1ZSB0byB1c2luZyBkaXJ0eSBmbGFnZ2luZy5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0IHZhbHVlIG9mIG9yaWdpbmFsIG1ldGhvZC5cbiAgICAgICAgICAgICAqIEBuYW1lIF93cmFwcGVyXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgZGlydHlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGFyZ2V0Ll93cmFwcGVyID0gZnVuY3Rpb24oZm4sIGZsYWdUb1NldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmxhZ1RvU2V0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4aXN0eShwaWNrKHRhcmdldCwgbWV0aG9kTmFtZSkpICYmXG4gICAgICAgICAgICBpc0Z1bmModGFyZ2V0W21ldGhvZE5hbWVdKSAmJlxuICAgICAgICAgICAgIWV4aXN0eShwaWNrKHRhcmdldCwgbWV0aG9kTmFtZSwgJ193cmFwcGVkJykpKSB7XG4gICAgICAgICAgICBmbiA9IHRhcmdldFttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIHRhcmdldFttZXRob2ROYW1lXSA9IHRhcmdldC5fd3JhcHBlcihmbiwgZmxhZyk7XG4gICAgICAgICAgICB0YXJnZXRbbWV0aG9kTmFtZV0uX3dyYXBwZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBkaXJ0eTtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFV0aWxpdHkgbW9kdWxlIGZvciBoYW5kbGluZyBET00gZXZlbnRzLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbCxcbiAgICBicm93c2VyID0gdXRpbC5icm93c2VyLFxuICAgIGV2ZW50S2V5ID0gJ19ldnQnLFxuICAgIERSQUcgPSB7XG4gICAgICAgIFNUQVJUOiBbJ3RvdWNoc3RhcnQnLCAnbW91c2Vkb3duJ10sXG4gICAgICAgIEVORDoge1xuICAgICAgICAgICAgbW91c2Vkb3duOiAnbW91c2V1cCcsXG4gICAgICAgICAgICB0b3VjaHN0YXJ0OiAndG91Y2hlbmQnLFxuICAgICAgICAgICAgcG9pbnRlcmRvd246ICd0b3VjaGVuZCcsXG4gICAgICAgICAgICBNU1BvaW50ZXJEb3duOiAndG91Y2hlbmQnXG4gICAgICAgIH0sXG4gICAgICAgIE1PVkU6IHtcbiAgICAgICAgICAgIG1vdXNlZG93bjogJ21vdXNlbW92ZScsXG4gICAgICAgICAgICB0b3VjaHN0YXJ0OiAndG91Y2htb3ZlJyxcbiAgICAgICAgICAgIHBvaW50ZXJkb3duOiAndG91Y2htb3ZlJyxcbiAgICAgICAgICAgIE1TUG9pbnRlckRvd246ICd0b3VjaG1vdmUnXG4gICAgICAgIH1cbiAgICB9O1xuXG52YXIgZG9tZXZlbnQgPSB7XG4gICAgLyoqXG4gICAgICogQmluZCBkb20gZXZlbnRzLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9iaiBIVE1MRWxlbWVudCB0byBiaW5kIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0gdHlwZXMgU3BhY2Ugc3BsaXR0ZWQgZXZlbnRzIG5hbWVzIG9yIGV2ZW50TmFtZTpoYW5kbGVyIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyp9IGZuIGhhbmRsZXIgZnVuY3Rpb24gb3IgY29udGV4dCBmb3IgaGFuZGxlciBtZXRob2QuXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF0gY29udGV4dCBvYmplY3QgZm9yIGhhbmRsZXIgbWV0aG9kLlxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xuICAgICAgICBpZiAodXRpbC5pc1N0cmluZyh0eXBlcykpIHtcbiAgICAgICAgICAgIHV0aWwuZm9yRWFjaCh0eXBlcy5zcGxpdCgnICcpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgZG9tZXZlbnQuX29uKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWwuZm9yRWFjaE93blByb3BlcnRpZXModHlwZXMsIGZ1bmN0aW9uKGhhbmRsZXIsIHR5cGUpIHtcbiAgICAgICAgICAgIGRvbWV2ZW50Ll9vbihvYmosIHR5cGUsIGhhbmRsZXIsIGZuKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERPTSBldmVudCBiaW5kaW5nLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9iaiBIVE1MRWxlbWVudCB0byBiaW5kIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiBldmVudHMuXG4gICAgICogQHBhcmFtIHsqfSBmbiBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF0gY29udGV4dCBvYmplY3QgZm9yIGhhbmRsZXIgbWV0aG9kLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uOiBmdW5jdGlvbihvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBpZCxcbiAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgICBvcmlnaW5IYW5kbGVyO1xuXG4gICAgICAgIGlkID0gdHlwZSArIHV0aWwuc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyB1dGlsLnN0YW1wKGNvbnRleHQpIDogJycpO1xuXG4gICAgICAgIGlmIChvYmpbZXZlbnRLZXldICYmIG9ialtldmVudEtleV1baWRdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZm4uY2FsbChjb250ZXh0IHx8IG9iaiwgZSB8fCB3aW5kb3cuZXZlbnQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG9yaWdpbkhhbmRsZXIgPSBoYW5kbGVyO1xuXG4gICAgICAgIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ21vdXNlZW50ZXInIHx8IHR5cGUgPT09ICdtb3VzZWxlYXZlJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb21ldmVudC5fY2hlY2tNb3VzZShvYmosIGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luSGFuZGxlcihlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKCh0eXBlID09PSAnbW91c2VlbnRlcicpID9cbiAgICAgICAgICAgICAgICAgICAgJ21vdXNlb3ZlcicgOiAnbW91c2VvdXQnLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgaGFuZGxlciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgnYXR0YWNoRXZlbnQnIGluIG9iaikge1xuICAgICAgICAgICAgb2JqLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9ialtldmVudEtleV0gPSBvYmpbZXZlbnRLZXldIHx8IHt9O1xuICAgICAgICBvYmpbZXZlbnRLZXldW2lkXSA9IGhhbmRsZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVuYmluZCBET00gRXZlbnQgaGFuZGxlci5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvYmogSFRNTEVsZW1lbnQgdG8gdW5iaW5kLlxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xvYmplY3QpfSB0eXBlcyBTcGFjZSBzcGxpdHRlZCBldmVudHMgbmFtZXMgb3IgZXZlbnROYW1lOmhhbmRsZXIgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gZm4gaGFuZGxlciBmdW5jdGlvbiBvciBjb250ZXh0IGZvciBoYW5kbGVyIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XSBjb250ZXh0IG9iamVjdCBmb3IgaGFuZGxlciBtZXRob2QuXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xuICAgICAgICBpZiAodXRpbC5pc1N0cmluZyh0eXBlcykpIHtcbiAgICAgICAgICAgIHV0aWwuZm9yRWFjaCh0eXBlcy5zcGxpdCgnICcpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgZG9tZXZlbnQuX29mZihvYmosIHR5cGUsIGZuLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1dGlsLmZvckVhY2hPd25Qcm9wZXJ0aWVzKHR5cGVzLCBmdW5jdGlvbihoYW5kbGVyLCB0eXBlKSB7XG4gICAgICAgICAgICBkb21ldmVudC5fb2ZmKG9iaiwgdHlwZSwgaGFuZGxlciwgZm4pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5iaW5kIERPTSBldmVudCBoYW5kbGVyLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9iaiBIVE1MRWxlbWVudCB0byB1bmJpbmQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgZXZlbnQgdG8gdW5iaW5kLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gZm4gRXZlbnQgaGFuZGxlciB0aGF0IHN1cHBsaWVkIHdoZW4gYmluZGluZy5cbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHQgY29udGV4dCBvYmplY3QgdGhhdCBzdXBwbGllZCB3aGVuIGJpbmRpbmcuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb2ZmOiBmdW5jdGlvbihvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBpZCA9IHR5cGUgKyB1dGlsLnN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgdXRpbC5zdGFtcChjb250ZXh0KSA6ICcnKSxcbiAgICAgICAgICAgIGhhbmRsZXIgPSBvYmpbZXZlbnRLZXldICYmIG9ialtldmVudEtleV1baWRdO1xuXG4gICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdyZW1vdmVFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbW91c2VlbnRlcicgfHwgdHlwZSA9PT0gJ21vdXNlbGVhdmUnKSB7XG4gICAgICAgICAgICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoKHR5cGUgPT09ICdtb3VzZWVudGVyJykgP1xuICAgICAgICAgICAgICAgICAgICAnbW91c2VvdmVyJyA6ICdtb3VzZW91dCcsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xuICAgICAgICAgICAgICAgICAgICBvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCdkZXRhY2hFdmVudCcgaW4gb2JqKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9iai5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fSAgICAvL2VzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBvYmpbZXZlbnRLZXldW2lkXTtcblxuICAgICAgICBpZiAodXRpbC5rZXlzKG9ialtldmVudEtleV0pLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIG9ialtldmVudEtleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJpbmQgRE9NIGV2ZW50LiB0aGlzIGV2ZW50IHdpbGwgdW5iaW5kIGFmdGVyIGludm9rZXMuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb2JqIEhUTUxFbGVtZW50IHRvIGJpbmQgZXZlbnRzLlxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xvYmplY3QpfSB0eXBlcyBTcGFjZSBzcGxpdHRlZCBldmVudHMgbmFtZXMgb3IgZXZlbnROYW1lOmhhbmRsZXIgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gZm4gaGFuZGxlciBmdW5jdGlvbiBvciBjb250ZXh0IGZvciBoYW5kbGVyIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XSBjb250ZXh0IG9iamVjdCBmb3IgaGFuZGxlciBtZXRob2QuXG4gICAgICovXG4gICAgb25jZTogZnVuY3Rpb24ob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIGlmICh1dGlsLmlzT2JqZWN0KHR5cGVzKSkge1xuICAgICAgICAgICAgdXRpbC5mb3JFYWNoT3duUHJvcGVydGllcyh0eXBlcywgZnVuY3Rpb24oaGFuZGxlciwgdHlwZSkge1xuICAgICAgICAgICAgICAgIGRvbWV2ZW50Lm9uY2Uob2JqLCB0eXBlLCBoYW5kbGVyLCBmbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uY2VIYW5kbGVyKCkge1xuICAgICAgICAgICAgZm4uYXBwbHkoY29udGV4dCB8fCBvYmosIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGF0Ll9vZmYob2JqLCB0eXBlcywgb25jZUhhbmRsZXIsIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9tZXZlbnQub24ob2JqLCB0eXBlcywgb25jZUhhbmRsZXIsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgZXZlbnQgYnViYmxpbmcuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QuXG4gICAgICovXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgYnJvd3NlciBkZWZhdWx0IGFjdGlvbnMuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QuXG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTeW50YXRpYyBzdWdhciBvZiBzdG9wUHJvcGFnYXRpb24gYW5kIHByZXZlbnREZWZhdWx0XG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QuXG4gICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24oZSkge1xuICAgICAgICBkb21ldmVudC5wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgZG9tZXZlbnQuc3RvcFByb3BhZ2F0aW9uKGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdG9wIHNjcm9sbCBldmVudHMuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgSFRNTCBlbGVtZW50IHRvIHByZXZlbnQgc2Nyb2xsLlxuICAgICAqL1xuICAgIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbjogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgZG9tZXZlbnQub24oZWwsICdtb3VzZXdoZWVsIE1vek1vdXNlUGl4ZWxTY3JvbGwnLCBkb21ldmVudC5zdG9wUHJvcGFnYXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGFsbCBldmVudHMgcmVsYXRlZCB3aXRoIGNsaWNrLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEhUTUwgZWxlbWVudCB0byBwcmV2ZW50IGFsbCBldmVudCByZWxhdGVkIHdpdGggY2xpY2suXG4gICAgICovXG4gICAgZGlzYWJsZUNsaWNrUHJvcGFnYXRpb246IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGRvbWV2ZW50Lm9uKGVsLCBEUkFHLlNUQVJULmpvaW4oJyAnKSArICcgY2xpY2sgZGJsY2xpY2snLCBkb21ldmVudC5zdG9wUHJvcGFnYXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbW91c2UgcG9zaXRpb24gZnJvbSBtb3VzZSBldmVudC5cbiAgICAgKlxuICAgICAqIElmIHN1cHBsaWVkIHJlbGF0dmVFbGVtZW50IHBhcmFtZXRlciB0aGVuIHJldHVybiByZWxhdGl2ZSBwb3NpdGlvbiBiYXNlZCBvbiBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IG1vdXNlRXZlbnQgTW91c2UgZXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVsYXRpdmVFbGVtZW50IEhUTUwgZWxlbWVudCB0aGF0IGNhbGN1bGF0ZSByZWxhdGl2ZSBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IG1vdXNlIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIGdldE1vdXNlUG9zaXRpb246IGZ1bmN0aW9uKG1vdXNlRXZlbnQsIHJlbGF0aXZlRWxlbWVudCkge1xuICAgICAgICB2YXIgcmVjdDtcblxuICAgICAgICBpZiAoIXJlbGF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFttb3VzZUV2ZW50LmNsaWVudFgsIG1vdXNlRXZlbnQuY2xpZW50WV07XG4gICAgICAgIH1cblxuICAgICAgICByZWN0ID0gcmVsYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtb3VzZUV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQgLSByZWxhdGl2ZUVsZW1lbnQuY2xpZW50TGVmdCxcbiAgICAgICAgICAgIG1vdXNlRXZlbnQuY2xpZW50WSAtIHJlY3QudG9wIC0gcmVsYXRpdmVFbGVtZW50LmNsaWVudFRvcFxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgbW91c2Ugd2hlZWwgZXZlbnQgdGhhdCBkaWZmZXJlbnQgZWFjaCBicm93c2Vycy5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgTW91c2Ugd2hlZWwgZXZlbnQuXG4gICAgICogQHJldHVybnMge051bWJlcn0gZGVsdGFcbiAgICAgKi9cbiAgICBnZXRXaGVlbERlbHRhOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBkZWx0YSA9IDA7XG5cbiAgICAgICAgaWYgKGUud2hlZWxEZWx0YSkge1xuICAgICAgICAgICAgZGVsdGEgPSBlLndoZWVsRGVsdGEgLyAxMjA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5kZXRhaWwpIHtcbiAgICAgICAgICAgIGRlbHRhID0gLWUuZGV0YWlsIC8gMztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcHJldmVudCBmaXJpbmcgbW91c2VsZWF2ZSBldmVudCB3aGVuIG1vdXNlIGVudGVyZWQgY2hpbGQgZWxlbWVudHMuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgSFRNTCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIE1vdXNlIGV2ZW50XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IGxlYXZlP1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NoZWNrTW91c2U6IGZ1bmN0aW9uKGVsLCBlKSB7XG4gICAgICAgIHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xuXG4gICAgICAgIGlmICghcmVsYXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2hpbGUgKHJlbGF0ZWQgJiYgKHJlbGF0ZWQgIT09IGVsKSkge1xuICAgICAgICAgICAgICAgIHJlbGF0ZWQgPSByZWxhdGVkLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChyZWxhdGVkICE9PSBlbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgc3BlY2lmaWMgZXZlbnRzIHRvIGh0bWwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvYmogSFRNTEVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlIG5hbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2V2ZW50RGF0YV0gRXZlbnQgZGF0YVxuICAgICAqL1xuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKG9iaiwgdHlwZSwgZXZlbnREYXRhKSB7XG4gICAgICAgIHZhciByTW91c2VFdmVudCA9IC8obW91c2V8Y2xpY2spLztcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQoZXZlbnREYXRhKSAmJiByTW91c2VFdmVudC5leGVjKHR5cGUpKSB7XG4gICAgICAgICAgICBldmVudERhdGEgPSBkb21ldmVudC5tb3VzZUV2ZW50KHR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iai5kaXNwYXRjaEV2ZW50KSB7XG4gICAgICAgICAgICBvYmouZGlzcGF0Y2hFdmVudChldmVudERhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iai5maXJlRXZlbnQpIHtcbiAgICAgICAgICAgIG9iai5maXJlRXZlbnQoJ29uJyArIHR5cGUsIGV2ZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHZpcnR1YWwgbW91c2UgZXZlbnQuXG4gICAgICpcbiAgICAgKiBUZXN0ZWQgYXRcbiAgICAgKlxuICAgICAqIC0gSUU3IH4gSUUxMVxuICAgICAqIC0gQ2hyb21lXG4gICAgICogLSBGaXJlZm94XG4gICAgICogLSBTYWZhcmlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtldmVudE9ial0gRXZlbnQgZGF0YVxuICAgICAqIEByZXR1cm5zIHtNb3VzZUV2ZW50fSBWaXJ0dWFsIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIG1vdXNlRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIGV2ZW50T2JqKSB7XG4gICAgICAgIHZhciBldnQsXG4gICAgICAgICAgICBlO1xuXG4gICAgICAgIGUgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogKHR5cGUgIT09ICdtb3VzZW1vdmUnKSxcbiAgICAgICAgICAgIHZpZXc6IHdpbmRvdyxcbiAgICAgICAgICAgIHdoZWVsRGVsdGE6IDAsXG4gICAgICAgICAgICBkZXRhaWw6IDAsXG4gICAgICAgICAgICBzY3JlZW5YOiAwLFxuICAgICAgICAgICAgc2NyZWVuWTogMCxcbiAgICAgICAgICAgIGNsaWVudFg6IDAsXG4gICAgICAgICAgICBjbGllbnRZOiAwLFxuICAgICAgICAgICAgY3RybEtleTogZmFsc2UsXG4gICAgICAgICAgICBhbHRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgc2hpZnRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgbWV0YUtleTogZmFsc2UsXG4gICAgICAgICAgICBidXR0b246IDAsXG4gICAgICAgICAgICByZWxhdGVkVGFyZ2V0OiB1bmRlZmluZWQgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgfSwgZXZlbnRPYmopO1xuXG4gICAgICAgIC8vIHByZXZlbnQgdGhyb3cgZXJyb3Igd2hlbiBpbnNlcnRpbmcgd2hlZWxEZWx0YSBwcm9wZXJ0eSB0byBtb3VzZSBldmVudCBvbiBiZWxvdyBJRThcbiAgICAgICAgaWYgKGJyb3dzZXIubXNpZSAmJiBicm93c2VyLnZlcnNpb24gPCA5KSB7XG4gICAgICAgICAgICBkZWxldGUgZS53aGVlbERlbHRhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG4gICAgICAgICAgICBldnQuaW5pdE1vdXNlRXZlbnQodHlwZSxcbiAgICAgICAgICAgICAgICBlLmJ1YmJsZXMsIGUuY2FuY2VsYWJsZSwgZS52aWV3LCBlLmRldGFpbCxcbiAgICAgICAgICAgICAgICBlLnNjcmVlblgsIGUuc2NyZWVuWSwgZS5jbGllbnRYLCBlLmNsaWVudFksXG4gICAgICAgICAgICAgICAgZS5jdHJsS2V5LCBlLmFsdEtleSwgZS5zaGlmdEtleSwgZS5tZXRhS2V5LFxuICAgICAgICAgICAgICAgIGUuYnV0dG9uLCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QpIHtcbiAgICAgICAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCk7XG5cbiAgICAgICAgICAgIHV0aWwuZm9yRWFjaChlLCBmdW5jdGlvbih2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICBldnRbcHJvcE5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIGV2dC5idXR0b24gPSB7MDogMSwgMTogNCwgMjogMn1bZXZ0LmJ1dHRvbl0gfHwgZXZ0LmJ1dHRvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZ0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgbW91c2UgZXZlbnQncyBidXR0b24gYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIENhbiBkZXRlY3Qgd2hpY2ggYnV0dG9uIGlzIGNsaWNrZWQgYnkgdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBNZWFuaW5nIG9mIHJldHVybiBudW1iZXJzXG4gICAgICpcbiAgICAgKiAtIDA6IHByaW1hcnkgbW91c2UgYnV0dG9uXG4gICAgICogLSAxOiB3aGVlbCBidXR0b24gb3IgY2VudGVyIGJ1dHRvblxuICAgICAqIC0gMjogc2Vjb25kYXJ5IG1vdXNlIGJ1dHRvblxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gbW91c2VFdmVudCAtIFRoZSBtb3VzZSBldmVudCBvYmplY3Qgd2FudCB0byBrbm93LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIHZhbHVlIG9mIG1lYW5pbmcgd2hpY2ggYnV0dG9uIGlzIGNsaWNrZWQ/XG4gICAgICovXG4gICAgZ2V0TW91c2VCdXR0b246IGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgdmFyIGJ1dHRvbixcbiAgICAgICAgICAgIHByaW1hcnkgPSAnMCwxLDMsNSw3JyxcbiAgICAgICAgICAgIHNlY29uZGFyeSA9ICcyLDYnLFxuICAgICAgICAgICAgd2hlZWwgPSAnNCc7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ01vdXNlRXZlbnRzJywgJzIuMCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gbW91c2VFdmVudC5idXR0b247XG4gICAgICAgIH1cblxuICAgICAgICBidXR0b24gPSBtb3VzZUV2ZW50LmJ1dHRvbiArICcnO1xuICAgICAgICBpZiAofnByaW1hcnkuaW5kZXhPZihidXR0b24pKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIGlmICh+c2Vjb25kYXJ5LmluZGV4T2YoYnV0dG9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH0gZWxzZSBpZiAofndoZWVsLmluZGV4T2YoYnV0dG9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRvbWV2ZW50O1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVXRpbGl0eSBtb2R1bGVzIGZvciBtYW5pcHVsYXRlIERPTSBlbGVtZW50cy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkb21ldmVudCA9IHJlcXVpcmUoJy4vZG9tZXZlbnQnKTtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9uJyk7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWwsXG4gICAgcG9zS2V5ID0gJ19wb3MnLFxuICAgIGRvbXV0aWw7XG5cbnZhciBDU1NfQVVUT19SRUdFWCA9IC9eYXV0byR8XiR8JS87XG5cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzXFxzKi8sICcnKS5yZXBsYWNlKC9cXHNcXHMqJC8sICcnKTtcbn1cblxuZG9tdXRpbCA9IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgRE9NIGVsZW1lbnQgYW5kIHJldHVybiBpdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSBUYWcgbmFtZSB0byBhcHBlbmQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2NvbnRhaW5lcl0gSFRNTCBlbGVtZW50IHdpbGwgYmUgcGFyZW50IHRvIGNyZWF0ZWQgZWxlbWVudC5cbiAgICAgKiBpZiBub3Qgc3VwcGxpZWQsIHdpbGwgdXNlICoqZG9jdW1lbnQuYm9keSoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjbGFzc05hbWVdIERlc2lnbiBjbGFzcyBuYW1lcyB0byBhcHBsaW5nIGNyZWF0ZWQgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IEhUTUwgZWxlbWVudCBjcmVhdGVkLlxuICAgICAqL1xuICAgIGFwcGVuZEhUTUxFbGVtZW50OiBmdW5jdGlvbih0YWdOYW1lLCBjb250YWluZXIsIGNsYXNzTmFtZSkge1xuICAgICAgICB2YXIgZWw7XG5cbiAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8ICcnO1xuXG4gICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuXG4gICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGVsZW1lbnQgZnJvbSBwYXJlbnQgbm9kZS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgaWYgKGVsICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBlbGVtZW50IGJ5IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIGVsZW1lbnQgaWQgYXR0cmlidXRlXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBzdXBwbGllZCBlbGVtZW50IGlzIG1hdGNoZWQgc2VsZWN0b3IuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBlbGVtZW50IHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIC0gc2VsZWN0b3Igc3RyaW5nIHRvIGNoZWNrXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gbWF0Y2g/XG4gICAgICovXG4gICAgX21hdGNoZXI6IGZ1bmN0aW9uKGVsLCBzZWxlY3Rvcikge1xuICAgICAgICB2YXIgY3NzQ2xhc3NTZWxlY3RvciA9IC9eXFwuLyxcbiAgICAgICAgICAgIGlkU2VsZWN0b3IgPSAvXiMvO1xuXG4gICAgICAgIGlmIChjc3NDbGFzc1NlbGVjdG9yLnRlc3Qoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9tdXRpbC5oYXNDbGFzcyhlbCwgc2VsZWN0b3IucmVwbGFjZSgnLicsICcnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaWRTZWxlY3Rvci50ZXN0KHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsLmlkID09PSBzZWxlY3Rvci5yZXBsYWNlKCcjJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHNlbGVjdG9yLnRvTG93ZXJDYXNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgRE9NIGVsZW1lbnQgYnkgc3BlY2lmaWMgc2VsZWN0b3JzLlxuICAgICAqIGJlbG93IHRocmVlIHNlbGVjdG9yIG9ubHkgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogMS4gY3NzIHNlbGVjdG9yXG4gICAgICogMi4gaWQgc2VsZWN0b3JcbiAgICAgKiAzLiBub2RlTmFtZSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7KEhUTUxFbGVtZW50fHN0cmluZyl9IFtyb290XSBZb3UgY2FuIGFzc2lnbiByb290IGVsZW1lbnQgdG8gZmluZC4gaWYgbm90IHN1cHBsaWVkLCBkb2N1bWVudC5ib2R5IHdpbGwgdXNlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxmdW5jdGlvbn0gW211bHRpcGxlPWZhbHNlXSAtIHNldCB0cnVlIHRoZW4gcmV0dXJuIGFsbCBlbGVtZW50cyB0aGF0IG1lZXQgY29uZGl0aW9uLCBpZiBzZXQgZnVuY3Rpb24gdGhlbiB1c2UgaXQgZmlsdGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gSFRNTCBlbGVtZW50IGZpbmRlZC5cbiAgICAgKi9cbiAgICBmaW5kOiBmdW5jdGlvbihzZWxlY3Rvciwgcm9vdCwgbXVsdGlwbGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgZm91bmQgPSBmYWxzZSxcbiAgICAgICAgICAgIGlzRmlyc3QgPSB1dGlsLmlzVW5kZWZpbmVkKG11bHRpcGxlKSB8fCBtdWx0aXBsZSA9PT0gZmFsc2UsXG4gICAgICAgICAgICBpc0ZpbHRlciA9IHV0aWwuaXNGdW5jdGlvbihtdWx0aXBsZSk7XG5cbiAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcocm9vdCkpIHtcbiAgICAgICAgICAgIHJvb3QgPSBkb211dGlsLmdldChyb290KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcm9vdCA9IHJvb3QgfHwgd2luZG93LmRvY3VtZW50LmJvZHk7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVjdXJzZShlbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gZWwuY2hpbGROb2RlcyxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBsZW4gPSBjaGlsZE5vZGVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjdXJzb3I7XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IgPSBjaGlsZE5vZGVzW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci5ub2RlTmFtZSA9PT0gJyN0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZG9tdXRpbC5fbWF0Y2hlcihjdXJzb3IsIHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGlzRmlsdGVyICYmIG11bHRpcGxlKGN1cnNvcikpIHx8ICFpc0ZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3Vyc29yLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZWN1cnNlKGN1cnNvciwgc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVjdXJzZShyb290LCBzZWxlY3Rvcik7XG5cbiAgICAgICAgcmV0dXJuIGlzRmlyc3QgPyAocmVzdWx0WzBdIHx8IG51bGwpIDogcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHBhcmVudCBlbGVtZW50IHJlY3Vyc2l2ZWx5LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gYmFzZSBlbGVtZW50IHRvIHN0YXJ0IGZpbmQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIC0gc2VsZWN0b3Igc3RyaW5nIGZvciBmaW5kXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSAtIGVsZW1lbnQgZmluZGVkIG9yIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBjbG9zZXN0OiBmdW5jdGlvbihlbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG5cbiAgICAgICAgaWYgKGRvbXV0aWwuX21hdGNoZXIoZWwsIHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQgIT09IHdpbmRvdy5kb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICBpZiAoZG9tdXRpbC5fbWF0Y2hlcihwYXJlbnQsIHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0ZXh0cyBpbnNpZGUgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGV4dCBpbnNpZGUgbm9kZVxuICAgICAqL1xuICAgIHRleHQ6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHZhciByZXQgPSAnJyxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbm9kZVR5cGUgPSBlbC5ub2RlVHlwZTtcblxuICAgICAgICBpZiAobm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgICAgICAgICAvLyBub2RlcyB0aGF0IGF2YWlsYWJsZSBjb250YWluIG90aGVyIG5vZGVzXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbC50ZXh0Q29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoZWwgPSBlbC5maXJzdENoaWxkOyBlbDsgZWwgPSBlbC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXQgKz0gZG9tdXRpbC50ZXh0KGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgLy8gVEVYVCwgQ0RBVEEgU0VDVElPTlxuICAgICAgICAgICAgICAgIHJldHVybiBlbC5ub2RlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKDsgZWxbaV07IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHJldCArPSBkb211dGlsLnRleHQoZWxbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIHNldERhdGE6IGZ1bmN0aW9uKGVsLCBrZXksIGRhdGEpIHtcbiAgICAgICAgaWYgKCdkYXRhc2V0JyBpbiBlbCkge1xuICAgICAgICAgICAgZWwuZGF0YXNldFtrZXldID0gZGF0YTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS0nICsga2V5LCBkYXRhKTtcbiAgICB9LFxuXG4gICAgZ2V0RGF0YTogZnVuY3Rpb24oZWwsIGtleSkge1xuICAgICAgICBpZiAoJ2RhdGFzZXQnIGluIGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwuZGF0YXNldFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnZGF0YS0nICsga2V5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgZWxlbWVudCBoYXMgc3BlY2lmaWMgZGVzaWduIGNsYXNzIG5hbWUuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBjc3MgY2xhc3NcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJuIHRydWUgd2hlbiBlbGVtZW50IGhhcyB0aGF0IGNzcyBjbGFzcyBuYW1lXG4gICAgICovXG4gICAgaGFzQ2xhc3M6IGZ1bmN0aW9uKGVsLCBuYW1lKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWU7XG5cbiAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKGVsLmNsYXNzTGlzdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc05hbWUgPSBkb211dGlsLmdldENsYXNzKGVsKTtcblxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIG5hbWUgKyAnKFxcXFxzfCQpJykudGVzdChjbGFzc05hbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgZGVzaWduIGNsYXNzIHRvIEhUTUwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNzcyBjbGFzcyBuYW1lXG4gICAgICovXG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKGVsLCBuYW1lKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWU7XG5cbiAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKGVsLmNsYXNzTGlzdCkpIHtcbiAgICAgICAgICAgIHV0aWwuZm9yRWFjaEFycmF5KG5hbWUuc3BsaXQoJyAnKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKCFkb211dGlsLmhhc0NsYXNzKGVsLCBuYW1lKSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gZG9tdXRpbC5nZXRDbGFzcyhlbCk7XG4gICAgICAgICAgICBkb211dGlsLnNldENsYXNzKGVsLCAoY2xhc3NOYW1lID8gY2xhc3NOYW1lICsgJyAnIDogJycpICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBPdmVyd3JpdGUgZGVzaWduIGNsYXNzIHRvIEhUTUwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNzcyBjbGFzcyBuYW1lXG4gICAgICovXG4gICAgc2V0Q2xhc3M6IGZ1bmN0aW9uKGVsLCBuYW1lKSB7XG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGVsLmNsYXNzTmFtZS5iYXNlVmFsKSkge1xuICAgICAgICAgICAgZWwuY2xhc3NOYW1lID0gbmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTmFtZS5iYXNlVmFsID0gbmFtZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbGVtZW507JeQIGNzc0NsYXNz7IaN7ISx7J2EIOygnOqxsO2VmOuKlCDrqZTshJzrk5xcbiAgICAgKiBSZW1vdmUgc3BlY2lmaWMgZGVzaWduIGNsYXNzIGZyb20gSFRNTCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgY2xhc3MgbmFtZSB0byByZW1vdmVcbiAgICAgKi9cbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oZWwsIG5hbWUpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSAnJztcblxuICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWQoZWwuY2xhc3NMaXN0KSkge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZWQgPSAoJyAnICsgZG9tdXRpbC5nZXRDbGFzcyhlbCkgKyAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKTtcbiAgICAgICAgICAgIGRvbXV0aWwuc2V0Q2xhc3MoZWwsIHRyaW0ocmVtb3ZlZCkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBIVE1MIGVsZW1lbnQncyBkZXNpZ24gY2xhc3Nlcy5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGVsZW1lbnQgY3NzIGNsYXNzIG5hbWVcbiAgICAgKi9cbiAgICBnZXRDbGFzczogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgaWYgKCFlbCB8fCAhZWwuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXRpbC5pc1VuZGVmaW5lZChlbC5jbGFzc05hbWUuYmFzZVZhbCkgPyBlbC5jbGFzc05hbWUgOiBlbC5jbGFzc05hbWUuYmFzZVZhbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNwZWNpZmljIENTUyBzdHlsZSB2YWx1ZSBmcm9tIEhUTUwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZSBjc3MgYXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7KHN0cmluZ3xudWxsKX0gY3NzIHN0eWxlIHZhbHVlXG4gICAgICovXG4gICAgZ2V0U3R5bGU6IGZ1bmN0aW9uKGVsLCBzdHlsZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBlbC5zdHlsZVtzdHlsZV0gfHwgKGVsLmN1cnJlbnRTdHlsZSAmJiBlbC5jdXJyZW50U3R5bGVbc3R5bGVdKSxcbiAgICAgICAgICAgIGNzcztcblxuICAgICAgICBpZiAoKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2F1dG8nKSAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldykge1xuICAgICAgICAgICAgY3NzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XG4gICAgICAgICAgICB2YWx1ZSA9IGNzcyA/IGNzc1tzdHlsZV0gOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAnYXV0bycgPyBudWxsIDogdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCBlbGVtZW50J3MgY29tcHV0ZWQgc3R5bGUgdmFsdWVzLlxuICAgICAqXG4gICAgICogaW4gbG93ZXIgSUU4LiB1c2UgcG9seWZpbGwgZnVuY3Rpb24gdGhhdCByZXR1cm4gb2JqZWN0LiBpdCBoYXMgb25seSBvbmUgZnVuY3Rpb24gJ2dldFByb3BlcnR5VmFsdWUnXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBlbGVtZW50IHdhbnQgdG8gZ2V0IHN0eWxlLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHZpcnR1YWwgQ1NTU3R5bGVEZWNsYXJhdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgZ2V0Q29tcHV0ZWRTdHlsZTogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRWaWV3ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cbiAgICAgICAgaWYgKCFkZWZhdWx0VmlldyB8fCAhZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBnZXRQcm9wZXJ0eVZhbHVlOiBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZSA9IC8oXFwtKFthLXpdKXsxfSkvZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICdmbG9hdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgPSAnc3R5bGVGbG9hdCc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocmUudGVzdChwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCA9IHByb3AucmVwbGFjZShyZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbMl0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLmN1cnJlbnRTdHlsZVtwcm9wXSA/IGVsLmN1cnJlbnRTdHlsZVtwcm9wXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHBvc2l0aW9uIENTUyBzdHlsZS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSBsZWZ0IHBpeGVsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSB0b3AgcGl4ZWwgdmFsdWUuXG4gICAgICovXG4gICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uKGVsLCB4LCB5KSB7XG4gICAgICAgIHggPSB1dGlsLmlzVW5kZWZpbmVkKHgpID8gMCA6IHg7XG4gICAgICAgIHkgPSB1dGlsLmlzVW5kZWZpbmVkKHkpID8gMCA6IHk7XG5cbiAgICAgICAgZWxbcG9zS2V5XSA9IFt4LCB5XTtcblxuICAgICAgICBlbC5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgICAgIGVsLnN0eWxlLnRvcCA9IHkgKyAncHgnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcG9zaXRpb24gZnJvbSBIVE1MIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjbGVhcj1mYWxzZV0gY2xlYXIgY2FjaGUgYmVmb3JlIGNhbGN1bGF0aW5nIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gcG9pbnRcbiAgICAgKi9cbiAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24oZWwsIGNsZWFyKSB7XG4gICAgICAgIHZhciBsZWZ0LFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgYm91bmQ7XG5cbiAgICAgICAgaWYgKGNsZWFyKSB7XG4gICAgICAgICAgICBlbFtwb3NLZXldID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbFtwb3NLZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxbcG9zS2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlZnQgPSAwO1xuICAgICAgICB0b3AgPSAwO1xuXG4gICAgICAgIGlmICgoQ1NTX0FVVE9fUkVHRVgudGVzdChlbC5zdHlsZS5sZWZ0KSB8fCBDU1NfQVVUT19SRUdFWC50ZXN0KGVsLnN0eWxlLnRvcCkpICYmXG4gICAgICAgICAgICAnZ2V0Qm91bmRpbmdDbGllbnRSZWN0JyBpbiBlbCkge1xuICAgICAgICAgICAgLy8g7JeY66as66i87Yq47J2YIGxlZnTrmJDripQgdG9w7J20ICdhdXRvJ+ydvCDrlYwg7IiY64uoXG4gICAgICAgICAgICBib3VuZCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICBsZWZ0ID0gYm91bmQubGVmdDtcbiAgICAgICAgICAgIHRvcCA9IGJvdW5kLnRvcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSBwYXJzZUZsb2F0KGVsLnN0eWxlLmxlZnQgfHwgMCk7XG4gICAgICAgICAgICB0b3AgPSBwYXJzZUZsb2F0KGVsLnN0eWxlLnRvcCB8fCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbGVmdCwgdG9wXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGVsZW1lbnQncyBzaXplXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJbXX0gd2lkdGgsIGhlaWdodFxuICAgICAqL1xuICAgIGdldFNpemU6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHZhciBib3VuZCxcbiAgICAgICAgICAgIHdpZHRoID0gZG9tdXRpbC5nZXRTdHlsZShlbCwgJ3dpZHRoJyksXG4gICAgICAgICAgICBoZWlnaHQgPSBkb211dGlsLmdldFN0eWxlKGVsLCAnaGVpZ2h0Jyk7XG5cbiAgICAgICAgaWYgKChDU1NfQVVUT19SRUdFWC50ZXN0KHdpZHRoKSB8fCBDU1NfQVVUT19SRUdFWC50ZXN0KGhlaWdodCkpICYmXG4gICAgICAgICAgICAnZ2V0Qm91bmRpbmdDbGllbnRSZWN0JyBpbiBlbCkge1xuICAgICAgICAgICAgYm91bmQgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHdpZHRoID0gYm91bmQud2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSBib3VuZC5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aWR0aCA9IHBhcnNlRmxvYXQod2lkdGggfHwgMCk7XG4gICAgICAgICAgICBoZWlnaHQgPSBwYXJzZUZsb2F0KGhlaWdodCB8fCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbd2lkdGgsIGhlaWdodF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHNwZWNpZmljIENTUyBzdHlsZSBpcyBhdmFpbGFibGUuXG4gICAgICogQHBhcmFtIHthcnJheX0gcHJvcHMgcHJvcGVydHkgbmFtZSB0byB0ZXN0aW5nXG4gICAgICogQHJldHVybiB7KHN0cmluZ3xib29sZWFuKX0gcmV0dXJuIHRydWUgd2hlbiBwcm9wZXJ0eSBpcyBhdmFpbGFibGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwcm9wcyA9IFsndHJhbnNmb3JtJywgJy13ZWJraXQtdHJhbnNmb3JtJ107XG4gICAgICogZG9tdXRpbC50ZXN0UHJvcChwcm9wcyk7ICAgIC8vICd0cmFuc2Zvcm0nXG4gICAgICovXG4gICAgdGVzdFByb3A6IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChwcm9wc1tpXSBpbiBzdHlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBmb3JtIGRhdGFcbiAgICAgKiBAcGFyYW0ge0hUTUxGb3JtRWxlbWVudH0gZm9ybUVsZW1lbnQgLSBmb3JtIGVsZW1lbnQgdG8gZXh0cmFjdCBkYXRhXG4gICAgICogQHJldHVybnMge29iamVjdH0gZm9ybSBkYXRhXG4gICAgICovXG4gICAgZ2V0Rm9ybURhdGE6IGZ1bmN0aW9uKGZvcm1FbGVtZW50KSB7XG4gICAgICAgIHZhciBncm91cGVkQnlOYW1lID0gbmV3IENvbGxlY3Rpb24oZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmxlbmd0aDsgfSksXG4gICAgICAgICAgICBub0Rpc2FibGVkRmlsdGVyID0gZnVuY3Rpb24oZWwpIHsgcmV0dXJuICFlbC5kaXNhYmxlZDsgfSxcbiAgICAgICAgICAgIG91dHB1dCA9IHt9O1xuICAgICAgICAgICAgXG4gICAgICAgIGdyb3VwZWRCeU5hbWUuYWRkLmFwcGx5KFxuICAgICAgICAgICAgZ3JvdXBlZEJ5TmFtZSwgXG4gICAgICAgICAgICBkb211dGlsLmZpbmQoJ2lucHV0JywgZm9ybUVsZW1lbnQsIG5vRGlzYWJsZWRGaWx0ZXIpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChkb211dGlsLmZpbmQoJ3NlbGVjdCcsIGZvcm1FbGVtZW50LCBub0Rpc2FibGVkRmlsdGVyKSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KGRvbXV0aWwuZmluZCgndGV4dGFyZWEnLCBmb3JtRWxlbWVudCwgbm9EaXNhYmxlZEZpbHRlcikpXG4gICAgICAgICk7XG5cbiAgICAgICAgZ3JvdXBlZEJ5TmFtZSA9IGdyb3VwZWRCeU5hbWUuZ3JvdXBCeShmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsICYmIGVsLmdldEF0dHJpYnV0ZSgnbmFtZScpIHx8ICdfb3RoZXInO1xuICAgICAgICB9KTtcblxuICAgICAgICB1dGlsLmZvckVhY2goZ3JvdXBlZEJ5TmFtZSwgZnVuY3Rpb24oZWxlbWVudHMsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnX290aGVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbWVudHMuZWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBlbC50eXBlLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAncmFkaW8nIHx8IHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZWxlbWVudHMuZmluZChmdW5jdGlvbihlbCkgeyByZXR1cm4gZWwuY2hlY2tlZDsgfSkudG9BcnJheSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZU5hbWUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLmZpbmQoZnVuY3Rpb24oZWwpIHsgcmV0dXJuICEhZWwuY2hpbGROb2Rlcy5sZW5ndGg7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoZG9tdXRpbC5maW5kKCdvcHRpb24nLCBlbCwgZnVuY3Rpb24ob3B0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHQuc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZWxlbWVudHMuZmluZChmdW5jdGlvbihlbCkgeyByZXR1cm4gZWwudmFsdWUgIT09ICcnOyB9KS50b0FycmF5KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdXRpbC5tYXAocmVzdWx0LCBmdW5jdGlvbihlbCkgeyByZXR1cm4gZWwudmFsdWU7IH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRbMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb3V0cHV0W25hbWVdID0gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxufTtcblxuLyplc2xpbnQtZGlzYWJsZSovXG52YXIgdXNlclNlbGVjdFByb3BlcnR5ID0gZG9tdXRpbC50ZXN0UHJvcChbXG4gICAgJ3VzZXJTZWxlY3QnLCBcbiAgICAnV2Via2l0VXNlclNlbGVjdCcsIFxuICAgICdPVXNlclNlbGVjdCcsIFxuICAgICdNb3pVc2VyU2VsZWN0JywgXG4gICAgJ21zVXNlclNlbGVjdCdcbl0pO1xudmFyIHN1cHBvcnRTZWxlY3RTdGFydCA9ICdvbnNlbGVjdHN0YXJ0JyBpbiBkb2N1bWVudDtcbnZhciBwcmV2U2VsZWN0U3R5bGUgPSAnJztcbi8qZXNsaW50LWVuYWJsZSovXG5cbi8qKlxuICogRGlzYWJsZSBicm93c2VyJ3MgdGV4dCBzZWxlY3Rpb24gYmVoYXZpb3JzLlxuICogQG1ldGhvZFxuICovXG5kb211dGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzdXBwb3J0U2VsZWN0U3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZG9tZXZlbnQub24od2luZG93LCAnc2VsZWN0c3RhcnQnLCBkb21ldmVudC5wcmV2ZW50RGVmYXVsdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG4gICAgICAgIHByZXZTZWxlY3RTdHlsZSA9IHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV07XG4gICAgICAgIHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSAnbm9uZSc7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogRW5hYmxlIGJyb3dzZXIncyB0ZXh0IHNlbGVjdGlvbiBiZWhhdmlvcnMuXG4gKiBAbWV0aG9kXG4gKi9cbmRvbXV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbiA9IChmdW5jdGlvbigpIHtcbiAgICBpZiAoc3VwcG9ydFNlbGVjdFN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRvbWV2ZW50Lm9mZih3aW5kb3csICdzZWxlY3RzdGFydCcsIGRvbWV2ZW50LnByZXZlbnREZWZhdWx0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gcHJldlNlbGVjdFN0eWxlO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIERpc2FibGUgYnJvd3NlcidzIGltYWdlIGRyYWcgYmVoYXZpb3JzLlxuICovXG5kb211dGlsLmRpc2FibGVJbWFnZURyYWcgPSBmdW5jdGlvbigpIHtcbiAgICBkb21ldmVudC5vbih3aW5kb3csICdkcmFnc3RhcnQnLCBkb21ldmVudC5wcmV2ZW50RGVmYXVsdCk7XG59O1xuXG4vKipcbiAqIEVuYWJsZSBicm93c2VyJ3MgaW1hZ2UgZHJhZyBiZWhhdmlvcnMuXG4gKi9cbmRvbXV0aWwuZW5hYmxlSW1hZ2VEcmFnID0gZnVuY3Rpb24oKSB7XG4gICAgZG9tZXZlbnQub2ZmKHdpbmRvdywgJ2RyYWdzdGFydCcsIGRvbWV2ZW50LnByZXZlbnREZWZhdWx0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZG9tdXRpbDtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1peGluIG1vZHVsZSBmb3IgbW9kZWxzLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbCxcbiAgICBzcGFjZVJ4ID0gL15cXHMqfFxccyokL2csXG4gICAgbW9kZWw7XG5cbnZhciBkYXRldGltZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9kYXRldGltZScpO1xuXG4vKipcbiAqIE1peGluIG1vZHVsZSBmb3IgbW9kZWxzLlxuICogQG1peGluXG4gKi9cbm1vZGVsID0ge1xuICAgIC8qKlxuICAgICAqIHN0cmluZyB0cmltXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBzdHJpbmcgdG8gdHJpbVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRyaW1lZCBzdHJpbmdcbiAgICAgKi9cbiAgICB0cmltOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKHNwYWNlUngsICcnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBjb2xsZWN0aW9ucyBvZiB2YWxpZGF0b3IgZnVuY3Rpb25zLlxuICAgICAqL1xuICAgIHZhbGlkYXRvcnM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoZWNrIGFsbCBvZiBzdXBwbGllZCBmaWVsZHMocHJvcGVydHkpIGlzIG5vdCB1bmRlZmluZWQgb3IgZW1wdHkgc3RyaW5nLlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdGFuY2UgbW9kZWwgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkcyBwcm9wZXJ0eSBuYW1lcyB0byBjaGVjay5cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybiB0cnVlIHdoZW4gc3VwcGxpZWQgZmllbGRzIGFyZSBub3QgdW5kZWZpbmVkIG9yIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHJlcXVpcmVkOiBmdW5jdGlvbihpbnN0YW5jZSwgZmllbGRzKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWQgPSB0cnVlLFxuICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF1dGlsLmlzVW5kZWZpbmVkKG9iaikgJiYgbW9kZWwudHJpbShvYmopICE9PSAnJztcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB1dGlsLmZvckVhY2goZmllbGRzLCBmdW5jdGlvbihmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YWxpZCA9IGlzVmFsaWQoaW5zdGFuY2VbZmllbGROYW1lXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB2YWxpZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hlY2sgc3VwcGxpZWQgZmllbGRzIGFyZSB2YWxpZCBkYXRlcyBhbmQgdmFsaWQgZGF0ZSByYW5nZXMuXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0YW5jZSBtb2RlbCBpbnN0YW5jZS5cbiAgICAgICAgICogQHBhcmFtIHtEYXRlW119IGZpZWxkcyBhcnJheSBvZiBkYXRlIHJhbmdlIChzdGFydHMsIGVuZHMpXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBpcyB2YWxpZCBkYXRlIHJhbmdlP1xuICAgICAgICAgKi9cbiAgICAgICAgZGF0ZVJhbmdlOiBmdW5jdGlvbihpbnN0YW5jZSwgZmllbGRzKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRzLFxuICAgICAgICAgICAgICAgIGVuZHM7XG5cbiAgICAgICAgICAgIGlmICghdXRpbC5pc0V4aXN0eShpbnN0YW5jZSkgfHwgZmllbGRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGFydHMgPSBuZXcgRGF0ZShpbnN0YW5jZVtmaWVsZHNbMF1dKTtcbiAgICAgICAgICAgIGVuZHMgPSBuZXcgRGF0ZShpbnN0YW5jZVtmaWVsZHNbMV1dKTtcblxuICAgICAgICAgICAgaWYgKCFkYXRldGltZS5pc1ZhbGlkKHN0YXJ0cykgfHwgIWRhdGV0aW1lLmlzVmFsaWQoZW5kcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRldGltZS5jb21wYXJlKHN0YXJ0cywgZW5kcykgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHZhbGlkYXRlIGZvciBtb2RlbCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIFRoZSB2YWxpZGF0ZSBhcmUgd29ya3Mgb24gYSBiYXNpcyBvZiBjb25zdHJ1Y3RvcidzIFwic2NoZW1hXCIgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGN1c3RvbWl6ZSB2YWxpZGF0b3JzIGFkZCBzb21lIG1ldGhvZCB0byBtb2RlbCN2YWxpZGF0b3JzLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBtb2RlbCBpcyB2YWxpZD9cbiAgICAgKi9cbiAgICBpc1ZhbGlkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgc2NoZW1hID0gdGhpcy5jb25zdHJ1Y3Rvci5zY2hlbWEsXG4gICAgICAgICAgICB2YWxpZGF0b3JzID0gbW9kZWwudmFsaWRhdG9ycyxcbiAgICAgICAgICAgIHZhbGlkYXRvcixcbiAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXNjaGVtYSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB1dGlsLmZvckVhY2goc2NoZW1hLCBmdW5jdGlvbih2YWx1ZXMsIHZhbGlkYXRvck5hbWUpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvciA9IHZhbGlkYXRvcnNbdmFsaWRhdG9yTmFtZV07XG5cbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICB2YWxpZCA9IHZhbGlkYXRvcih0aGF0LCB2YWx1ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGRhdGEgb2JqZWN0IGZvcm0gaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBJdCByZXR1cm4gb2JqZWN0IGZpbGwgd2l0aCBhbGwgb3duZWQgcHJvcGVydGllcyBidXQgZXhjbHVkZSBmdW5jdGlvbnMuXG4gICAgICogQHJldHVybnMge29iamVjdH0gRGF0YSBvYmplY3RcbiAgICAgKi9cbiAgICBwYXJhbWV0ZXJpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSB7fSxcbiAgICAgICAgICAgIGlzRnVuYyA9IHV0aWwuaXNGdW5jdGlvbjtcblxuICAgICAgICB1dGlsLmZvckVhY2godGhpcywgZnVuY3Rpb24odmFsdWUsIHByb3BOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWlzRnVuYyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBwYXJhbVtwcm9wTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNaXhpbiBtb2RlbCBtb2R1bGUgdG8gc3VwcGxpZWQgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCBvZiB3YW50IHRvIG1peGVkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogZnVuY3Rpb24gTWFuKCkge1xuICAgICAqICAgICB0aGlzLm5hbWUgPSAnam9obic7XG4gICAgICogfVxuICAgICAqIG1vZGVsLm1peGluKE1hbi5wcm90b3R5cGUpO1xuICAgICAqL1xuICAgIG1peGluOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgdXRpbC5mb3JFYWNoKG1vZGVsLCBmdW5jdGlvbihtZXRob2QsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSAnbWl4aW4nKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gbWV0aG9kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1vZGVsO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqIENsYXNzIGZvciByZXByZXNlbnQgdHdvIGRpbWVuc2lvbmFsIHgsIHkgY29vcmRpbmF0ZXMuXG4gKlxuICogSXQgc3VwcGxpeSBhIGdyb3VwIG9mIGZ1bmN0aW9ucyBmb3IgbWFuaXB1bGF0ZSBjb29yZGluYXRlcy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICogQGV4YW1wbGVcbiAqIHZhciBwID0gcG9pbnQoMTAsIDEwKTtcbiAqIHZhciByMSA9IHAuYWRkKFBvaW50KDUsIDUpKTtcbiAqIGNvbnNvbGUubG9nKHAudG9TdHJpbmcoKSkgICAgLy8gXCJQb2ludCgxMCwgMTApXCJcbiAqIGNvbnNvbGUubG9nKHIxLnRvU3RyaW5nKCkpICAgIC8vIFwiUG9pbnQoMTUsIDE1KVwiXG4gKlxuICogdmFyIHAyID0gbmV3IFBvaW50KDEwLCAxMCk7XG4gKiBwMi5fYWRkKHBvaW50KDUsIDUpKTtcbiAqIGNvbnNvbGUubG9nKHAyLnRvU3RyaW5nKCkpICAgLy8gXCJQb2ludCgxNSwgMTUpXCJcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xuXG4vKipcbiAqIENsYXNzIGZvciByZXByZXNlbnQgdHdvIGRpbWVudGlvbmFsIHgsIHkgY29vcmRpbmF0ZXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBudW1iZXIgb2YgWCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSBudW1iZXIgb2YgWSBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZVJvdW5kPWZhbHNlXSBzZXQgdHJ1ZSB3aGVuIGVhY2ggY29vcmRpbmF0ZXMgYXJlIHJvdW5kZWQgYmVmb3JlIGluaXRpYWxpemUuXG4gKiBAZXhhbXBsZVxuICogdmFyIHQgPSBuZXcgUG9pbnQoMTMsIDUpO1xuICovXG5mdW5jdGlvbiBQb2ludCh4LCB5LCB1c2VSb3VuZCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy54ID0gKHVzZVJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnkgPSAodXNlUm91bmQgPyBNYXRoLnJvdW5kKHkpIDogeSk7XG59XG5cbi8qKioqKioqKioqXG4gKiBzdGF0aWMgcHJvcHNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIENhbGN1bGF0ZSBwb2ludCByYXRpby5cbiAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IFRoZSBpbnN0YW5jZSBvZiBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYWN0b3IgRnJvbSBmYWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0ZhY3RvciBUbyBmYWN0b3JcbiAqIEByZXR1cm5zIHtQb2ludH0gUG9pbnQgaW5zdGFuY2UgY2FsY3VsYXRlZC5cbiAqL1xuUG9pbnQuZ2V0UmF0aW8gPSBmdW5jdGlvbihwb2ludCwgZmFjdG9yLCB0b0ZhY3Rvcikge1xuICAgIGlmIChmYWN0b3IgPT09IHRvRmFjdG9yKSB7XG4gICAgICAgIHJldHVybiBwb2ludC5jbG9uZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludC5tdWx0aXBseUJ5KHRvRmFjdG9yKS5fZGl2aWRlQnkoZmFjdG9yKTtcbn07XG5cbi8qKlxuICogU3ludGF0aWMgc3VnYXIgb2YgbmV3IFBvaW50KClcbiAqIEBwYXJhbSB7KFBvaW50fG51bWJlcnxudW1iZXJbXSl9IHggWCBjb29yZGluYXRlIHZhbHVlLlxuICogQHBhcmFtIHsobnVtYmVyfGJvb2xlYW4pfSBbeV0gWSBjb29yZGluYXRlIHZhbHVlIG9yIGJvb2xlYW4gdmFsdWUgZm9yIGNvb3JkaW5hdGVzIHJvdW5kLlxuICogQHBhcmFtIHtib29sZWFufSBbdXNlUm91bmRdIFNldCB0cnVlIHRoZW4gcm91bmQgaW5pdGlhbCBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtQb2ludH0gVGhlIGluc3RhbmNlIG9mIHBvaW50LlxuICogQGV4YW1wbGVcbiAqIHZhciBwMSA9IHBvaW50KDEwLCAxNSk7XG4gKiB2YXIgcDIgPSBwb2ludChbMTAsIDE1XSk7XG4gKi9cblBvaW50Lm4gPSBmdW5jdGlvbih4LCB5LCB1c2VSb3VuZCkge1xuICAgIGlmICh4IGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgaWYgKHV0aWwuaXNBcnJheSh4KSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHhbMF0sIHhbMV0sIHkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgdXNlUm91bmQpO1xufTtcblxuLyoqKioqKioqKipcbiAqIHByb3RvdHlwZSBwcm9wc1xuICoqKioqKioqKiovXG5cbi8qKlxuICogQ2xvbmUgcG9pbnRzXG4gKiBAcmV0dXJucyB7UG9pbnR9IFRoZSBwb2ludCBpbnN0YW5jZSBjbG9uZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xufTtcblxuLyoqXG4gKiBBZGQgcG9pbnRzLlxuICogQHBhcmFtIHtQb2ludH0gcG9pbnQgVGhlIHBvaW50IGluc3RhbmNlIHRvIGFkZC5cbiAqIEByZXR1cm4ge1BvaW50fSBQb2ludCBjYWxjdWxhdGVkLlxuICovXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQoUG9pbnQubihwb2ludCkpO1xufTtcblxuLyoqXG4gKiBBZGQgc2VsZiBwb2ludHMuXG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludCBUaGUgcG9pbnQgaW5zdGFuY2UgdG8gYWRkLlxuICogQHJldHVybiB7UG9pbnR9IFBvaW50IGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5fYWRkID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICB0aGlzLnggKz0gcG9pbnQueDtcbiAgICB0aGlzLnkgKz0gcG9pbnQueTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3VidHJhY3QgcG9pbnRzLlxuICogQHBhcmFtIHtQb2ludH0gcG9pbnQgVGhlIHBvaW50IGluc3RhbmNlIHRvIHN1YnRyYWN0LlxuICogQHJldHVybiB7UG9pbnR9IFBvaW50IGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fc3VidHJhY3QoUG9pbnQubihwb2ludCkpO1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdCBwb2ludHMuIChtYW5pcHVsYXRlIHNlbGYpXG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludCBUaGUgcG9pbnQgaW5zdGFuY2UgdG8gc3VidHJhY3QuXG4gKiBAcmV0dXJucyB7UG9pbnR9IFBvaW50IGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5fc3VidHJhY3QgPSBmdW5jdGlvbihwb2ludCkge1xuICAgIHRoaXMueCAtPSBwb2ludC54O1xuICAgIHRoaXMueSAtPSBwb2ludC55O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEaXZpZGUgcG9pbnRzLlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIGRpdmlkZS5cbiAqIEByZXR1cm5zIHtQb2ludH0gUG9pbnQgY2FsY3VsYXRlZC5cbiAqL1xuUG9pbnQucHJvdG90eXBlLmRpdmlkZUJ5ID0gZnVuY3Rpb24obnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2aWRlQnkobnVtKTtcbn07XG5cbi8qKlxuICogRGl2aWRlIHBvaW50cy4gKG1hbmlwdWxhdGUgc2VsZilcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBkaXZpZGUuXG4gKiBAcmV0dXJucyB7UG9pbnR9IFBvaW50IGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5fZGl2aWRlQnkgPSBmdW5jdGlvbihudW0pIHtcbiAgICB0aGlzLnggLz0gbnVtO1xuICAgIHRoaXMueSAvPSBudW07XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaHllbiBudW1iZXIgdG8gbXVsdGlwbHlcbiAqIEByZXR1cm4ge1BvaW50fSBQb2ludCBjYWxjdWxhdGVkLlxuICovXG5Qb2ludC5wcm90b3R5cGUubXVsdGlwbHlCeSA9IGZ1bmN0aW9uKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuX211bHRpcGx5QnkobnVtKTtcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgc2VsZiBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBtdWx0aXBseS5cbiAqIEByZXR1cm5zIHtQb2ludH0gUG9pbnQgY2FsY3VsYXRlZC5cbiAqL1xuUG9pbnQucHJvdG90eXBlLl9tdWx0aXBseUJ5ID0gZnVuY3Rpb24obnVtKSB7XG4gICAgdGhpcy54ICo9IG51bTtcbiAgICB0aGlzLnkgKj0gbnVtO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSb3VuZCBjb29yZGluYXRlcy5cbiAqIEByZXR1cm5zIHtQb2ludH0gUG9pbnQgY2FsY3VsYXRlZC5cbiAqL1xuUG9pbnQucHJvdG90eXBlLnJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTtcbn07XG5cbi8qKlxuICogUm91bmQgc2VsZiBjb29yZGluYXRlcy5cbiAqIEByZXR1cm5zIHtQb2ludH0gUG9pbnQgY2FsY3VsYXRlZC5cbiAqL1xuUG9pbnQucHJvdG90eXBlLl9yb3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcbiAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldmVyc2UgdmFsdWVzIGJldHdlZW4gcG9zaXRpdmUgYW5kIG5lZ2F0aXZlLlxuICogQHJldHVybnMge1BvaW50fSBQb2ludCBjYWxjdWxhdGVkLlxuICovXG5Qb2ludC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuX3JldmVyc2UoKTtcbn07XG5cbi8qKlxuICogUmV2ZXJzZSBzZWxmIHZhbHVlcyBiZXR3ZWVuIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZS5cbiAqIEByZXR1cm5zIHtQb2ludH0gUG9pbnQgY2FsY3VsYXRlZC5cbiAqL1xuUG9pbnQucHJvdG90eXBlLl9yZXZlcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy54ICo9IC0xO1xuICAgIHRoaXMueSAqPSAtMTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmxvb3IgY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJucyB7UG9pbnR9IFBvaW50IGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5mbG9vciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuX2Zsb29yKCk7XG59O1xuXG4vKipcbiAqIEZsb29yIHNlbGYgY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJucyB7UG9pbnR9IFBvaW50IGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5fZmxvb3IgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XG4gICAgdGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDZWlsIGNvb3JkaW5hdGVzLlxuICogQHJldHVybnMge1BvaW50fSBQb2ludCBjYWxjdWxhdGVkLlxuICovXG5Qb2ludC5wcm90b3R5cGUuY2VpbCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuX2NlaWwoKTtcbn07XG5cbi8qKlxuICogQ2VpbCBzZWxmIGNvb2RpbmF0ZXMuXG4gKiBAcmV0dXJucyB7UG9pbnR9IFBvaW50IGNhbGN1bGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5fY2VpbCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMueCA9IE1hdGguY2VpbCh0aGlzLngpO1xuICAgIHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSb3RhdGUgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVnIFRoZSBudW1iZXIgb2Ygcm90YXRlIGRlZ3JlZS5cbiAqIEBwYXJhbSB7UG9pbnR9IFtjZW50ZXI9dGhpc10gQ2VudGVyIHBvaW50IGluc3RhbmNlIHRvIHVzZSByb3RhdGUgY2VudGVyLiB1c2Ugb3duIHdoZW4gbm90IHN1cHBsaWVkLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb3NdIENvc2luZSB2YWx1ZXMgZm9yIHJvdGF0ZS4gaXQgdXNlZnVsIHdoZW4gbXVsdGkgcG9pbnQgcm90YXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaW5dIFNpbmUgdmFsdWVzIGZvciByb3RhdGUuIGl0IHVzZWZ1bCB3aGVuIG11bHRpIHBvaW50IHJvdGF0ZS5cbiAqIEByZXR1cm5zIHtQb2ludH0gVGhlIHBvaW50IGluc3RhbmNlIHJvdGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbihkZWcsIGNlbnRlciwgY29zLCBzaW4pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3RhdGUoZGVnLCBjZW50ZXIsIGNvcywgc2luKTtcbn07XG5cbi8qKlxuICogUm90YXRlIHNlbGYuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVnIFRoZSBudW1iZXIgb2Ygcm90YXRlIGRlZ3JlZS5cbiAqIEBwYXJhbSB7UG9pbnR9IFtjZW50ZXI9dGhpc10gQ2VudGVyIHBvaW50IGluc3RhbmNlIHRvIHVzZSByb3RhdGUgY2VudGVyLiB1c2Ugb3duIHdoZW4gbm90IHN1cHBsaWVkLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb3NdIENvc2luZSB2YWx1ZXMgZm9yIHJvdGF0ZS4gaXQgdXNlZnVsIHdoZW4gbXVsdGkgcG9pbnQgcm90YXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaW5dIFNpbmUgdmFsdWVzIGZvciByb3RhdGUuIGl0IHVzZWZ1bCB3aGVuIG11bHRpIHBvaW50IHJvdGF0ZS5cbiAqIEByZXR1cm5zIHtQb2ludH0gVGhlIHBvaW50IGluc3RhbmNlIHJvdGF0ZWQuXG4gKi9cblBvaW50LnByb3RvdHlwZS5fcm90YXRlID0gZnVuY3Rpb24oZGVnLCBjZW50ZXIsIGNvcywgc2luKSB7XG4gICAgdmFyIHJhZCA9IGRlZyAqIChNYXRoLlBJIC8gMTgwKSxcbiAgICAgICAgeCxcbiAgICAgICAgeTtcblxuICAgIGNvcyA9IGNvcyB8fCBwYXJzZUZsb2F0KE1hdGguY29zKHJhZCkudG9GaXhlZCg4KSk7XG4gICAgc2luID0gc2luIHx8IHBhcnNlRmxvYXQoTWF0aC5zaW4ocmFkKS50b0ZpeGVkKDgpKTtcblxuICAgIHRoaXMuX3N1YnRyYWN0KGNlbnRlcik7XG5cbiAgICB4ID0gdGhpcy54O1xuICAgIHkgPSB0aGlzLnk7XG5cbiAgICB0aGlzLnggPSB4ICogY29zIC0geSAqIHNpbjtcbiAgICB0aGlzLnkgPSB4ICogc2luICsgeSAqIGNvcztcblxuICAgIHRoaXMuX2FkZChjZW50ZXIpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludCBQb2ludCBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICovXG5Qb2ludC5wcm90b3R5cGUuZGlzdGFuY2VUbyA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgdmFyIHgsXG4gICAgICAgIHk7XG5cbiAgICBwb2ludCA9IFBvaW50Lm4ocG9pbnQpO1xuXG4gICAgeCA9IHBvaW50LnggLSB0aGlzLng7XG4gICAgeSA9IHBvaW50LnkgLSB0aGlzLnk7XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xufTtcblxuLyoqXG4gKiBDaGVjayBwb2ludCBlcXVhbHMuXG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludCBQb2ludCBpbnN0YW5jZSB0byBjb21wYXJlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gZXF1YWxpdHlcbiAqL1xuUG9pbnQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgcG9pbnQgPSBQb2ludC5uKHBvaW50KTtcbiAgICByZXR1cm4gcG9pbnQueCA9PT0gdGhpcy54ICYmIHBvaW50LnkgPT09IHRoaXMueTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGZvcm1hdHRlZCBzdHJpbmcuICdQb2ludCh4LCB5KSdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHN0cmluZ1xuICovXG5Qb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ1BvaW50KCcgKyB0aGlzLnggKyAnLCAnICsgdGhpcy55ICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gY29vZGluYXRlcyB0byBhcnJheS4gW3gsIHldXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IGNvb3JkaW5hdGUgYXJyYXkuXG4gKi9cblBvaW50LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFt0aGlzLngsIHRoaXMueV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVxdWVzdEFuaW1GcmFtZVxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciByZXF1ZXN0Rm4sXG4gICAgY2FuY2VsRm47XG5cbmZ1bmN0aW9uIGdldFByZWZpeGVkKG5hbWUpIHtcbiAgICByZXR1cm4gZ2xvYmFsWyd3ZWJraXQnICsgbmFtZV0gfHwgZ2xvYmFsWydtb3onICsgbmFtZV0gfHwgZ2xvYmFsWydtcycgKyBuYW1lXTtcbn1cblxucmVxdWVzdEZuID0gZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIGdldFByZWZpeGVkKCdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fFxuICAgIGZ1bmN0aW9uKGZuLCBjb250ZXh0KSB7XG4gICAgICAgIGZuLmNhbGwoY29udGV4dCk7XG4gICAgfTtcblxuY2FuY2VsRm4gPSBnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICBnZXRQcmVmaXhlZCgnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnKSB8fFxuICAgIGdldFByZWZpeGVkKCdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fFxuICAgIGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogQG1vZHVsZSBtb2R1bGU6cmVxQW5pbUZyYW1lXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogU2hpbSBvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gY29udGV4dCBjb250ZXh0IGZvciBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFVuaXF1ZSBpZFxuICAgICAqL1xuICAgIHJlcXVlc3RBbmltRnJhbWU6IGZ1bmN0aW9uKGZuLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0Rm4uY2FsbChnbG9iYWwsIHV0aWwuYmluZChmbiwgY29udGV4dCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaGltIG9mIGNhbmNlbEFuaW1hdGlvbkZyYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIHJlcXVlc3RBbmltYXRpb25GcmFtZSBpZFxuICAgICAqL1xuICAgIGNhbmNlbEFuaW1GcmFtZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FuY2VsRm4uY2FsbChnbG9iYWwsIGlkKTtcbiAgICB9XG59O1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQmFzZSBjYWxlbmRhciBjb250cm9sbGVyXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vbW9kZWwvZXZlbnQnKTtcbnZhciBFdmVudFZpZXdNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVsL3ZpZXdNb2RlbC9ldmVudCcpO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2NvbW1vbicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGZvciBiYXNlIGNvbnRyb2xsZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmdyb3VwRnVuY10gLSBmdW5jdGlvbiBmb3IgZ3JvdXAgZWFjaCBtb2RlbHMge0BzZWUgQ29sbGVjdGlvbiNncm91cEJ5fVxuICogQG1peGVzIHV0aWwuQ3VzdG9tRXZlbnRzXG4gKi9cbmZ1bmN0aW9uIEJhc2Uob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogZnVuY3Rpb24gZm9yIGdyb3VwIGVhY2ggZXZlbnQgbW9kZWxzLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKiBAcGFyYW0ge0V2ZW50Vmlld01vZGVsfSB2aWV3TW9kZWwgLSB2aWV3IG1vZGVsIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBncm91cCBrZXlcbiAgICAgKi9cbiAgICB0aGlzLmdyb3VwRnVuYyA9IG9wdGlvbnMuZ3JvdXBGdW5jIHx8IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgICAgICBpZiAodmlld01vZGVsLm1vZGVsLmlzQWxsRGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gJ2FsbGRheSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICd0aW1lJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBldmVudHMgY29sbGVjdGlvbi5cbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmV2ZW50cyA9IGNvbW1vbi5jcmVhdGVFdmVudENvbGxlY3Rpb24oKTtcblxuICAgIC8qKlxuICAgICAqIE1hdHJpeCBmb3IgbXVsdGlkYXRlIGV2ZW50cy5cbiAgICAgKiBAdHlwZSB7b2JqZWN0LjxzdHJpbmcsIGFycmF5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmRhdGVNYXRyaXggPSB7fTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgY29udGFpbiBkYXRlcyBpbiBldmVudC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgaW5zdGFuY2Ugb2YgZXZlbnQuXG4gKiBAcmV0dXJucyB7YXJyYXl9IGNvbnRhaW4gZGF0ZXMuXG4gKi9cbkJhc2UucHJvdG90eXBlLl9nZXRDb250YWluRGF0ZXNJbkV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgcmFuZ2UgPSBkYXRldGltZS5yYW5nZShcbiAgICAgICAgZGF0ZXRpbWUuc3RhcnQoZXZlbnQuZ2V0U3RhcnRzKCkpLFxuICAgICAgICBkYXRldGltZS5zdGFydChldmVudC5nZXRFbmRzKCkpLFxuICAgICAgICBkYXRldGltZS5NSUxMSVNFQ09ORFNfUEVSX0RBWVxuICAgICk7XG5cbiAgICByZXR1cm4gcmFuZ2U7XG59O1xuXG4vKioqKioqKioqKlxuICogQ1JVRFxuICoqKioqKioqKiovXG5cbi8qKlxuICogQ3JlYXRlIGFuIGV2ZW50IGluc3RhbmNlIGZyb20gcmF3IGRhdGEuXG4gKiBAZW1pdHMgQmFzZSNjcmVhdGVkRXZlbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIERhdGEgb2JqZWN0IHRvIGNyZWF0ZSBldmVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IC0gc2V0IHRydWUgdGhlbiBkb24ndCBmaXJlIGV2ZW50cy5cbiAqIEByZXR1cm5zIHtFdmVudH0gVGhlIGluc3RhbmNlIG9mIEV2ZW50IHRoYXQgY3JlYXRlZC5cbiAqL1xuQmFzZS5wcm90b3R5cGUuY3JlYXRlRXZlbnQgPSBmdW5jdGlvbihvcHRpb25zLCBzaWxlbnQpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLmFkZEV2ZW50KEV2ZW50LmNyZWF0ZShvcHRpb25zKSk7XG5cbiAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGV2ZW50IEJhc2UjY3JlYXRlZEV2ZW50XG4gICAgICAgICAqIEB0eXBlIHtFdmVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlyZSgnY3JlYXRlZEV2ZW50JywgZXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudDtcbn07XG5cbi8qKlxuICogU2V0IGRhdGUgbWF0cml4IHRvIHN1cHBsaWVkIGV2ZW50IGluc3RhbmNlLlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBpbnN0YW5jZSBvZiBldmVudC5cbiAqL1xuQmFzZS5wcm90b3R5cGUuX2FkZFRvTWF0cml4ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgb3duTWF0cml4ID0gdGhpcy5kYXRlTWF0cml4LFxuICAgICAgICBjb250YWluRGF0ZXMgPSB0aGlzLl9nZXRDb250YWluRGF0ZXNJbkV2ZW50KGV2ZW50KTtcblxuICAgIHV0aWwuZm9yRWFjaChjb250YWluRGF0ZXMsIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgdmFyIHltZCA9IGRhdGV0aW1lLmZvcm1hdChkYXRlLCAnWVlZWU1NREQnKSxcbiAgICAgICAgICAgIG1hdHJpeCA9IG93bk1hdHJpeFt5bWRdID0gb3duTWF0cml4W3ltZF0gfHwgW107XG5cbiAgICAgICAgbWF0cml4LnB1c2godXRpbC5zdGFtcChldmVudCkpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQncyBpZCBmcm9tIG1hdHJpeC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gaW5zdGFuY2Ugb2YgZXZlbnRcbiAqL1xuQmFzZS5wcm90b3R5cGUuX3JlbW92ZUZyb21NYXRyaXggPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBtb2RlbElEID0gdXRpbC5zdGFtcChldmVudCk7XG5cbiAgICB1dGlsLmZvckVhY2godGhpcy5kYXRlTWF0cml4LCBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdXRpbC5pbkFycmF5KG1vZGVsSUQsIG1hdHJpeCk7XG5cbiAgICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICAgICAgbWF0cml4LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGluc3RhbmNlLlxuICogQGVtaXRzIEJhc2UjYWRkZWRFdmVudFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGluc3RhbmNlIG9mIEV2ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBzaWxlbnQgLSBzZXQgdHJ1ZSB0aGVuIGRvbid0IGZpcmUgZXZlbnRzLlxuICogQHJldHVybnMge0V2ZW50fSBUaGUgaW5zdGFuY2Ugb2YgRXZlbnQgdGhhdCBhZGRlZC5cbiAqL1xuQmFzZS5wcm90b3R5cGUuYWRkRXZlbnQgPSBmdW5jdGlvbihldmVudCwgc2lsZW50KSB7XG4gICAgdGhpcy5ldmVudHMuYWRkKGV2ZW50KTtcbiAgICB0aGlzLl9hZGRUb01hdHJpeChldmVudCk7XG5cbiAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGV2ZW50IEJhc2UjYWRkZWRFdmVudFxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maXJlKCdhZGRlZEV2ZW50JywgZXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudDtcbn07XG5cbi8qKlxuICogc3BsaXQgZXZlbnQgbW9kZWwgYnkgeW1kLlxuICogQHBhcmFtIHtEYXRlfSBzdGFydHMgLSBzdGFydCBkYXRlXG4gKiBAcGFyYW0ge0RhdGV9IGVuZHMgLSBlbmQgZGF0ZVxuICogQHBhcmFtIHtDb2xsZWN0aW9ufSBldmVudENvbGxlY3Rpb24gLSBjb2xsZWN0aW9uIG9mIGV2ZW50IG1vZGVsLlxuICogQHJldHVybnMge29iamVjdC48c3RyaW5nLCBDb2xsZWN0aW9uPn0gc3BsaXR0ZWQgZXZlbnQgbW9kZWwgY29sbGVjdGlvbnMuXG4gKi9cbkJhc2UucHJvdG90eXBlLnNwbGl0RXZlbnRCeURhdGVSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0cywgZW5kcywgZXZlbnRDb2xsZWN0aW9uKSB7XG4gICAgdmFyIHJhbmdlID0gZGF0ZXRpbWUucmFuZ2UoXG4gICAgICAgICAgICBkYXRldGltZS5zdGFydChzdGFydHMpLFxuICAgICAgICAgICAgZGF0ZXRpbWUuc3RhcnQoZW5kcyksXG4gICAgICAgICAgICBkYXRldGltZS5NSUxMSVNFQ09ORFNfUEVSX0RBWVxuICAgICAgICApLFxuICAgICAgICBvd25NYXRyaXggPSB0aGlzLmRhdGVNYXRyaXgsXG4gICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgdXRpbC5mb3JFYWNoQXJyYXkocmFuZ2UsIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgdmFyIHltZCA9IGRhdGV0aW1lLmZvcm1hdChkYXRlLCAnWVlZWU1NREQnKSxcbiAgICAgICAgICAgIG1hdHJpeCA9IG93bk1hdHJpeFt5bWRdLFxuICAgICAgICAgICAgY29sbGVjdGlvbjtcblxuICAgICAgICBjb2xsZWN0aW9uID0gcmVzdWx0W3ltZF0gPSBjb21tb24uY3JlYXRlRXZlbnRDb2xsZWN0aW9uKCk7XG5cbiAgICAgICAgaWYgKG1hdHJpeCAmJiBtYXRyaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICB1dGlsLmZvckVhY2hBcnJheShtYXRyaXgsIGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRDb2xsZWN0aW9uLmRvV2hlbkhhcyhpZCwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5hZGQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJldHVybiBldmVudHMgaW4gc3VwcGxpZWQgZGF0ZSByYW5nZS5cbiAqXG4gKiBhdmFpbGFibGUgb25seSBZTUQuXG4gKiBAcGFyYW0ge0RhdGV9IHN0YXJ0cyBzdGFydCBkYXRlLlxuICogQHBhcmFtIHtEYXRlfSBlbmRzIGVuZCBkYXRlLlxuICogQHJldHVybnMge29iamVjdC48c3RyaW5nLCBDb2xsZWN0aW9uPn0gZXZlbnQgY29sbGVjdGlvbiBncm91cGVkIGJ5IGRhdGVzLlxuICovXG5CYXNlLnByb3RvdHlwZS5maW5kQnlEYXRlUmFuZ2UgPSBmdW5jdGlvbihzdGFydHMsIGVuZHMpIHtcbiAgICB2YXIgcmFuZ2UgPSBkYXRldGltZS5yYW5nZShcbiAgICAgICAgICAgIGRhdGV0aW1lLnN0YXJ0KHN0YXJ0cyksXG4gICAgICAgICAgICBkYXRldGltZS5zdGFydChlbmRzKSxcbiAgICAgICAgICAgIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZXG4gICAgICAgICksXG4gICAgICAgIG93bkV2ZW50cyA9IHRoaXMuZXZlbnRzLml0ZW1zLFxuICAgICAgICBvd25NYXRyaXggPSB0aGlzLmRhdGVNYXRyaXgsXG4gICAgICAgIGRmb3JtYXQgPSBkYXRldGltZS5mb3JtYXQsXG4gICAgICAgIHJlc3VsdCA9IHt9LFxuICAgICAgICBtYXRyaXgsXG4gICAgICAgIHltZCxcbiAgICAgICAgdmlld01vZGVscztcblxuICAgIHV0aWwuZm9yRWFjaEFycmF5KHJhbmdlLCBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHltZCA9IGRmb3JtYXQoZGF0ZSwgJ1lZWVlNTUREJyk7XG4gICAgICAgIG1hdHJpeCA9IG93bk1hdHJpeFt5bWRdO1xuICAgICAgICB2aWV3TW9kZWxzID0gcmVzdWx0W3ltZF0gPSBjb21tb24uY3JlYXRlRXZlbnRDb2xsZWN0aW9uKCk7XG5cbiAgICAgICAgaWYgKG1hdHJpeCAmJiBtYXRyaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICB2aWV3TW9kZWxzLmFkZC5hcHBseSh2aWV3TW9kZWxzLCB1dGlsLm1hcChtYXRyaXgsIGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEV2ZW50Vmlld01vZGVsLmNyZWF0ZShvd25FdmVudHNbaWRdKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIFVwZGF0ZVxuLyoqXG4gKiBVcGRhdGUgYW4gZXZlbnQuXG4gKiBAZW1pdHMgQmFzZSN1cGRhdGVFdmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGlkIFRoZSB1bmlxdWUgaWQgb2YgRXZlbnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyB1cGRhdGVkIG9iamVjdCBkYXRhLlxuICogQHJldHVybnMge0V2ZW50fGJvb2xlYW59IHVwZGF0ZWQgZXZlbnQgaW5zdGFuY2UsIHdoZW4gaXQgZmFpbCB0aGVuIHJldHVybiBmYWxzZS5cbiAqL1xuQmFzZS5wcm90b3R5cGUudXBkYXRlRXZlbnQgPSBmdW5jdGlvbihpZCwgb3B0aW9ucykge1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcblxuICAgIHRoaXMuZXZlbnRzLmRvV2hlbkhhcyhpZCwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUpIHtcbiAgICAgICAgICAgIGV2ZW50LnNldCgndGl0bGUnLCBvcHRpb25zLnRpdGxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmlzQWxsRGF5KSB7XG4gICAgICAgICAgICBldmVudC5zZXQoJ2lzQWxsRGF5Jywgb3B0aW9ucy5pc0FsbERheSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zdGFydHMpIHtcbiAgICAgICAgICAgIGV2ZW50LnNldCgnc3RhcnRzJywgbmV3IERhdGUob3B0aW9ucy5zdGFydHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmVuZHMpIHtcbiAgICAgICAgICAgIGV2ZW50LnNldCgnZW5kcycsIG5ldyBEYXRlKG9wdGlvbnMuZW5kcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVtb3ZlRnJvbU1hdHJpeChldmVudCk7XG4gICAgICAgIHRoaXMuX2FkZFRvTWF0cml4KGV2ZW50KTtcblxuICAgICAgICByZXN1bHQgPSBldmVudDtcbiAgICB9LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBCYXNlI3VwZGF0ZUV2ZW50XG4gICAgICovXG4gICAgdGhpcy5maXJlKCd1cGRhdGVFdmVudCcpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIERlbGV0ZVxuLyoqXG4gKiBEZWxldGUgZXZlbnQgaW5zdGFuY2UgZnJvbSBjb250cm9sbGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGlkIC0gdW5pcXVlIGlkIG9mIG1vZGVsIGluc3RhbmNlLlxuICogQHJldHVybnMge0V2ZW50fSBkZWxldGVkIG1vZGVsIGluc3RhbmNlLlxuICovXG5CYXNlLnByb3RvdHlwZS5kZWxldGVFdmVudCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgdGhpcy5ldmVudHMuZG9XaGVuSGFzKGlkLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICByZXN1bHQgPSBldmVudDtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRnJvbU1hdHJpeChldmVudCk7XG4gICAgICAgIHRoaXMuZXZlbnRzLnJlbW92ZShldmVudCk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gbWl4aW5cbnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKEJhc2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2U7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBDb250cm9sbGVyIG1peGluIG1vZHVsZXMgZm9yIGRheSB2aWV3cy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi8uLi9jb21tb24vY29tbW9uJyk7XG52YXIgYXJyYXkgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vYXJyYXknKTtcbnZhciBFdmVudFZpZXdNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL21vZGVsL3ZpZXdNb2RlbC9ldmVudCcpO1xudmFyIGFwcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBAbWl4aW4gQmFzZS5XZWVrXG4gKi9cbnZhciBXZWVrID0ge1xuICAgIC8qKioqKioqKioqXG4gICAgICogQ09NTU9OXG4gICAgICoqKioqKioqKiovXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgY29sbGlzaW9uIGdyb3VwLlxuICAgICAqIEB0aGlzIEJhc2UuV2Vla1xuICAgICAqIEBwYXJhbSB7YXJyYXl9IHZpZXdNb2RlbHMgTGlzdCBvZiB2aWV3bW9kZWxzLlxuICAgICAqIEByZXR1cm5zIHthcnJheX0gQ29sbGlzaW9uIEdyb3VwLlxuICAgICAqL1xuICAgIGdldENvbGxpc2lvbkdyb3VwOiBmdW5jdGlvbih2aWV3TW9kZWxzKSB7XG4gICAgICAgIHZhciBjb2xsaXNpb25Hcm91cHMgPSBbXSxcbiAgICAgICAgICAgIGZvdW5kUHJldkNvbGxpc2lvbkV2ZW50ID0gZmFsc2UsXG4gICAgICAgICAgICBwcmV2aW91c0V2ZW50TGlzdDtcblxuICAgICAgICBpZiAoIXZpZXdNb2RlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sbGlzaW9uR3JvdXBzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29sbGlzaW9uR3JvdXBzWzBdID0gW3V0aWwuc3RhbXAodmlld01vZGVsc1swXS52YWx1ZU9mKCkpXTtcbiAgICAgICAgdXRpbC5mb3JFYWNoQXJyYXkodmlld01vZGVscy5zbGljZSgxKSwgZnVuY3Rpb24oZXZlbnQsIGluZGV4KSB7XG4gICAgICAgICAgICBmb3VuZFByZXZDb2xsaXNpb25FdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgcHJldmlvdXNFdmVudExpc3QgPSBhcHMuYXBwbHkodmlld01vZGVscywgWzAsIGluZGV4ICsgMV0pLnJldmVyc2UoKTtcblxuICAgICAgICAgICAgdXRpbC5mb3JFYWNoQXJyYXkocHJldmlvdXNFdmVudExpc3QsIGZ1bmN0aW9uKHByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmNvbGxpZGVzV2l0aChwcmV2aW91cykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g7J207KCEIOydvOygleuTpOqzvCDqsrnsuZjripQg6rK97JqwIOqyuey5mOuKlCDsnbzsoJXsnZggQ29sbGlzaW9uIEdyb3Vw7J2EXG4gICAgICAgICAgICAgICAgICAgIC8vIOywvuyVhCDsnbQg7J287KCV7J2EIOy2lOqwgO2VnOuLpFxuICAgICAgICAgICAgICAgICAgICBmb3VuZFByZXZDb2xsaXNpb25FdmVudCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdXRpbC5mb3JFYWNoQXJyYXkoY29sbGlzaW9uR3JvdXBzLnNsaWNlKDApLnJldmVyc2UoKSwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh+dXRpbC5pbkFycmF5KHV0aWwuc3RhbXAocHJldmlvdXMudmFsdWVPZigpKSwgZ3JvdXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g6rK57LmY64qUIOydtOyghCDsnbzsoJXsnYQg7LC+7J2AIOqyveyasCDqt7gg7J287KCV7J20IOyGje2VnFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbGxpc2lvbiBHcm91cOyXkCDsnbQg7J287KCV7J2EIO2PrO2VqOyLnO2CqOuLpC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cC5wdXNoKHV0aWwuc3RhbXAoZXZlbnQudmFsdWVPZigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghZm91bmRQcmV2Q29sbGlzaW9uRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyDsnbQg7J287KCV7J2AIOydtOyghOydvOygleqzvCDqsrnsuZjsp4Ag7JWK64qUIOydvOygleydtOuvgOuhnFxuICAgICAgICAgICAgICAgIC8vIOyDiCBDb2xsaXNpb24gR3JvdXDsnYQg6rWs7ISx7ZWc64ukLlxuICAgICAgICAgICAgICAgIGNvbGxpc2lvbkdyb3Vwcy5wdXNoKFt1dGlsLnN0YW1wKGV2ZW50LnZhbHVlT2YoKSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbGxpc2lvbkdyb3VwcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHJvdyBsZW5ndGggYnkgY29sdW1uIGluZGV4IGluIDJkIG1hdHJpeC5cbiAgICAgKiBAdGhpcyBCYXNlLldlZWtcbiAgICAgKiBAcGFyYW0ge2FycmF5W119IGFycjJkIE1hdHJpeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2wgQ29sdW1uIGluZGV4LlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gTGFzdCByb3cgbnVtYmVyIGluIGNvbHVtbi5cbiAgICAgKi9cbiAgICBnZXRMYXN0Um93SW5Db2x1bW46IGZ1bmN0aW9uKGFycjJkLCBjb2wpIHtcbiAgICAgICAgdmFyIHJvdyA9IGFycjJkLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAocm93ID4gMCkge1xuICAgICAgICAgICAgcm93IC09IDE7XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWQoYXJyMmRbcm93XVtjb2xdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBtYXRyaXggZm9yIGFwcG9pbnRtZW50IGJsb2NrIGVsZW1lbnQgcGxhY2luZy5cbiAgICAgKiBAdGhpcyBCYXNlLldlZWtcbiAgICAgKiBAcGFyYW0ge0NvbGxlY3Rpb259IGNvbGxlY3Rpb24gbW9kZWwgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2FycmF5W119IGNvbGxpc2lvbkdyb3VwcyBDb2xsaXNpb24gZ3JvdXBzIGZvciBldmVudCBzZXQuXG4gICAgICogQHJldHVybnMge2FycmF5fSBtYXRyaWNlc1xuICAgICAqL1xuICAgIGdldE1hdHJpY2VzOiBmdW5jdGlvbihjb2xsZWN0aW9uLCBjb2xsaXNpb25Hcm91cHMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgZ2V0TGFzdFJvd0luQ29sdW1uID0gV2Vlay5nZXRMYXN0Um93SW5Db2x1bW47XG5cbiAgICAgICAgdXRpbC5mb3JFYWNoQXJyYXkoY29sbGlzaW9uR3JvdXBzLCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICAgICAgdmFyIG1hdHJpeCA9IFtbXV07XG5cbiAgICAgICAgICAgIHV0aWwuZm9yRWFjaEFycmF5KGdyb3VwLCBmdW5jdGlvbihldmVudElEKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gY29sbGVjdGlvbi5pdGVtc1tldmVudElEXSxcbiAgICAgICAgICAgICAgICAgICAgY29sID0gMCxcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJvdyxcbiAgICAgICAgICAgICAgICAgICAgbGFzdFJvd0luQ29sdW1uO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0Um93SW5Db2x1bW4gPSBnZXRMYXN0Um93SW5Db2x1bW4obWF0cml4LCBjb2wpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0Um93SW5Db2x1bW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXhbMF0ucHVzaChldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWV2ZW50LmNvbGxpZGVzV2l0aChtYXRyaXhbbGFzdFJvd0luQ29sdW1uXVtjb2xdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFJvdyA9IGxhc3RSb3dJbkNvbHVtbiArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChtYXRyaXhbbmV4dFJvd10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4W25leHRSb3ddID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXhbbmV4dFJvd11bY29sXSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29sICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1hdHJpeCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKioqKioqKioqXG4gICAgICogVElNRSBHUklEIFZJRVdcbiAgICAgKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIE1ha2UgYXJyYXkgd2l0aCBzdGFydCBhbmQgZW5kIHRpbWVzIG9uIGV2ZW50cy5cbiAgICAgKiBAdGhpcyBCYXNlLldlZWtcbiAgICAgKiBAcGFyYW0ge2FycmF5W119IG1hdHJpeCAtIG1hdHJpeCBmcm9tIGNvbnRyb2xsZXIuXG4gICAgICogQHJldHVybnMge2FycmF5W119IHN0YXJ0dGltZSwgZW5kdGltZSBhcnJheSAoZXhjbHVkZSBmaXJzdCByb3cncyBldmVudHMpXG4gICAgICovXG4gICAgZ2VuZXJhdGVUaW1lQXJyYXlJblJvdzogZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICAgIHZhciByb3csXG4gICAgICAgICAgICBjb2wsXG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIG1hcCA9IFtdLFxuICAgICAgICAgICAgY3Vyc29yID0gW10sXG4gICAgICAgICAgICBtYXhDb2xMZW4gPSBNYXRoLm1heC5hcHBseShudWxsLCB1dGlsLm1hcChtYXRyaXgsIGZ1bmN0aW9uKGNvbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2wubGVuZ3RoO1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIGZvciAoY29sID0gMTsgY29sIDwgbWF4Q29sTGVuOyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgcm93ID0gMDtcbiAgICAgICAgICAgIGV2ZW50ID0gdXRpbC5waWNrKG1hdHJpeCwgcm93LCBjb2wpO1xuXG4gICAgICAgICAgICB3aGlsZSAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaChbZXZlbnQuZ2V0U3RhcnRzKCkuZ2V0VGltZSgpLCBldmVudC5nZXRFbmRzKCkuZ2V0VGltZSgpXSk7XG5cbiAgICAgICAgICAgICAgICByb3cgKz0gMTtcbiAgICAgICAgICAgICAgICBldmVudCA9IHV0aWwucGljayhtYXRyaXgsIHJvdywgY29sKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWFwLnB1c2goY3Vyc29yKTtcbiAgICAgICAgICAgIGN1cnNvciA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvbGxpc2lvbiBpbmZvcm1hdGlvbiBmcm9tIGxpc3RcbiAgICAgKiBAdGhpcyBCYXNlLldlZWtcbiAgICAgKiBAcGFyYW0ge2FycmF5LjxudW1iZXJbXT59IGFyciAtIGxpc3QgdG8gZGV0ZWN0aW5nIGNvbGxpc2lvbi4gW1tzdGFydCwgZW5kXSwgW3N0YXJ0LCBlbmRdXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIGV2ZW50IHN0YXJ0IHRpbWUgdGhhdCB3YW50IHRvIGRldGVjdCBjb2xsaXNpb25zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgLSBldmVudCBlbmQgdGltZSB0aGF0IHdhbnQgdG8gZGV0ZWN0IGNvbGxpc2lvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRhcmdldCBoYXMgY29sbGlkZSBpbiBzdXBwbGllZCBhcnJheT9cbiAgICAgKi9cbiAgICBoYXNDb2xsaWRlOiBmdW5jdGlvbihhcnIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIHN0YXJ0U3RhcnQsXG4gICAgICAgICAgICBzdGFydEVuZCxcbiAgICAgICAgICAgIGVuZFN0YXJ0LFxuICAgICAgICAgICAgZW5kRW5kLFxuICAgICAgICAgICAgZ2V0RnVuYyA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibG9ja1tpbmRleF07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgICAgIGNvbXBhcmUgPSBhcnJheS5jb21wYXJlLm51bS5hc2MsXG4gICAgICAgICAgICBoYXNDb2xsaWRlO1xuXG4gICAgICAgIGlmICghYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRTdGFydCA9IGFicyhhcnJheS5ic2VhcmNoKGFyciwgc3RhcnQsIGdldEZ1bmMoMCksIGNvbXBhcmUpKTtcbiAgICAgICAgc3RhcnRFbmQgPSBhYnMoYXJyYXkuYnNlYXJjaChhcnIsIHN0YXJ0LCBnZXRGdW5jKDEpLCBjb21wYXJlKSk7XG4gICAgICAgIGVuZFN0YXJ0ID0gYWJzKGFycmF5LmJzZWFyY2goYXJyLCBlbmQsIGdldEZ1bmMoMCksIGNvbXBhcmUpKTtcbiAgICAgICAgZW5kRW5kID0gYWJzKGFycmF5LmJzZWFyY2goYXJyLCBlbmQsIGdldEZ1bmMoMSksIGNvbXBhcmUpKTtcbiAgICAgICAgaGFzQ29sbGlkZSA9ICEoc3RhcnRTdGFydCA9PT0gc3RhcnRFbmQgJiYgc3RhcnRFbmQgPT09IGVuZFN0YXJ0ICYmIGVuZFN0YXJ0ID09PSBlbmRFbmQpO1xuXG4gICAgICAgIHJldHVybiBoYXNDb2xsaWRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHZhbHVlcyB0byB2aWV3bW9kZWxzIGZvciBkZXRlY3QgcmVhbCBjb2xsaXNpb24gYXQgcmVuZGVyaW5nIHBoYXNlLlxuICAgICAqIEB0aGlzIEJhc2UuV2Vla1xuICAgICAqIEBwYXJhbSB7YXJyYXlbXX0gbWF0cmljZXMgLSBNYXRyaXggZGF0YS5cbiAgICAgKi9cbiAgICBnZXRDb2xsaWRlczogZnVuY3Rpb24obWF0cmljZXMpIHtcbiAgICAgICAgdXRpbC5mb3JFYWNoQXJyYXkobWF0cmljZXMsIGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgICAgICAgICAgdmFyIGJpbmFyeU1hcCxcbiAgICAgICAgICAgICAgICBtYXhSb3dMZW5ndGg7XG5cbiAgICAgICAgICAgIGJpbmFyeU1hcCA9IFdlZWsuZ2VuZXJhdGVUaW1lQXJyYXlJblJvdyhtYXRyaXgpO1xuICAgICAgICAgICAgbWF4Um93TGVuZ3RoID0gTWF0aC5tYXguYXBwbHkobnVsbCwgdXRpbC5tYXAobWF0cml4LCBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93Lmxlbmd0aDtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdXRpbC5mb3JFYWNoQXJyYXkobWF0cml4LCBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgICAgICB1dGlsLmZvckVhY2hBcnJheShyb3csIGZ1bmN0aW9uKHZpZXdNb2RlbCwgY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ29sbGlkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aWV3TW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZSA9IHZpZXdNb2RlbC5nZXRTdGFydHMoKS5nZXRUaW1lKCkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBlbmRUaW1lID0gdmlld01vZGVsLmdldEVuZHMoKS5nZXRUaW1lKCkgLSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IChjb2wgKyAxKTsgaSA8IG1heFJvd0xlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDb2xsaWRlID0gV2Vlay5oYXNDb2xsaWRlKGJpbmFyeU1hcFtpIC0gMV0sIHN0YXJ0VGltZSwgZW5kVGltZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNDb2xsaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld01vZGVsLmhhc0NvbGxpZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZWwuZXh0cmFTcGFjZSArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0aGlzIEJhc2VcbiAgICAgKiBAcGFyYW0ge0RhdGV9IHN0YXJ0cyAtIHN0YXJ0IGRhdGUuXG4gICAgICogQHBhcmFtIHtEYXRlfSBlbmRzIC0gZW5kIGRhdGUuXG4gICAgICogQHBhcmFtIHtDb2xsZWN0aW9ufSB0aW1lIC0gdmlldyBtb2RlbCBjb2xsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHZpZXcgbW9kZWwgZm9yIHRpbWUgcGFydC5cbiAgICAgKi9cbiAgICBnZXRWaWV3TW9kZWxGb3JUaW1lVmlldzogZnVuY3Rpb24oc3RhcnRzLCBlbmRzLCB0aW1lKSB7XG4gICAgICAgIHZhciB5bWRTcGxpdHRlZCA9IHRoaXMuc3BsaXRFdmVudEJ5RGF0ZVJhbmdlKHN0YXJ0cywgZW5kcywgdGltZSksXG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgICB1dGlsLmZvckVhY2goeW1kU3BsaXR0ZWQsIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHltZCkge1xuICAgICAgICAgICAgdmFyIHZpZXdNb2RlbHMgPSBjb2xsZWN0aW9uLnNvcnQoYXJyYXkuY29tcGFyZS5ldmVudC5hc2MpLFxuICAgICAgICAgICAgICAgIGNvbGxpc2lvbkdyb3VwcyxcbiAgICAgICAgICAgICAgICBtYXRyaWNlcztcblxuICAgICAgICAgICAgY29sbGlzaW9uR3JvdXBzID0gdGhpcy5nZXRDb2xsaXNpb25Hcm91cCh2aWV3TW9kZWxzKTtcbiAgICAgICAgICAgIG1hdHJpY2VzID0gdGhpcy5nZXRNYXRyaWNlcyhjb2xsZWN0aW9uLCBjb2xsaXNpb25Hcm91cHMpO1xuICAgICAgICAgICAgdGhpcy5nZXRDb2xsaWRlcyhtYXRyaWNlcyk7XG5cbiAgICAgICAgICAgIHJlc3VsdFt5bWRdID0gbWF0cmljZXM7XG4gICAgICAgIH0sIFdlZWspO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKioqKioqKioqXG4gICAgICogQUxMREFZIFZJRVdcbiAgICAgKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSB2aWV3IG1vZGVsIGZvciBhbGxkYXkgdmlldyBwYXJ0LlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gc3RhcnRzIHN0YXJ0IGRhdGUuXG4gICAgICogQHBhcmFtIHtEYXRlfSBlbmRzIGVuZCBkYXRlLlxuICAgICAqIEBwYXJhbSB7Q29sbGVjdGlvbn0gdmlld01vZGVscyAtIGFsbGRheSBldmVudCB2aWV3TW9kZWwgdmlld01vZGVscy5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBhbGxkYXkgdmlld01vZGVsLlxuICAgICAqL1xuICAgIGdldFZpZXdNb2RlbEZvckFsbGRheVZpZXc6IGZ1bmN0aW9uKHN0YXJ0cywgZW5kcywgdmlld01vZGVscykge1xuICAgICAgICB2YXIgbGlzdCxcbiAgICAgICAgICAgIHltZHNUb1JlbmRlcixcbiAgICAgICAgICAgIGNvbGxpc2lvbkdyb3VwcyxcbiAgICAgICAgICAgIG1hdHJpY2VzO1xuXG4gICAgICAgIGlmICghdmlld01vZGVscyB8fCAhdmlld01vZGVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHltZHNUb1JlbmRlciA9IHV0aWwubWFwKFxuICAgICAgICAgICAgZGF0ZXRpbWUucmFuZ2Uoc3RhcnRzLCBlbmRzLCBkYXRldGltZS5NSUxMSVNFQ09ORFNfUEVSX0RBWSksXG4gICAgICAgICAgICBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGV0aW1lLmZvcm1hdChkYXRlLCAnWVlZWU1NREQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBsaXN0ID0gdmlld01vZGVscy5zb3J0KGFycmF5LmNvbXBhcmUuZXZlbnQuYXNjKTtcbiAgICAgICAgY29sbGlzaW9uR3JvdXBzID0gV2Vlay5nZXRDb2xsaXNpb25Hcm91cChsaXN0KTtcbiAgICAgICAgbWF0cmljZXMgPSBXZWVrLmdldE1hdHJpY2VzKHZpZXdNb2RlbHMsIGNvbGxpc2lvbkdyb3Vwcyk7XG5cbiAgICAgICAgdXRpbC5mb3JFYWNoQXJyYXkobWF0cmljZXMsIGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgICAgICAgICAgdXRpbC5mb3JFYWNoQXJyYXkobWF0cml4LCBmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICB1dGlsLmZvckVhY2hBcnJheShjb2x1bW4sIGZ1bmN0aW9uKHZpZXdNb2RlbCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHltZCwgZGF0ZUxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZpZXdNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeW1kID0gZGF0ZXRpbWUuZm9ybWF0KHZpZXdNb2RlbC5nZXRTdGFydHMoKSwgJ1lZWVlNTUREJyk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVMZW5ndGggPSBkYXRldGltZS5yYW5nZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdNb2RlbC5nZXRTdGFydHMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdNb2RlbC5nZXRFbmRzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRldGltZS5NSUxMSVNFQ09ORFNfUEVSX0RBWVxuICAgICAgICAgICAgICAgICAgICApLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZWwudG9wID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdNb2RlbC5sZWZ0ID0gdXRpbC5pbkFycmF5KHltZCwgeW1kc1RvUmVuZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmlld01vZGVsLndpZHRoID0gZGF0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWF0cmljZXM7XG4gICAgfSxcblxuICAgIC8qKioqKioqKioqXG4gICAgICogUkVBRFxuICAgICAqKioqKioqKioqL1xuXG4gICAgLyoqXG4gICAgICogUG9wdWxhdGUgZXZlbnRzIGluIGRhdGUgcmFuZ2UuXG4gICAgICogQHRoaXMgQmFzZVxuICAgICAqIEBwYXJhbSB7RGF0ZX0gc3RhcnRzIHN0YXJ0IGRhdGUuXG4gICAgICogQHBhcmFtIHtEYXRlfSBlbmRzIGVuZCBkYXRlLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGV2ZW50cyBncm91cGVkIGJ5IGRhdGVzLlxuICAgICAqL1xuICAgIGZpbmRCeURhdGVSYW5nZTogZnVuY3Rpb24oc3RhcnRzLCBlbmRzKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIGV2ZW50cyxcbiAgICAgICAgICAgIHZpZXdNb2RlbHM7XG5cbiAgICAgICAgLy8gUVVFUlkgRVZFTlRTXG4gICAgICAgIGV2ZW50cyA9IHRoaXMuZXZlbnRzLmZpbmQoZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBvd25TdGFydHMgPSBtb2RlbC5nZXRTdGFydHMoKSxcbiAgICAgICAgICAgICAgICBvd25FbmRzID0gbW9kZWwuZ2V0RW5kcygpO1xuXG4gICAgICAgICAgICByZXR1cm4gKG93blN0YXJ0cyA+PSBzdGFydHMgJiYgb3duRW5kcyA8PSBlbmRzKSB8fFxuICAgICAgICAgICAgICAgIChvd25TdGFydHMgPCBzdGFydHMgJiYgb3duRW5kcyA+PSBzdGFydHMpIHx8XG4gICAgICAgICAgICAgICAgKG93bkVuZHMgPiBlbmRzICYmIG93blN0YXJ0cyA8PSBlbmRzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ09OVkVSVCBUTyBWSUVXTU9ERUxcbiAgICAgICAgdmlld01vZGVscyA9IGNvbW1vbi5jcmVhdGVFdmVudENvbGxlY3Rpb24uYXBwbHkoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdXRpbC5tYXAoZXZlbnRzLml0ZW1zLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFdmVudFZpZXdNb2RlbC5jcmVhdGUoZXZlbnQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKS5ncm91cEJ5KFsnYWxsZGF5JywgJ3RpbWUnXSwgdGhpcy5ncm91cEZ1bmMpO1xuXG4gICAgICAgIC8vIENVU1RPTUlaRSBWSUVXTU9ERUwgRk9SIEVBQ0ggVklFV1xuICAgICAgICB1dGlsLmZvckVhY2godmlld01vZGVscywgZnVuY3Rpb24oY29sbCwga2V5LCBvYmopIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdhbGxkYXknKSB7XG4gICAgICAgICAgICAgICAgY29sbC5lYWNoKGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3duU3RhcnRzID0gdmlld01vZGVsLmdldFN0YXJ0cygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3duRW5kcyA9IHZpZXdNb2RlbC5nZXRFbmRzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG93blN0YXJ0cyA8IHN0YXJ0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlld01vZGVsLnJlbmRlclN0YXJ0cyA9IG5ldyBEYXRlKHN0YXJ0cy5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG93bkVuZHMgPiBlbmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZWwucmVuZGVyRW5kcyA9IG5ldyBEYXRlKGVuZHMuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgb2JqLmFsbGRheSA9IHV0aWwuYmluZChXZWVrLmdldFZpZXdNb2RlbEZvckFsbGRheVZpZXcsIHRoYXQpKHN0YXJ0cywgZW5kcywgY29sbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgICAgICAgICAgb2JqLnRpbWUgPSB1dGlsLmJpbmQoV2Vlay5nZXRWaWV3TW9kZWxGb3JUaW1lVmlldywgdGhhdCkoc3RhcnRzLCBlbmRzLCBjb2xsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZpZXdNb2RlbHM7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWVrO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQmFzZSBjb250cm9sbGVyIGZvciBEb29yYXkgc2VydmljZSBwcm9qZWN0LlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBCYXNlID0gcmVxdWlyZSgnLi4vLi4vY29udHJvbGxlci9iYXNlJyk7XG52YXIgRG9vcmF5RXZlbnQgPSByZXF1aXJlKCcuLi9tb2RlbC9ldmVudCcpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGZvciBiYXNlIGNvbnRyb2xsZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmdyb3VwRnVuY10gLSBmdW5jdGlvbiBmb3IgZ3JvdXAgZWFjaCBtb2RlbHMge0BzZWUgQ29sbGVjdGlvbiNncm91cEJ5fVxuICogQGV4dGVuZHMge0Jhc2V9XG4gKi9cbmZ1bmN0aW9uIERvb3JheUJhc2Uob3B0aW9ucykge1xuICAgIEJhc2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxudXRpbC5pbmhlcml0KERvb3JheUJhc2UsIEJhc2UpO1xuXG4vKioqKioqKioqKlxuICogQ1JVRCBvdmVycmlkZVxuICoqKioqKioqKiovXG5cbi8qKlxuICogQ3JlYXRlIGFuIGV2ZW50IGluc3RhbmNlIGZyb20gcmF3IGRhdGEuXG4gKiBAb3ZlcnJpZGVcbiAqIEBlbWl0cyBCYXNlI2JlZm9yZUNyZWF0ZUV2ZW50XG4gKiBAZW1pdHMgQmFzZSNjcmVhdGVkRXZlbnRcbiAqIEBwYXJhbSB7U2VydmljZUNhbGVuZGFyfkV2ZW50c30gZGF0YSAtIERhdGEgb2JqZWN0IHRvIGNyZWF0ZSBldmVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IC0gc2V0IHRydWUgdGhlbiBkb24ndCBmaXJlIGV2ZW50cy5cbiAqIEByZXR1cm5zIHtEb29yYXlFdmVudH0gVGhlIGluc3RhbmNlIG9mIEV2ZW50IHRoYXQgY3JlYXRlZC5cbiAqL1xuRG9vcmF5QmFzZS5wcm90b3R5cGUuY3JlYXRlRXZlbnQgPSBmdW5jdGlvbihkYXRhLCBzaWxlbnQpIHtcbiAgICB2YXIgaW5zdCxcbiAgICAgICAgZXZlbnREYXRhID0ge1xuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IEJhc2UjYmVmb3JlQ3JlYXRlRXZlbnRcbiAgICAgKiBAdHlwZSB7U2VydmljZUNhbGVuZGFyfkV2ZW50c1tdfVxuICAgICAqL1xuICAgIGlmICghdGhpcy5pbnZva2UoJ2JlZm9yZUNyZWF0ZUV2ZW50JywgZXZlbnREYXRhKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5zdCA9IHRoaXMuYWRkRXZlbnQoRG9vcmF5RXZlbnQuY3JlYXRlKGRhdGEpKTtcblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXZlbnQgQmFzZSNjcmVhdGVkRXZlbnRcbiAgICAgICAgICogQHR5cGUge0Rvb3JheUV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maXJlKCdjcmVhdGVkRXZlbnQnLCBpbnN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdDtcbn07XG5cbi8qKlxuICogQGVtaXRzIEJhc2UjYmVmb3JlQ3JlYXRlRXZlbnRcbiAqIEBlbWl0cyBCYXNlI2NyZWF0ZWRFdmVudFxuICogQHBhcmFtIHtTZXJ2aWNlQ2FsZW5kYXJ+RXZlbnRzW119IGRhdGFMaXN0IC0gZGF0YU9iamVjdCBsaXN0IHRvIGNyZWF0ZSBldmVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NpbGVudD1mYWxzZV0gLSBzZXQgdHJ1ZSB0aGVuIGRvbid0IGZpcmUgZXZlbnRzLlxuICogQHJldHVybnMge0Rvb3JheUV2ZW50W119IFRoZSBpbnN0YW5jZSBsaXN0IG9mIEV2ZW50IHRoYXQgY3JlYXRlZC5cbiAqL1xuRG9vcmF5QmFzZS5wcm90b3R5cGUuY3JlYXRlRXZlbnRzID0gZnVuY3Rpb24oZGF0YUxpc3QsIHNpbGVudCkge1xuICAgIHJldHVybiB1dGlsLm1hcChkYXRhTGlzdCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFdmVudChkYXRhLCBzaWxlbnQpO1xuICAgIH0sIHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEb29yYXlCYXNlO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2FsZW5kYXIgZm9yIHNlcnZpY2UuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgQ2FsZW5kYXIgPSByZXF1aXJlKCcuLi8uLi9mYWN0b3J5L2NhbGVuZGFyJyk7XG52YXIgRG9vcmF5QmFzZSA9IHJlcXVpcmUoJy4uL2NvbnRyb2xsZXIvYmFzZScpO1xudmFyIFdlZWsgPSByZXF1aXJlKCcuLi8uLi9jb250cm9sbGVyL3ZpZXdNaXhpbi93ZWVrJyk7XG52YXIgc2VydmljZVdlZWtWaWV3RmFjdG9yeSA9IHJlcXVpcmUoJy4vd2Vla1ZpZXcnKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTZXJ2aWNlQ2FsZW5kYXJ+RXZlbnRzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2lkXSAtIOydvOygleydmCB1bmlxdWVJRC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2FsZW5kYXJJRF0gLSDqsIEg7J287KCV7J2EIOy6mOumsOuNlOuzhOuhnCDqt7jro7nsp4DsnYQg7IiYIOyeiOuKlCDqsJIuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGl0bGUgLSDsnbTrsqTtirgg7KCc66qpXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY2F0ZWdvcnkgLSDsnbTrsqTtirgg7YOA7J6FXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZHVlRGF0ZUNsYXNzIC0g7JeF66y0IOydvOyglSDrtoTrpZggKGNhdGVnb3J56rCAICd0YXNrJ+ydvCDrlYwg7Jyg7ZqoKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXJ0cyAtIOydvOyglSDsi5zsnpEg7Iuc6rCEXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZW5kcyAtIOydvOyglSDsooXro4wg7Iuc6rCEXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbG9yXSAtIOydvOyglSDthY3siqTtirjsg4lcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYmdDb2xvcl0gLSDsnbzsoJUg67Cw6rK97IOJXG4gKi9cblxuLyoqXG4gKiBDYWxlbmRhciBmYWN0b3IgbW9kdWxlIGZvciBzZXJ2aWNlIChkb29yYXkpXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtDYWxlbmRhcn1cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgY2FsZW5kYXJcbiAqICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ncm91cEZ1bmNdIC0gZnVuY3Rpb24gZm9yIGdyb3VwIGV2ZW50IG1vZGVscyB7QHNlZSBDb2xsZWN0aW9uI2dyb3VwQnl9XG4gKiAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuY29udHJvbGxlcl0gLSBjb250cm9sbGVyIGluc3RhbmNlXG4gKiAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRlZmF1bHRWaWV3PSd3ZWVrJ10gLSBkZWZhdWx0IHZpZXcgb2YgY2FsZW5kYXJcbiAqICBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMud2Vla10gLSBvcHRpb25zIGZvciB3ZWVrIHZpZXdcbiAqICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMud2Vlay5yZW5kZXJTdGFydERhdGUgLSBZWVlZLU1NLUREIHJlbmRlciBzdGFydCBkYXRlXG4gKiAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLndlZWsucmVuZGVyRW5kRGF0ZSAtIFlZWVktTU0tREQgcmVuZGVyIGVuZCBkYXRlXG4gKiAgQHBhcmFtIHtTZXJ2aWNlQ2FsZW5kYXJ+RXZlbnRzW119IG9wdGlvbnMuZXZlbnRzIC0g6riw67O4IOydvOyglSDrqqnroZ1cbiAqICBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMubW9udGhdIC0gb3B0aW9ucyBmb3IgbW9udGggdmlld1xuICogIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm1vbnRoLnJlbmRlck1vbnRoIC0gWVlZWS1NTSByZW5kZXIgbW9udGhcbiAqIEBwYXJhbSB7SFRNTERpdkVsZW1lbnR9IGNvbnRhaW5lciA9IGNvbnRhaW5lciBlbGVtZW50IGZvciBjYWxlbmRhclxuICovXG5mdW5jdGlvbiBTZXJ2aWNlQ2FsZW5kYXIob3B0aW9ucywgY29udGFpbmVyKSB7XG4gICAgdmFyIGNvbnRyb2xsZXI7XG4gICAgLyoqXG4gICAgICog7ISc67mE7Iqk7JeQ7IScIOyCrOyaqeuQmOuKlCDrqqjrjbgg6rWs67aE7JqpIOyYteyFmCDtlajsiJhcbiAgICAgKiBAcGFyYW0ge0V2ZW50Vmlld01vZGVsfSB2aWV3TW9kZWwgLSBEb29yYXlFdmVudOulvCDrnpjtlZHtlZwg67ewIOuqqOuNuFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IOq1rOu2hCDtgqQg6rCSXG4gICAgICovXG4gICAgb3B0aW9ucy5ncm91cEZ1bmMgPSBmdW5jdGlvbih2aWV3TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHZpZXdNb2RlbC5tb2RlbC5jYXRlZ29yeTtcbiAgICB9O1xuXG4gICAgLy8g7Luo7Yq466Gk65+sIOunjOuTpOq4sFxuICAgIGNvbnRyb2xsZXIgPSBvcHRpb25zLmNvbnRyb2xsZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb250cm9sbGVyID0gbmV3IERvb3JheUJhc2Uob3B0aW9ucyksXG4gICAgICAgICAgICBvcmlnaW5GaW5kQnlEYXRlUmFuZ2U7XG5cbiAgICAgICAgLy8g7KO867ewIOy7qO2KuOuhpOufrCDrr7nsiqTsnbhcbiAgICAgICAgY29udHJvbGxlci5XZWVrID0ge307XG4gICAgICAgIHV0aWwuZm9yRWFjaChXZWVrLCBmdW5jdGlvbihtZXRob2QsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuV2Vla1ttZXRob2ROYW1lXSA9IHV0aWwuYmluZChtZXRob2QsIGNvbnRyb2xsZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyDsnbzsoJUg7KGw7ZqMIEFQSeyXkCDquLDsobQg7LqY66aw642U7JeQIOyXhuyXiOuNmCBtaWxzdG9uZSwgdGFza+ulvCDsp4Dsm5DtlZjrj4TroZ1cbiAgICAgICAgLy8g7ZWY6riwIOychO2VtCDrqZTshJzrk5zrpbwg7Jik67KE65287J2065Sp7ZWc64ukLlxuICAgICAgICBvcmlnaW5GaW5kQnlEYXRlUmFuZ2UgPSBjb250cm9sbGVyLldlZWsuZmluZEJ5RGF0ZVJhbmdlO1xuICAgICAgICBjb250cm9sbGVyLldlZWsuZmluZEJ5RGF0ZVJhbmdlID0gZnVuY3Rpb24oc3RhcnRzLCBlbmRzKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZVJhbmdlID0gdXRpbC5tYXAoZGF0ZXRpbWUucmFuZ2UoXG4gICAgICAgICAgICAgICAgICAgIGRhdGV0aW1lLnN0YXJ0KHN0YXJ0cyksXG4gICAgICAgICAgICAgICAgICAgIGRhdGV0aW1lLmVuZChlbmRzKSxcbiAgICAgICAgICAgICAgICAgICAgZGF0ZXRpbWUuTUlMTElTRUNPTkRTX1BFUl9EQVlcbiAgICAgICAgICAgICAgICApLCBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRldGltZS5mb3JtYXQoZCwgJ1lZWVktTU0tREQnKTsgfSksXG4gICAgICAgICAgICAgICAgdmlld01vZGVsID0gb3JpZ2luRmluZEJ5RGF0ZVJhbmdlKHN0YXJ0cywgZW5kcyk7XG5cbiAgICAgICAgICAgIHV0aWwuZm9yRWFjaCh2aWV3TW9kZWwsIGZ1bmN0aW9uKGNvbGwsIGtleSwgb2JqKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwZWRCeVlNRDtcblxuICAgICAgICAgICAgICAgIC8vIOuniOydvOyKpO2GpCwg7JeF66y0IOu3sCDrt7Drqqjrjbgg6rCA6rO1XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3Rhc2snIHx8IGtleSA9PT0gJ21pbGVzdG9uZScpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBlZEJ5WU1EID0gY29sbC5ncm91cEJ5KGRhdGVSYW5nZSwgZnVuY3Rpb24odmlld01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZXRpbWUuZm9ybWF0KHZpZXdNb2RlbC5tb2RlbC5lbmRzLCAnWVlZWS1NTS1ERCcpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAndGFzaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuZm9yRWFjaChncm91cGVkQnlZTUQsIGZ1bmN0aW9uKGNvbGwsIHltZCwgb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3ltZF0gPSBjb2xsLmdyb3VwQnkoZnVuY3Rpb24odmlld01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aWV3TW9kZWwubW9kZWwuZHVlRGF0ZUNsYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGdyb3VwZWRCeVlNRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHZpZXdNb2RlbDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9KSgpO1xuXG4gICAgLy8gRnVsbENhbGVuZGFyIOq4sOuzuCDrqqjrk4jsnYAgY2F0ZWdvcnksIGR1ZURhdGVDbGFzcyDtlIzrnpjqt7jrpbwg66qo66aELiDrlYzrrLjsl5BcbiAgICAvLyDsnbTqs7Psl5DshJwg7J2067Kk7Yq4IO2VuOuTpOufrOulvCDrk7HroZ3tlbTshJwg7J287KCVIOyDneyEsSDsoITsl5AgaXNBbGxEYXntlIzrnpjqt7jrpbwg67O06rOgXG4gICAgLy8gY2F0ZWdvcnnrpbwg7IiY64+Z7Jy866GcIOyngOygle2VtOykgOuLpFxuICAgIGNvbnRyb2xsZXIub24oJ2JlZm9yZUNyZWF0ZUV2ZW50JywgZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcblxuICAgICAgICBpZiAoIWRhdGEuY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgIGRhdGEuY2F0ZWdvcnkgPSBkYXRhLmlzQWxsRGF5ID8gJ2FsbGRheScgOiAndGltZSc7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLmV2ZW50cykge1xuICAgICAgICBjb250cm9sbGVyLmNyZWF0ZUV2ZW50cyhvcHRpb25zLmV2ZW50cywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgQ2FsZW5kYXIuY2FsbCh0aGlzLCBvcHRpb25zLCBjb250YWluZXIpO1xufVxuXG51dGlsLmluaGVyaXQoU2VydmljZUNhbGVuZGFyLCBDYWxlbmRhcik7XG5cbi8qKlxuICog6rCBIOu3sOydmCDtgbTrpq0g7ZW465Ok65+s7JmAIOyCrOyaqeyekCDtgbTrpq0g7J2067Kk7Yq4IO2VuOuTpOufrOulvCDsnofquLAg7JyE7ZWcIOu4jOumv+yngCDqsJzrhZDsnZgg7J2067Kk7Yq4IO2VuOuTpOufrFxuICogQGVtaXRzIFNlcnZpY2VDYWxlbmRhciNjbGlja1xuICogQHBhcmFtIHtvYmplY3R9IGNsaWNrRXZlbnREYXRhIC0gJ2NsaWNrJyDtlbjrk6Trn6zsnZgg7J2067Kk7Yq4IOuNsOydtO2EsFxuICovXG5TZXJ2aWNlQ2FsZW5kYXIucHJvdG90eXBlLl9vbkNsaWNrID0gZnVuY3Rpb24oY2xpY2tFdmVudERhdGEpIHtcbiAgICAvKipcbiAgICAgKiBAZXZlbnRzIFNlcnZpY2VDYWxlbmRhciNjbGlja1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtEb29yYXlFdmVudH0gbW9kZWwgLSDtgbTrpq0g7J2067Kk7Yq4IOu4lOuhneqzvCDqtIDroKjrkJwg7J287KCVIOuqqOuNuCDsnbjsiqTthLTsiqRcbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ2NsaWNrJywgY2xpY2tFdmVudERhdGEpO1xufTtcblxuLyoqXG4gKiDsupjrprDrjZQg7Yyp7Yag66asIO2BtOuemOyKpOyZgCDso7zrt7AsIOyblOu3sOydmCDsnbTrsqTtirgg7Jew6rKw7J2EIO2GoOq4gO2VnOuLpFxuICogQHBhcmFtIHtib29sZWFufSBpc0F0dGFjaCAtIHRydWXrqbQg7J2067Kk7Yq4IOyXsOqysO2VqC5cbiAqIEBwYXJhbSB7V2Vla3xNb250aH0gdmlldyAtIOyjvOu3sCDrmJDripQg7JuU67ewXG4gKiBAcGFyYW0ge1NlcnZpY2VDYWxlbmRhcn0gY2FsZW5kYXIgLSDsupjrprDrjZQg7Yyp7Yag66asIO2BtOuemOyKpFxuICovXG5TZXJ2aWNlQ2FsZW5kYXIucHJvdG90eXBlLl90b2dnbGVWaWV3RXZlbnQgPSBmdW5jdGlvbihpc0F0dGFjaCwgdmlldywgY2FsZW5kYXIpIHtcbiAgICB2YXIgaGFuZGxlcnMgPSB2aWV3LmhhbmRsZXJzO1xuXG4gICAgdXRpbC5mb3JFYWNoKGhhbmRsZXJzLmNsaWNrLCBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgIGlmIChpc0F0dGFjaCkge1xuICAgICAgICAgICAgaGFuZGxlci5vbignY2xpY2snLCBjYWxlbmRhci5fb25DbGljaywgY2FsZW5kYXIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFuZGxlci5vZmYoJ2NsaWNrJywgY2FsZW5kYXIuX29uQ2xpY2ssIGNhbGVuZGFyKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICog7KO867ewLCDsm5Trt7Ag6rCEIOyghO2ZmFxuICogQG92ZXJyaWRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmlld05hbWUgLSAnd2VlaycsICdtb250aCcg7KSRIO2VmOuCmFxuICogQHBhcmFtIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdIC0gdHJ1ZSDsp4DsoJXsi5wg67ewIOyghO2ZmOydtCDsl4bslrTrj4Qg7KCE7ZmY7J2EIOychO2VnCDrj5nsnpHsnYQg7IiY7ZaJ7ZWc64ukXG4gKi9cblNlcnZpY2VDYWxlbmRhci5wcm90b3R5cGUudG9nZ2xlVmlldyA9IGZ1bmN0aW9uKHZpZXdOYW1lLCBmb3JjZSkge1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLmxheW91dCxcbiAgICAgICAgY29udHJvbGxlciA9IHRoaXMuY29udHJvbGxlcixcbiAgICAgICAgZHJhZ0hhbmRsZXIgPSB0aGlzLmRyYWdIYW5kbGVyLFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKCFmb3JjZSAmJiB0aGlzLmN1cnJlbnRWaWV3TmFtZSA9PT0gdmlld05hbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBsYXlvdXQuY2hpbGRzLmRvV2hlbkhhcyh2aWV3TmFtZSwgZnVuY3Rpb24odmlldykge1xuICAgICAgICB0aGlzLl90b2dnbGVWaWV3RXZlbnQoZmFsc2UsIHZpZXcsIHRoaXMpO1xuICAgIH0sIHRoaXMpO1xuICAgIGxheW91dC5jbGVhcigpO1xuXG4gICAgaWYgKHZpZXdOYW1lID09PSAnd2VlaycpIHtcbiAgICAgICAgbGF5b3V0LmFkZENoaWxkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZpY2VXZWVrVmlld0ZhY3RvcnkoY29udHJvbGxlciwgbGF5b3V0LmNvbnRhaW5lciwgZHJhZ0hhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHZpZXdOYW1lID09PSAnbW9udGgnKSB7XG4gICAgICAgIC8vVE9ETzogaW1wbGVtZW50c1xuICAgICAgICBjb25zb2xlLmxvZygn7JuU67ewIOyghO2ZmCcpO1xuICAgIH1cblxuICAgIGxheW91dC5jaGlsZHMuZG9XaGVuSGFzKHZpZXdOYW1lLCBmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZVZpZXdFdmVudCh0cnVlLCB2aWV3LCB0aGlzKTtcbiAgICB9LCB0aGlzKTtcbiAgICBsYXlvdXQucmVuZGVyKCk7XG5cbiAgICB0aGlzLmN1cnJlbnRWaWV3TmFtZSA9IHZpZXdOYW1lO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXJ2aWNlQ2FsZW5kYXI7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBGYWN0b3J5IG1vZHVsZSBmb3IgV2Vla1ZpZXcgKGN1c3RvbWl6ZWQgZm9yIHNlcnZpY2UpXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xuXG4vLyBQYXJlbnQgdmlld3NcbnZhciBXZWVrID0gcmVxdWlyZSgnLi4vLi4vdmlldy93ZWVrL3dlZWsnKTtcblxuLy8gU3ViIHZpZXdzXG52YXIgRGF5TmFtZSA9IHJlcXVpcmUoJy4uLy4uL3ZpZXcvd2Vlay9kYXluYW1lJyk7XG52YXIgTWlsZXN0b25lID0gcmVxdWlyZSgnLi4vdmlldy9taWxlc3RvbmUnKTtcbnZhciBUYXNrVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXcvdGFza3ZpZXcnKTtcbnZhciBUaW1lR3JpZCA9IHJlcXVpcmUoJy4uLy4uL3ZpZXcvd2Vlay90aW1lR3JpZCcpO1xudmFyIEFsbGRheSA9IHJlcXVpcmUoJy4uLy4uL3ZpZXcvd2Vlay9hbGxkYXknKTtcblxuXG4vLyBIYW5kbGVyc1xudmFyIEFsbGRheUNsaWNrID0gcmVxdWlyZSgnLi4vLi4vaGFuZGxlci9hbGxkYXkvY2xpY2snKTtcbnZhciBBbGxkYXlDcmVhdGlvbiA9IHJlcXVpcmUoJy4uLy4uL2hhbmRsZXIvYWxsZGF5L2NyZWF0aW9uJyk7XG52YXIgQWxsZGF5TW92ZSA9IHJlcXVpcmUoJy4uLy4uL2hhbmRsZXIvYWxsZGF5L21vdmUnKTtcbnZhciBBbGxkYXlSZXNpemUgPSByZXF1aXJlKCcuLi8uLi9oYW5kbGVyL2FsbGRheS9yZXNpemUnKTtcbnZhciBUaW1lQ2xpY2sgPSByZXF1aXJlKCcuLi8uLi9oYW5kbGVyL3RpbWUvY2xpY2snKTtcbnZhciBUaW1lQ3JlYXRpb24gPSByZXF1aXJlKCcuLi8uLi9oYW5kbGVyL3RpbWUvY3JlYXRpb24nKTtcbnZhciBUaW1lTW92ZSA9IHJlcXVpcmUoJy4uLy4uL2hhbmRsZXIvdGltZS9tb3ZlJyk7XG52YXIgVGltZVJlc2l6ZSA9IHJlcXVpcmUoJy4uLy4uL2hhbmRsZXIvdGltZS9yZXNpemUnKTtcbnZhciBNaWxlc3RvbmVDbGljayA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvbWlsZXN0b25lQ2xpY2snKTtcbnZhciBUYXNrQ2xpY2sgPSByZXF1aXJlKCcuLi9oYW5kbGVyL3Rhc2tDbGljaycpO1xuXG4vLyBCYXNlIFRlbXBsYXRlc1xudmFyIHdlZWtWaWV3VG1wbCA9IHJlcXVpcmUoJy4uLy4uL2Rvb3JheS92aWV3L3RlbXBsYXRlL2ZhY3Rvcnkvd2Vla1ZpZXcuaGJzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYmFzZUNvbnRyb2xsZXIsIGxheW91dENvbnRhaW5lciwgZHJhZ0hhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgd2Vla1ZpZXcsXG4gICAgICAgIGRheU5hbWVWaWV3LFxuICAgICAgICBtaWxlc3RvbmVWaWV3LFxuICAgICAgICB0YXNrVmlldyxcbiAgICAgICAgYWxsZGF5VmlldyxcbiAgICAgICAgdGltZUdyaWRWaWV3LFxuICAgICAgICBtaWxlc3RvbmVDbGlja0hhbmRsZXIsXG4gICAgICAgIHRhc2tDbGlja0hhbmRsZXIsXG4gICAgICAgIGFsbGRheUNsaWNrSGFuZGxlcixcbiAgICAgICAgYWxsZGF5Q3JlYXRpb25IYW5kbGVyLFxuICAgICAgICBhbGxkYXlNb3ZlSGFuZGxlcixcbiAgICAgICAgYWxsZGF5UmVzaXplSGFuZGxlcixcbiAgICAgICAgdGltZUNsaWNrSGFuZGxlcixcbiAgICAgICAgdGltZUNyZWF0aW9uSGFuZGxlcixcbiAgICAgICAgdGltZU1vdmVIYW5kbGVyLFxuICAgICAgICB0aW1lUmVzaXplSGFuZGxlcjtcblxuICAgIHdlZWtWaWV3ID0gbmV3IFdlZWsobnVsbCwgb3B0aW9ucy53ZWVrLCBsYXlvdXRDb250YWluZXIpO1xuICAgIHdlZWtWaWV3LmNvbnRhaW5lci5pbm5lckhUTUwgPSB3ZWVrVmlld1RtcGwoKTtcblxuICAgIC8qKioqKioqKioqXG4gICAgICog7J287J6Q7ZGc6riwICjsg4Hri6gg7J287JuU7ZmU7IiYLi4uKVxuICAgICAqKioqKioqKioqL1xuICAgIGRheU5hbWVWaWV3ID0gbmV3IERheU5hbWUobnVsbCwgZG9tdXRpbC5maW5kKCcuc2NoZWR1bGUtdmlldy1kYXluYW1lLWxheW91dCcsIHdlZWtWaWV3LmNvbnRhaW5lcikpO1xuICAgIHdlZWtWaWV3LmFkZENoaWxkKGRheU5hbWVWaWV3KTtcblxuICAgIC8qKioqKioqKioqXG4gICAgICog66eI7J287Iqk7YakXG4gICAgICoqKioqKioqKiovXG4gICAgbWlsZXN0b25lVmlldyA9IG5ldyBNaWxlc3RvbmUob3B0aW9ucy53ZWVrLCBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LW1pbGVzdG9uZS1sYXlvdXQnKSk7XG4gICAgd2Vla1ZpZXcuYWRkQ2hpbGQobWlsZXN0b25lVmlldyk7XG4gICAgbWlsZXN0b25lQ2xpY2tIYW5kbGVyID0gbmV3IE1pbGVzdG9uZUNsaWNrKGRyYWdIYW5kbGVyLCBtaWxlc3RvbmVWaWV3LCBiYXNlQ29udHJvbGxlcik7XG5cbiAgICAvKioqKioqKioqKlxuICAgICAqIOyXheustFxuICAgICAqKioqKioqKioqL1xuICAgIHRhc2tWaWV3ID0gbmV3IFRhc2tWaWV3KG9wdGlvbnMud2VlaywgZG9tdXRpbC5maW5kKCcuc2NoZWR1bGUtdmlldy1taWxlc3RvbmUtbGF5b3V0JykpO1xuICAgIHdlZWtWaWV3LmFkZENoaWxkKHRhc2tWaWV3KTtcbiAgICB0YXNrQ2xpY2tIYW5kbGVyID0gbmV3IFRhc2tDbGljayhkcmFnSGFuZGxlciwgdGFza1ZpZXcsIGJhc2VDb250cm9sbGVyKTtcblxuICAgIC8qKioqKioqKioqXG4gICAgICog7KKF7J287J287KCVXG4gICAgICoqKioqKioqKiovXG4gICAgYWxsZGF5VmlldyA9IG5ldyBBbGxkYXkob3B0aW9ucy53ZWVrLCBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LWFsbGRheS1sYXlvdXQnLCB3ZWVrVmlldy5jb250YWluZXIpKTtcbiAgICB3ZWVrVmlldy5hZGRDaGlsZChhbGxkYXlWaWV3KTtcbiAgICBhbGxkYXlDbGlja0hhbmRsZXIgPSBuZXcgQWxsZGF5Q2xpY2soZHJhZ0hhbmRsZXIsIGFsbGRheVZpZXcsIGJhc2VDb250cm9sbGVyKTtcbiAgICBhbGxkYXlDcmVhdGlvbkhhbmRsZXIgPSBuZXcgQWxsZGF5Q3JlYXRpb24oZHJhZ0hhbmRsZXIsIGFsbGRheVZpZXcsIGJhc2VDb250cm9sbGVyKTtcbiAgICBhbGxkYXlNb3ZlSGFuZGxlciA9IG5ldyBBbGxkYXlNb3ZlKGRyYWdIYW5kbGVyLCBhbGxkYXlWaWV3LCBiYXNlQ29udHJvbGxlcik7XG4gICAgYWxsZGF5UmVzaXplSGFuZGxlciA9IG5ldyBBbGxkYXlSZXNpemUoZHJhZ0hhbmRsZXIsIGFsbGRheVZpZXcsIGJhc2VDb250cm9sbGVyKTtcblxuICAgIC8qKioqKioqKioqXG4gICAgICog7Iuc6rCE67OEIOydvOyglVxuICAgICAqKioqKioqKioqL1xuICAgIHRpbWVHcmlkVmlldyA9IG5ldyBUaW1lR3JpZChvcHRpb25zLndlZWssIGRvbXV0aWwuZmluZCgnLnNjaGVkdWxlLXZpZXctdGltZWdyaWQtbGF5b3V0Jywgd2Vla1ZpZXcuY29udGFpbmVyKSk7XG4gICAgd2Vla1ZpZXcuYWRkQ2hpbGQodGltZUdyaWRWaWV3KTtcbiAgICB0aW1lQ2xpY2tIYW5kbGVyID0gbmV3IFRpbWVDbGljayhkcmFnSGFuZGxlciwgdGltZUdyaWRWaWV3LCBiYXNlQ29udHJvbGxlcik7XG4gICAgdGltZUNyZWF0aW9uSGFuZGxlciA9IG5ldyBUaW1lQ3JlYXRpb24oZHJhZ0hhbmRsZXIsIHRpbWVHcmlkVmlldywgYmFzZUNvbnRyb2xsZXIpO1xuICAgIHRpbWVNb3ZlSGFuZGxlciA9IG5ldyBUaW1lTW92ZShkcmFnSGFuZGxlciwgdGltZUdyaWRWaWV3LCBiYXNlQ29udHJvbGxlcik7XG4gICAgdGltZVJlc2l6ZUhhbmRsZXIgPSBuZXcgVGltZVJlc2l6ZShkcmFnSGFuZGxlciwgdGltZUdyaWRWaWV3LCBiYXNlQ29udHJvbGxlcik7XG5cbiAgICB3ZWVrVmlldy5oYW5kbGVycyA9IHtcbiAgICAgICAgY2xpY2s6IHtcbiAgICAgICAgICAgIG1pbGVzdG9uZTogbWlsZXN0b25lQ2xpY2tIYW5kbGVyLFxuICAgICAgICAgICAgdGFzazogdGFza0NsaWNrSGFuZGxlcixcbiAgICAgICAgICAgIGFsbGRheTogYWxsZGF5Q2xpY2tIYW5kbGVyLFxuICAgICAgICAgICAgdGltZTogdGltZUNsaWNrSGFuZGxlclxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGlvbjoge1xuICAgICAgICAgICAgYWxsZGF5OiBhbGxkYXlDcmVhdGlvbkhhbmRsZXIsXG4gICAgICAgICAgICB0aW1lOiB0aW1lQ3JlYXRpb25IYW5kbGVyXG4gICAgICAgIH0sXG4gICAgICAgIG1vdmU6IHtcbiAgICAgICAgICAgIGFsbGRheTogYWxsZGF5TW92ZUhhbmRsZXIsXG4gICAgICAgICAgICB0aW1lOiB0aW1lTW92ZUhhbmRsZXJcbiAgICAgICAgfSxcbiAgICAgICAgcmVzaXplOiB7XG4gICAgICAgICAgICBhbGxkYXk6IGFsbGRheVJlc2l6ZUhhbmRsZXIsXG4gICAgICAgICAgICB0aW1lOiB0aW1lUmVzaXplSGFuZGxlclxuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLy8gYWRkIGNvbnRyb2xsZXJcbiAgICB3ZWVrVmlldy5jb250cm9sbGVyID0gYmFzZUNvbnRyb2xsZXIuV2VlaztcblxuICAgIC8vIGFkZCBkZXN0cm95XG4gICAgd2Vla1ZpZXcuX2JlZm9yZURlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdXRpbC5mb3JFYWNoKHdlZWtWaWV3LmhhbmRsZXJzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICB1dGlsLmZvckVhY2godHlwZSwgZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub2ZmKCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiB3ZWVrVmlldztcbn07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcg66eI7J287Iqk7YakIO2VreuqqSDtgbTrpq0g7J2067Kk7Yq4IO2VuOuTpOufrCDrqqjrk4hcbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG5cbi8qKlxuICog66eI7J287Iqk7YakIO2BtOumrSDsnbTrsqTtirgg7ZW465Ok65+sIOuqqOuTiFxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVsZW1lbnRzIHtIYW5kbGVyfVxuICogQG1peGVzIHV0aWwuQ3VzdG9tRXZlbnRzXG4gKiBAcGFyYW0ge0RyYWd9IGRyYWdIYW5kbGVyIC0gZHJhZ0hhbmRsZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7TWlsZXN0b25lfSBtaWxlc3RvbmVWaWV3IC0gbWlsc3RvbmUgdmlldyBpbnN0YW5jZVxuICogQHBhcmFtIHtCYXNlfSBiYXNlQ29udHJvbGxlciAtIGJhc2VDb250cm9sbGVyIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIE1pbGVzdG9uZUNsaWNrKGRyYWdIYW5kbGVyLCBtaWxlc3RvbmVWaWV3LCBiYXNlQ29udHJvbGxlcikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEcmFnfVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBkcmFnSGFuZGxlcjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNaWxlc3RvbmV9XG4gICAgICovXG4gICAgdGhpcy5taWxlc3RvbmVWaWV3ID0gbWlsZXN0b25lVmlldztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCYXNlfVxuICAgICAqL1xuICAgIHRoaXMuYmFzZUNvbnRyb2xsZXIgPSBiYXNlQ29udHJvbGxlcjtcblxuICAgIGRyYWdIYW5kbGVyLm9uKHtcbiAgICAgICAgJ2NsaWNrJzogdGhpcy5fb25DbGlja1xuICAgIH0sIHRoaXMpO1xufVxuXG4vKipcbiAqIERlc3Ryb3lcbiAqL1xuTWlsZXN0b25lQ2xpY2sucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9mZih0aGlzKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gdGhpcy5taWxlc3RvbmVWaWV3ID0gdGhpcy5iYXNlQ29udHJvbGxlciA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIGNoZWNrIHJlcG9uc2liaWxpdHkgdG8gdGhpcyBoYW5kbGVyIG1vZHVsZSBzdXBwbGllZCBlbGVtZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbnxzdHJpbmd9IHJldHVybiBmYWxzZSB3aGVuIGhhbmRsZXIgaGFzIG5vIHJlc3BvbnNpYmlsaXR5IGZvciBzdXBwbGllZCBlbGVtZW50LiBcbiAqIG90aGVyd2lzZSwgcmV0dXJuIGV2ZW50IG1vZGVsIGlkIHRoYXQgcmVsYXRlZCB3aXRoIHRhcmdldCBlbGVtZW50LlxuICovXG5NaWxlc3RvbmVDbGljay5wcm90b3R5cGUuY2hlY2tFeHBlY3RlZENvbmRpdGlvbiA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgIGlmICghZG9tdXRpbC5oYXNDbGFzcyh0YXJnZXQsICdzY2hlZHVsZS12aWV3LWRvdCcpICYmXG4gICAgICAgICFkb211dGlsLmhhc0NsYXNzKHRhcmdldCwgJ3NjaGVkdWxlLXZpZXctbWlsZXN0b25lLWl0ZW0nKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gZG9tdXRpbC5jbG9zZXN0KHRhcmdldCwgJy5zY2hlZHVsZS12aWV3LW1pbGVzdG9uZS1pdGVtJyk7XG4gICAgXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBkb211dGlsLmdldERhdGEodGFyZ2V0LCAnaWQnKTtcbn07XG5cbi8qKlxuICogQGVtaXRzIE1pbGVzdG9uZUNsaWNrI2NsaWNrXG4gKiBAcGFyYW0ge29iamVjdH0gY2xpY2tFdmVudCAtIGNsaWNrIGV2ZW50IG9iamVjdFxuICovXG5NaWxlc3RvbmVDbGljay5wcm90b3R5cGUuX29uQ2xpY2sgPSBmdW5jdGlvbihjbGlja0V2ZW50KSB7XG4gICAgdmFyIG1vZGVsSUQgPSB0aGlzLmNoZWNrRXhwZWN0ZWRDb25kaXRpb24oY2xpY2tFdmVudC50YXJnZXQpO1xuXG4gICAgaWYgKCFtb2RlbElEKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmJhc2VDb250cm9sbGVyLmV2ZW50cy5kb1doZW5IYXMobW9kZWxJRCwgZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudHMgTWlsZXN0b25lQ2xpY2sjY2xpY2tcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gbW9kZWwgLSBtb2RlbCBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maXJlKCdjbGljaycsIHtcbiAgICAgICAgICAgIG1vZGVsOiAgbW9kZWxcbiAgICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG59O1xuXG51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihNaWxlc3RvbmVDbGljayk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWlsZXN0b25lQ2xpY2s7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyDrp4jsnbzsiqTthqQg7ZWt66qpIO2BtOumrSDsnbTrsqTtirgg7ZW465Ok65+sIOuqqOuTiFxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcblxuLyoqXG4gKiDrp4jsnbzsiqTthqQg7YG066atIOydtOuypO2KuCDtlbjrk6Trn6wg66qo65OIXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZWxlbWVudHMge0hhbmRsZXJ9XG4gKiBAbWl4ZXMgdXRpbC5DdXN0b21FdmVudHNcbiAqIEBwYXJhbSB7RHJhZ30gZHJhZ0hhbmRsZXIgLSBkcmFnSGFuZGxlciBpbnN0YW5jZVxuICogQHBhcmFtIHtUYXNrfSB0YXNrVmlldyAtIG1pbHN0b25lIHZpZXcgaW5zdGFuY2VcbiAqIEBwYXJhbSB7QmFzZX0gYmFzZUNvbnRyb2xsZXIgLSBiYXNlQ29udHJvbGxlciBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBUYXNrQ2xpY2soZHJhZ0hhbmRsZXIsIHRhc2tWaWV3LCBiYXNlQ29udHJvbGxlcikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEcmFnfVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBkcmFnSGFuZGxlcjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtUYXNrfVxuICAgICAqL1xuICAgIHRoaXMudGFza1ZpZXcgPSB0YXNrVmlldztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCYXNlfVxuICAgICAqL1xuICAgIHRoaXMuYmFzZUNvbnRyb2xsZXIgPSBiYXNlQ29udHJvbGxlcjtcblxuICAgIGRyYWdIYW5kbGVyLm9uKHtcbiAgICAgICAgJ2NsaWNrJzogdGhpcy5fb25DbGlja1xuICAgIH0sIHRoaXMpO1xufVxuXG4vKipcbiAqIERlc3Ryb3lcbiAqL1xuVGFza0NsaWNrLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kcmFnSGFuZGxlci5vZmYodGhpcyk7XG4gICAgdGhpcy5kcmFnSGFuZGxlciA9IHRoaXMudGFza1ZpZXcgPSB0aGlzLmJhc2VDb250cm9sbGVyID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gY2hlY2sgcmVwb25zaWJpbGl0eSB0byB0aGlzIGhhbmRsZXIgbW9kdWxlIHN1cHBsaWVkIGVsZW1lbnRcbiAqIEByZXR1cm5zIHtib29sZWFufHN0cmluZ30gcmV0dXJuIGZhbHNlIHdoZW4gaGFuZGxlciBoYXMgbm8gcmVzcG9uc2liaWxpdHkgZm9yIHN1cHBsaWVkIGVsZW1lbnQuIFxuICogb3RoZXJ3aXNlLCByZXR1cm4gZXZlbnQgbW9kZWwgaWQgdGhhdCByZWxhdGVkIHdpdGggdGFyZ2V0IGVsZW1lbnQuXG4gKi9cblRhc2tDbGljay5wcm90b3R5cGUuY2hlY2tFeHBlY3RlZENvbmRpdGlvbiA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgIGlmICghZG9tdXRpbC5oYXNDbGFzcyh0YXJnZXQsICdzY2hlZHVsZS12aWV3LWRvdCcpICYmXG4gICAgICAgICFkb211dGlsLmhhc0NsYXNzKHRhcmdldCwgJ3NjaGVkdWxlLXZpZXctdGFzay1pdGVtJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRhcmdldCA9IGRvbXV0aWwuY2xvc2VzdCh0YXJnZXQsICcuc2NoZWR1bGUtdmlldy10YXNrLWl0ZW0nKTtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9tdXRpbC5nZXREYXRhKHRhcmdldCwgJ2lkJyk7XG59O1xuXG4vKipcbiAqIEBlbWl0cyBUYXNrQ2xpY2sjY2xpY2tcbiAqIEBwYXJhbSB7b2JqZWN0fSBjbGlja0V2ZW50IC0gY2xpY2sgZXZlbnQgb2JqZWN0XG4gKi9cblRhc2tDbGljay5wcm90b3R5cGUuX29uQ2xpY2sgPSBmdW5jdGlvbihjbGlja0V2ZW50KSB7XG4gICAgdmFyIG1vZGVsSUQgPSB0aGlzLmNoZWNrRXhwZWN0ZWRDb25kaXRpb24oY2xpY2tFdmVudC50YXJnZXQpO1xuXG4gICAgaWYgKCFtb2RlbElEKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmJhc2VDb250cm9sbGVyLmV2ZW50cy5kb1doZW5IYXMobW9kZWxJRCwgZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudHMgVGFza0NsaWNrI2NsaWNrXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IG1vZGVsIC0gbW9kZWwgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlyZSgnY2xpY2snLCB7XG4gICAgICAgICAgICBtb2RlbDogIG1vZGVsXG4gICAgICAgIH0pO1xuICAgIH0sIHRoaXMpO1xufTtcblxudXRpbC5DdXN0b21FdmVudHMubWl4aW4oVGFza0NsaWNrKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUYXNrQ2xpY2s7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBFeHRlbmQgbW9kZWwgY2xhc3MgZm9yIERvb3JheSBDYWxlbmRhciBwcm9qZWN0LlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uL21vZGVsL2V2ZW50Jyk7XG5cbi8qKlxuICog7J287KCVIOy5tO2FjOqzoOumrFxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG52YXIgRVZFTlRfQ0FURUdPUlkgPSB7XG4gICAgLyoqIOuniOydvOyKpO2GpCAqL1xuICAgIE1JTEVTVE9ORTogJ21pbGVzdG9uZScsXG5cbiAgICAvKiog7JeF66y0ICovXG4gICAgVEFTSzogJ3Rhc2snLFxuICAgIFxuICAgIC8qKiDsooXsnbzsnbzsoJUgKi9cbiAgICBBTExEQVk6ICdhbGxkYXknLFxuXG4gICAgLyoqIOyLnOqwhOuzhCDsnbzsoJUgKi9cbiAgICBUSU1FOiAndGltZSdcbn07XG5cbi8qKlxuICogRXZlbnQgY2xhc3MgZm9yIGRvb3JheSBwcm9qZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtFdmVudH1cbiAqL1xuZnVuY3Rpb24gRG9vcmF5RXZlbnQoKSB7XG4gICAgRXZlbnQuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIOydvOyglSDsubTthYzqs6DrpqwgKOuniOydvOyKpO2GpCwg7JeF66y0LCDsooXsnbzsnbzsoJUsIOyLnOqwhOuzhOydvOyglSlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY2F0ZWdvcnkgPSAnJztcblxuICAgIC8qKlxuICAgICAqIOyXheustCDsnbzsoJXsnZgg6rK97JqwIOq1rOu2hCAo7Lac6re87KCELCDsoJDsi6zsoIQsIO2HtOq3vOyghClcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZHVlRGF0ZUNsYXNzID0gJyc7XG59XG5cbnV0aWwuaW5oZXJpdChEb29yYXlFdmVudCwgRXZlbnQpO1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5Eb29yYXlFdmVudC5jcmVhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIGluc3QgPSBuZXcgRG9vcmF5RXZlbnQoKTtcbiAgICBpbnN0LmluaXQoZGF0YSk7XG5cbiAgICByZXR1cm4gaW5zdDtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBvcHRpb25zLlxuICovXG5Eb29yYXlFdmVudC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIEV2ZW50LnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmlzQWxsRGF5ID0gb3B0aW9ucy5jYXRlZ29yeSA9PT0gRVZFTlRfQ0FURUdPUlkuQUxMREFZO1xuICAgIHRoaXMuY2F0ZWdvcnkgPSBvcHRpb25zLmNhdGVnb3J5O1xuICAgIHRoaXMuZHVlRGF0ZUNsYXNzID0gb3B0aW9ucy5kdWVEYXRlQ2xhc3M7XG5cbiAgICBpZiAob3B0aW9ucy5jYXRlZ29yeSA9PT0gRVZFTlRfQ0FURUdPUlkuTUlMRVNUT05FIHx8XG4gICAgICAgIG9wdGlvbnMuY2F0ZWdvcnkgPT09IEVWRU5UX0NBVEVHT1JZLlRBU0spIHtcbiAgICAgICAgdGhpcy5zdGFydHMgPSBuZXcgRGF0ZSgrdGhpcy5lbmRzKTtcbiAgICAgICAgdGhpcy5zdGFydHMuc2V0TWludXRlcyh0aGlzLnN0YXJ0cy5nZXRNaW51dGVzKCkgLSAzMCk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEb29yYXlFdmVudDtcblxuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcIjFcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGFsaWFzMT1jb250YWluZXIubGFtYmRhLCBhbGlhczI9Y29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb24sIGFsaWFzMz1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9O1xuXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctbWlsZXN0b25lLWRheVxcXCIgXFxuICAgICAgICBzdHlsZT1cXFwid2lkdGg6XCJcbiAgICArIGFsaWFzMihhbGlhczEoKChzdGFjazEgPSAoZGF0YSAmJiBkYXRhLnJvb3QpKSAmJiBzdGFjazEud2lkdGgpLCBkZXB0aDApKVxuICAgICsgXCIlO2xlZnQ6XCJcbiAgICArIGFsaWFzMigoaGVscGVycy5tdWx0aXBseSB8fCAoZGVwdGgwICYmIGRlcHRoMC5tdWx0aXBseSkgfHwgaGVscGVycy5oZWxwZXJNaXNzaW5nKS5jYWxsKGFsaWFzMywoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS53aWR0aCksKGRhdGEgJiYgZGF0YS5pbmRleCkse1wibmFtZVwiOlwibXVsdGlwbHlcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpXG4gICAgKyBcIiU7bWluLWhlaWdodDpcIlxuICAgICsgYWxpYXMyKGFsaWFzMSgoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS5taW5IZWlnaHQpLCBkZXB0aDApKVxuICAgICsgXCJweDtoZWlnaHQ6XCJcbiAgICArIGFsaWFzMihhbGlhczEoKChzdGFjazEgPSAoZGF0YSAmJiBkYXRhLnJvb3QpKSAmJiBzdGFjazEuaGVpZ2h0KSwgZGVwdGgwKSlcbiAgICArIFwicHhcXFwiPlxcbiAgICAgICAgPHVsIGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LW1pbGVzdG9uZS1saXN0XFxcIj5cXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChhbGlhczMsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLml0ZW1zIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDIsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIjwvdWw+XFxuICAgIDwvZGl2PlxcblwiO1xufSxcIjJcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGFsaWFzMT1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbiwgYWxpYXMyPWNvbnRhaW5lci5sYW1iZGE7XG5cbiAgcmV0dXJuIFwiPGxpIGRhdGEtaWQ9XCJcbiAgICArIGFsaWFzMSgoaGVscGVycy5zdGFtcCB8fCAoZGVwdGgwICYmIGRlcHRoMC5zdGFtcCkgfHwgaGVscGVycy5oZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1vZGVsIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJzdGFtcFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSlcbiAgICArIFwiIGRhdGEtdGl0bGU9XFxcIlwiXG4gICAgKyBhbGlhczEoYWxpYXMyKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1vZGVsIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS50aXRsZSA6IHN0YWNrMSksIGRlcHRoMCkpXG4gICAgKyBcIlxcXCIgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctbWlsZXN0b25lLWl0ZW1cXFwiIFxcbiAgICAgICAgICAgIHN0eWxlPVxcXCJsaW5lLWhlaWdodDpcIlxuICAgICsgYWxpYXMxKGFsaWFzMigoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS5saW5lSGVpZ2h0KSwgZGVwdGgwKSlcbiAgICArIFwicHg7Y29sb3I6XCJcbiAgICArIGFsaWFzMShhbGlhczIoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubW9kZWwgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLmNvbG9yIDogc3RhY2sxKSwgZGVwdGgwKSlcbiAgICArIFwiXFxcIj48c3BhbiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1kb3RcXFwiIHN0eWxlPVxcXCJiYWNrZ3JvdW5kLWNvbG9yOlwiXG4gICAgKyBhbGlhczEoYWxpYXMyKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1vZGVsIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5iZ0NvbG9yIDogc3RhY2sxKSwgZGVwdGgwKSlcbiAgICArIFwiXFxcIj48L3NwYW4+IFwiXG4gICAgKyBhbGlhczEoYWxpYXMyKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1vZGVsIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS50aXRsZSA6IHN0YWNrMSksIGRlcHRoMCkpXG4gICAgKyBcIjwvbGk+XFxuXCI7XG59LFwiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMTtcblxuICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LW1pbGVzdG9uZS1sZWZ0XFxcIj5cXG4gICAgPHNwYW4+66eI7J287Iqk7YakPC9zcGFuPlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctbWlsZXN0b25lLXJpZ2h0IHNjaGVkdWxlLXZpZXctY2xlYXJcXFwiPlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmV2ZW50cyA6IGRlcHRoMCkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgxLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L2Rpdj5cXG5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IOuniOydvOyKpO2GpCDrt7BcbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciBWaWV3ID0gcmVxdWlyZSgnLi4vLi4vdmlldy92aWV3Jyk7XG52YXIgdG1wbCA9IHJlcXVpcmUoJy4vbWlsZXN0b25lLmhicycpO1xuXG52YXIgUEFERElORyA9IDQ7ICAgIC8vIOuniOydvOyKpO2GpCDqt7jrpqzrk5wg64K0IO2MqOuUqSDqsJIgKHRvcCArIGhlaWdodClcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtWaWV3fVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yZW5kZXJTdGFydERhdGUgLSBzdGFydCBkYXRlIG9mIGFsbGRheSB2aWV3J3MgcmVuZGVyIGRhdGUuIFlZWVktTU0tRERcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJlbmRlckVuZERhdGUgLSBlbmQgZGF0ZSBvZiBhbGxkYXkgdmlldydzIHJlbmRlciBkYXRlLiBZWVlZLU1NLUREXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWluSGVpZ2h0PTQwXSAtIG1pbi1oZWlnaHQgb2YgbWlsZXN0b25lIHZpZXcgXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGluZUhlaWdodD0xMl0gLSBsaW5lIGhlaWdodCBvZiBtaWxlc3RvbmUgdmlld1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIC0gY29udGFpbmVyIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gTWlsZXN0b25lKG9wdGlvbnMsIGNvbnRhaW5lcikge1xuICAgIGNvbnRhaW5lciA9IGRvbXV0aWwuYXBwZW5kSFRNTEVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgICdzY2hlZHVsZS12aWV3LW1pbGVzdG9uZS1jb250YWluZXInXG4gICAgKTtcblxuICAgIFZpZXcuY2FsbCh0aGlzLCBvcHRpb25zLCBjb250YWluZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgIHJlbmRlclN0YXJ0RGF0ZTogJycsXG4gICAgICAgIHJlbmRlckVuZERhdGU6ICcnLFxuICAgICAgICBtaW5IZWlnaHQ6IDQwLFxuICAgICAgICBsaW5lSGVpZ2h0OiAxMlxuICAgIH0sIG9wdGlvbnMpO1xufVxuXG51dGlsLmluaGVyaXQoTWlsZXN0b25lLCBWaWV3KTtcblxuLyoqXG4gKiBHZXQgYmFzZSB2aWV3bW9kZWwgZm9yIHRhc2sgdmlld1xuICogQHBhcmFtIHtvYmplY3R9IFt2aWV3TW9kZWxdIC0gdmlldyBtb2RlbCBmcm9tIHBhcmVudCB2aWV3XG4gKiBAcmV0dXJucyB7b2JqZWN0fSB2aWV3IG1vZGVsIGZvciB0YXNrIHZpZXdcbiAqL1xuTWlsZXN0b25lLnByb3RvdHlwZS5fZ2V0QmFzZVZpZXdNb2RlbCA9IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBldmVudHMgPSB7fSxcbiAgICAgICAgcmFuZ2UgPSBkYXRldGltZS5yYW5nZShcbiAgICAgICAgICAgIGRhdGV0aW1lLnN0YXJ0KGRhdGV0aW1lLnBhcnNlKG9wdGlvbnMucmVuZGVyU3RhcnREYXRlKSksXG4gICAgICAgICAgICBkYXRldGltZS5lbmQoZGF0ZXRpbWUucGFyc2Uob3B0aW9ucy5yZW5kZXJFbmREYXRlKSksXG4gICAgICAgICAgICBkYXRldGltZS5NSUxMSVNFQ09ORFNfUEVSX0RBWVxuICAgICAgICApLFxuICAgICAgICBoZWlnaHQ7XG5cbiAgICB1dGlsLmZvckVhY2gocmFuZ2UsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgZXZlbnRzW2RhdGV0aW1lLmZvcm1hdChkLCAnWVlZWS1NTS1ERCcpXSA9IHt9O1xuICAgIH0pO1xuXG4gICAgdXRpbC5leHRlbmQoZXZlbnRzLCB2aWV3TW9kZWwpO1xuXG4gICAgaGVpZ2h0ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgdXRpbC5tYXAoZXZlbnRzLCBmdW5jdGlvbihjb2xsKSB7XG4gICAgICAgIHJldHVybiBjb2xsLmxlbmd0aDtcbiAgICB9KSkgKiBvcHRpb25zLmxpbmVIZWlnaHQ7XG5cbiAgICBoZWlnaHQgPSBNYXRoLm1heChvcHRpb25zLm1pbkhlaWdodCwgaGVpZ2h0KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGV2ZW50czogZXZlbnRzLFxuICAgICAgICB3aWR0aDogMTAwIC8gcmFuZ2UubGVuZ3RoLFxuICAgICAgICBtaW5IZWlnaHQ6IG9wdGlvbnMubWluSGVpZ2h0LFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCArIFBBRERJTkcsXG4gICAgICAgIGxpbmVIZWlnaHQ6IG9wdGlvbnMubGluZUhlaWdodFxuICAgIH07XG59O1xuXG4vKipcbiAqIOuniOydvOyKpO2GpCDrt7Ag66CM642U66eBXG4gKiBAb3ZlcnJpZGVcbiAqL1xuTWlsZXN0b25lLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbih2aWV3TW9kZWwpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIsXG4gICAgICAgIGJhc2VWaWV3TW9kZWwgPSB0aGlzLl9nZXRCYXNlVmlld01vZGVsKHV0aWwucGljayh2aWV3TW9kZWwuZXZlbnRzSW5EYXRlUmFuZ2UsICdtaWxlc3RvbmUnKSk7XG5cbiAgICBjb250YWluZXIuc3R5bGUubWluSGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1pbkhlaWdodCArICdweCc7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IHRtcGwoYmFzZVZpZXdNb2RlbCk7XG5cbiAgICB1dGlsLmZvckVhY2goZG9tdXRpbC5maW5kKCdsaScsIGNvbnRhaW5lciwgdHJ1ZSksIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGlmIChlbC5vZmZzZXRXaWR0aCA8IGVsLnNjcm9sbFdpZHRoKSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgZG9tdXRpbC5nZXREYXRhKGVsLCAndGl0bGUnKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWlsZXN0b25lO1xuXG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoe1wiMVwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgcmV0dXJuIFwiPHRoPlwiXG4gICAgKyBjb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbihjb250YWluZXIubGFtYmRhKGRlcHRoMCwgZGVwdGgwKSlcbiAgICArIFwiPC90aD5cXG5cIjtcbn0sXCIzXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxO1xuXG4gIHJldHVybiBcIjx0cj5cXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LGRlcHRoMCx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDQsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIjwvdHI+XFxuXCI7XG59LFwiNFwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMSwgaGVscGVyLCBhbGlhczE9ZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSwgYWxpYXMyPWhlbHBlcnMuaGVscGVyTWlzc2luZywgYWxpYXMzPVwiZnVuY3Rpb25cIiwgYWxpYXM0PWNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uO1xuXG4gIHJldHVybiBcIjx0ZCBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1taW5pY2FsZW5kYXItXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnltZCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAueW1kIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJ5bWRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiIFxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaXNOb3RUaGlzTW9udGggOiBkZXB0aDApLHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDUsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuc2VsZWN0ZWQgOiBkZXB0aDApLHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDcsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudG9kYXkgOiBkZXB0aDApLHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDksIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaGFzU2NoZWR1bGUgOiBkZXB0aDApLHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDExLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzW1wiaWZcIl0uY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLndlZWtlbmQgOiBkZXB0aDApLHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDEzLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCJcXFwiPlxcbjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LW1pbmljYWxlbmRhci1kYXRlXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1taW5pY2FsZW5kYXItbGFiZWxcXFwiPjxzcGFuPlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5kIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5kIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJkXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIjwvc3Bhbj48L2Rpdj5cXG48L2J1dHRvbj5cXG48L3RkPlxcblwiO1xufSxcIjVcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHJldHVybiBcInNjaGVkdWxlLXZpZXctbWluaWNhbGVuZGFyLW90aGVyIFwiO1xufSxcIjdcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHJldHVybiBcInNjaGVkdWxlLXZpZXctbWluaWNhbGVuZGFyLWZvY3VzZWQgXCI7XG59LFwiOVwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgcmV0dXJuIFwic2NoZWR1bGUtdmlldy1taW5pY2FsZW5kYXItdG9kYXkgXCI7XG59LFwiMTFcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHJldHVybiBcInNjaGVkdWxlLXZpZXctbWluaWNhbGVuZGFyLWhhcy1zY2hlZHVsZSBcIjtcbn0sXCIxM1wiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgcmV0dXJuIFwic2NoZWR1bGUtdmlldy1taW5pY2FsZW5kYXItd2Vla2VuZCBcIjtcbn0sXCJjb21waWxlclwiOls3LFwiPj0gNC4wLjBcIl0sXCJtYWluXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxLCBoZWxwZXIsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9O1xuXG4gIHJldHVybiBcIjx0YWJsZT5cXG48Y2FwdGlvbj5cXG4gICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LW1pbmljYWxlbmRhci1uYXYgc2NoZWR1bGUtdmlldy1taW5pY2FsZW5kYXItcHJldlxcXCI+PHNwYW4+Jmx0Ozwvc3Bhbj48L2J1dHRvbj5cXG4gICAgPHNwYW4gY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctbWluaWNhbGVuZGFyLXRpdGxlXFxcIj5cIlxuICAgICsgY29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy50aXRsZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudGl0bGUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVycy5oZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gXCJmdW5jdGlvblwiID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcInRpdGxlXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIjwvc3Bhbj5cXG4gICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LW1pbmljYWxlbmRhci1uYXYgc2NoZWR1bGUtdmlldy1taW5pY2FsZW5kYXItbmV4dFxcXCI+PHNwYW4+Jmd0Ozwvc3Bhbj48L2J1dHRvbj5cXG48L2NhcHRpb24+XFxuPHRoZWFkPjx0cj5cXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmRheW5hbWUgOiBkZXB0aDApLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMSwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiPC90cj48L3RoZWFkPlxcbjx0Ym9keT5cXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNhbGVuZGFyIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDMsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIjwvdGJvZHk+XFxuPC90YWJsZT5cXG5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1pbmljYWxlbmRhciB2aWV3LlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBWaWV3ID0gcmVxdWlyZSgnLi4vLi4vdmlldy92aWV3Jyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgZG9tZXZlbnQgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tZXZlbnQnKTtcbnZhciBkYXRldGltZSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kYXRldGltZScpO1xudmFyIHRtcGwgPSByZXF1aXJlKCcuL21pbmljYWxlbmRhci5oYnMnKTtcblxudmFyIGdldERhdGVSeCA9IC9zY2hlZHVsZS12aWV3LW1pbmljYWxlbmRhci0oXFxkezR9LVxcZHsyfS1cXGR7Mn0pLztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtWaWV3fVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGZvciBtaW5pY2FsZW5kYXIgdmlld1xuICogIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGFydERheU9mV2Vlaz0wXSAtIHN0YXJ0IGRheSBvZiB3ZWVrLiBkZWZhdWx0IDAgKHN1bmRheSlcbiAqICBAcGFyYW0ge3N0cmluZ3xEYXRlfSBbb3B0aW9ucy5yZW5kZXJNb250aF0gLSBtb250aCB0byByZW5kZXJcbiAqICBAcGFyYW0ge3N0cmluZ1tdfSBbb3B0aW9ucy5oaWdobGlnaHREYXRlXSAtIGRhdGVzIHRvIGhpZ2hsaWdodFxuICogIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zLmRheW5hbWVzXSAtIGFycmF5IG9mIGVhY2ggZGF5cyBuYW1lLlxuICogQHBhcmFtIHtIVE1MRGl2RWxlbWVudH0gY29udGFpbmVyIC0gZWxlbWVudCB0byB1c2UgY29udGFpbmVyXG4gKi9cbmZ1bmN0aW9uIE1pbmlDYWxlbmRhcihvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICB2YXIgdG9kYXkgPSBkYXRldGltZS5zdGFydChuZXcgRGF0ZSgpKTtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNaW5pQ2FsZW5kYXIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWluaUNhbGVuZGFyKG9wdGlvbnMsIGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgVmlldy5jYWxsKHRoaXMsIG9wdGlvbnMsIGNvbnRhaW5lcik7XG4gICAgZG9tdXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdzY2hlZHVsZS12aWV3LW1pbmljYWxlbmRhcicpO1xuICAgIGRvbWV2ZW50Lm9uKHRoaXMuY29udGFpbmVyLCAnY2xpY2snLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgc3RhcnREYXlPZldlZWs6IDAsXG4gICAgICAgIHJlbmRlck1vbnRoOiBuZXcgRGF0ZSgrdG9kYXkpLFxuICAgICAgICBoaWdobGlnaHREYXRlOiBbXSxcbiAgICAgICAgZGF5bmFtZXM6IFsn7J28JywgJ+yblCcsICftmZQnLCAn7IiYJywgJ+uqqScsICfquIgnLCAn7YagJ11cbiAgICB9LCBvcHRpb25zKTtcblxuICAgIC8vIHBhcnNlIHJlbmRlck1vbnRoIG9wdGlvbnMgaWYgaXQgaXMgYW4gc3RyaW5nXG4gICAgaWYgKHV0aWwuaXNTdHJpbmcob3B0aW9ucy5yZW5kZXJNb250aCkpIHtcbiAgICAgICAgb3B0aW9ucy5yZW5kZXJNb250aCA9IGRhdGV0aW1lLnN0YXJ0KGRhdGV0aW1lLnBhcnNlKG9wdGlvbnMucmVuZGVyTW9udGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDsnbzsnpAg6rCV7KGwIOuNsOydtO2EsFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5obERhdGEgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5oaWdobGlnaHREYXRlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmhpZ2hsaWdodERhdGUob3B0aW9ucy5oaWdobGlnaHREYXRlKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcigpO1xufVxuXG51dGlsLmluaGVyaXQoTWluaUNhbGVuZGFyLCBWaWV3KTtcblxuLyoqXG4gKiBOZXh0LCBQcmV2IGJ1dHRvbiBldmVudCBoYW5kbGVyXG4gKiBAZmlyZXMgTWluaWNhbGVuZGFyI2NoYW5nZVxuICogQHBhcmFtIHtIVE1MQnV0dG9uRWxlbWVudH0gYnV0dG9uRWxlbWVudCAtIG5leHQsIHByZXYgYnV0dG9uIGZyb20gX29uQ2xpY2sgZXZlbnQgaGFuZGxlclxuICovXG5NaW5pQ2FsZW5kYXIucHJvdG90eXBlLl9uYXYgPSBmdW5jdGlvbihidXR0b25FbGVtZW50KSB7XG4gICAgdmFyIGlzTmV4dCA9IGRvbXV0aWwuaGFzQ2xhc3MoYnV0dG9uRWxlbWVudCwgJ3NjaGVkdWxlLXZpZXctbWluaWNhbGVuZGFyLW5leHQnKSxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgb2Zmc2V0ID0gaXNOZXh0ID8gMSA6IC0xLFxuICAgICAgICBldmVudERhdGEgPSB7XG4gICAgICAgICAgICBiZWZvcmU6IHRoaXMuZ2V0U2VsZWN0ZWREYXRlKClcbiAgICAgICAgfTtcblxuICAgIG9wdGlvbnMucmVuZGVyTW9udGguc2V0TW9udGgob3B0aW9ucy5yZW5kZXJNb250aC5nZXRNb250aCgpICsgb2Zmc2V0KTtcblxuICAgIHRoaXMucmVuZGVyKCk7XG5cbiAgICBldmVudERhdGEuYWZ0ZXIgPSB0aGlzLmdldFNlbGVjdGVkRGF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IE1pbmlDYWxlbmRhciNjaGFuZ2VcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7RGF0ZX0gYmVmb3JlIC0gdGhlIGRhdGUgb2YgYmVmb3JlIGNoYW5nZWRcbiAgICAgKiBAcHJvcGVydHkge0RhdGV9IGFmdGVyIC0gdGhlIGRhdGUgb2YgYWZ0ZXIgY2hhbmdlZFxuICAgICAqL1xuICAgIHRoaXMuZmlyZSgnY2hhbmdlJywgZXZlbnREYXRhKTtcbn07XG5cbi8qKlxuICogRGF0ZSBidXR0b24gZXZlbnQgaGFuZGxlclxuICogQGZpcmVzIE1pbmljYWxlbmRhciNjaGFuZ2VcbiAqIEBwYXJhbSB7SFRNTEJ1dHRvbkVsZW1lbnR9IGJ1dHRvbkVsZW1lbnQgLSBkYXRlIGJ1dHRvbiBmcm9tIF9vbkNsaWNrIGV2ZW50IGhhbmRsZXJcbiAqL1xuTWluaUNhbGVuZGFyLnByb3RvdHlwZS5fZGF0ZSA9IGZ1bmN0aW9uKGJ1dHRvbkVsZW1lbnQpIHtcbiAgICB2YXIgdGQgPSBkb211dGlsLmNsb3Nlc3QoYnV0dG9uRWxlbWVudCwgJ3RkJyksXG4gICAgICAgIHRvZGF5ID0gKG5ldyBEYXRlKCkpLFxuICAgICAgICBwcmV2aW91cyxcbiAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgIGV2ZW50RGF0YSA9IHtcbiAgICAgICAgICAgIGJlZm9yZTogdGhpcy5nZXRTZWxlY3RlZERhdGUoKVxuICAgICAgICB9O1xuXG4gICAgaWYgKHRkKSB7XG4gICAgICAgIHByZXZpb3VzID0gZG9tdXRpbC5maW5kKCcuc2NoZWR1bGUtdmlldy1taW5pY2FsZW5kYXItZm9jdXNlZCcsIHRoaXMuY29udGFpbmVyKTtcblxuICAgICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgICAgIGRvbXV0aWwucmVtb3ZlQ2xhc3MocHJldmlvdXMsICdzY2hlZHVsZS12aWV3LW1pbmljYWxlbmRhci1mb2N1c2VkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBkb211dGlsLmFkZENsYXNzKHRkLCAnc2NoZWR1bGUtdmlldy1taW5pY2FsZW5kYXItZm9jdXNlZCcpO1xuXG4gICAgICAgIHNlbGVjdGVkID0gdGhpcy5nZXRTZWxlY3RlZERhdGUoKTtcblxuICAgICAgICBpZiAoZGF0ZXRpbWUuaXNTYW1lRGF0ZShzZWxlY3RlZCwgdG9kYXkpKSB7XG4gICAgICAgICAgICBkb211dGlsLmFkZENsYXNzKHRkLCAnc2NoZWR1bGUtdmlldy1taW5pY2FsZW5kYXItdG9kYXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50RGF0YS5hZnRlciA9IHNlbGVjdGVkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXZlbnQgTWluaUNhbGVuZGFyI2NoYW5nZVxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJvcGVydHkge0RhdGV9IGJlZm9yZSAtIHRoZSBkYXRlIG9mIGJlZm9yZSBjaGFuZ2VkXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7RGF0ZX0gYWZ0ZXIgLSB0aGUgZGF0ZSBvZiBhZnRlciBjaGFuZ2VkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpcmUoJ2NoYW5nZScsIGV2ZW50RGF0YSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDbGljayBldmVudCBoYW5kbGVyXG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IGNsaWNrRXZlbnQgLSBjbGljayBtb3VzZSBldmVudCBvYmplY3RcbiAqL1xuTWluaUNhbGVuZGFyLnByb3RvdHlwZS5fb25DbGljayA9IGZ1bmN0aW9uKGNsaWNrRXZlbnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gY2xpY2tFdmVudC5zcmNFbGVtZW50IHx8IGNsaWNrRXZlbnQudGFyZ2V0LFxuICAgICAgICBidXR0b24gPSBkb211dGlsLmNsb3Nlc3QodGFyZ2V0LCAnYnV0dG9uJyk7XG5cbiAgICBpZiAoIWJ1dHRvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRvbXV0aWwuaGFzQ2xhc3MoYnV0dG9uLCAnc2NoZWR1bGUtdmlldy1taW5pY2FsZW5kYXItZGF0ZScpKSB7XG4gICAgICAgIHRoaXMuX2RhdGUoYnV0dG9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkb211dGlsLmhhc0NsYXNzKGJ1dHRvbiwgJ3NjaGVkdWxlLXZpZXctbWluaWNhbGVuZGFyLW5hdicpKSB7XG4gICAgICAgIHRoaXMuX25hdihidXR0b24pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgc2VsZWN0ZWQgZGF0YVxuICogQHJldHVybnMge0RhdGV9IHNlbGVjdGVkIGRhdGVcbiAqL1xuTWluaUNhbGVuZGFyLnByb3RvdHlwZS5nZXRTZWxlY3RlZERhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LW1pbmljYWxlbmRhci1mb2N1c2VkJywgdGhpcy5jb250YWluZXIpLFxuICAgICAgICBtYXRjaGVzO1xuXG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBtYXRjaGVzID0gc2VsZWN0ZWQuY2xhc3NOYW1lLm1hdGNoKGdldERhdGVSeCk7XG5cbiAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0ZXRpbWUucGFyc2UobWF0Y2hlc1sxXSk7XG59O1xuXG4vKipcbiAqIHNlbGVjdCBzcGVjaWZpYyBkYXRlLlxuICogQHBhcmFtIHtEYXRlfHN0cmluZ30gZGF0ZSAtIGRhdGUgdG8gc2VsZWN0XG4gKi9cbk1pbmlDYWxlbmRhci5wcm90b3R5cGUuc2VsZWN0RGF0ZSA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICB2YXIgX2RhdGUsXG4gICAgICAgIHRkLCBidXR0b247XG5cbiAgICBpZiAodXRpbC5pc1N0cmluZyhkYXRlKSkge1xuICAgICAgICBkYXRlID0gZGF0ZXRpbWUucGFyc2UoZGF0ZSk7XG4gICAgfVxuXG4gICAgX2RhdGUgPSBkYXRldGltZS5mb3JtYXQoZGF0ZSwgJ1lZWVktTU0tREQnKTtcbiAgICB0ZCA9IGRvbXV0aWwuZmluZCgnLnNjaGVkdWxlLXZpZXctbWluaWNhbGVuZGFyLScgKyBfZGF0ZSwgdGhpcy5jb250YWluZXIpO1xuICAgIGJ1dHRvbiA9IGRvbXV0aWwuZmluZCgnYnV0dG9uJywgdGQpO1xuXG4gICAgaWYgKCF0ZCB8fCAhYnV0dG9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9kYXRlKGJ1dHRvbik7XG59O1xuXG4vKipcbiAqIEdldCBtaW5pY2FsZW5kYXIgdmlldyBtb2RlbFxuICogQHBhcmFtIHtEYXRlfSByZW5kZXJEYXRlIC0gRGF0ZSB0byByZW5kZXIgbWluaWNhbGVuZGFyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnREYXlPZldlZWsgLSBudW1iZXIgb2Ygc3RhcnQgb2Ygd2VlayAoMDpzdW4gLi4uKVxuICogQHJldHVybnMge29iamVjdH0gdmlld21vZGVsXG4gKi9cbk1pbmlDYWxlbmRhci5wcm90b3R5cGUuX2dldFZpZXdNb2RlbCA9IGZ1bmN0aW9uKHJlbmRlckRhdGUsIHN0YXJ0RGF5T2ZXZWVrKSB7XG4gICAgdmFyIGRheW5hbWVzID0gdGhpcy5vcHRpb25zLmRheW5hbWVzLFxuICAgICAgICBobERhdGEgPSB0aGlzLmhsRGF0YSxcbiAgICAgICAgdG9kYXkgPSBkYXRldGltZS5zdGFydChuZXcgRGF0ZSgpKSxcbiAgICAgICAgaXNDdXJyZW50TW9udGggPSBkYXRldGltZS5pc1NhbWVNb250aChyZW5kZXJEYXRlLCB0b2RheSksXG4gICAgICAgIHZpZXdNb2RlbCA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBkYXRldGltZS5mb3JtYXQocmVuZGVyRGF0ZSwgJ1lZWVkuTU0nKSxcbiAgICAgICAgICAgIHN0YXJ0RGF5T2ZXZWVrOiBzdGFydERheU9mV2Vla1xuICAgICAgICB9O1xuXG4gICAgdmlld01vZGVsLmRheW5hbWUgPSB1dGlsLm1hcChcbiAgICAgICAgdXRpbC5yYW5nZShzdGFydERheU9mV2VlaywgNykuY29uY2F0KHV0aWwucmFuZ2UoNykpLnNsaWNlKDAsIDcpLFxuICAgICAgICBmdW5jdGlvbihpKSB7IHJldHVybiBkYXluYW1lc1tpXTsgfSBcbiAgICApO1xuXG4gICAgdmlld01vZGVsLmNhbGVuZGFyID0gZGF0ZXRpbWUuYXJyMmRDYWxlbmRhcihyZW5kZXJEYXRlLCBzdGFydERheU9mV2VlaywgZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB2YXIgZCA9IGRhdGUuZ2V0RGF0ZSgpLFxuICAgICAgICAgICAgeW1kID0gZGF0ZXRpbWUuZm9ybWF0KGRhdGUsICdZWVlZLU1NLUREJyksXG4gICAgICAgICAgICBkYXkgPSBkYXRlLmdldERheSgpLFxuICAgICAgICAgICAgc2VsZWN0ZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIGlzVG9kYXkgPSBkYXRldGltZS5pc1NhbWVEYXRlKGRhdGUsIHRvZGF5KSxcbiAgICAgICAgICAgIGRhdGVJc0luVGhpc01vbnRoID0gZGF0ZXRpbWUuaXNTYW1lTW9udGgoZGF0ZSwgcmVuZGVyRGF0ZSk7XG5cbiAgICAgICAgaWYgKGRhdGVJc0luVGhpc01vbnRoKSB7XG4gICAgICAgICAgICBpZiAoaXNDdXJyZW50TW9udGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNUb2RheSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlzVG9kYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkOiBkLFxuICAgICAgICAgICAgeW1kOiB5bWQsXG4gICAgICAgICAgICBoYXNTY2hlZHVsZTogaGxEYXRhW3ltZF0sXG4gICAgICAgICAgICBpc05vdFRoaXNNb250aDogIWRhdGVJc0luVGhpc01vbnRoLFxuICAgICAgICAgICAgd2Vla2VuZDogKGRheSA9PT0gMCB8fCBkYXkgPT09IDYpLFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgICAgICAgdG9kYXk6IGlzVG9kYXlcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiB2aWV3TW9kZWw7XG59O1xuXG4vKipcbiAqIFJlbmRlciB2aWV3XG4gKi9cbk1pbmlDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICByZW5kZXJEYXRlID0gb3B0aW9ucy5yZW5kZXJNb250aCxcbiAgICAgICAgc3RhcnREYXlPZldlZWsgPSBvcHRpb25zLnN0YXJ0RGF5T2ZXZWVrLFxuICAgICAgICB2aWV3TW9kZWw7XG5cbiAgICB2aWV3TW9kZWwgPSB0aGlzLl9nZXRWaWV3TW9kZWwocmVuZGVyRGF0ZSwgc3RhcnREYXlPZldlZWspO1xuXG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IHRtcGwodmlld01vZGVsKTtcbn07XG5cbi8qKlxuICogQ2FjaGUgZGF0YSBmb3IgaGlnaGxpZ2h0IHNwZWNpZmljIGRhdGVzIGluIGNhbGVuZGFyLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZGF0ZVN0ckxpc3QgLSB0aGUgYXJyYXkgb2YgZGF0ZXMgdG8gaGlnaGxpZ2h0LiAoWVlZWS1NTS1ERClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NpbGVudD1mYWxzZV0gLSBzZXQgdHJ1ZSBmb3IgcHJldmVudCBhdXRvIHJlbmRlcmluZy5cbiAqL1xuTWluaUNhbGVuZGFyLnByb3RvdHlwZS5oaWdobGlnaHREYXRlID0gZnVuY3Rpb24oZGF0ZVN0ckxpc3QsIHNpbGVudCkge1xuICAgIHZhciBvd25EYXRhID0gdGhpcy5obERhdGE7XG5cbiAgICB1dGlsLmZvckVhY2goZGF0ZVN0ckxpc3QsIGZ1bmN0aW9uKHltZCkge1xuICAgICAgICBvd25EYXRhW3ltZF0gPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENsZWFyIGNhY2hlZCBkYXRhIGZvciBoaWdobGlnaHRpbmcgc3BlY2lmaWMgZGF0ZSBmb3IgcmVwcmVzZW50IHRoZSBkYXRlIGhhcyBzY2hlZHVsZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NpbGVudD1mYWxzZV0gLSBzZXQgdHJ1ZSBmb3IgcHJldmVudCBhdXRvIHJlbmRlcmluZy5cbiAqL1xuTWluaUNhbGVuZGFyLnByb3RvdHlwZS5jbGVhckhpZ2hsaWdodERhdGUgPSBmdW5jdGlvbihzaWxlbnQpIHtcbiAgICBkZWxldGUgdGhpcy5obERhdGE7XG4gICAgdGhpcy5obERhdGEgPSB7fTtcblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxufTtcblxudXRpbC5DdXN0b21FdmVudHMubWl4aW4oTWluaUNhbGVuZGFyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNaW5pQ2FsZW5kYXI7XG5cbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZSh7XCIxXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxLCBhbGlhczE9Y29udGFpbmVyLmxhbWJkYSwgYWxpYXMyPWNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uLCBhbGlhczM9ZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fTtcblxuICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LXRhc2stZGF5XFxcIiBcXG4gICAgc3R5bGU9XFxcIndpZHRoOlwiXG4gICAgKyBhbGlhczIoYWxpYXMxKCgoc3RhY2sxID0gKGRhdGEgJiYgZGF0YS5yb290KSkgJiYgc3RhY2sxLndpZHRoKSwgZGVwdGgwKSlcbiAgICArIFwiJTtsZWZ0OlwiXG4gICAgKyBhbGlhczIoKGhlbHBlcnMubXVsdGlwbHkgfHwgKGRlcHRoMCAmJiBkZXB0aDAubXVsdGlwbHkpIHx8IGhlbHBlcnMuaGVscGVyTWlzc2luZykuY2FsbChhbGlhczMsKChzdGFjazEgPSAoZGF0YSAmJiBkYXRhLnJvb3QpKSAmJiBzdGFjazEud2lkdGgpLChkYXRhICYmIGRhdGEuaW5kZXgpLHtcIm5hbWVcIjpcIm11bHRpcGx5XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKVxuICAgICsgXCIlO1xcbiAgICAgICAgbWluLWhlaWdodDpcIlxuICAgICsgYWxpYXMyKGFsaWFzMSgoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS5taW5IZWlnaHQpLCBkZXB0aDApKVxuICAgICsgXCJweDtoZWlnaHQ6XCJcbiAgICArIGFsaWFzMihhbGlhczEoKChzdGFjazEgPSAoZGF0YSAmJiBkYXRhLnJvb3QpKSAmJiBzdGFjazEuaGVpZ2h0KSwgZGVwdGgwKSlcbiAgICArIFwicHg7XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy10YXNrLWRheS13cmFwXFxcIj5cXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzW1wiaWZcIl0uY2FsbChhbGlhczMsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1vcm5pbmcgOiBkZXB0aDApLHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDIsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMywoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubHVuY2ggOiBkZXB0aDApLHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDUsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMywoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZXZlbmluZyA6IGRlcHRoMCkse1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oNywgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG59LFwiMlwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMTtcblxuICByZXR1cm4gXCI8aDYgc3R5bGU9XFxcImxpbmUtaGVpZ2h0OlwiXG4gICAgKyBjb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbihjb250YWluZXIubGFtYmRhKCgoc3RhY2sxID0gKGRhdGEgJiYgZGF0YS5yb290KSkgJiYgc3RhY2sxLmxpbmVIZWlnaHQpLCBkZXB0aDApKVxuICAgICsgXCJweFxcXCI+7Lac6re8IOyghDwvaDY+XFxuICAgICAgICA8dWw+XFxuXCJcbiAgICArICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSwoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tb3JuaW5nIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5pdGVtcyA6IHN0YWNrMSkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgzLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L3VsPlxcblwiO1xufSxcIjNcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGFsaWFzMT1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbiwgYWxpYXMyPWNvbnRhaW5lci5sYW1iZGE7XG5cbiAgcmV0dXJuIFwiPGxpIGRhdGEtaWQ9XCJcbiAgICArIGFsaWFzMSgoaGVscGVycy5zdGFtcCB8fCAoZGVwdGgwICYmIGRlcHRoMC5zdGFtcCkgfHwgaGVscGVycy5oZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1vZGVsIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJzdGFtcFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSlcbiAgICArIFwiIGRhdGEtdGl0bGU9XFxcIlwiXG4gICAgKyBhbGlhczEoYWxpYXMyKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1vZGVsIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS50aXRsZSA6IHN0YWNrMSksIGRlcHRoMCkpXG4gICAgKyBcIlxcXCIgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctdGFzay1pdGVtXFxcIiBcXG4gICAgICAgICAgICBzdHlsZT1cXFwibGluZS1oZWlnaHQ6XCJcbiAgICArIGFsaWFzMShhbGlhczIoKChzdGFjazEgPSAoZGF0YSAmJiBkYXRhLnJvb3QpKSAmJiBzdGFjazEubGluZUhlaWdodCksIGRlcHRoMCkpXG4gICAgKyBcInB4O2NvbG9yOlwiXG4gICAgKyBhbGlhczEoYWxpYXMyKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1vZGVsIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5jb2xvciA6IHN0YWNrMSksIGRlcHRoMCkpXG4gICAgKyBcIlxcXCI+PHNwYW4gY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctZG90XFxcIiBzdHlsZT1cXFwiYmFja2dyb3VuZC1jb2xvcjpcIlxuICAgICsgYWxpYXMxKGFsaWFzMigoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tb2RlbCA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuYmdDb2xvciA6IHN0YWNrMSksIGRlcHRoMCkpXG4gICAgKyBcIlxcXCI+PC9zcGFuPiBcIlxuICAgICsgYWxpYXMxKGFsaWFzMigoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tb2RlbCA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEudGl0bGUgOiBzdGFjazEpLCBkZXB0aDApKVxuICAgICsgXCI8L2xpPlxcblwiO1xufSxcIjVcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazE7XG5cbiAgcmV0dXJuIFwiPGg2IHN0eWxlPVxcXCJsaW5lLWhlaWdodDpcIlxuICAgICsgY29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb24oY29udGFpbmVyLmxhbWJkYSgoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS5saW5lSGVpZ2h0KSwgZGVwdGgwKSlcbiAgICArIFwicHhcXFwiPuygkOyLrCDsoIQ8L2g2PlxcbiAgICAgICAgPHVsPlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubHVuY2ggOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLml0ZW1zIDogc3RhY2sxKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDMsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIjwvdWw+XFxuXCI7XG59LFwiN1wiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMTtcblxuICByZXR1cm4gXCI8aDYgc3R5bGU9XFxcImxpbmUtaGVpZ2h0OlwiXG4gICAgKyBjb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbihjb250YWluZXIubGFtYmRhKCgoc3RhY2sxID0gKGRhdGEgJiYgZGF0YS5yb290KSkgJiYgc3RhY2sxLmxpbmVIZWlnaHQpLCBkZXB0aDApKVxuICAgICsgXCJweFxcXCI+7Ye06re8IOyghDwvaDY+XFxuICAgICAgICA8dWw+XFxuXCJcbiAgICArICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSwoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5ldmVuaW5nIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5pdGVtcyA6IHN0YWNrMSkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgzLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L3VsPlxcblwiO1xufSxcImNvbXBpbGVyXCI6WzcsXCI+PSA0LjAuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazE7XG5cbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy10YXNrLWxlZnRcXFwiPlxcbiAgICA8c3Bhbj7sl4XrrLQ8L3NwYW4+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy10YXNrLXJpZ2h0IHNjaGVkdWxlLXZpZXcgY2xlYXJcXFwiPlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmV2ZW50cyA6IGRlcHRoMCkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgxLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L2Rpdj5cXG5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRhc2sgdmlldyBmb3IgdXBwZXIgYXJlYSBvZiBXZWVrIHZpZXcuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgVmlldyA9IHJlcXVpcmUoJy4uLy4uL3ZpZXcvdmlldycpO1xudmFyIHRtcGwgPSByZXF1aXJlKCcuL3Rhc2t2aWV3LmhicycpO1xuXG52YXIgUEFERElORyA9IDQ7ICAgIC8vIOq3uOumrOuTnCDrgrQg7Yyo65SpIOqwkiAodG9wICsgaGVpZ2h0KVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge1ZpZXd9XG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIFRhc2tWaWV3XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yZW5kZXJTdGFydERhdGUgLSBzdGFydCBkYXRlIG9mIGFsbGRheSB2aWV3J3MgcmVuZGVyIGRhdGUuIFlZWVktTU0tRERcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJlbmRlckVuZERhdGUgLSBlbmQgZGF0ZSBvZiBhbGxkYXkgdmlldydzIHJlbmRlciBkYXRlLiBZWVlZLU1NLUREXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWluSGVpZ2h0PTQwXSAtIG1pbi1oZWlnaHQgb2YgdGFza3ZpZXdcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5saW5lSGVpZ2h0PTEyXSAtIGxpbmUgaGVpZ2h0IG9mIG1pbGVzdG9uZSB2aWV3XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgLSBjb250YWluZXIgZWxlbWVudFxuICovXG5mdW5jdGlvbiBUYXNrVmlldyhvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICBjb250YWluZXIgPSBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAnc2NoZWR1bGUtdmlldy10YXNrLWNvbnRhaW5lcidcbiAgICApO1xuXG4gICAgVmlldy5jYWxsKHRoaXMsIG9wdGlvbnMsIGNvbnRhaW5lcik7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgcmVuZGVyU3RhcnREYXRlOiAnJyxcbiAgICAgICAgcmVuZGVyRW5kRGF0ZTogJycsXG4gICAgICAgIG1pbkhlaWdodDogNDAsXG4gICAgICAgIGxpbmVIZWlnaHQ6IDEyXG4gICAgfSwgb3B0aW9ucyk7XG59XG5cbnV0aWwuaW5oZXJpdChUYXNrVmlldywgVmlldyk7XG5cbi8qKlxuICogR2V0IGJhc2Ugdmlld21vZGVsIGZvciB0YXNrIHZpZXdcbiAqIEBwYXJhbSB7b2JqZWN0fSBbdmlld01vZGVsXSAtIHZpZXcgbW9kZWwgZnJvbSBwYXJlbnQgdmlld1xuICogQHJldHVybnMge29iamVjdH0gdmlldyBtb2RlbCBmb3IgdGFzayB2aWV3XG4gKi9cblRhc2tWaWV3LnByb3RvdHlwZS5fZ2V0QmFzZVZpZXdNb2RlbCA9IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBldmVudHMgPSB7fSxcbiAgICAgICAgcmFuZ2UgPSBkYXRldGltZS5yYW5nZShcbiAgICAgICAgICAgIGRhdGV0aW1lLnN0YXJ0KGRhdGV0aW1lLnBhcnNlKG9wdGlvbnMucmVuZGVyU3RhcnREYXRlKSksXG4gICAgICAgICAgICBkYXRldGltZS5lbmQoZGF0ZXRpbWUucGFyc2Uob3B0aW9ucy5yZW5kZXJFbmREYXRlKSksXG4gICAgICAgICAgICBkYXRldGltZS5NSUxMSVNFQ09ORFNfUEVSX0RBWVxuICAgICAgICApLFxuICAgICAgICBoZWlnaHQgPSAwLFxuICAgICAgICBtbWF4ID0gTWF0aC5tYXg7XG5cbiAgICB1dGlsLmZvckVhY2gocmFuZ2UsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgZXZlbnRzW2RhdGV0aW1lLmZvcm1hdChkLCAnWVlZWS1NTS1ERCcpXSA9IHt9O1xuICAgIH0pO1xuXG4gICAgdXRpbC5leHRlbmQoZXZlbnRzLCB2aWV3TW9kZWwpO1xuXG4gICAgLy8gKOy2nOq3vOyghCwg7KCQ7Ius7KCELCDth7Tqt7zsoIQg7ZWt66qpIOyImCAqIDEycHgpICsgKOqwgSDtla3rqqnsnZgg7JWE7J207YWcIOyImCAqIDEycHgpXG4gICAgaGVpZ2h0ID0gbW1heC5hcHBseShudWxsLCB1dGlsLm1hcChldmVudHMsIGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgdmFyIHN1YmNvdW50ID0gdXRpbC5rZXlzKGcpLmxlbmd0aDtcblxuICAgICAgICB1dGlsLmZvckVhY2goZywgZnVuY3Rpb24oY29sbCkge1xuICAgICAgICAgICAgc3ViY291bnQgKz0gY29sbC5sZW5ndGg7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzdWJjb3VudDtcbiAgICB9KSkgKiBvcHRpb25zLmxpbmVIZWlnaHQ7XG5cbiAgICBoZWlnaHQgPSBtbWF4KG9wdGlvbnMubWluSGVpZ2h0LCBoZWlnaHQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICAgIHdpZHRoOiAxMDAgLyByYW5nZS5sZW5ndGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgUEFERElORyxcbiAgICAgICAgbGluZUhlaWdodDogb3B0aW9ucy5saW5lSGVpZ2h0XG4gICAgfTtcbn07XG5cbi8qKlxuICog7JeF66y0IOu3sCDroIzrjZTrp4FcbiAqIEBvdmVycmlkZVxuICovXG5UYXNrVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24odmlld01vZGVsKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLFxuICAgICAgICBiYXNlVmlld01vZGVsID0gdGhpcy5fZ2V0QmFzZVZpZXdNb2RlbCh1dGlsLnBpY2sodmlld01vZGVsLmV2ZW50c0luRGF0ZVJhbmdlLCAndGFzaycpKTtcblxuICAgIGNvbnRhaW5lci5zdHlsZS5taW5IZWlnaHQgPSB0aGlzLm9wdGlvbnMubWluSGVpZ2h0ICsgJ3B4JztcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gdG1wbChiYXNlVmlld01vZGVsKTtcblxuICAgIHV0aWwuZm9yRWFjaChkb211dGlsLmZpbmQoJ2xpJywgY29udGFpbmVyLCB0cnVlKSwgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgaWYgKGVsLm9mZnNldFdpZHRoIDwgZWwuc2Nyb2xsV2lkdGgpIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBkb211dGlsLmdldERhdGEoZWwsICd0aXRsZScpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUYXNrVmlldztcblxuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcImNvbXBpbGVyXCI6WzcsXCI+PSA0LjAuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctZGlzcGxheS10YWJsZVxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctZGlzcGxheS10YWJsZS1yb3dcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1kaXNwbGF5LXRhYmxlLWNlbGxcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctc2Nyb2xsLXkgc2NoZWR1bGUtdmlldy1kYXluYW1lLWxheW91dFxcXCI+PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctZGlzcGxheS10YWJsZS1yb3dcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1kaXNwbGF5LXRhYmxlLWNlbGxcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctc2Nyb2xsLXkgc2NoZWR1bGUtdmlldy1taWxlc3RvbmUtbGF5b3V0XFxcIiBzdHlsZT1cXFwibWluLWhlaWdodDo4MHB4O21heC1oZWlnaHQ6MTAwcHhcXFwiPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LWRpc3BsYXktdGFibGUtcm93XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctZGlzcGxheS10YWJsZS1jZWxsXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LXNjcm9sbC15IHNjaGVkdWxlLXZpZXctYWxsZGF5LWxheW91dFxcXCI+PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctZGlzcGxheS10YWJsZS1yb3dcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1kaXNwbGF5LXRhYmxlLWNlbGwgc2NoZWR1bGUtdmlldy10aW1lZ3JpZC1sYXlvdXRcXFwiPjwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEZhY3RvcnkgbW9kdWxlIGZvciBjb250cm9sIGFsbCBvdGhlciBmYWN0b3J5LlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBkYXRldGltZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9kYXRldGltZScpO1xudmFyIExheW91dCA9IHJlcXVpcmUoJy4uL3ZpZXcvbGF5b3V0Jyk7XG52YXIgRHJhZyA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvZHJhZycpO1xudmFyIGNvbnRyb2xsZXJGYWN0b3J5ID0gcmVxdWlyZSgnLi9jb250cm9sbGVyJyk7XG52YXIgd2Vla1ZpZXdGYWN0b3J5ID0gcmVxdWlyZSgnLi93ZWVrVmlldycpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IENhbGVuZGFyfkV2ZW50c1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHRpdGxlIC0g7J2067Kk7Yq4IOygnOuqqVxuICogQHByb3BlcnR5IHtib29sZWFufSBpc0FsbERheSAtIOyiheydvOydvOygleyXrOu2gFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXJ0cyAtIOydvOyglSDsi5zsnpEg7Iuc6rCEXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZW5kcyAtIOydvOyglSDsooXro4wg7Iuc6rCEXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbG9yXSAtIOydvOyglSDthY3siqTtirjsg4lcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYmdDb2xvcl0gLSDsnbzsoJUg67Cw6rK97IOJXG4gKi9cblxuLyoqXG4gKiBDYWxlbmRhciBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAbWl4ZXMgdXRpbC5DdXN0b21FdmVudHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgY2FsZW5kYXJcbiAqICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ncm91cEZ1bmNdIC0gZnVuY3Rpb24gZm9yIGdyb3VwIGV2ZW50IG1vZGVscyB7QHNlZSBDb2xsZWN0aW9uI2dyb3VwQnl9XG4gKiAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuY29udHJvbGxlcl0gLSBjb250cm9sbGVyIGluc3RhbmNlXG4gKiAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRlZmF1bHRWaWV3PSd3ZWVrJ10gLSBkZWZhdWx0IHZpZXcgb2YgY2FsZW5kYXJcbiAqICBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMud2Vla10gLSBvcHRpb25zIGZvciB3ZWVrIHZpZXdcbiAqICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMud2Vlay5yZW5kZXJTdGFydERhdGUgLSBZWVlZLU1NLUREIHJlbmRlciBzdGFydCBkYXRlXG4gKiAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLndlZWsucmVuZGVyRW5kRGF0ZSAtIFlZWVktTU0tREQgcmVuZGVyIGVuZCBkYXRlXG4gKiAgQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm1vbnRoXSAtIG9wdGlvbnMgZm9yIG1vbnRoIHZpZXdcbiAqICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubW9udGgucmVuZGVyTW9udGggLSBZWVlZLU1NIHJlbmRlciBtb250aFxuICogQHBhcmFtIHtIVE1MRGl2RWxlbWVudH0gY29udGFpbmVyID0gY29udGFpbmVyIGVsZW1lbnQgZm9yIGNhbGVuZGFyXG4gKi9cbmZ1bmN0aW9uIENhbGVuZGFyKG9wdGlvbnMsIGNvbnRhaW5lcikge1xuICAgIC8qKlxuICAgICAqIGJhc2UgZGF0ZSBvZiB2aWV3ICh0b2RheSgpIHdpbGwgdXNlIHRoaXMgcHJvcGVydHkpXG4gICAgICogQHR5cGUge0RhdGV9XG4gICAgICovXG4gICAgdGhpcy5iYXNlRGF0ZSA9IGRhdGV0aW1lLnN0YXJ0KG5ldyBEYXRlKCkpO1xuXG4gICAgLyoqXG4gICAgICogZGVmYXVsdCBvcHRpb24gZnJvbSBzZXJ2aWNlIHBhZ2VcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIG9yaWdpbmFsIG9wdGlvbnMgZm9yIHJlZmVyZW5jZSB3aGVuIHVpIHJlc2V0XG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbk9wdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMub3B0aW9ucykpO1xuXG4gICAgLyoqXG4gICAgICogYmFzZSBjb250cm9sbGVyXG4gICAgICogQHR5cGUge0Jhc2V9XG4gICAgICovXG4gICAgdGhpcy5jb250cm9sbGVyID0gb3B0aW9ucy5jb250cm9sbGVyIHx8IGNvbnRyb2xsZXJGYWN0b3J5KG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogbGF5b3V0IHZpZXcgKGxheW91dCBtYW5hZ2VyKVxuICAgICAqIEB0eXBlIHtMYXlvdXR9XG4gICAgICovXG4gICAgdGhpcy5sYXlvdXQgPSBuZXcgTGF5b3V0KGNvbnRhaW5lcik7XG5cbiAgICAvKipcbiAgICAgKiBnbG9iYWwgZHJhZyBoYW5kbGVyXG4gICAgICogQHR5cGUge0RyYWd9XG4gICAgICovXG4gICAgdGhpcy5kcmFnSGFuZGxlciA9IG5ldyBEcmFnKG51bGwsIHRoaXMubGF5b3V0KTtcblxuICAgIC8qKlxuICAgICAqIGN1cnJlbnQgcmVuZGVyZWQgdmlldyBuYW1lLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50Vmlld05hbWUgPSBvcHRpb25zLmRlZmF1bHRWaWV3IHx8ICd3ZWVrJztcblxuICAgIC8qKioqKioqKioqXG4gICAgICogU0VUVElOR1xuICAgICAqKioqKioqKioqL1xuICAgIHRoaXMubGF5b3V0LmNvbnRyb2xsZXIgPSB0aGlzLmNvbnRyb2xsZXI7XG5cbiAgICBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgICB0aGlzLnJlZnJlc2hDaGlsZFZpZXcoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyb2xsZXIub24oe1xuICAgICAgICB1cGRhdGVFdmVudDogcmVmcmVzaCxcbiAgICAgICAgY3JlYXRlZEV2ZW50OiByZWZyZXNoXG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLnRvZ2dsZVZpZXcob3B0aW9ucy5kZWZhdWx0VmlldywgdHJ1ZSk7XG5cbiAgICB0aGlzLnJlbmRlcigpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBldmVudHMgaW5zdGFuY2UgYW5kIHJlbmRlciBjYWxlbmRhci5cbiAqIEBwYXJhbSB7Q2FsZW5kYXJ+RXZlbnRbXX0gZGF0YU9iamVjdExpc3QgLSBhcnJheSBvZiB7QHNlZSBDYWxlbmRhcn5FdmVudH0gb2JqZWN0XG4gKi9cbkNhbGVuZGFyLnByb3RvdHlwZS5jcmVhdGVFdmVudCA9IGZ1bmN0aW9uKGRhdGFPYmplY3RMaXN0KSB7XG4gICAgdGhpcy5jb250cm9sbGVyLmNyZWF0ZUV2ZW50cyhkYXRhT2JqZWN0TGlzdCwgdHJ1ZSk7XG4gICAgdGhpcy5yZW5kZXIoKTtcbn07XG5cbi8qKlxuICogUmVuZGVyIGNhbGVuZGFyLlxuICovXG5DYWxlbmRhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5sYXlvdXQucmVuZGVyKCk7XG59O1xuXG4vKipcbiAqIERlbGV0ZSBhbGwgZGF0YSBhbmQgY2xlYXIgdmlldy5cbiAqL1xuQ2FsZW5kYXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb250cm9sbGVyLmRhdGVNYXRyaXggPSB7fTtcbiAgICB0aGlzLmNvbnRyb2xsZXIuZXZlbnRzLmNsZWFyKCk7XG4gICAgdGhpcy5yZW5kZXIoKTtcbn07XG5cbi8qKlxuICogTW92ZSBuZXh0LlxuICovXG5DYWxlbmRhci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW92ZSgxKTtcbn07XG5cbi8qKlxuICogTW92ZSBwcmV2aW91cy5cbiAqL1xuQ2FsZW5kYXIucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vdmUoLTEpO1xufTtcblxuLyoqXG4gKiBNb3ZlIHRvIHRvZGF5LlxuICovXG5DYWxlbmRhci5wcm90b3R5cGUudG9kYXkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VycmVudFZpZXcgPSB0aGlzLmdldEN1cnJlbnRWaWV3KCksXG4gICAgICAgIG9yaWdpbk9wdGlvbnMgPSB0aGlzLm9yaWdpbk9wdGlvbnM7XG5cbiAgICBpZiAoY3VycmVudFZpZXcudmlld05hbWUgPT09ICd3ZWVrJykge1xuICAgICAgICBvcmlnaW5PcHRpb25zID0gb3JpZ2luT3B0aW9ucy53ZWVrO1xuICAgICAgICB0aGlzLm9wdGlvbnMud2VlayA9IHtcbiAgICAgICAgICAgIHJlbmRlclN0YXJ0RGF0ZTogb3JpZ2luT3B0aW9ucy5yZW5kZXJTdGFydERhdGUsXG4gICAgICAgICAgICByZW5kZXJFbmREYXRlOiBvcmlnaW5PcHRpb25zLnJlbmRlckVuZERhdGUgXG4gICAgICAgIH07XG4gICAgICAgIGN1cnJlbnRWaWV3LnJlY3Vyc2l2ZShmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgICAgICBpZiAoIXZpZXcub3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmlldy5vcHRpb25zLnJlbmRlclN0YXJ0RGF0ZSA9IG9yaWdpbk9wdGlvbnMucmVuZGVyU3RhcnREYXRlO1xuICAgICAgICAgICAgdmlldy5vcHRpb25zLnJlbmRlckVuZERhdGUgPSBvcmlnaW5PcHRpb25zLnJlbmRlckVuZERhdGU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMucmVmcmVzaENoaWxkVmlldyhjdXJyZW50Vmlldy52aWV3TmFtZSk7XG59O1xuXG4vKipcbiAqIE1vdmUgY2FsZW5kYXIgYnkgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gZGlyZWN0aW9uIC0gdGhlIG51bWJlciB0aGF0IHdhbnQgdG8gbW92ZSAoKzEsIC0xKVxuICovXG5DYWxlbmRhci5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuICAgIHZhciBjdXJyZW50VmlldyA9IHRoaXMuZ2V0Q3VycmVudFZpZXcoKSxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblxuICAgICAgICBkYXRlT2Zmc2V0LFxuICAgICAgICBuZXdTdGFydCxcbiAgICAgICAgbmV3RW5kO1xuXG4gICAgaWYgKGN1cnJlbnRWaWV3LnZpZXdOYW1lID09PSAnd2VlaycpIHtcbiAgICAgICAgbmV3U3RhcnQgPSBkYXRldGltZS5zdGFydChkYXRldGltZS5wYXJzZShvcHRpb25zLndlZWsucmVuZGVyU3RhcnREYXRlKSk7XG4gICAgICAgIG5ld0VuZCA9IGRhdGV0aW1lLmVuZChkYXRldGltZS5wYXJzZShvcHRpb25zLndlZWsucmVuZGVyRW5kRGF0ZSkpO1xuICAgICAgICBkYXRlT2Zmc2V0ID0gZGF0ZXRpbWUucmFuZ2UobmV3U3RhcnQsIG5ld0VuZCwgZGF0ZXRpbWUuTUlMTElTRUNPTkRTX1BFUl9EQVkpLmxlbmd0aCAqIGRpcmVjdGlvbjtcbiAgICAgICAgbmV3U3RhcnQgPSBkYXRldGltZS5mb3JtYXQobmV3IERhdGUobmV3U3RhcnQuc2V0RGF0ZShuZXdTdGFydC5nZXREYXRlKCkgKyBkYXRlT2Zmc2V0KSksICdZWVlZLU1NLUREJyk7XG4gICAgICAgIG5ld0VuZCA9IGRhdGV0aW1lLmZvcm1hdChuZXcgRGF0ZShuZXdFbmQuc2V0RGF0ZShuZXdFbmQuZ2V0RGF0ZSgpICsgZGF0ZU9mZnNldCkpLCAnWVlZWS1NTS1ERCcpO1xuXG4gICAgICAgIG9wdGlvbnMud2VlayA9IHtcbiAgICAgICAgICAgIHJlbmRlclN0YXJ0RGF0ZTogbmV3U3RhcnQsXG4gICAgICAgICAgICByZW5kZXJFbmREYXRlOiBuZXdFbmRcbiAgICAgICAgfTtcbiAgICAgICAgY3VycmVudFZpZXcucmVjdXJzaXZlKGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgICAgIGlmICghdmlldy5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2aWV3Lm9wdGlvbnMucmVuZGVyU3RhcnREYXRlID0gbmV3U3RhcnQ7XG4gICAgICAgICAgICB2aWV3Lm9wdGlvbnMucmVuZGVyRW5kRGF0ZSA9IG5ld0VuZDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWZyZXNoQ2hpbGRWaWV3KGN1cnJlbnRWaWV3LnZpZXdOYW1lKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gY3VycmVudCByZW5kZXJlZCB2aWV3LlxuICogQHJldHVybnMge1ZpZXd9IGN1cnJlbnQgdmlldyBpbnN0YW5jZVxuICovXG5DYWxlbmRhci5wcm90b3R5cGUuZ2V0Q3VycmVudFZpZXcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdXRpbC5waWNrKHRoaXMubGF5b3V0LmNoaWxkcy5pdGVtcywgdGhpcy5jdXJyZW50Vmlld05hbWUpO1xufVxuXG4vKipcbiAqIFRvZ2dsZSBjdXJyZW50IHZpZXdcbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3TmFtZSAtIHRoZSBuYW1lIG9mIHZpZXcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIC0gZm9yY2UgcmVuZGVyIGRlc3BpdGUgb2YgY3VycmVudCB2aWV3IGFuZCBuZXcgdmlldyBhcmUgZXF1YWxcbiAqL1xuQ2FsZW5kYXIucHJvdG90eXBlLnRvZ2dsZVZpZXcgPSBmdW5jdGlvbih2aWV3TmFtZSwgZm9yY2UpIHtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5sYXlvdXQsXG4gICAgICAgIGNvbnRyb2xsZXIgPSB0aGlzLmNvbnRyb2xsZXIsXG4gICAgICAgIGRyYWdIYW5kbGVyID0gdGhpcy5kcmFnSGFuZGxlcixcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmICghZm9yY2UgJiYgdGhpcy5jdXJyZW50Vmlld05hbWUgPT09IHZpZXdOYW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRWaWV3TmFtZSA9IHZpZXdOYW1lO1xuICAgIGxheW91dC5jbGVhcigpO1xuXG4gICAgaWYgKHZpZXdOYW1lID09PSAnd2VlaycpIHtcbiAgICAgICAgbGF5b3V0LmFkZENoaWxkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtWaWV3RmFjdG9yeShjb250cm9sbGVyLCBsYXlvdXQuY29udGFpbmVyLCBkcmFnSGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEZXN0cm95IGNhbGVuZGFyIGluc3RhbmNlLlxuICovXG5DYWxlbmRhci5wcm90b3R5cGUuZGVzdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuY29udHJvbGxlci5vZmYoKTtcbiAgICB0aGlzLmxheW91dC5jbGVhcigpO1xuICAgIHRoaXMubGF5b3V0LmRlc3Ryb3koKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuYmFzZURhdGUgPSB0aGlzLmNvbnRyb2xsZXIgPVxuICAgICAgICB0aGlzLmxheW91dCA9IHRoaXMuZHJhZ0hhbmRsZXIgPSBudWxsO1xufVxuXG4vKipcbiAqIFJlZnJlc2ggY2hpbGQgdmlld3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdmlld05hbWVdIC0gdGhlIG5hbWUgb2YgdmlldyB0byByZW5kZXIuIGlmIG5vdCBzdXBwbGllZCB0aGVuIHJlZnJlc2ggYWxsLlxuICovXG5DYWxlbmRhci5wcm90b3R5cGUucmVmcmVzaENoaWxkVmlldyA9IGZ1bmN0aW9uKHZpZXdOYW1lKSB7XG4gICAgaWYgKCF2aWV3TmFtZSkge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sYXlvdXQuY2hpbGRzLml0ZW1zW3ZpZXdOYW1lXS5yZW5kZXIoKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGRlZmF1bHQgb3B0aW9uXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9wdGlvbiBmcm9tIHNlcnZpY2UgcGFnZVxuICogQHJldHVybnMge29iamVjdH0gZGVmYXVsdCBvcHRpb24uIFxuICovXG5DYWxlbmRhci5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgdG9kYXkgPSB0aGlzLmJhc2VEYXRlLFxuICAgICAgICBkYXRlUmFuZ2U7XG5cbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICBkZWZhdWx0VmlldzogJ3dlZWsnLCAgICAvLyDquLDrs7gg7KO86rCEIOu3sCDshKTsoJVcbiAgICAgICAgd2VlazogbnVsbCxcbiAgICAgICAgbW9udGg6IG51bGwgXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIW9wdGlvbnMud2Vlaykge1xuICAgICAgICBkYXRlUmFuZ2UgPSBkYXRldGltZS5yYW5nZShcbiAgICAgICAgICAgIGRhdGV0aW1lLnN0YXJ0KG5ldyBEYXRlKG5ldyBEYXRlKHRvZGF5KS5zZXREYXRlKHRvZGF5LmdldERhdGUoKSAtIDMpKSksXG4gICAgICAgICAgICBkYXRldGltZS5lbmQobmV3IERhdGUobmV3IERhdGUodG9kYXkpLnNldERhdGUodG9kYXkuZ2V0RGF0ZSgpICsgMykpKSxcbiAgICAgICAgICAgIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZXG4gICAgICAgICk7XG5cbiAgICAgICAgb3B0aW9ucy53ZWVrID0ge1xuICAgICAgICAgICAgcmVuZGVyU3RhcnREYXRlOiBkYXRldGltZS5mb3JtYXQoZGF0ZVJhbmdlWzBdLCAnWVlZWS1NTS1ERCcpLFxuICAgICAgICAgICAgcmVuZGVyRW5kRGF0ZTogZGF0ZXRpbWUuZm9ybWF0KGRhdGVSYW5nZVs2XSwgJ1lZWVktTU0tREQnKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5tb250aCkge1xuICAgICAgICBvcHRpb25zLm1vbnRoID0ge1xuICAgICAgICAgICAgcmVuZGVyTW9udGg6IGRhdGV0aW1lLmZvcm1hdCh0b2RheSwgJ1lZWVktTU0nKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zO1xufTtcblxudXRpbC5DdXN0b21FdmVudHMubWl4aW4oQ2FsZW5kYXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbGVuZGFyO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29udHJvbGxlciBmYWN0b3J5IG1vZHVsZS5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL2NvbnRyb2xsZXIvYmFzZScpO1xudmFyIFdlZWsgPSByZXF1aXJlKCcuLi9jb250cm9sbGVyL3ZpZXdNaXhpbi93ZWVrJyk7XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGZvciBiYXNlIGNvbnRyb2xsZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmdyb3VwRnVuY10gLSBmdW5jdGlvbiBmb3IgZ3JvdXAgZWFjaCBtb2RlbHMge0BzZWUgQ29sbGVjdGlvbiNncm91cEJ5fVxuICogQHJldHVybnMge0Jhc2V9IFRoZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgY29udHJvbGxlciA9IG5ldyBCYXNlKG9wdGlvbnMpO1xuXG4gICAgY29udHJvbGxlci5XZWVrID0ge307XG4gICAgdXRpbC5mb3JFYWNoKFdlZWssIGZ1bmN0aW9uKG1ldGhvZCwgbWV0aG9kTmFtZSkge1xuICAgICAgICBjb250cm9sbGVyLldlZWtbbWV0aG9kTmFtZV0gPSB1dGlsLmJpbmQobWV0aG9kLCBjb250cm9sbGVyKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb250cm9sbGVyO1xufTtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEZhY3RvcnkgbW9kdWxlIGZvciBXZWVrVmlld1xuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi9jb21tb24vZG9tdXRpbCcpO1xuXG4vLyBQYXJlbnQgdmlld3NcbnZhciBXZWVrID0gcmVxdWlyZSgnLi4vdmlldy93ZWVrL3dlZWsnKTtcblxuLy8gU3ViIHZpZXdzXG52YXIgRGF5TmFtZSA9IHJlcXVpcmUoJy4uL3ZpZXcvd2Vlay9kYXluYW1lJyk7XG52YXIgVGltZUdyaWQgPSByZXF1aXJlKCcuLi92aWV3L3dlZWsvdGltZUdyaWQnKTtcbnZhciBBbGxkYXkgPSByZXF1aXJlKCcuLi92aWV3L3dlZWsvYWxsZGF5Jyk7XG5cbi8vIEhhbmRsZXJzXG52YXIgQWxsZGF5Q2xpY2sgPSByZXF1aXJlKCcuLi9oYW5kbGVyL2FsbGRheS9jbGljaycpO1xudmFyIEFsbGRheUNyZWF0aW9uID0gcmVxdWlyZSgnLi4vaGFuZGxlci9hbGxkYXkvY3JlYXRpb24nKTtcbnZhciBBbGxkYXlNb3ZlID0gcmVxdWlyZSgnLi4vaGFuZGxlci9hbGxkYXkvbW92ZScpO1xudmFyIEFsbGRheVJlc2l6ZSA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvYWxsZGF5L3Jlc2l6ZScpO1xudmFyIFRpbWVDbGljayA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvdGltZS9jbGljaycpO1xudmFyIFRpbWVDcmVhdGlvbiA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvdGltZS9jcmVhdGlvbicpO1xudmFyIFRpbWVNb3ZlID0gcmVxdWlyZSgnLi4vaGFuZGxlci90aW1lL21vdmUnKTtcbnZhciBUaW1lUmVzaXplID0gcmVxdWlyZSgnLi4vaGFuZGxlci90aW1lL3Jlc2l6ZScpO1xuXG4vLyBCYXNlIFRlbXBsYXRlc1xudmFyIHdlZWtWaWV3VG1wbCA9IHJlcXVpcmUoJy4uL3ZpZXcvdGVtcGxhdGUvZmFjdG9yeS93ZWVrVmlldy5oYnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiYXNlQ29udHJvbGxlciwgbGF5b3V0Q29udGFpbmVyLCBkcmFnSGFuZGxlciwgb3B0aW9ucykge1xuICAgIHZhciB3ZWVrVmlldyxcbiAgICAgICAgZGF5TmFtZVZpZXcsXG4gICAgICAgIGFsbGRheVZpZXcsXG4gICAgICAgIHRpbWVHcmlkVmlldyxcbiAgICAgICAgYWxsZGF5Q2xpY2tIYW5kbGVyLFxuICAgICAgICBhbGxkYXlDcmVhdGlvbkhhbmRsZXIsXG4gICAgICAgIGFsbGRheU1vdmVIYW5kbGVyLFxuICAgICAgICBhbGxkYXlSZXNpemVIYW5kbGVyLFxuICAgICAgICB0aW1lQ2xpY2tIYW5kbGVyLFxuICAgICAgICB0aW1lQ3JlYXRpb25IYW5kbGVyLFxuICAgICAgICB0aW1lTW92ZUhhbmRsZXIsXG4gICAgICAgIHRpbWVSZXNpemVIYW5kbGVyO1xuXG4gICAgd2Vla1ZpZXcgPSBuZXcgV2VlayhudWxsLCBvcHRpb25zLndlZWssIGxheW91dENvbnRhaW5lcik7XG4gICAgd2Vla1ZpZXcuY29udGFpbmVyLmlubmVySFRNTCA9IHdlZWtWaWV3VG1wbCgpO1xuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiDsnbzsnpDtkZzquLAgKOyDgeuLqCDsnbzsm5TtmZTsiJguLi4pXG4gICAgICoqKioqKioqKiovXG4gICAgZGF5TmFtZVZpZXcgPSBuZXcgRGF5TmFtZShudWxsLCBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LWRheW5hbWUtbGF5b3V0Jywgd2Vla1ZpZXcuY29udGFpbmVyKSk7XG4gICAgd2Vla1ZpZXcuYWRkQ2hpbGQoZGF5TmFtZVZpZXcpO1xuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiDsooXsnbzsnbzsoJVcbiAgICAgKioqKioqKioqKi9cbiAgICBhbGxkYXlWaWV3ID0gbmV3IEFsbGRheShvcHRpb25zLndlZWssIGRvbXV0aWwuZmluZCgnLnNjaGVkdWxlLXZpZXctYWxsZGF5LWxheW91dCcsIHdlZWtWaWV3LmNvbnRhaW5lcikpO1xuICAgIHdlZWtWaWV3LmFkZENoaWxkKGFsbGRheVZpZXcpO1xuICAgIGFsbGRheUNsaWNrSGFuZGxlciA9IG5ldyBBbGxkYXlDbGljayhkcmFnSGFuZGxlciwgYWxsZGF5VmlldywgYmFzZUNvbnRyb2xsZXIpO1xuICAgIGFsbGRheUNyZWF0aW9uSGFuZGxlciA9IG5ldyBBbGxkYXlDcmVhdGlvbihkcmFnSGFuZGxlciwgYWxsZGF5VmlldywgYmFzZUNvbnRyb2xsZXIpO1xuICAgIGFsbGRheU1vdmVIYW5kbGVyID0gbmV3IEFsbGRheU1vdmUoZHJhZ0hhbmRsZXIsIGFsbGRheVZpZXcsIGJhc2VDb250cm9sbGVyKTtcbiAgICBhbGxkYXlSZXNpemVIYW5kbGVyID0gbmV3IEFsbGRheVJlc2l6ZShkcmFnSGFuZGxlciwgYWxsZGF5VmlldywgYmFzZUNvbnRyb2xsZXIpO1xuXG4gICAgLyoqKioqKioqKipcbiAgICAgKiDsi5zqsITrs4Qg7J287KCVXG4gICAgICoqKioqKioqKiovXG4gICAgdGltZUdyaWRWaWV3ID0gbmV3IFRpbWVHcmlkKG9wdGlvbnMud2VlaywgZG9tdXRpbC5maW5kKCcuc2NoZWR1bGUtdmlldy10aW1lZ3JpZC1sYXlvdXQnLCB3ZWVrVmlldy5jb250YWluZXIpKTtcbiAgICB3ZWVrVmlldy5hZGRDaGlsZCh0aW1lR3JpZFZpZXcpO1xuICAgIHRpbWVDbGlja0hhbmRsZXIgPSBuZXcgVGltZUNsaWNrKGRyYWdIYW5kbGVyLCB0aW1lR2lyZFZpZXcpO1xuICAgIHRpbWVDcmVhdGlvbkhhbmRsZXIgPSBuZXcgVGltZUNyZWF0aW9uKGRyYWdIYW5kbGVyLCB0aW1lR3JpZFZpZXcsIGJhc2VDb250cm9sbGVyKTtcbiAgICB0aW1lTW92ZUhhbmRsZXIgPSBuZXcgVGltZU1vdmUoZHJhZ0hhbmRsZXIsIHRpbWVHcmlkVmlldywgYmFzZUNvbnRyb2xsZXIpO1xuICAgIHRpbWVSZXNpemVIYW5kbGVyID0gbmV3IFRpbWVSZXNpemUoZHJhZ0hhbmRsZXIsIHRpbWVHcmlkVmlldywgYmFzZUNvbnRyb2xsZXIpO1xuXG4gICAgd2Vla1ZpZXcuaGFuZGxlcnMgPSB7XG4gICAgICAgIGNsaWNrOiB7XG4gICAgICAgICAgICBhbGxkYXk6IGFsbGRheUNsaWNrSGFuZGxlcixcbiAgICAgICAgICAgIHRpbWU6IHRpbWVDbGlja0hhbmRsZXJcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRpb246IHtcbiAgICAgICAgICAgIGFsbGRheTogYWxsZGF5Q3JlYXRpb25IYW5kbGVyLFxuICAgICAgICAgICAgdGltZTogdGltZUNyZWF0aW9uSGFuZGxlclxuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiB7XG4gICAgICAgICAgICBhbGxkYXk6IGFsbGRheU1vdmVIYW5kbGVyLFxuICAgICAgICAgICAgdGltZTogdGltZU1vdmVIYW5kbGVyXG4gICAgICAgIH0sXG4gICAgICAgIHJlc2l6ZToge1xuICAgICAgICAgICAgYWxsZGF5OiBhbGxkYXlSZXNpemVIYW5kbGVyLFxuICAgICAgICAgICAgdGltZTogdGltZVJlc2l6ZUhhbmRsZXJcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBhZGQgY29udHJvbGxlclxuICAgIHdlZWtWaWV3LmNvbnRyb2xsZXIgPSBiYXNlQ29udHJvbGxlci5XZWVrO1xuXG4gICAgLy8gYWRkIGRlc3Ryb3lcbiAgICB3ZWVrVmlldy5fYmVmb3JlRGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB1dGlsLmZvckVhY2god2Vla1ZpZXcuaGFuZGxlcnMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICAgIHV0aWwuZm9yRWFjaCh0eXBlLCBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5vZmYoKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHdlZWtWaWV3O1xufTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBDbGljayBoYW5kbGUgbW9kdWxlIGZvciBhbGxkYXkgZXZlbnRzXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIEFsbGRheU1vdmUgPSByZXF1aXJlKCcuL21vdmUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtIYW5kbGVyfVxuICogQG1peGVzIEN1c3RvbUV2ZW50c1xuICogQHBhcmFtIHtEcmFnfSBbZHJhZ0hhbmRsZXJdIC0gRHJhZyBoYW5kbGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHtBbGxkYXl9IFthbGxkYXlWaWV3XSAtIE1vbnRoV2VlayB2aWV3IGluc3RhbmNlLlxuICogQHBhcmFtIHtCYXNlfSBbYmFzZUNvbnRyb2xsZXJdIC0gQmFzZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBBbGxkYXlDbGljayhkcmFnSGFuZGxlciwgYWxsZGF5VmlldywgYmFzZUNvbnRyb2xsZXIpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RHJhZ31cbiAgICAgKi9cbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gZHJhZ0hhbmRsZXI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QWxsZGF5fVxuICAgICAqL1xuICAgIHRoaXMuYWxsZGF5VmlldyA9IGFsbGRheVZpZXc7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QmFzZX1cbiAgICAgKi9cbiAgICB0aGlzLmJhc2VDb250cm9sbGVyID0gYmFzZUNvbnRyb2xsZXI7XG5cbiAgICBkcmFnSGFuZGxlci5vbih7XG4gICAgICAgICdjbGljayc6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcbn1cblxuLyoqXG4gKiBEZXN0cm95IGhhbmRsZXIgbW9kdWxlXG4gKi9cbkFsbGRheUNsaWNrLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kcmFnSGFuZGxlci5vZmYodGhpcyk7XG4gICAgdGhpcy5hbGxkYXlWaWV3ID0gdGhpcy5iYXNlQ29udHJvbGxlciA9IHRoaXMuZHJhZ0hhbmRsZXIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDaGVjayB0YXJnZXQgZWxlbWVudCBpcyBleHBlY3RlZCBjb25kaXRpb24gZm9yIGFjdGl2YXRlIHRoaXMgcGx1Z2lucy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIFRoZSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIG1vZGVsIGlkXG4gKi9cbkFsbGRheUNsaWNrLnByb3RvdHlwZS5jaGVja0V4cGVjdENvbmRpdGlvbiA9IEFsbGRheU1vdmUucHJvdG90eXBlLmNoZWNrRXhwZWN0ZWRDb25kaXRpb247XG5cbi8qKlxuICogQ2xpY2sgZXZlbnQgaGFuZGxlclxuICogQHBhcmFtIHtvYmplY3R9IGNsaWNrRXZlbnQgLSBjbGljayBldmVudCBkYXRhXG4gKiBAZW1pdHMgQWxsZGF5Q2xpY2sjY2xpY2tcbiAqL1xuQWxsZGF5Q2xpY2sucHJvdG90eXBlLl9vbkNsaWNrID0gZnVuY3Rpb24oY2xpY2tFdmVudCkge1xuICAgIHZhciB0YXJnZXQgPSBjbGlja0V2ZW50LnRhcmdldCxcbiAgICAgICAgdGltZVZpZXcgPSB0aGlzLmNoZWNrRXhwZWN0Q29uZGl0aW9uKHRhcmdldCksXG4gICAgICAgIGJsb2NrRWxlbWVudCA9IGRvbXV0aWwuY2xvc2VzdCh0YXJnZXQsICcuc2NoZWR1bGUtdmlldy1hbGxkYXktZXZlbnQtYmxvY2snKSxcbiAgICAgICAgZXZlbnRDb2xsZWN0aW9uID0gdGhpcy5iYXNlQ29udHJvbGxlci5ldmVudHM7XG5cbiAgICBpZiAoIXRpbWVWaWV3IHx8ICFibG9ja0VsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50Q29sbGVjdGlvbi5kb1doZW5IYXMoZG9tdXRpbC5nZXREYXRhKGJsb2NrRWxlbWVudCwgJ2lkJyksIGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXZlbnRzIEFsbGRheUNsaWNrI2NsaWNrXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IG1vZGVsIC0gbW9kZWwgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlyZSgnY2xpY2snLCB7XG4gICAgICAgICAgICBtb2RlbDogIG1vZGVsXG4gICAgICAgIH0pO1xuICAgIH0sIHRoaXMpO1xufTtcblxudXRpbC5DdXN0b21FdmVudHMubWl4aW4oQWxsZGF5Q2xpY2spO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFsbGRheUNsaWNrO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQmFzZSBtaXhpbiBvYmplY3QgZm9yIGhhbmRsZXIvYWxsZGF5XG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIGRvbWV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbWV2ZW50Jyk7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi8uLi9jb21tb24vY29tbW9uJyk7XG5cbnZhciBtbWF4ID0gTWF0aC5tYXgsXG4gICAgbW1pbiA9IE1hdGgubWluLFxuICAgIENPTlRBSU5FUl9QQURESU5HX0xFRlQgPSA2MDtcblxuLyoqXG4gKiBAbWl4aW4gQWxsZGF5LkNvcmVcbiAqL1xudmFyIGFsbGRheUNvcmUgPSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBbGxkYXl9IGFsbGRheVZpZXcgLSB2aWV3IGluc3RhbmNlIG9mIGFsbGRheS5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IG1vdXNlRXZlbnQgLSBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9ufSBmdW5jdGlvbiB0aGF0IHJldHVybiBldmVudCBkYXRhIGJ5IG1vdXNlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBfcmV0cml2ZUV2ZW50RGF0YTogZnVuY3Rpb24oYWxsZGF5VmlldywgbW91c2VFdmVudCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gYWxsZGF5Vmlldy5jb250YWluZXIsXG4gICAgICAgICAgICByZW5kZXJTdGFydERhdGUsXG4gICAgICAgICAgICByZW5kZXJFbmREYXRlLFxuICAgICAgICAgICAgZGF0ZXNJblJhbmdlLFxuICAgICAgICAgICAgY29udGFpbmVyV2lkdGgsXG4gICAgICAgICAgICBtb3VzZVBvcyxcbiAgICAgICAgICAgIGRyYWdTdGFydFhJbmRleDtcblxuICAgICAgICByZW5kZXJTdGFydERhdGUgPSBkYXRldGltZS5wYXJzZShhbGxkYXlWaWV3Lm9wdGlvbnMucmVuZGVyU3RhcnREYXRlKTtcbiAgICAgICAgcmVuZGVyRW5kRGF0ZSA9IGRhdGV0aW1lLmVuZChkYXRldGltZS5wYXJzZShhbGxkYXlWaWV3Lm9wdGlvbnMucmVuZGVyRW5kRGF0ZSkpO1xuICAgICAgICBkYXRlc0luUmFuZ2UgPSBkYXRldGltZS5yYW5nZShyZW5kZXJTdGFydERhdGUsIHJlbmRlckVuZERhdGUsIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZKS5sZW5ndGg7XG4gICAgICAgIGNvbnRhaW5lcldpZHRoID0gZG9tdXRpbC5nZXRTaXplKGNvbnRhaW5lcilbMF0gLSBDT05UQUlORVJfUEFERElOR19MRUZUOyAgICAvLyBzdWJ0cmFjdCBjb250YWluZXIgbGVmdCBwYWRkaW5nLlxuXG4gICAgICAgIG1vdXNlUG9zID0gZG9tZXZlbnQuZ2V0TW91c2VQb3NpdGlvbihtb3VzZUV2ZW50LCBjb250YWluZXIpO1xuICAgICAgICBkcmFnU3RhcnRYSW5kZXggPSBjb21tb24ucmF0aW8oY29udGFpbmVyV2lkdGgsIGRhdGVzSW5SYW5nZSwgbW91c2VQb3NbMF0gLSBDT05UQUlORVJfUEFERElOR19MRUZUKSB8IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gbW91c2VFdmVudCAtIG1vdXNlIGV2ZW50IGluIGRyYWcgYWN0aW9ucy5cbiAgICAgICAgICogQHJldHVybnMge29iamVjdH0gZXZlbnQgZGF0YS5cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihtb3VzZUV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gZG9tZXZlbnQuZ2V0TW91c2VQb3NpdGlvbihtb3VzZUV2ZW50LCBjb250YWluZXIpLFxuICAgICAgICAgICAgICAgIG1vdXNlWCA9IHBvc1swXSAtIENPTlRBSU5FUl9QQURESU5HX0xFRlQsXG4gICAgICAgICAgICAgICAgeEluZGV4ID0gY29tbW9uLnJhdGlvKGNvbnRhaW5lcldpZHRoLCBkYXRlc0luUmFuZ2UsIG1vdXNlWCkgfCAwO1xuXG4gICAgICAgICAgICAvLyBhcHBseSBsaW1pdGF0aW9uIG9mIGNyZWF0aW9uIGV2ZW50IFggaW5kZXguXG4gICAgICAgICAgICB4SW5kZXggPSBtbWF4KHhJbmRleCwgMCk7XG4gICAgICAgICAgICB4SW5kZXggPSBtbWluKHhJbmRleCwgZGF0ZXNJblJhbmdlIC0gMSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVsYXRlZFZpZXc6IGFsbGRheVZpZXcsXG4gICAgICAgICAgICAgICAgZHJhZ1N0YXJ0WEluZGV4OiBkcmFnU3RhcnRYSW5kZXgsXG4gICAgICAgICAgICAgICAgZGF0ZXNJblJhbmdlOiBkYXRlc0luUmFuZ2UsXG4gICAgICAgICAgICAgICAgeEluZGV4OiB4SW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhbGxkYXlDb3JlO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgSGFuZGxlciBtb2R1bGUgZm9yIE1vbnRoV2VlayB2aWV3J3MgY3JlYXRpb24gYWN0aW9ucy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2NvbW1vbicpO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIGFsbGRheUNvcmUgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBBbGxkYXlDcmVhdGlvbkd1aWRlID0gcmVxdWlyZSgnLi9jcmVhdGlvbkd1aWRlJyk7XG5cbnZhciBwYXJzZVZpZXdJRFJ4ID0gL15zY2hlZHVsZS12aWV3LWFsbGRheS1tb250aHdlZWtbXFxzXXNjaGVkdWxlLXZpZXctKFxcZCspLztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtIYW5kbGVyfVxuICogQG1peGVzIEFsbGRheUNvcmVcbiAqIEBtaXhlcyBDdXRvbUV2ZW50c1xuICogQHBhcmFtIHtEcmFnfSBbZHJhZ0hhbmRsZXJdIC0gRHJhZyBoYW5kbGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHtBbGxkYXl9IFthbGxkYXlWaWV3XSAtIE1vbnRoV2VlayB2aWV3IGluc3RhbmNlLlxuICogQHBhcmFtIHtCYXNlfSBbYmFzZUNvbnRyb2xsZXJdIC0gQmFzZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBBbGxkYXlDcmVhdGlvbihkcmFnSGFuZGxlciwgYWxsZGF5VmlldywgYmFzZUNvbnRyb2xsZXIpIHsgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIC8qKlxuICAgICAqIERyYWcgaGFuZGxlciBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7RHJhZ31cbiAgICAgKi9cbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIGFsbGRheSB2aWV3IGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtBbGxkYXl9XG4gICAgICovXG4gICAgdGhpcy5hbGxkYXlWaWV3ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEJhc2UgY29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7QmFzZX1cbiAgICAgKi9cbiAgICB0aGlzLmJhc2VDb250cm9sbGVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmdldEV2ZW50RGF0YUZ1bmMgPSBudWxsO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FsbGRheUNyZWF0aW9uR3VpZGV9XG4gICAgICovXG4gICAgdGhpcy5ndWlkZSA9IG5ldyBBbGxkYXlDcmVhdGlvbkd1aWRlKHRoaXMpO1xufVxuXG4vKipcbiAqIERlc3Ryb3kgbWV0aG9kXG4gKi9cbkFsbGRheUNyZWF0aW9uLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5ndWlkZS5kZXN0cm95KCk7XG4gICAgdGhpcy5kcmFnSGFuZGxlci5vZmYodGhpcyk7XG4gICAgdGhpcy5kcmFnSGFuZGxlciA9IHRoaXMuYWxsZGF5VmlldyA9IHRoaXMuYmFzZUNvbnRyb2xsZXIgPVxuICAgICAgICB0aGlzLmdldEV2ZW50RGF0YUZ1bmMgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDaGVjayBkcmFnc3RhcnQgdGFyZ2V0IGlzIGV4cGVjdGVkIGNvbmRpdGlvbnMgZm9yIHRoaXMgaGFuZGxlci5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIGRyYWdzdGFydCBldmVudCBoYW5kbGVyJ3MgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbnxNb250aFdlZWt9IHJldHVybiBNb250aFdlZWsgdmlldyBpbnN0YW5jZSB3aGVuIHNhdGlhdGUgY29uZGl0aW9uLlxuICovXG5BbGxkYXlDcmVhdGlvbi5wcm90b3R5cGUuY2hlY2tFeHBlY3RlZENvbmRpdGlvbiA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgIHZhciBjc3NDbGFzcyA9IGRvbXV0aWwuZ2V0Q2xhc3ModGFyZ2V0KSxcbiAgICAgICAgbWF0Y2hlcztcblxuICAgIGlmIChjc3NDbGFzcyAhPT0gJ3NjaGVkdWxlLXZpZXctbW9udGh3ZWVrLWV2ZW50cycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgIGNzc0NsYXNzID0gZG9tdXRpbC5nZXRDbGFzcyh0YXJnZXQpO1xuICAgIG1hdGNoZXMgPSBjc3NDbGFzcy5tYXRjaChwYXJzZVZpZXdJRFJ4KTtcblxuICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlsLnBpY2sodGhpcy5hbGxkYXlWaWV3LmNoaWxkcy5pdGVtcywgbWF0Y2hlc1sxXSk7XG59O1xuXG4vKipcbiAqIENvbm5lY3QgaGFuZGxlciwgdmlldywgY29udHJvbGxlci5cbiAqIEBwYXJhbSB7RHJhZ30gW2RyYWdIYW5kbGVyXSAtIERyYWcgaGFuZGxlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7QWxsZGF5fSBbYWxsZGF5Vmlld10gLSBNb250aFdlZWsgdmlldyBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7QmFzZX0gW2Jhc2VDb250cm9sbGVyXSAtIEJhc2UgY29udHJvbGxlciBpbnN0YW5jZS5cbiAqL1xuQWxsZGF5Q3JlYXRpb24ucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihkcmFnSGFuZGxlciwgYWxsZGF5VmlldywgYmFzZUNvbnRyb2xsZXIpIHtcbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gZHJhZ0hhbmRsZXI7XG4gICAgdGhpcy5hbGxkYXlWaWV3ID0gYWxsZGF5VmlldztcbiAgICB0aGlzLmJhc2VDb250cm9sbGVyID0gYmFzZUNvbnRyb2xsZXI7XG5cbiAgICBkcmFnSGFuZGxlci5vbih7XG4gICAgICAgIGRyYWdTdGFydDogdGhpcy5fb25EcmFnU3RhcnRcbiAgICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogUmVxdWVzdCBldmVudCBtb2RlbCBjcmVhdGlvbiB0byBjb250cm9sbGVyIGJ5IGN1c3RvbSBldmVudHMuXG4gKiBAcGFyYW0ge29iamVjdH0gZXZlbnREYXRhIC0gZXZlbnQgZGF0YSBmcm9tIEFsbGRheUNyZWF0aW9uIG1vZHVsZS5cbiAqL1xuQWxsZGF5Q3JlYXRpb24ucHJvdG90eXBlLl9jcmVhdGVFdmVudCA9IGZ1bmN0aW9uKGV2ZW50RGF0YSkge1xuICAgIHZhciB0aXRsZSA9IHdpbmRvdy5wcm9tcHQoJ05hbWUgb2YgZXZlbnQgdG8gY3JlYXRlOicpLFxuICAgICAgICBjdHJsID0gdGhpcy5iYXNlQ29udHJvbGxlcixcbiAgICAgICAgdmlld09wdGlvbnMgPSBldmVudERhdGEucmVsYXRlZFZpZXcub3B0aW9ucyxcbiAgICAgICAgZGF0ZVJhbmdlID0gZGF0ZXRpbWUucmFuZ2UoXG4gICAgICAgICAgICBkYXRldGltZS5zdGFydChkYXRldGltZS5wYXJzZSh2aWV3T3B0aW9ucy5yZW5kZXJTdGFydERhdGUpKSxcbiAgICAgICAgICAgIGRhdGV0aW1lLmVuZChkYXRldGltZS5wYXJzZSh2aWV3T3B0aW9ucy5yZW5kZXJFbmREYXRlKSksXG4gICAgICAgICAgICBkYXRldGltZS5NSUxMSVNFQ09ORFNfUEVSX0RBWVxuICAgICAgICApLFxuICAgICAgICBzdGFydFhJbmRleCA9IGV2ZW50RGF0YS5kcmFnU3RhcnRYSW5kZXgsXG4gICAgICAgIHhJbmRleCA9IGV2ZW50RGF0YS54SW5kZXgsXG4gICAgICAgIG5ld1N0YXJ0cyxcbiAgICAgICAgbmV3RW5kcztcblxuICAgIHRoaXMuZ3VpZGUuY2xlYXJHdWlkZUVsZW1lbnQoKTtcblxuICAgIGlmICghdGl0bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHdoZW4gaW52ZXJzZSBzdGFydCwgZW5kIHRoZW4gY2hhbmdlIGl0LlxuICAgIGlmICh4SW5kZXggPCBzdGFydFhJbmRleCkge1xuICAgICAgICBzdGFydFhJbmRleCA9IHhJbmRleCArIHN0YXJ0WEluZGV4O1xuICAgICAgICB4SW5kZXggPSBzdGFydFhJbmRleCAtIHhJbmRleDtcbiAgICAgICAgc3RhcnRYSW5kZXggPSBzdGFydFhJbmRleCAtIHhJbmRleDtcbiAgICB9XG5cbiAgICBuZXdTdGFydHMgPSBuZXcgRGF0ZShkYXRlUmFuZ2Vbc3RhcnRYSW5kZXhdLmdldFRpbWUoKSk7XG4gICAgbmV3RW5kcyA9IGRhdGV0aW1lLmVuZChkYXRlUmFuZ2VbeEluZGV4XSk7XG5cbiAgICAvLyByZXF1ZXN0IGV2ZW50IGNyZWF0aW9uIHRvIFwiYmFzZVwiIGNvbnRyb2xsZXIuXG4gICAgY3RybC5jcmVhdGVFdmVudCh7XG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgaXNBbGxEYXk6IHRydWUsXG4gICAgICAgIHN0YXJ0czogbmV3U3RhcnRzLFxuICAgICAgICBlbmRzOiBuZXdFbmRzXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIERyYWdTdGFydCBldmVudCBoYW5kbGVyIG1ldGhvZC5cbiAqIEBlbWl0cyBBbGxkYXlDcmVhdGlvbiNhbGxkYXlfY3JlYXRpb25fZHJhZ3N0YXJ0XG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ1N0YXJ0RXZlbnREYXRhIC0gRHJhZyNkcmFnU3RhcnQgZXZlbnQgaGFuZGxlciBldmVudCBkYXRhLlxuICovXG5BbGxkYXlDcmVhdGlvbi5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZHJhZ1N0YXJ0RXZlbnREYXRhKSB7XG4gICAgdmFyIHRhcmdldCA9IGRyYWdTdGFydEV2ZW50RGF0YS50YXJnZXQsXG4gICAgICAgIHJlc3VsdCA9IHRoaXMuY2hlY2tFeHBlY3RlZENvbmRpdGlvbih0YXJnZXQpLFxuICAgICAgICBnZXRFdmVudERhdGFGdW5jLFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnSGFuZGxlci5vbih7XG4gICAgICAgIGRyYWc6IHRoaXMuX29uRHJhZyxcbiAgICAgICAgZHJhZ0VuZDogdGhpcy5fb25EcmFnRW5kLFxuICAgICAgICBjbGljazogdGhpcy5fb25DbGlja1xuICAgIH0sIHRoaXMpO1xuXG4gICAgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX3JldHJpdmVFdmVudERhdGEodGhpcy5hbGxkYXlWaWV3LCBkcmFnU3RhcnRFdmVudERhdGEub3JpZ2luRXZlbnQpO1xuICAgIGV2ZW50RGF0YSA9IGdldEV2ZW50RGF0YUZ1bmMoZHJhZ1N0YXJ0RXZlbnREYXRhLm9yaWdpbkV2ZW50KTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBBbGxkYXlDcmVhdGlvbiNhbGxkYXlfY3JlYXRpb25fZHJhZ3N0YXJ0XG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0FsbGRheVZpZXd9IHJlbGF0ZWRWaWV3IC0gYWxsZGF5IHZpZXcgaW5zdGFuY2UuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGVzSW5SYW5nZSAtIGRhdGUgY291bnQgb2YgdGhpcyB2aWV3LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkcmFnU3RhcnRYSW5kZXggLSBpbmRleCBudW1iZXIgb2YgZHJhZ3N0YXJ0IGdyaWQgaW5kZXguXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHhJbmRleCAtIGluZGV4IG51bWJlciBvZiBtb3VzZSBwb3NpdGlvbnMuXG4gICAgICovXG4gICAgdGhpcy5maXJlKCdhbGxkYXlfY3JlYXRpb25fZHJhZ3N0YXJ0JywgZXZlbnREYXRhKTtcbn07XG5cbi8qKlxuICogRHJhZyBldmVudCBoYW5kbGVyIG1ldGhvZC5cbiAqIEBlbWl0cyBBbGxkYXlDcmVhdGlvbiNhbGxkYXlfY3JlYXRpb25fZHJhZ1xuICogQHBhcmFtIHtvYmplY3R9IGRyYWdFdmVudERhdGEgLSBEcmFnI2RyYWcgZXZlbnQgaGFuZGxlciBldmVudGRhdGEuXG4gKi9cbkFsbGRheUNyZWF0aW9uLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24oZHJhZ0V2ZW50RGF0YSkge1xuICAgIHZhciBnZXRFdmVudERhdGFGdW5jID0gdGhpcy5nZXRFdmVudERhdGFGdW5jLFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICBpZiAoIWdldEV2ZW50RGF0YUZ1bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50RGF0YSA9IGdldEV2ZW50RGF0YUZ1bmMoZHJhZ0V2ZW50RGF0YS5vcmlnaW5FdmVudCk7XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgQWxsZGF5Q3JlYXRpb24jYWxsZGF5X2NyZWF0aW9uX2RyYWdcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7QWxsZGF5Vmlld30gcmVsYXRlZFZpZXcgLSBhbGxkYXkgdmlldyBpbnN0YW5jZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGF0ZXNJblJhbmdlIC0gZGF0ZSBjb3VudCBvZiB0aGlzIHZpZXcuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRyYWdTdGFydFhJbmRleCAtIGluZGV4IG51bWJlciBvZiBkcmFnc3RhcnQgZ3JpZCBpbmRleC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIG1vdXNlIHBvc2l0aW9ucy5cbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ2FsbGRheV9jcmVhdGlvbl9kcmFnJywgZXZlbnREYXRhKTtcbn07XG5cbi8qKlxuICogRHJhZ0VuZCBldmVudCBoYW5kZXIgbWV0aG9kLlxuICogQGVtaXRzIEFsbGRheUNyZWF0aW9uI2FsbGRheV9jcmVhdGlvbl9kcmFnZW5kXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ0VuZEV2ZW50RGF0YSAtIERyYWcjRHJhZ0VuZCBldmVudCBoYW5kbGVyIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gW292ZXJyaWRlRXZlbnROYW1lXSAtIG92ZXJyaWRlIGVtaXR0ZWQgZXZlbnQgbmFtZSB3aGVuIHN1cHBsaWVkLlxuICovXG5BbGxkYXlDcmVhdGlvbi5wcm90b3R5cGUuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uKGRyYWdFbmRFdmVudERhdGEsIG92ZXJyaWRlRXZlbnROYW1lKSB7XG4gICAgdmFyIGdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLmdldEV2ZW50RGF0YUZ1bmMsXG4gICAgICAgIGV2ZW50RGF0YTtcblxuICAgIGlmICghZ2V0RXZlbnREYXRhRnVuYykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnSGFuZGxlci5vZmYoe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIGV2ZW50RGF0YSA9IGdldEV2ZW50RGF0YUZ1bmMoZHJhZ0VuZEV2ZW50RGF0YS5vcmlnaW5FdmVudCk7XG5cbiAgICB0aGlzLl9jcmVhdGVFdmVudChldmVudERhdGEpO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IEFsbGRheUNyZWF0aW9uI2FsbGRheV9jcmVhdGlvbl9kcmFnZW5kXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0FsbGRheVZpZXd9IHJlbGF0ZWRWaWV3IC0gYWxsZGF5IHZpZXcgaW5zdGFuY2UuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGVzSW5SYW5nZSAtIGRhdGUgY291bnQgb2YgdGhpcyB2aWV3LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkcmFnU3RhcnRYSW5kZXggLSBpbmRleCBudW1iZXIgb2YgZHJhZ3N0YXJ0IGdyaWQgaW5kZXguXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHhJbmRleCAtIGluZGV4IG51bWJlciBvZiBtb3VzZSBwb3NpdGlvbnMuXG4gICAgICovXG4gICAgdGhpcy5maXJlKG92ZXJyaWRlRXZlbnROYW1lIHx8ICdhbGxkYXlfY3JlYXRpb25fZHJhZ2VuZCcsIGV2ZW50RGF0YSk7XG5cbiAgICB0aGlzLmdldEV2ZW50RGF0YUZ1bmMgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDbGljayBldmVudCBoYW5kbGVyIG1ldGhvZC5cbiAqIEBlbWl0cyBBbGxkYXlDcmVhdGlvbiNhbGxkYXlfY3JlYXRpb25fY2xpY2tcbiAqIEBwYXJhbSB7b2JqZWN0fSBjbGlja0V2ZW50RGF0YSAtIERyYWcjQ2xpY2sgZXZlbnQgaGFuZGxlciBkYXRhLlxuICovXG5BbGxkYXlDcmVhdGlvbi5wcm90b3R5cGUuX29uQ2xpY2sgPSBmdW5jdGlvbihjbGlja0V2ZW50RGF0YSkge1xuICAgIC8qKlxuICAgICAqIEBldmVudCBBbGxkYXlDcmVhdGlvbiNhbGxkYXlfY3JlYXRpb25fY2xpY2tcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7QWxsZGF5Vmlld30gcmVsYXRlZFZpZXcgLSBhbGxkYXkgdmlldyBpbnN0YW5jZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGF0ZXNJblJhbmdlIC0gZGF0ZSBjb3VudCBvZiB0aGlzIHZpZXcuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRyYWdTdGFydFhJbmRleCAtIGluZGV4IG51bWJlciBvZiBkcmFnc3RhcnQgZ3JpZCBpbmRleC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIG1vdXNlIHBvc2l0aW9ucy5cbiAgICAgKi9cbiAgICB0aGlzLl9vbkRyYWdFbmQoY2xpY2tFdmVudERhdGEsICdhbGxkYXlfY3JlYXRpb25fY2xpY2snKTtcbn07XG5cbmNvbW1vbi5taXhpbihhbGxkYXlDb3JlLCBBbGxkYXlDcmVhdGlvbik7XG51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihBbGxkYXlDcmVhdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gQWxsZGF5Q3JlYXRpb247XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBHdWlkZSBlbGVtZW50IGZvciBBbGxkYXkuQ3JlYXRpb25cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgcmVxQW5pbUZyYW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL3JlcUFuaW1GcmFtZScpO1xuXG52YXIgQ1JFQVRFX05FV19MQUJFTCA9ICfsg4gg7J287KCVJztcblxuLyoqXG4gKiBDbGFzcyBmb3IgQWxsZGF5LkNyZWF0aW9uIGRyYWdnaW5nIGVmZmVjdC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBbGxkYXlDcmVhdGlvbn0gYWxsZGF5Q3JlYXRpb24gLSBpbnN0YW5jZSBvZiBBbGxkYXlDcmVhdGlvbi5cbiAqL1xuZnVuY3Rpb24gQWxsZGF5Q3JlYXRpb25HdWlkZShhbGxkYXlDcmVhdGlvbikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBbGxkYXlDcmVhdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmFsbGRheUNyZWF0aW9uID0gYWxsZGF5Q3JlYXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTERJVkVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5ldmVudENvbnRhaW5lciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTERJVkVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5ndWlkZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZUd1aWRlRWxlbWVudCgpO1xuXG4gICAgYWxsZGF5Q3JlYXRpb24ub24oe1xuICAgICAgICAnYWxsZGF5X2NyZWF0aW9uX2RyYWdzdGFydCc6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuICAgICAgICAnYWxsZGF5X2NyZWF0aW9uX2RyYWcnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIC8vICdhbGxkYXlfY3JlYXRpb25fZHJhZ2VuZCc6IHRoaXMuY2xlYXJHdWlkZUVsZW1lbnQsXG4gICAgICAgICdhbGxkYXlfY3JlYXRpb25fY2xpY2snOiB0aGlzLmNsZWFyR3VpZGVFbGVtZW50XG4gICAgfSwgdGhpcyk7XG59XG5cbi8qKlxuICogRGVzdHJveSBtZXRob2RcbiAqL1xuQWxsZGF5Q3JlYXRpb25HdWlkZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJHdWlkZUVsZW1lbnQoKTtcbiAgICB0aGlzLmFsbGRheUNyZWF0aW9uLm9mZih0aGlzKTtcbiAgICB0aGlzLmFsbGRheUNyZWF0aW9uID0gdGhpcy5ldmVudENvbnRhaW5lciA9XG4gICAgICAgIHRoaXMuZ3VpZGVFbGVtZW50ID0gbnVsbDtcbn07XG5cbi8qKlxuICogaW5pdGlhbGl6ZSBndWlkZSBlbGVtZW50J3MgZGVmYXVsdCBzdHlsZS5cbiAqL1xuQWxsZGF5Q3JlYXRpb25HdWlkZS5wcm90b3R5cGUuaW5pdGlhbGl6ZUd1aWRlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBndWlkZUVsZW1lbnQgPSB0aGlzLmd1aWRlRWxlbWVudCxcbiAgICAgICAgYWxsZGF5VmlldyA9IHRoaXMuYWxsZGF5Q3JlYXRpb24uYWxsZGF5VmlldyxcbiAgICAgICAgZXZlbnRCbG9ja0hlaWdodCA9IGFsbGRheVZpZXcub3B0aW9ucy5ldmVudEJsb2NrSGVpZ2h0LFxuICAgICAgICBzcGFuRWxlbWVudDtcblxuICAgIGRvbXV0aWwuYWRkQ2xhc3MoZ3VpZGVFbGVtZW50LCAnc2NoZWR1bGUtdmlldy1hbGxkYXktY3JlYXRpb24tZ3VpZGUtYmxvY2snKTtcbiAgICBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KCdkaXYnLCBndWlkZUVsZW1lbnQsICdzY2hlZHVsZS12aWV3LWFsbGRheS1jcmVhdGlvbi1ndWlkZScpO1xuXG4gICAgc3BhbkVsZW1lbnQgPSBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KCdzcGFuJywgZ3VpZGVFbGVtZW50KTtcbiAgICBzcGFuRWxlbWVudC5pbm5lckhUTUwgPSBDUkVBVEVfTkVXX0xBQkVMO1xufTtcblxuLyoqXG4gKiBSZWZyZXNoIGd1aWRlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gZXZlbnREYXRhIC0gZXZlbnQgZGF0YSBmcm9tIEFsbGRheS5DcmVhdGlvbiBoYW5kbGVyLlxuICovXG5BbGxkYXlDcmVhdGlvbkd1aWRlLnByb3RvdHlwZS5fcmVmcmVzaEd1aWRlRWxlbWVudCA9IGZ1bmN0aW9uKGV2ZW50RGF0YSkge1xuICAgIHZhciBndWlkZUVsZW1lbnQgPSB0aGlzLmd1aWRlRWxlbWVudCxcbiAgICAgICAgYmFzZVdpZHRoUGVyY2VudCA9ICgxMDAgLyBldmVudERhdGEuZGF0ZXNJblJhbmdlKSxcbiAgICAgICAgZHJhZ1N0YXJ0WEluZGV4ID0gZXZlbnREYXRhLmRyYWdTdGFydFhJbmRleCxcbiAgICAgICAgeEluZGV4ID0gZXZlbnREYXRhLnhJbmRleCxcbiAgICAgICAgbGVuZ3RoID0geEluZGV4IC0gZHJhZ1N0YXJ0WEluZGV4LFxuICAgICAgICBsZWZ0UGVyY2VudCxcbiAgICAgICAgd2lkdGhQZXJjZW50O1xuXG4gICAgLy8gd2hlbiByZXZlcnQgZHJhZ2dpbmcuXG4gICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgZHJhZ1N0YXJ0WEluZGV4ID0geEluZGV4O1xuICAgICAgICBsZW5ndGggPSBNYXRoLmFicyhsZW5ndGgpO1xuICAgIH1cblxuICAgIGxlZnRQZXJjZW50ID0gYmFzZVdpZHRoUGVyY2VudCAqIGRyYWdTdGFydFhJbmRleDtcbiAgICB3aWR0aFBlcmNlbnQgPSBiYXNlV2lkdGhQZXJjZW50ICogKGxlbmd0aCArIDEpO1xuXG4gICAgcmVxQW5pbUZyYW1lLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgIGd1aWRlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgZ3VpZGVFbGVtZW50LnN0eWxlLmxlZnQgPSBsZWZ0UGVyY2VudCArICclJztcbiAgICAgICAgZ3VpZGVFbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGhQZXJjZW50ICsgJyUnO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDbGVhciBndWlkZSBlbGVtZW50LlxuICovXG5BbGxkYXlDcmVhdGlvbkd1aWRlLnByb3RvdHlwZS5jbGVhckd1aWRlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBndWlkZUVsZW1lbnQgPSB0aGlzLmd1aWRlRWxlbWVudDtcblxuICAgIGRvbXV0aWwucmVtb3ZlKGd1aWRlRWxlbWVudCk7XG5cbiAgICBndWlkZUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBndWlkZUVsZW1lbnQuc3R5bGUubGVmdCA9ICcnO1xuICAgIGd1aWRlRWxlbWVudC5zdHlsZS53aWR0aCA9ICcnO1xufTtcblxuLyoqXG4gKiBEcmFnU3RhcnQgZXZlbnQgaGFuZGxlci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnU3RhcnRFdmVudERhdGEgLSBldmVudCBkYXRhIG9iamVjdCBvZiBBbGxkYXkuQ3JlYXRpb24uXG4gKi9cbkFsbGRheUNyZWF0aW9uR3VpZGUucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGRyYWdTdGFydEV2ZW50RGF0YSkge1xuICAgIHZhciBhbGxkYXlDcmVhdGlvbiA9IHRoaXMuYWxsZGF5Q3JlYXRpb24sXG4gICAgICAgIGFsbGRheVZpZXcgPSBhbGxkYXlDcmVhdGlvbi5hbGxkYXlWaWV3LFxuICAgICAgICBhbGxkYXlDb250YWluZXJFbGVtZW50ID0gYWxsZGF5Vmlldy5jb250YWluZXIsXG4gICAgICAgIGV2ZW50Q29udGFpbmVyID0gZG9tdXRpbC5maW5kKCcuc2NoZWR1bGUtdmlldy1tb250aHdlZWstZXZlbnRzJywgYWxsZGF5Q29udGFpbmVyRWxlbWVudCk7XG5cbiAgICBldmVudENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmd1aWRlRWxlbWVudCk7XG4gICAgdGhpcy5fcmVmcmVzaEd1aWRlRWxlbWVudChkcmFnU3RhcnRFdmVudERhdGEpO1xufTtcblxuLyoqXG4gKiBEcmFnIGV2ZW50IGhhbmRsZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ0V2ZW50RGF0YSAtIGV2ZW50IGRhdGEgb2JqZWN0IG9mIEFsbGRheS5DcmVhdGlvbi5cbiAqL1xuQWxsZGF5Q3JlYXRpb25HdWlkZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uKGRyYWdFdmVudERhdGEpIHtcbiAgICB0aGlzLl9yZWZyZXNoR3VpZGVFbGVtZW50KGRyYWdFdmVudERhdGEpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbGxkYXlDcmVhdGlvbkd1aWRlO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTW92ZSBoYW5kbGVyIGZvciBBbGxkYXkgdmlldy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9jb21tb24nKTtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciBBbGxkYXlDb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG52YXIgQWxsZGF5TW92ZUd1aWRlID0gcmVxdWlyZSgnLi9tb3ZlR3VpZGUnKTtcblxudmFyIGNoZWNrRXhwZWN0ZWRDb25kaXRpb25JRFJ4ID0gL15zY2hlZHVsZS12aWV3LWFsbGRheS1ldmVudCgtdGl0bGUpPyQvO1xudmFyIHBhcnNlVmlld0lEUnggPSAvXnNjaGVkdWxlLXZpZXctYWxsZGF5LW1vbnRod2Vla1tcXHNdc2NoZWR1bGUtdmlldy0oXFxkKykvO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge0hhbmRsZXJ9XG4gKiBAbWl4ZXMgQWxsZGF5Q29yZVxuICogQG1peGVzIEN1c3RvbUV2ZW50c1xuICogQHBhcmFtIHtEcmFnfSBbZHJhZ0hhbmRsZXJdIC0gRHJhZyBoYW5kbGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHtBbGxkYXl9IFthbGxkYXlWaWV3XSAtIE1vbnRoV2VlayB2aWV3IGluc3RhbmNlLlxuICogQHBhcmFtIHtCYXNlfSBbYmFzZUNvbnRyb2xsZXJdIC0gQmFzZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBBbGxkYXlNb3ZlKGRyYWdIYW5kbGVyLCBhbGxkYXlWaWV3LCBiYXNlQ29udHJvbGxlcikge1xuICAgIC8qKlxuICAgICAqIERyYWcgaGFuZGxlciBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7RHJhZ31cbiAgICAgKi9cbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gZHJhZ0hhbmRsZXI7XG5cbiAgICAvKipcbiAgICAgKiBhbGxkYXkgdmlldyBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7QWxsZGF5fVxuICAgICAqL1xuICAgIHRoaXMuYWxsZGF5VmlldyA9IGFsbGRheVZpZXc7XG5cbiAgICAvKipcbiAgICAgKiBCYXNlIGNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICogQHR5cGUge0Jhc2V9XG4gICAgICovXG4gICAgdGhpcy5iYXNlQ29udHJvbGxlciA9IGJhc2VDb250cm9sbGVyO1xuXG4gICAgLyoqXG4gICAgICogVGVtcG9yYXJ5IHZhcmlhYmxlIGZvciBkcmFnc3RhcnQgZXZlbnQgZGF0YS5cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuX2RyYWdTdGFydCA9IG51bGw7XG5cbiAgICBkcmFnSGFuZGxlci5vbih7XG4gICAgICAgIGRyYWdTdGFydDogdGhpcy5fb25EcmFnU3RhcnRcbiAgICB9LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBbGxkYXlNb3ZlR3VpZGV9XG4gICAgICovXG4gICAgdGhpcy5ndWlkZSA9IG5ldyBBbGxkYXlNb3ZlR3VpZGUodGhpcyk7XG59XG5cbkFsbGRheU1vdmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmd1aWRlLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9mZih0aGlzKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gdGhpcy5hbGxkYXlWaWV3ID0gdGhpcy5iYXNlQ29udHJvbGxlciA9XG4gICAgICAgIHRoaXMuZ3VpZGUgPSB0aGlzLl9kcmFnU3RhcnQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDaGVjayBkcmFnc3RhcnQgdGFyZ2V0IGlzIGV4cGVjdGVkIGNvbmRpdGlvbnMgZm9yIHRoaXMgaGFuZGxlci5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIGRyYWdzdGFydCBldmVudCBoYW5kbGVyJ3MgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbnxNb250aFdlZWt9IHJldHVybiBNb250aFdlZWsgdmlldyBpbnN0YW5jZSB3aGVuIHNhdGlhdGUgY29uZGl0aW9uLlxuICovXG5BbGxkYXlNb3ZlLnByb3RvdHlwZS5jaGVja0V4cGVjdGVkQ29uZGl0aW9uID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgdmFyIGNzc0NsYXNzID0gZG9tdXRpbC5nZXRDbGFzcyh0YXJnZXQpLFxuICAgICAgICBwYXJlbnRWaWV3LFxuICAgICAgICBtYXRjaGVzO1xuXG4gICAgaWYgKCFjaGVja0V4cGVjdGVkQ29uZGl0aW9uSURSeC50ZXN0KGNzc0NsYXNzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcGFyZW50VmlldyA9IGRvbXV0aWwuY2xvc2VzdCh0YXJnZXQsICcuc2NoZWR1bGUtdmlldy1hbGxkYXktbW9udGh3ZWVrJyk7XG5cbiAgICBpZiAoIXBhcmVudFZpZXcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNzc0NsYXNzID0gZG9tdXRpbC5nZXRDbGFzcyhwYXJlbnRWaWV3KTtcbiAgICBtYXRjaGVzID0gY3NzQ2xhc3MubWF0Y2gocGFyc2VWaWV3SURSeCk7XG5cbiAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbC5waWNrKHRoaXMuYWxsZGF5Vmlldy5jaGlsZHMuaXRlbXMsIG1hdGNoZXNbMV0pO1xufTtcblxuLyoqXG4gKiBEcmFnU3RhcnQgZXZlbnQgaGFuZGxlciBtZXRob2QuXG4gKiBAZW1pdHMgQWxsZGF5TW92ZSNhbGxkYXlfbW92ZV9kcmFnc3RhcnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnU3RhcnRFdmVudERhdGEgLSBEcmFnI2RyYWdTdGFydCBldmVudCBoYW5kbGVyIGV2ZW50IGRhdGEuXG4gKi9cbkFsbGRheU1vdmUucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGRyYWdTdGFydEV2ZW50RGF0YSkge1xuICAgIHZhciB0YXJnZXQgPSBkcmFnU3RhcnRFdmVudERhdGEudGFyZ2V0LFxuICAgICAgICByZXN1bHQgPSB0aGlzLmNoZWNrRXhwZWN0ZWRDb25kaXRpb24odGFyZ2V0KSxcbiAgICAgICAgY29udHJvbGxlciA9IHRoaXMuYmFzZUNvbnRyb2xsZXIsXG4gICAgICAgIGV2ZW50QmxvY2tFbGVtZW50LFxuICAgICAgICBtb2RlbElELFxuICAgICAgICB0YXJnZXRNb2RlbCxcbiAgICAgICAgZ2V0RXZlbnREYXRhRnVuYyxcbiAgICAgICAgZXZlbnREYXRhO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50QmxvY2tFbGVtZW50ID0gZG9tdXRpbC5jbG9zZXN0KHRhcmdldCwgJy5zY2hlZHVsZS12aWV3LWFsbGRheS1ldmVudC1ibG9jaycpO1xuICAgIG1vZGVsSUQgPSBkb211dGlsLmdldERhdGEoZXZlbnRCbG9ja0VsZW1lbnQsICdpZCcpO1xuICAgIHRhcmdldE1vZGVsID0gY29udHJvbGxlci5ldmVudHMuaXRlbXNbbW9kZWxJRF07XG5cbiAgICBpZiAoIXRhcmdldE1vZGVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBnZXRFdmVudERhdGFGdW5jID0gdGhpcy5nZXRFdmVudERhdGFGdW5jID0gdGhpcy5fcmV0cml2ZUV2ZW50RGF0YSh0aGlzLmFsbGRheVZpZXcsIGRyYWdTdGFydEV2ZW50RGF0YS5vcmlnaW5FdmVudCk7XG4gICAgZXZlbnREYXRhID0gdGhpcy5fZHJhZ1N0YXJ0ID0gZ2V0RXZlbnREYXRhRnVuYyhkcmFnU3RhcnRFdmVudERhdGEub3JpZ2luRXZlbnQpO1xuXG4gICAgdXRpbC5leHRlbmQoZXZlbnREYXRhLCB7XG4gICAgICAgIGV2ZW50QmxvY2tFbGVtZW50OiBldmVudEJsb2NrRWxlbWVudCxcbiAgICAgICAgbW9kZWw6IHRhcmdldE1vZGVsXG4gICAgfSk7XG5cbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9uKHtcbiAgICAgICAgZHJhZzogdGhpcy5fb25EcmFnLFxuICAgICAgICBkcmFnRW5kOiB0aGlzLl9vbkRyYWdFbmQsXG4gICAgICAgIGNsaWNrOiB0aGlzLl9vbkNsaWNrXG4gICAgfSwgdGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgQWxsZGF5TW92ZSNhbGxkYXlfbW92ZV9kcmFnc3RhcnRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7QWxsZGF5Vmlld30gcmVsYXRlZFZpZXcgLSBhbGxkYXkgdmlldyBpbnN0YW5jZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGF0ZXNJblJhbmdlIC0gZGF0ZSBjb3VudCBvZiB0aGlzIHZpZXcuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRyYWdTdGFydFhJbmRleCAtIGluZGV4IG51bWJlciBvZiBkcmFnc3RhcnQgZ3JpZCBpbmRleC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIG1vdXNlIHBvc2l0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBtb2RlbCAtIGRhdGEgb2JqZWN0IG9mIG1vZGVsIGlzbnRhbmNlLlxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTERpdkVsZW1lbnR9IGV2ZW50QmxvY2tFbGVtZW50IC0gdGFyZ2V0IGV2ZW50IGJsb2NrIGVsZW1lbnQuXG4gICAgICovXG4gICAgdGhpcy5maXJlKCdhbGxkYXlfbW92ZV9kcmFnc3RhcnQnLCBldmVudERhdGEpO1xufTtcblxuXG4vKipcbiAqIERyYWcgZXZlbnQgaGFuZGxlciBtZXRob2QuXG4gKiBAZW1pdHMgQWxsZGF5TW92ZSNhbGxkYXlfbW92ZV9kcmFnXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ0V2ZW50RGF0YSAtIERyYWcjZHJhZyBldmVudCBoYW5kbGVyIGV2ZW50ZGF0YS5cbiAqL1xuQWxsZGF5TW92ZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uKGRyYWdFdmVudERhdGEpIHtcbiAgICB2YXIgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuZ2V0RXZlbnREYXRhRnVuYztcblxuICAgIGlmICghZ2V0RXZlbnREYXRhRnVuYykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IEFsbGRheU1vdmUjYWxsZGF5X21vdmVfZHJhZ1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtBbGxkYXlWaWV3fSByZWxhdGVkVmlldyAtIGFsbGRheSB2aWV3IGluc3RhbmNlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRlc0luUmFuZ2UgLSBkYXRlIGNvdW50IG9mIHRoaXMgdmlldy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZHJhZ1N0YXJ0WEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIGRyYWdzdGFydCBncmlkIGluZGV4LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4SW5kZXggLSBpbmRleCBudW1iZXIgb2YgbW91c2UgcG9zaXRpb25zLlxuICAgICAqL1xuICAgIHRoaXMuZmlyZSgnYWxsZGF5X21vdmVfZHJhZycsIGdldEV2ZW50RGF0YUZ1bmMoZHJhZ0V2ZW50RGF0YS5vcmlnaW5FdmVudCkpO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IHVwZGF0ZSBldmVudCBtb2RlbCB0byBiYXNlIGNvbnRyb2xsZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gZXZlbnREYXRhIC0gZXZlbnQgZGF0YSBmcm9tIEFsbGRheU1vdmUgaGFuZGxlciBtb2R1bGUuXG4gKi9cbkFsbGRheU1vdmUucHJvdG90eXBlLl91cGRhdGVFdmVudCA9IGZ1bmN0aW9uKGV2ZW50RGF0YSkge1xuICAgIHZhciBjdHJsID0gdGhpcy5iYXNlQ29udHJvbGxlcixcbiAgICAgICAgbW9kZWwgPSBldmVudERhdGEudGFyZ2V0TW9kZWwsXG4gICAgICAgIGRhdGVPZmZzZXQgPSBldmVudERhdGEueEluZGV4IC0gZXZlbnREYXRhLmRyYWdTdGFydFhJbmRleCxcbiAgICAgICAgbmV3U3RhcnRzID0gbmV3IERhdGUobW9kZWwuc3RhcnRzLmdldFRpbWUoKSksXG4gICAgICAgIG5ld0VuZHMgPSBuZXcgRGF0ZShtb2RlbC5lbmRzLmdldFRpbWUoKSk7XG5cbiAgICBuZXdTdGFydHMgPSBuZXcgRGF0ZShuZXdTdGFydHMuc2V0RGF0ZShuZXdTdGFydHMuZ2V0RGF0ZSgpICsgZGF0ZU9mZnNldCkpO1xuICAgIG5ld0VuZHMgPSBuZXcgRGF0ZShuZXdFbmRzLnNldERhdGUobmV3RW5kcy5nZXREYXRlKCkgKyBkYXRlT2Zmc2V0KSk7XG5cbiAgICBjdHJsLnVwZGF0ZUV2ZW50KG1vZGVsLmNpZCgpLCB7XG4gICAgICAgIHN0YXJ0czogbmV3U3RhcnRzLFxuICAgICAgICBlbmRzOiBuZXdFbmRzXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIERyYWdFbmQgZXZlbnQgaGFuZGVyIG1ldGhvZC5cbiAqIEBlbWl0cyBBbGxkYXlNb3ZlI2FsbGRheV9tb3ZlX2RyYWdlbmRcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnRW5kRXZlbnREYXRhIC0gRHJhZyNEcmFnRW5kIGV2ZW50IGhhbmRsZXIgZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3ZlcnJpZGVFdmVudE5hbWVdIC0gb3ZlcnJpZGUgZW1pdHRlZCBldmVudCBuYW1lIHdoZW4gc3VwcGxpZWQuXG4gKiBAcGFyYW0gez9ib29sZWFufSBza2lwVXBkYXRlIC0gdHJ1ZSB0aGVuIHNraXAgdXBkYXRlIGV2ZW50IG1vZGVsLlxuICovXG5BbGxkYXlNb3ZlLnByb3RvdHlwZS5fb25EcmFnRW5kID0gZnVuY3Rpb24oZHJhZ0VuZEV2ZW50RGF0YSwgb3ZlcnJpZGVFdmVudE5hbWUsIHNraXBVcGRhdGUpIHtcbiAgICB2YXIgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuZ2V0RXZlbnREYXRhRnVuYyxcbiAgICAgICAgZHJhZ1N0YXJ0ID0gdGhpcy5fZHJhZ1N0YXJ0LFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICBpZiAoIWdldEV2ZW50RGF0YUZ1bmMgfHwgIWRyYWdTdGFydCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnSGFuZGxlci5vZmYoe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIGV2ZW50RGF0YSA9IGdldEV2ZW50RGF0YUZ1bmMoZHJhZ0VuZEV2ZW50RGF0YS5vcmlnaW5FdmVudCk7XG4gICAgdXRpbC5leHRlbmQoZXZlbnREYXRhLCB7XG4gICAgICAgIHRhcmdldE1vZGVsOiBkcmFnU3RhcnQubW9kZWxcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXNraXBVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlRXZlbnQoZXZlbnREYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgQWxsZGF5TW92ZSNhbGxkYXlfbW92ZV9kcmFnZW5kXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0FsbGRheVZpZXd9IHJlbGF0ZWRWaWV3IC0gYWxsZGF5IHZpZXcgaW5zdGFuY2UuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGVzSW5SYW5nZSAtIGRhdGUgY291bnQgb2YgdGhpcyB2aWV3LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkcmFnU3RhcnRYSW5kZXggLSBpbmRleCBudW1iZXIgb2YgZHJhZ3N0YXJ0IGdyaWQgaW5kZXguXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHhJbmRleCAtIGluZGV4IG51bWJlciBvZiBtb3VzZSBwb3NpdGlvbnMuXG4gICAgICovXG4gICAgdGhpcy5maXJlKG92ZXJyaWRlRXZlbnROYW1lIHx8ICdhbGxkYXlfbW92ZV9kcmFnZW5kJywgZXZlbnREYXRhKTtcblxuICAgIHRoaXMuZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX2RyYWdTdGFydCA9IG51bGw7XG59O1xuXG4vKipcbiAqIENsaWNrIGV2ZW50IGhhbmRsZXIgbWV0aG9kLlxuICogQGVtaXRzIEFsbGRheU1vdmUjYWxsZGF5X21vdmVfY2xpY2tcbiAqIEBwYXJhbSB7b2JqZWN0fSBjbGlja0V2ZW50RGF0YSAtIERyYWcjQ2xpY2sgZXZlbnQgaGFuZGxlciBkYXRhLlxuICovXG5BbGxkYXlNb3ZlLnByb3RvdHlwZS5fb25DbGljayA9IGZ1bmN0aW9uKGNsaWNrRXZlbnREYXRhKSB7XG4gICAgLyoqXG4gICAgICogQGV2ZW50IEFsbGRheU1vdmUjYWxsZGF5X21vdmVfY2xpY2tcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7QWxsZGF5Vmlld30gcmVsYXRlZFZpZXcgLSBhbGxkYXkgdmlldyBpbnN0YW5jZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGF0ZXNJblJhbmdlIC0gZGF0ZSBjb3VudCBvZiB0aGlzIHZpZXcuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRyYWdTdGFydFhJbmRleCAtIGluZGV4IG51bWJlciBvZiBkcmFnc3RhcnQgZ3JpZCBpbmRleC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIG1vdXNlIHBvc2l0aW9ucy5cbiAgICAgKi9cbiAgICB0aGlzLl9vbkRyYWdFbmQoY2xpY2tFdmVudERhdGEsICdhbGxkYXlfbW92ZV9jbGljaycsIHRydWUpO1xufTtcblxuY29tbW9uLm1peGluKEFsbGRheUNvcmUsIEFsbGRheU1vdmUpO1xudXRpbC5DdXN0b21FdmVudHMubWl4aW4oQWxsZGF5TW92ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWxsZGF5TW92ZTtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEVmZmVjdCBtb2R1bGUgZm9yIEFsbGRheS5Nb3ZlXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBkYXRldGltZSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kYXRldGltZScpO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIHJlcUFuaW1GcmFtZSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9yZXFBbmltRnJhbWUnKTtcblxuLyoqXG4gKiBDbGFzcyBmb3IgQWxsZGF5Lk1vdmUgZHJhZ2dpbmcgZWZmZWN0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FsbGRheU1vdmV9IGFsbGRheU1vdmUgLSBpbnN0YW5jZSBvZiBBbGxkYXlNb3ZlLlxuICovXG5mdW5jdGlvbiBBbGxkYXlNb3ZlR3VpZGUoYWxsZGF5TW92ZSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBbGxkYXlNb3ZlfVxuICAgICAqL1xuICAgIHRoaXMuYWxsZGF5TW92ZSA9IGFsbGRheU1vdmU7XG5cbiAgICAvKipcbiAgICAgKiDsi6TsoJzroZwg7J2067Kk7Yq4IOyXmOumrOuovO2KuOulvCDri7TripQg7JeY66as66i87Yq4XG4gICAgICogQHR5cGUge0hUTUxESVZFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRDb250YWluZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9kcmFnU3RhcnRYSW5kZXggPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0hUTUxESVZFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZ3VpZGVFbGVtZW50ID0gbnVsbDtcblxuICAgIGFsbGRheU1vdmUub24oe1xuICAgICAgICAnYWxsZGF5X21vdmVfZHJhZ3N0YXJ0JzogdGhpcy5fb25EcmFnU3RhcnQsXG4gICAgICAgICdhbGxkYXlfbW92ZV9kcmFnJzogdGhpcy5fb25EcmFnLFxuICAgICAgICAnYWxsZGF5X21vdmVfZHJhZ2VuZCc6IHRoaXMuX2NsZWFyR3VpZGVFbGVtZW50LFxuICAgICAgICAnYWxsZGF5X21vdmVfY2xpY2snOiB0aGlzLl9jbGVhckd1aWRlRWxlbWVudFxuICAgIH0sIHRoaXMpO1xufVxuXG4vKipcbiAqIERlc3Ryb3kgbWV0aG9kXG4gKi9cbkFsbGRheU1vdmVHdWlkZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NsZWFyR3VpZGVFbGVtZW50KCk7XG4gICAgdGhpcy5hbGxkYXlNb3ZlLm9mZih0aGlzKTtcbiAgICB0aGlzLmFsbGRheU1vdmUgPSB0aGlzLmV2ZW50Q29udGFpbmVyID0gdGhpcy5fZHJhZ1N0YXJ0WEluZGV4ID1cbiAgICAgICAgdGhpcy5ndWlkZUVsZW1lbnQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhciBndWlkZSBlbGVtZW50LlxuICovXG5BbGxkYXlNb3ZlR3VpZGUucHJvdG90eXBlLl9jbGVhckd1aWRlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIGRvbXV0aWwucmVtb3ZlKHRoaXMuZ3VpZGVFbGVtZW50KTtcblxuICAgIGlmICghdXRpbC5icm93c2VyLm1zaWUpIHtcbiAgICAgICAgZG9tdXRpbC5yZW1vdmVDbGFzcyhnbG9iYWwuZG9jdW1lbnQuYm9keSwgJ3NjaGVkdWxlLXZpZXctZHJhZ2dpbmcnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kcmFnU3RhcnRYSW5kZXggPSB0aGlzLmdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLmd1aWRlRWxlbWVudCA9IG51bGw7XG59O1xuXG4vKipcbiAqIFJlZnJlc2ggZ3VpZGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0UGVyY2VudCAtIGxlZnQgcGVyY2VudCBvZiBndWlkZSBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoUGVyY2VudCAtIHdpZHRoIHBlcmNlbnQgb2YgZ3VpZGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNFeGNlZWRlZExlZnQgLSBldmVudCBzdGFydHMgaXMgZmFzdGVyIHRoZW4gcmVuZGVyIHN0YXJ0IGRhdGU/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRXhjZWVkZWRSaWdodCAtIGV2ZW50IGVuZHMgaXMgbGF0ZXIgdGhlbiByZW5kZXIgZW5kIGRhdGU/XG4gKi9cbkFsbGRheU1vdmVHdWlkZS5wcm90b3R5cGUucmVmcmVzaEd1aWRlRWxlbWVudCA9IGZ1bmN0aW9uKGxlZnRQZXJjZW50LCB3aWR0aFBlcmNlbnQsIGlzRXhjZWVkZWRMZWZ0LCBpc0V4Y2VlZGVkUmlnaHQpIHtcbiAgICB2YXIgZ3VpZGVFbGVtZW50ID0gdGhpcy5ndWlkZUVsZW1lbnQ7XG5cbiAgICByZXFBbmltRnJhbWUucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgZ3VpZGVFbGVtZW50LnN0eWxlLmxlZnQgPSBsZWZ0UGVyY2VudCArICclJztcbiAgICAgICAgZ3VpZGVFbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGhQZXJjZW50ICsgJyUnO1xuXG4gICAgICAgIGlmIChpc0V4Y2VlZGVkTGVmdCkge1xuICAgICAgICAgICAgZG9tdXRpbC5hZGRDbGFzcyhndWlkZUVsZW1lbnQsICdzY2hlZHVsZS12aWV3LWFsbGRheS1leGNlZWQtbGVmdCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tdXRpbC5yZW1vdmVDbGFzcyhndWlkZUVsZW1lbnQsICdzY2hlZHVsZS12aWV3LWFsbGRheS1leGNlZWQtbGVmdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRXhjZWVkZWRSaWdodCkge1xuICAgICAgICAgICAgZG9tdXRpbC5hZGRDbGFzcyhndWlkZUVsZW1lbnQsICdzY2hlZHVsZS12aWV3LWFsbGRheS1leGNlZWQtcmlnaHQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbXV0aWwucmVtb3ZlQ2xhc3MoZ3VpZGVFbGVtZW50LCAnc2NoZWR1bGUtdmlldy1hbGxkYXktZXhjZWVkLXJpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogR2V0IGV2ZW50IGJsb2NrIGluZm9ybWF0aW9uIGZyb20gZXZlbnQgZGF0YS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgdGhlcmUgaXMgc2luZ2xlIGV2ZW50IGhhcyAxMCBsZW5ndGguIGJ1dCByZW5kZXIgcmFuZ2UgaW4gdmlldyBpcyA1IHRoZW5cbiAqIHJlbmRlcmVkIGJsb2NrIG11c3QgYmUgY3V0IG91dCB0byByZW5kZXIgcHJvcGVybHkuIGluIHRoaXMgY2FzZSwgdGhpcyBtZXRob2QgcmV0dXJuXG4gKiBob3cgbWFueSBibG9jayBhcmUgY3V0IGJlZm9yZSByZW5kZXJpbmcuXG4gKiBcbiAqIOydtOuypO2KuCDrjbDsnbTthLDsl5DshJwg7J2067Kk7Yq4IOu4lOuhnSDsl5jrpqzrqLztirgg66CM642U66eB7JeQIOuMgO2VnCDtlYTsmpQg7KCV67O066W8IOy2lOy2nO2VnOuLpC5cbiAqXG4gKiBleCkg66CM642U66eBIOuQnCDruJTroZ3snZgg6ri47J2064qUIDXsp4Drp4wg7Iuk7KCcIOydtCDsnbTrsqTtirjripQgMTDsnZgg6ri47J2066W8IOqwgOyngOqzoCDsnojsnYQg65WMXG4gKiDsoowg7Jqw66GcIOuqhyDrp4ztgbwg7J6Y66Ck7J6I64qU7KeA7JeQIOq0gO2VnCDsoJXrs7Trpbwg67CY7ZmY7ZWoLlxuICogQHBhcmFtIHtvYmplY3R9IGRyYWdTdGFydEV2ZW50RGF0YSAtIGV2ZW50IGRhdGEgZnJvbSBBbGxkYXkuTW92ZSBoYW5kbGVyLlxuICogQHJldHVybnMge2Z1bmN0aW9ufSBmdW5jdGlvbiB0aGF0IHJldHVybiBldmVudCBibG9jayBpbmZvcm1hdGlvbi5cbiAqL1xuQWxsZGF5TW92ZUd1aWRlLnByb3RvdHlwZS5fZ2V0RXZlbnRCbG9ja0RhdGFGdW5jID0gZnVuY3Rpb24oZHJhZ1N0YXJ0RXZlbnREYXRhKSB7XG4gICAgdmFyIG1vZGVsID0gZHJhZ1N0YXJ0RXZlbnREYXRhLm1vZGVsLFxuICAgICAgICBkYXRlc0luUmFuZ2UgPSBkcmFnU3RhcnRFdmVudERhdGEuZGF0ZXNJblJhbmdlLFxuICAgICAgICBiYXNlV2lkdGhQZXJjZW50ID0gKDEwMCAvIGRhdGVzSW5SYW5nZSksXG4gICAgICAgIG9yaWdpbkV2ZW50U3RhcnRzID0gZGF0ZXRpbWUuc3RhcnQobW9kZWwuc3RhcnRzKSxcbiAgICAgICAgb3JpZ2luRXZlbnRFbmRzID0gZGF0ZXRpbWUuZW5kKG1vZGVsLmVuZHMpLFxuICAgICAgICB2aWV3T3B0aW9ucyA9IHRoaXMuYWxsZGF5TW92ZS5hbGxkYXlWaWV3Lm9wdGlvbnMsXG4gICAgICAgIHJlbmRlclN0YXJ0RGF0ZSA9IGRhdGV0aW1lLnN0YXJ0KGRhdGV0aW1lLnBhcnNlKHZpZXdPcHRpb25zLnJlbmRlclN0YXJ0RGF0ZSkpLFxuICAgICAgICByZW5kZXJFbmREYXRlID0gZGF0ZXRpbWUuZW5kKGRhdGV0aW1lLnBhcnNlKHZpZXdPcHRpb25zLnJlbmRlckVuZERhdGUpKSxcbiAgICAgICAgZnJvbUxlZnQgPSAobmV3IERhdGUob3JpZ2luRXZlbnRTdGFydHMuZ2V0VGltZSgpIC0gcmVuZGVyU3RhcnREYXRlLmdldFRpbWUoKSkpIC8gZGF0ZXRpbWUuTUlMTElTRUNPTkRTX1BFUl9EQVkgfCAwLFxuICAgICAgICBmcm9tUmlnaHQgPSAobmV3IERhdGUob3JpZ2luRXZlbnRFbmRzLmdldFRpbWUoKSAtIHJlbmRlckVuZERhdGUuZ2V0VGltZSgpKSkgLyBkYXRldGltZS5NSUxMSVNFQ09ORFNfUEVSX0RBWSB8IDA7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oaW5kZXhPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJhc2VXaWR0aFBlcmNlbnQ6IGJhc2VXaWR0aFBlcmNlbnQsXG4gICAgICAgICAgICBmcm9tTGVmdDogZnJvbUxlZnQgKyBpbmRleE9mZnNldCxcbiAgICAgICAgICAgIGZyb21SaWdodDogZnJvbVJpZ2h0ICsgaW5kZXhPZmZzZXRcbiAgICAgICAgfTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBEcmFnU3RhcnQgZXZlbnQgaGFuZGxlci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnU3RhcnRFdmVudERhdGEgLSBldmVudCBkYXRhLlxuICovXG5BbGxkYXlNb3ZlR3VpZGUucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGRyYWdTdGFydEV2ZW50RGF0YSkge1xuICAgIHZhciBhbGxkYXlWaWV3Q29udGFpbmVyID0gdGhpcy5hbGxkYXlNb3ZlLmFsbGRheVZpZXcuY29udGFpbmVyLFxuICAgICAgICBndWlkZUVsZW1lbnQgPSB0aGlzLmd1aWRlRWxlbWVudCA9IGRyYWdTdGFydEV2ZW50RGF0YS5ldmVudEJsb2NrRWxlbWVudC5jbG9uZU5vZGUodHJ1ZSksXG4gICAgICAgIGV2ZW50Q29udGFpbmVyO1xuXG4gICAgaWYgKCF1dGlsLmJyb3dzZXIubXNpZSkge1xuICAgICAgICBkb211dGlsLmFkZENsYXNzKGdsb2JhbC5kb2N1bWVudC5ib2R5LCAnc2NoZWR1bGUtdmlldy1kcmFnZ2luZycpO1xuICAgIH1cblxuICAgIGV2ZW50Q29udGFpbmVyID0gZG9tdXRpbC5maW5kKCcuc2NoZWR1bGUtdmlldy1tb250aHdlZWstZXZlbnRzJywgYWxsZGF5Vmlld0NvbnRhaW5lcik7XG4gICAgZG9tdXRpbC5hZGRDbGFzcyhndWlkZUVsZW1lbnQsICdzY2hlZHVsZS12aWV3LWFsbGRheS1tb3ZlLWd1aWRlJyk7XG4gICAgZXZlbnRDb250YWluZXIuYXBwZW5kQ2hpbGQoZ3VpZGVFbGVtZW50KTtcblxuICAgIHRoaXMuX2RyYWdTdGFydFhJbmRleCA9IGRyYWdTdGFydEV2ZW50RGF0YS54SW5kZXg7XG4gICAgdGhpcy5nZXRFdmVudERhdGFGdW5jID0gdGhpcy5fZ2V0RXZlbnRCbG9ja0RhdGFGdW5jKGRyYWdTdGFydEV2ZW50RGF0YSk7XG59O1xuXG4vKipcbiAqIERyYWcgZXZlbnQgaGFuZGxlci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnRXZlbnREYXRhIC0gZXZlbnQgZGF0YS5cbiAqL1xuQWxsZGF5TW92ZUd1aWRlLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24oZHJhZ0V2ZW50RGF0YSkge1xuICAgIHZhciBnZXRFdmVudERhdGFGdW5jID0gdGhpcy5nZXRFdmVudERhdGFGdW5jLFxuICAgICAgICBkcmFnU3RhcnRYSW5kZXggPSB0aGlzLl9kcmFnU3RhcnRYSW5kZXgsXG4gICAgICAgIGRhdGVzSW5SYW5nZSA9IGRyYWdFdmVudERhdGEuZGF0ZXNJblJhbmdlLFxuICAgICAgICBldmVudERhdGEsXG4gICAgICAgIGlzRXhjZWVkZWRMZWZ0LFxuICAgICAgICBpc0V4Y2VlZGVkUmlnaHQsXG4gICAgICAgIG9yaWdpbkxlbmd0aCxcbiAgICAgICAgbmV3TGVmdCxcbiAgICAgICAgbmV3V2lkdGg7XG5cbiAgICBpZiAoIWdldEV2ZW50RGF0YUZ1bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50RGF0YSA9IGdldEV2ZW50RGF0YUZ1bmMoZHJhZ0V2ZW50RGF0YS54SW5kZXggLSBkcmFnU3RhcnRYSW5kZXgpO1xuICAgIGlzRXhjZWVkZWRMZWZ0ID0gZXZlbnREYXRhLmZyb21MZWZ0IDwgMDtcbiAgICBpc0V4Y2VlZGVkUmlnaHQgPSBldmVudERhdGEuZnJvbVJpZ2h0ID4gMDtcblxuICAgIG5ld0xlZnQgPSBNYXRoLm1heCgwLCBldmVudERhdGEuZnJvbUxlZnQpO1xuICAgIG9yaWdpbkxlbmd0aCA9IChldmVudERhdGEuZnJvbUxlZnQgKiAtMSkgKyAoZGF0ZXNJblJhbmdlICsgZXZlbnREYXRhLmZyb21SaWdodCk7XG4gICAgbmV3V2lkdGggPSBpc0V4Y2VlZGVkTGVmdCA/IChvcmlnaW5MZW5ndGggKyBldmVudERhdGEuZnJvbUxlZnQpIDogb3JpZ2luTGVuZ3RoO1xuICAgIG5ld1dpZHRoID0gaXNFeGNlZWRlZFJpZ2h0ID8gKG5ld1dpZHRoIC0gZXZlbnREYXRhLmZyb21SaWdodCkgOiBuZXdXaWR0aDtcblxuICAgIG5ld0xlZnQgKj0gZXZlbnREYXRhLmJhc2VXaWR0aFBlcmNlbnQ7XG4gICAgbmV3V2lkdGggKj0gZXZlbnREYXRhLmJhc2VXaWR0aFBlcmNlbnQ7XG5cbiAgICB0aGlzLnJlZnJlc2hHdWlkZUVsZW1lbnQobmV3TGVmdCwgbmV3V2lkdGgsIGlzRXhjZWVkZWRMZWZ0LCBpc0V4Y2VlZGVkUmlnaHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbGxkYXlNb3ZlR3VpZGU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBSZXNpemUgaGFuZGxlciBtb2R1bGUgZm9yIEFsbGRheSB2aWV3LlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi8uLi9jb21tb24vY29tbW9uJyk7XG52YXIgQWxsZGF5Q29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIEFsbGRheVJlc2l6ZUd1aWRlID0gcmVxdWlyZSgnLi9yZXNpemVHdWlkZScpO1xuXG52YXIgcGFyc2VWaWV3SURSeCA9IC9ec2NoZWR1bGUtdmlldy1hbGxkYXktbW9udGh3ZWVrW1xcc11zY2hlZHVsZS12aWV3LShcXGQrKS87XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7SGFuZGxlcn1cbiAqIEBtaXhlcyBBbGxkYXlDb3JlXG4gKiBAbWl4ZXMgQ3VzdG9tRXZlbnRzXG4gKiBAcGFyYW0ge0RyYWd9IFtkcmFnSGFuZGxlcl0gLSBEcmFnIGhhbmRsZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0FsbGRheX0gW2FsbGRheVZpZXddIC0gTW9udGhXZWVrIHZpZXcgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0Jhc2V9IFtiYXNlQ29udHJvbGxlcl0gLSBCYXNlIGNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIEFsbGRheVJlc2l6ZShkcmFnSGFuZGxlciwgYWxsZGF5VmlldywgYmFzZUNvbnRyb2xsZXIpIHtcbiAgICAvKipcbiAgICAgKiBEcmFnIGhhbmRsZXIgaW5zdGFuY2UuXG4gICAgICogQHR5cGUge0RyYWd9XG4gICAgICovXG4gICAgdGhpcy5kcmFnSGFuZGxlciA9IGRyYWdIYW5kbGVyO1xuXG4gICAgLyoqXG4gICAgICogYWxsZGF5IHZpZXcgaW5zdGFuY2UuXG4gICAgICogQHR5cGUge0FsbGRheX1cbiAgICAgKi9cbiAgICB0aGlzLmFsbGRheVZpZXcgPSBhbGxkYXlWaWV3O1xuXG4gICAgLyoqXG4gICAgICogQmFzZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtCYXNlfVxuICAgICAqL1xuICAgIHRoaXMuYmFzZUNvbnRyb2xsZXIgPSBiYXNlQ29udHJvbGxlcjtcblxuICAgIC8qKlxuICAgICAqIFRlbXBvcmFyeSB2YXJpYWJsZSBmb3IgZHJhZ1N0YXJ0IGV2ZW50IGRhdGEuXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLl9kcmFnU3RhcnQgPSBudWxsO1xuXG4gICAgZHJhZ0hhbmRsZXIub24oe1xuICAgICAgICBkcmFnU3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0XG4gICAgfSwgdGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QWxsZGF5UmVzaXplR3VpZGV9XG4gICAgICovXG4gICAgdGhpcy5ndWlkZSA9IG5ldyBBbGxkYXlSZXNpemVHdWlkZSh0aGlzKTtcbn1cblxuLyoqXG4gKiBEZXN0cm95IG1ldGhvZFxuICovXG5BbGxkYXlSZXNpemUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmd1aWRlLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9mZih0aGlzKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gdGhpcy5hbGxkYXlWaWV3ID0gdGhpcy5iYXNlQ29udHJvbGxlciA9XG4gICAgICAgIHRoaXMuZ3VpZGUgPSB0aGlzLl9kcmFnU3RhcnQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDaGVjayBkcmFnc3RhcnQgdGFyZ2V0IGlzIGV4cGVjdGVkIGNvbmRpdGlvbnMgZm9yIHRoaXMgaGFuZGxlci5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIGRyYWdzdGFydCBldmVudCBoYW5kbGVyJ3MgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbnxNb250aFdlZWt9IHJldHVybiBNb250aFdlZWsgdmlldyBpbnN0YW5jZSB3aGVuIHNhdGlhdGUgY29uZGl0aW9uLlxuICovXG5BbGxkYXlSZXNpemUucHJvdG90eXBlLmNoZWNrRXhwZWN0ZWRDb25kaXRpb24gPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICB2YXIgY3NzQ2xhc3MgPSBkb211dGlsLmdldENsYXNzKHRhcmdldCksXG4gICAgICAgIG1hdGNoZXM7XG5cbiAgICBpZiAoIX5jc3NDbGFzcy5pbmRleE9mKCdzY2hlZHVsZS12aWV3LWFsbGRheS1yZXNpemUtaGFuZGxlJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRhcmdldCA9IGRvbXV0aWwuY2xvc2VzdCh0YXJnZXQsICcuc2NoZWR1bGUtdmlldy1hbGxkYXktbW9udGh3ZWVrJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY3NzQ2xhc3MgPSBkb211dGlsLmdldENsYXNzKHRhcmdldCk7XG4gICAgbWF0Y2hlcyA9IGNzc0NsYXNzLm1hdGNoKHBhcnNlVmlld0lEUngpO1xuXG4gICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWwucGljayh0aGlzLmFsbGRheVZpZXcuY2hpbGRzLml0ZW1zLCBtYXRjaGVzWzFdKTtcbn07XG5cbi8qKlxuICogRHJhZ1N0YXJ0IGV2ZW50IGhhbmRsZXIuXG4gKiBAZW1pdHMgQWxsZGF5UmVzaXplI2FsbGRheV9yZXNpemVfZHJhZ3N0YXJ0XG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ1N0YXJ0RXZlbnREYXRhIC0gZXZlbnQgZGF0YS5cbiAqL1xuQWxsZGF5UmVzaXplLnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbihkcmFnU3RhcnRFdmVudERhdGEpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZHJhZ1N0YXJ0RXZlbnREYXRhLnRhcmdldCxcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5jaGVja0V4cGVjdGVkQ29uZGl0aW9uKHRhcmdldCksXG4gICAgICAgIGNvbnRyb2xsZXIgPSB0aGlzLmJhc2VDb250cm9sbGVyLFxuICAgICAgICBldmVudEJsb2NrRWxlbWVudCxcbiAgICAgICAgbW9kZWxJRCxcbiAgICAgICAgdGFyZ2V0TW9kZWwsXG4gICAgICAgIGdldEV2ZW50RGF0YUZ1bmMsXG4gICAgICAgIGV2ZW50RGF0YTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudEJsb2NrRWxlbWVudCA9IGRvbXV0aWwuY2xvc2VzdCh0YXJnZXQsICcuc2NoZWR1bGUtdmlldy1hbGxkYXktZXZlbnQtYmxvY2snKTtcbiAgICBtb2RlbElEID0gZG9tdXRpbC5nZXREYXRhKGV2ZW50QmxvY2tFbGVtZW50LCAnaWQnKTtcbiAgICB0YXJnZXRNb2RlbCA9IGNvbnRyb2xsZXIuZXZlbnRzLml0ZW1zW21vZGVsSURdO1xuXG4gICAgaWYgKCF0YXJnZXRNb2RlbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX3JldHJpdmVFdmVudERhdGEodGhpcy5hbGxkYXlWaWV3LCBkcmFnU3RhcnRFdmVudERhdGEub3JpZ2luRXZlbnQpO1xuICAgIGV2ZW50RGF0YSA9IHRoaXMuX2RyYWdTdGFydCA9IGdldEV2ZW50RGF0YUZ1bmMoZHJhZ1N0YXJ0RXZlbnREYXRhLm9yaWdpbkV2ZW50KTtcblxuICAgIHV0aWwuZXh0ZW5kKGV2ZW50RGF0YSwge1xuICAgICAgICBldmVudEJsb2NrRWxlbWVudDogZXZlbnRCbG9ja0VsZW1lbnQsXG4gICAgICAgIG1vZGVsOiB0YXJnZXRNb2RlbFxuICAgIH0pO1xuXG4gICAgdGhpcy5kcmFnSGFuZGxlci5vbih7XG4gICAgICAgIGRyYWc6IHRoaXMuX29uRHJhZyxcbiAgICAgICAgZHJhZ0VuZDogdGhpcy5fb25EcmFnRW5kLFxuICAgICAgICBjbGljazogdGhpcy5fb25DbGlja1xuICAgIH0sIHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IEFsbGRheVJlc2l6ZSNhbGxkYXlfcmVzaXplX2RyYWdzdGFydFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtBbGxkYXlWaWV3fSByZWxhdGVkVmlldyAtIGFsbGRheSB2aWV3IGluc3RhbmNlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRlc0luUmFuZ2UgLSBkYXRlIGNvdW50IG9mIHRoaXMgdmlldy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZHJhZ1N0YXJ0WEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIGRyYWdzdGFydCBncmlkIGluZGV4LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4SW5kZXggLSBpbmRleCBudW1iZXIgb2YgbW91c2UgcG9zaXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IG1vZGVsIC0gZGF0YSBvYmplY3Qgb2YgbW9kZWwgaXNudGFuY2UuXG4gICAgICogQHByb3BlcnR5IHtIVE1MRGl2RWxlbWVudH0gZXZlbnRCbG9ja0VsZW1lbnQgLSB0YXJnZXQgZXZlbnQgYmxvY2sgZWxlbWVudC5cbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ2FsbGRheV9yZXNpemVfZHJhZ3N0YXJ0JywgZXZlbnREYXRhKTtcbn07XG5cbi8qKlxuICogRHJhZyBldmVudCBoYW5kbGVyIG1ldGhvZC5cbiAqIEBlbWl0cyBBbGxkYXlSZXNpemUjYWxsZGF5X3Jlc2l6ZV9kcmFnXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ0V2ZW50RGF0YSAtIERyYWcjZHJhZyBldmVudCBoYW5kbGVyIGV2ZW50ZGF0YS5cbiAqL1xuQWxsZGF5UmVzaXplLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24oZHJhZ0V2ZW50RGF0YSkge1xuICAgIHZhciBnZXRFdmVudERhdGFGdW5jID0gdGhpcy5nZXRFdmVudERhdGFGdW5jO1xuXG4gICAgaWYgKCFnZXRFdmVudERhdGFGdW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgQWxsZGF5UmVzaXplI2FsbGRheV9yZXNpemVfZHJhZ1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtBbGxkYXlWaWV3fSByZWxhdGVkVmlldyAtIGFsbGRheSB2aWV3IGluc3RhbmNlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRlc0luUmFuZ2UgLSBkYXRlIGNvdW50IG9mIHRoaXMgdmlldy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZHJhZ1N0YXJ0WEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIGRyYWdzdGFydCBncmlkIGluZGV4LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4SW5kZXggLSBpbmRleCBudW1iZXIgb2YgbW91c2UgcG9zaXRpb25zLlxuICAgICAqL1xuICAgIHRoaXMuZmlyZSgnYWxsZGF5X3Jlc2l6ZV9kcmFnJywgZ2V0RXZlbnREYXRhRnVuYyhkcmFnRXZlbnREYXRhLm9yaWdpbkV2ZW50KSk7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgdXBkYXRlIGV2ZW50IGluc3RhbmNlIHRvIGJhc2UgY29udHJvbGxlci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBldmVudERhdGEgLSBldmVudCBkYXRhIGZyb20gQWxsZGF5UmVzaXplIGhhbmRsZXIuXG4gKi9cbkFsbGRheVJlc2l6ZS5wcm90b3R5cGUuX3VwZGF0ZUV2ZW50ID0gZnVuY3Rpb24oZXZlbnREYXRhKSB7XG4gICAgdmFyIGN0cmwgPSB0aGlzLmJhc2VDb250cm9sbGVyLFxuICAgICAgICBtb2RlbCA9IGV2ZW50RGF0YS50YXJnZXRNb2RlbCxcbiAgICAgICAgZGF0ZU9mZnNldCA9IGV2ZW50RGF0YS54SW5kZXggLSBldmVudERhdGEuZHJhZ1N0YXJ0WEluZGV4LFxuICAgICAgICBuZXdFbmRzID0gbmV3IERhdGUobW9kZWwuZW5kcy5nZXRUaW1lKCkpO1xuXG4gICAgbmV3RW5kcyA9IG5ldyBEYXRlKG5ld0VuZHMuc2V0RGF0ZShuZXdFbmRzLmdldERhdGUoKSArIGRhdGVPZmZzZXQpKTtcbiAgICBuZXdFbmRzID0gbmV3IERhdGUoTWF0aC5tYXgoZGF0ZXRpbWUuZW5kKG1vZGVsLnN0YXJ0cykuZ2V0VGltZSgpLCBuZXdFbmRzLmdldFRpbWUoKSkpO1xuXG4gICAgY3RybC51cGRhdGVFdmVudChtb2RlbC5jaWQoKSwge1xuICAgICAgICBlbmRzOiBuZXdFbmRzXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIERyYWdFbmQgZXZlbnQgaGFuZGVyIG1ldGhvZC5cbiAqIEBlbWl0cyBBbGxkYXlSZXNpemUjYWxsZGF5X3Jlc2l6ZV9kcmFnZW5kXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ0VuZEV2ZW50RGF0YSAtIERyYWcjRHJhZ0VuZCBldmVudCBoYW5kbGVyIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gW292ZXJyaWRlRXZlbnROYW1lXSAtIG92ZXJyaWRlIGVtaXR0ZWQgZXZlbnQgbmFtZSB3aGVuIHN1cHBsaWVkLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gc2tpcFVwZGF0ZSAtIHRydWUgdGhlbiBza2lwIHVwZGF0ZSBldmVudCBtb2RlbC5cbiAqL1xuQWxsZGF5UmVzaXplLnByb3RvdHlwZS5fb25EcmFnRW5kID0gZnVuY3Rpb24oZHJhZ0VuZEV2ZW50RGF0YSwgb3ZlcnJpZGVFdmVudE5hbWUsIHNraXBVcGRhdGUpIHtcbiAgICB2YXIgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuZ2V0RXZlbnREYXRhRnVuYyxcbiAgICAgICAgZHJhZ1N0YXJ0ID0gdGhpcy5fZHJhZ1N0YXJ0LFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICBpZiAoIWdldEV2ZW50RGF0YUZ1bmMgfHwgIWRyYWdTdGFydCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnSGFuZGxlci5vZmYoe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIGV2ZW50RGF0YSA9IGdldEV2ZW50RGF0YUZ1bmMoZHJhZ0VuZEV2ZW50RGF0YS5vcmlnaW5FdmVudCk7XG4gICAgdXRpbC5leHRlbmQoZXZlbnREYXRhLCB7XG4gICAgICAgIHRhcmdldE1vZGVsOiBkcmFnU3RhcnQubW9kZWxcbiAgICB9KTtcblxuICAgIGlmICghc2tpcFVwZGF0ZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVFdmVudChldmVudERhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBldmVudCBBbGxkYXlSZXNpemUjYWxsZGF5X3Jlc2l6ZV9kcmFnZW5kXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0FsbGRheVZpZXd9IHJlbGF0ZWRWaWV3IC0gYWxsZGF5IHZpZXcgaW5zdGFuY2UuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGVzSW5SYW5nZSAtIGRhdGUgY291bnQgb2YgdGhpcyB2aWV3LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkcmFnU3RhcnRYSW5kZXggLSBpbmRleCBudW1iZXIgb2YgZHJhZ3N0YXJ0IGdyaWQgaW5kZXguXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHhJbmRleCAtIGluZGV4IG51bWJlciBvZiBtb3VzZSBwb3NpdGlvbnMuXG4gICAgICovXG4gICAgdGhpcy5maXJlKG92ZXJyaWRlRXZlbnROYW1lIHx8ICdhbGxkYXlfcmVzaXplX2RyYWdlbmQnLCBldmVudERhdGEpO1xuXG4gICAgdGhpcy5nZXRFdmVudERhdGFGdW5jID0gdGhpcy5fZHJhZ1N0YXJ0ID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xpY2sgZXZlbnQgaGFuZGxlciBtZXRob2QuXG4gKiBAZW1pdHMgQWxsZGF5UmVzaXplI2FsbGRheV9yZXNpemVfY2xpY2tcbiAqIEBwYXJhbSB7b2JqZWN0fSBjbGlja0V2ZW50RGF0YSAtIERyYWcjQ2xpY2sgZXZlbnQgaGFuZGxlciBkYXRhLlxuICovXG5BbGxkYXlSZXNpemUucHJvdG90eXBlLl9vbkNsaWNrID0gZnVuY3Rpb24oY2xpY2tFdmVudERhdGEpIHtcbiAgICAvKipcbiAgICAgKiBAZXZlbnQgQWxsZGF5UmVzaXplI2FsbGRheV9yZXNpemVfY2xpY2tcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7QWxsZGF5Vmlld30gcmVsYXRlZFZpZXcgLSBhbGxkYXkgdmlldyBpbnN0YW5jZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGF0ZXNJblJhbmdlIC0gZGF0ZSBjb3VudCBvZiB0aGlzIHZpZXcuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRyYWdTdGFydFhJbmRleCAtIGluZGV4IG51bWJlciBvZiBkcmFnc3RhcnQgZ3JpZCBpbmRleC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geEluZGV4IC0gaW5kZXggbnVtYmVyIG9mIG1vdXNlIHBvc2l0aW9ucy5cbiAgICAgKi9cbiAgICB0aGlzLl9vbkRyYWdFbmQoY2xpY2tFdmVudERhdGEsICdhbGxkYXlfcmVzaXplX2NsaWNrJywgdHJ1ZSk7XG59O1xuXG5jb21tb24ubWl4aW4oQWxsZGF5Q29yZSwgQWxsZGF5UmVzaXplKTtcbnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKEFsbGRheVJlc2l6ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWxsZGF5UmVzaXplO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVzaXplIEd1aWRlIG1vZHVsZS5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgdXRpbCA9IHdpbmRvdy5uZS51dGlsO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgcmVxQW5pbUZyYW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL3JlcUFuaW1GcmFtZScpO1xuXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FsbGRheVJlc2l6ZX0gYWxsZGF5UmVzaXplIC0gaW5zdGFuY2Ugb2YgQWxsZGF5UmVzaXplXG4gKi9cbmZ1bmN0aW9uIEFsbGRheVJlc2l6ZUd1aWRlKGFsbGRheVJlc2l6ZSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBbGxkYXlSZXNpemV9XG4gICAgICovXG4gICAgdGhpcy5hbGxkYXlSZXNpemUgPSBhbGxkYXlSZXNpemU7XG5cbiAgICAvKipcbiAgICAgKiDsi6TsoJzroZwg7J2067Kk7Yq4IOyXmOumrOuovO2KuOulvCDri7TripQg7JeY66as66i87Yq4XG4gICAgICogQHR5cGUge0hUTUxESVZFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRDb250YWluZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuZ2V0RXZlbnREYXRhRnVuYyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTERJVkVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5ndWlkZUVsZW1lbnQgPSBudWxsO1xuXG4gICAgYWxsZGF5UmVzaXplLm9uKHtcbiAgICAgICAgJ2FsbGRheV9yZXNpemVfZHJhZ3N0YXJ0JzogdGhpcy5fb25EcmFnU3RhcnQsXG4gICAgICAgICdhbGxkYXlfcmVzaXplX2RyYWcnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgICdhbGxkYXlfcmVzaXplX2RyYWdlbmQnOiB0aGlzLl9jbGVhckd1aWRlRWxlbWVudCxcbiAgICAgICAgJ2FsbGRheV9yZXNpemVfY2xpY2snOiB0aGlzLl9jbGVhckd1aWRlRWxlbWVudFxuICAgIH0sIHRoaXMpO1xufVxuXG4vKipcbiAqIERlc3Ryb3kgbWV0aG9kXG4gKi9cbkFsbGRheVJlc2l6ZUd1aWRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2xlYXJHdWlkZUVsZW1lbnQoKTtcbiAgICB0aGlzLmFsbGRheVJlc2l6ZS5vZmYodGhpcyk7XG4gICAgdGhpcy5hbGxkYXlSZXNpemUgPSB0aGlzLmV2ZW50Q29udGFpbmVyID0gdGhpcy5nZXRFdmVudERhdGFGdW5jID1cbiAgICAgICAgdGhpcy5ndWlkZUVsZW1lbnQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhciBndWlkZSBlbGVtZW50LlxuICovXG5BbGxkYXlSZXNpemVHdWlkZS5wcm90b3R5cGUuX2NsZWFyR3VpZGVFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgZG9tdXRpbC5yZW1vdmUodGhpcy5ndWlkZUVsZW1lbnQpO1xuXG4gICAgaWYgKCF1dGlsLmJyb3dzZXIubXNpZSkge1xuICAgICAgICBkb211dGlsLnJlbW92ZUNsYXNzKGdsb2JhbC5kb2N1bWVudC5ib2R5LCAnc2NoZWR1bGUtdmlldy1yZXNpemluZy14Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5nZXRFdmVudERhdGFGdW5jID0gbnVsbDtcbn07XG5cbi8qKlxuICogUmVmcmVzaCBndWlkZSBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gbmV3V2lkdGggLSBuZXcgd2lkdGggcGVyY2VudGFnZSB2YWx1ZSB0byByZXNpemUgZ3VpZGUgZWxlbWVudC5cbiAqL1xuQWxsZGF5UmVzaXplR3VpZGUucHJvdG90eXBlLnJlZnJlc2hHdWlkZUVsZW1lbnQgPSBmdW5jdGlvbihuZXdXaWR0aCkge1xuICAgIHZhciBndWlkZUVsZW1lbnQgPSB0aGlzLmd1aWRlRWxlbWVudDtcblxuICAgIHJlcUFuaW1GcmFtZS5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICBndWlkZUVsZW1lbnQuc3R5bGUud2lkdGggPSBuZXdXaWR0aCArICclJztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGZ1bmN0aW9uIHRoYXQgY2FsY3VsYXRlIGd1aWRlIGVsZW1lbnQncyBuZXcgd2lkdGggcGVyY2VudGFnZSB2YWx1ZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnU3RhcnRFdmVudERhdGEgLSBkcmFnc3RhcnQgZXZlbnQgZGF0YS5cbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gcmV0dXJuIGZ1bmN0aW9uIHRoYXQgY2FsY3VsYXRlIGd1aWRlIGVsZW1lbnQgbmV3IHdpZHRoIHBlcmNlbnRhZ2UuXG4gKi9cbkFsbGRheVJlc2l6ZUd1aWRlLnByb3RvdHlwZS5nZXRHdWlkZUVsZW1lbnRXaWR0aEZ1bmMgPSBmdW5jdGlvbihkcmFnU3RhcnRFdmVudERhdGEpIHtcbiAgICB2YXIgbW9kZWwgPSBkcmFnU3RhcnRFdmVudERhdGEubW9kZWwsXG4gICAgICAgIHZpZXdPcHRpb25zID0gdGhpcy5hbGxkYXlSZXNpemUuYWxsZGF5Vmlldy5vcHRpb25zLFxuICAgICAgICBzdGFydERhdGUgPSBkYXRldGltZS5zdGFydChuZXcgRGF0ZShNYXRoLm1heChtb2RlbC5zdGFydHMuZ2V0VGltZSgpLCBkYXRldGltZS5wYXJzZSh2aWV3T3B0aW9ucy5yZW5kZXJTdGFydERhdGUpLmdldFRpbWUoKSkpKSxcbiAgICAgICAgZW5kRGF0ZSA9IGRhdGV0aW1lLmVuZChuZXcgRGF0ZShNYXRoLm1pbihtb2RlbC5lbmRzLmdldFRpbWUoKSwgZGF0ZXRpbWUucGFyc2Uodmlld09wdGlvbnMucmVuZGVyRW5kRGF0ZSkuZ2V0VGltZSgpKSkpLFxuICAgICAgICBvcmlnaW5MZW5ndGggPSBkYXRldGltZS5yYW5nZShzdGFydERhdGUsIGVuZERhdGUsIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZKS5sZW5ndGgsXG4gICAgICAgIGJhc2VXaWR0aFBlcmNlbnQgPSAxMDAgLyBkcmFnU3RhcnRFdmVudERhdGEuZGF0ZXNJblJhbmdlLFxuICAgICAgICBkcmFnU3RhcnRJbmRleCA9IGRyYWdTdGFydEV2ZW50RGF0YS54SW5kZXg7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oeEluZGV4KSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB4SW5kZXggLSBkcmFnU3RhcnRJbmRleCxcbiAgICAgICAgICAgIG5ld0xlbmd0aCA9IG9yaWdpbkxlbmd0aCArIG9mZnNldDtcblxuICAgICAgICBuZXdMZW5ndGggPSBNYXRoLm1heCgxLCBuZXdMZW5ndGgpO1xuXG4gICAgICAgIHJldHVybiBuZXdMZW5ndGggKiBiYXNlV2lkdGhQZXJjZW50O1xuICAgIH1cbn07XG5cbi8qKlxuICogRHJhZ1N0YXJ0IGV2ZW50IGhhbmRsZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ1N0YXJ0RXZlbnREYXRhIC0gZXZlbnQgZGF0YS5cbiAqL1xuQWxsZGF5UmVzaXplR3VpZGUucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGRyYWdTdGFydEV2ZW50RGF0YSkge1xuICAgIHZhciBhbGxkYXlWaWV3Q29udGFpbmVyID0gdGhpcy5hbGxkYXlSZXNpemUuYWxsZGF5Vmlldy5jb250YWluZXIsXG4gICAgICAgIGd1aWRlRWxlbWVudCA9IHRoaXMuZ3VpZGVFbGVtZW50ID0gZHJhZ1N0YXJ0RXZlbnREYXRhLmV2ZW50QmxvY2tFbGVtZW50LmNsb25lTm9kZSh0cnVlKSxcbiAgICAgICAgZXZlbnRDb250YWluZXI7XG5cbiAgICBpZiAoIXV0aWwuYnJvd3Nlci5tc2llKSB7XG4gICAgICAgIGRvbXV0aWwuYWRkQ2xhc3MoZ2xvYmFsLmRvY3VtZW50LmJvZHksICdzY2hlZHVsZS12aWV3LXJlc2l6aW5nLXgnKTtcbiAgICB9XG5cbiAgICBldmVudENvbnRhaW5lciA9IGRvbXV0aWwuZmluZCgnLnNjaGVkdWxlLXZpZXctbW9udGh3ZWVrLWV2ZW50cycsIGFsbGRheVZpZXdDb250YWluZXIpO1xuICAgIGRvbXV0aWwuYWRkQ2xhc3MoZ3VpZGVFbGVtZW50LCAnc2NoZWR1bGUtdmlldy1hbGxkYXktbW92ZS1ndWlkZScpO1xuICAgIGV2ZW50Q29udGFpbmVyLmFwcGVuZENoaWxkKGd1aWRlRWxlbWVudCk7XG5cbiAgICB0aGlzLmdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLmdldEd1aWRlRWxlbWVudFdpZHRoRnVuYyhkcmFnU3RhcnRFdmVudERhdGEpO1xufTtcblxuLyoqXG4gKiBEcmFnIGV2ZW50IGhhbmRsZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ0V2ZW50RGF0YSAtIGV2ZW50IGRhdGEuXG4gKi9cbkFsbGRheVJlc2l6ZUd1aWRlLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24oZHJhZ0V2ZW50RGF0YSkge1xuICAgIHZhciBmdW5jID0gdGhpcy5nZXRFdmVudERhdGFGdW5jO1xuXG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlZnJlc2hHdWlkZUVsZW1lbnQoZnVuYyhkcmFnRXZlbnREYXRhLnhJbmRleCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbGxkYXlSZXNpemVHdWlkZTtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERyYWcgaGFuZGxlciBmb3IgY2FsZW5kYXIuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIGRvbWV2ZW50ID0gcmVxdWlyZSgnLi4vY29tbW9uL2RvbWV2ZW50Jyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAbWl4ZXMgQ3VzdG9tRXZlbnRzXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIGRyYWcgaGFuZGxlclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRpc3RhbmNlPTEwXSAtIGRpc3RhbmNlIGluIHBpeGVscyBhZnRlciBtb3VzZSBtdXN0IG1vdmUgYmVmb3JlIGRyYWdnaW5nIHNob3VsZCBzdGFydFxuICogQHBhcmFtIHtMYXlvdXRWaWV3fSBsYXlvdXRWaWV3IExheW91dCB2aWV3IGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBEcmFnKG9wdGlvbnMsIGxheW91dFZpZXcpIHtcbiAgICB2YXIgY29udGFpbmVyID0gbGF5b3V0Vmlldy5jb250YWluZXI7XG5cbiAgICBkb21ldmVudC5vbihjb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgIGRpc3RhbmNlOiAxMFxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5faXNNb3ZlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogZHJhZ2dpbmcgZGlzdGFuY2UgaW4gcGl4ZWwgYmV0d2VlbiBtb3VzZWRvd24gYW5kIGZpcmluZyBkcmFnU3RhcnQgZXZlbnRzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9kaXN0YW5jZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9kcmFnU3RhcnRGaXJlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLl9kcmFnU3RhcnRFdmVudERhdGEgPSBudWxsO1xufVxuXG4vKipcbiAqIERlc3Ryb3kgbWV0aG9kLlxuICovXG5EcmFnLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgZG9tZXZlbnQub2ZmKHRoaXMuY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuICAgIHRoaXMuX2lzTW92ZWQgPSBudWxsO1xuICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbn07XG5cbi8qKlxuICogVG9nZ2xlIGV2ZW50cyBmb3IgbW91c2UgZHJhZ2dpbmcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHRvQmluZCAtIGJpbmQgZXZlbnRzIHJlbGF0ZWQgd2l0aCBkcmFnZ2luZyB3aGVuIHN1cHBsaWVkIFwidHJ1ZVwiXG4gKi9cbkRyYWcucHJvdG90eXBlLl90b2dnbGVEcmFnRXZlbnQgPSBmdW5jdGlvbih0b0JpbmQpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIsXG4gICAgICAgIGRvbU1ldGhvZCxcbiAgICAgICAgbWV0aG9kO1xuXG4gICAgaWYgKHRvQmluZCkge1xuICAgICAgICBkb21NZXRob2QgPSAnb24nO1xuICAgICAgICBtZXRob2QgPSAnZGlzYWJsZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG9tTWV0aG9kID0gJ29mZic7XG4gICAgICAgIG1ldGhvZCA9ICdlbmFibGUnO1xuICAgIH1cblxuICAgIGRvbXV0aWxbbWV0aG9kICsgJ1RleHRTZWxlY3Rpb24nXShjb250YWluZXIpO1xuICAgIGRvbXV0aWxbbWV0aG9kICsgJ0ltYWdlRHJhZyddKGNvbnRhaW5lcik7XG4gICAgZG9tZXZlbnRbZG9tTWV0aG9kXShnbG9iYWwsIHtcbiAgICAgICAgbW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcbiAgICAgICAgbW91c2V1cDogdGhpcy5fb25Nb3VzZVVwXG4gICAgfSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBtb3VzZSBldmVudCBvYmplY3QuXG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IG1vdXNlRXZlbnQgLSBtb3VzZSBldmVudCBvYmplY3QuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBub3JtYWxpemVkIG1vdXNlIGV2ZW50IGRhdGEuXG4gKi9cbkRyYWcucHJvdG90eXBlLl9nZXRFdmVudERhdGEgPSBmdW5jdGlvbihtb3VzZUV2ZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBtb3VzZUV2ZW50LnRhcmdldCB8fCBtb3VzZUV2ZW50LnNyY0VsZW1lbnQsXG4gICAgICAgIG9yaWdpbkV2ZW50OiBtb3VzZUV2ZW50XG4gICAgfTtcbn07XG5cbi8qKlxuICogTW91c2VEb3duIERPTSBldmVudCBoYW5kbGVyLlxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZURvd25FdmVudCBNb3VzZURvd24gZXZlbnQgb2JqZWN0LlxuICovXG5EcmFnLnByb3RvdHlwZS5fb25Nb3VzZURvd24gPSBmdW5jdGlvbihtb3VzZURvd25FdmVudCkge1xuICAgIC8vIG9ubHkgcHJpbWFyeSBidXR0b24gY2FuIHN0YXJ0IGRyYWcuXG4gICAgaWYgKGRvbWV2ZW50LmdldE1vdXNlQnV0dG9uKG1vdXNlRG93bkV2ZW50KSAhPT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZGlzdGFuY2UgPSAwO1xuICAgIHRoaXMuX2RyYWdTdGFydEZpcmVkID0gZmFsc2U7XG4gICAgdGhpcy5fZHJhZ1N0YXJ0RXZlbnREYXRhID0gdGhpcy5fZ2V0RXZlbnREYXRhKG1vdXNlRG93bkV2ZW50KTtcblxuICAgIHRoaXMuX3RvZ2dsZURyYWdFdmVudCh0cnVlKTtcbn07XG5cbi8qKlxuICogTW91c2VNb3ZlIERPTSBldmVudCBoYW5kbGVyLlxuICogQGVtaXRzIERyYWcjZHJhZ1xuICogQGVtaXRzIERyYWcjZHJhZ1N0YXJ0XG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IG1vdXNlTW92ZUV2ZW50IE1vdXNlTW92ZSBldmVudCBvYmplY3QuXG4gKi9cbkRyYWcucHJvdG90eXBlLl9vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uKG1vdXNlTW92ZUV2ZW50KSB7XG4gICAgdmFyIGRpc3RhbmNlID0gdGhpcy5vcHRpb25zLmRpc3RhbmNlO1xuICAgIC8vIHByZXZlbnQgYXV0b21hdGljIHNjcm9sbGluZy5cbiAgICBkb21ldmVudC5wcmV2ZW50RGVmYXVsdChtb3VzZU1vdmVFdmVudCk7XG5cbiAgICB0aGlzLl9pc01vdmVkID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLl9kaXN0YW5jZSA8IGRpc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlICs9IDE7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2RyYWdTdGFydEZpcmVkKSB7XG4gICAgICAgIHRoaXMuX2RyYWdTdGFydEZpcmVkID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRHJhZyBzdGFydHMgZXZlbnRzLiBjYW5jZWxhYmxlLlxuICAgICAgICAgKiBAZXZlbnQgRHJhZyNkcmFnU3RhcnRcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gdGFyZ2V0IGVsZW1lbnQgaW4gdGhpcyBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBvcmlnaW5FdmVudCAtIG9yaWdpbmFsIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghdGhpcy5pbnZva2UoJ2RyYWdTdGFydCcsIHRoaXMuX2RyYWdTdGFydEV2ZW50RGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZURyYWdFdmVudChmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmVudHMgd2hpbGUgZHJhZ2dpbmcuXG4gICAgICogQGV2ZW50IERyYWcjZHJhZ1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gdGFyZ2V0IGVsZW1lbnQgaW4gdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge01vdXNlRXZlbnR9IG9yaWdpbkV2ZW50IC0gb3JpZ2luYWwgbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqL1xuICAgIHRoaXMuZmlyZSgnZHJhZycsIHRoaXMuX2dldEV2ZW50RGF0YShtb3VzZU1vdmVFdmVudCkpO1xufTtcblxuLyoqXG4gKiBNb3VzZVVwIERPTSBldmVudCBoYW5kbGVyLlxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZVVwRXZlbnQgTW91c2VVcCBldmVudCBvYmplY3QuXG4gKiBAZW1pdHMgRHJhZyNkcmFnRW5kXG4gKiBAZW1pdHMgRHJhZyNjbGlja1xuICovXG5EcmFnLnByb3RvdHlwZS5fb25Nb3VzZVVwID0gZnVuY3Rpb24obW91c2VVcEV2ZW50KSB7XG4gICAgdGhpcy5fdG9nZ2xlRHJhZ0V2ZW50KGZhbHNlKTtcblxuICAgIC8vIGVtaXQgXCJjbGlja1wiIGV2ZW50IHdoZW4gbm90IGVtaXR0ZWQgZHJhZyBldmVudCBiZXR3ZWVuIG1vdXNlZG93biBhbmQgbW91c2V1cC5cbiAgICBpZiAodGhpcy5faXNNb3ZlZCkge1xuICAgICAgICB0aGlzLl9pc01vdmVkID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyYWcgZW5kIGV2ZW50cy5cbiAgICAgICAgICogQGV2ZW50IERyYWcjZHJhZ0VuZFxuICAgICAgICAgKiBAdHlwZSB7TW91c2VFdmVudH1cbiAgICAgICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gdGFyZ2V0IGVsZW1lbnQgaW4gdGhpcyBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBvcmlnaW5FdmVudCAtIG9yaWdpbmFsIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlyZSgnZHJhZ0VuZCcsIHRoaXMuX2dldEV2ZW50RGF0YShtb3VzZVVwRXZlbnQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsaWNrIGV2ZW50cy5cbiAgICAgKiBAZXZlbnQgRHJhZyNjbGlja1xuICAgICAqIEB0eXBlIHtNb3VzZUV2ZW50fVxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIHRhcmdldCBlbGVtZW50IGluIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBvcmlnaW5FdmVudCAtIG9yaWdpbmFsIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ2NsaWNrJywgdGhpcy5fZ2V0RXZlbnREYXRhKG1vdXNlVXBFdmVudCkpO1xufTtcblxudXRpbC5DdXN0b21FdmVudHMubWl4aW4oRHJhZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRHJhZztcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEFsbGRheSBldmVudCBjbGljayBldmVudCBoYW5kZXIgbW9kdWxlXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIFRpbWVNb3ZlID0gcmVxdWlyZSgnLi9tb3ZlJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgcGFyc2VUaW1lVmlld0lEUnggPSAvXnNjaGVkdWxlLXZpZXctdGltZS1kYXRlW1xcc11zY2hlZHVsZS12aWV3LShcXGQrKS87XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7SGFuZGxlcn1cbiAqIEBtaXhlcyB1dGlsLkN1c3RvbUV2ZW50c1xuICogQHBhcmFtIHtEcmFnfSBbZHJhZ0hhbmRsZXJdIC0gRHJhZyBoYW5kbGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHtUaW1lR3JpZH0gW3RpbWVHcmlkVmlld10gLSBUaW1lR3JpZCB2aWV3IGluc3RhbmNlLlxuICogQHBhcmFtIHtCYXNlfSBbYmFzZUNvbnRyb2xsZXJdIC0gQmFzZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBUaW1lQ2xpY2soZHJhZ0hhbmRsZXIsIHRpbWVHcmlkVmlldywgYmFzZUNvbnRyb2xsZXIpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RHJhZ31cbiAgICAgKi9cbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gZHJhZ0hhbmRsZXI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VGltZUdyaWR9XG4gICAgICovXG4gICAgdGhpcy50aW1lR3JpZFZpZXcgPSB0aW1lR3JpZFZpZXc7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QmFzZX1cbiAgICAgKi9cbiAgICB0aGlzLmJhc2VDb250cm9sbGVyID0gYmFzZUNvbnRyb2xsZXI7XG5cbiAgICBkcmFnSGFuZGxlci5vbih7XG4gICAgICAgICdjbGljayc6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcbn1cblxuLyoqXG4gKiBEZXN0cm95IG1ldGhvZFxuICovXG5UaW1lQ2xpY2sucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9mZih0aGlzKTtcbiAgICB0aGlzLnRpbWVHcmlkVmlldyA9IHRoaXMuYmFzZUNvbnRyb2xsZXIgPSB0aGlzLmRyYWdIYW5kbGVyID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2hlY2sgdGFyZ2V0IGVsZW1lbnQgaXMgZXhwZWN0ZWQgY29uZGl0aW9uIGZvciBhY3RpdmF0ZSB0aGlzIHBsdWdpbnMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBUaGUgZWxlbWVudCB0byBjaGVja1xuICogQHJldHVybnMge3N0cmluZ30gLSBtb2RlbCBpZFxuICovXG5UaW1lQ2xpY2sucHJvdG90eXBlLmNoZWNrRXhwZWN0Q29uZGl0aW9uID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgdmFyIGNvbnRhaW5lcixcbiAgICAgICAgbWF0Y2hlcztcblxuICAgIGlmICghZG9tdXRpbC5oYXNDbGFzcyh0YXJnZXQsICdzY2hlZHVsZS12aWV3LXRpbWUtZXZlbnQnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29udGFpbmVyID0gZG9tdXRpbC5jbG9zZXN0KHRhcmdldCwgJy5zY2hlZHVsZS12aWV3LXRpbWUtZGF0ZScpO1xuXG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG1hdGNoZXMgPSBkb211dGlsLmdldENsYXNzKGNvbnRhaW5lcikubWF0Y2gocGFyc2VUaW1lVmlld0lEUngpO1xuXG4gICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWwucGljayh0aGlzLnRpbWVHcmlkVmlldy5jaGlsZHMuaXRlbXMsICttYXRjaGVzWzFdKTtcbn07XG5cbi8qKlxuICogQ2xpY2sgZXZlbnQgaGFuZGVyXG4gKiBAcGFyYW0ge29iamVjdH0gY2xpY2tFdmVudCAtIGNsaWNrIGV2ZW50IGZyb20ge0BsaW5rIERyYWd9XG4gKiBAZW1pdHMgVGltZUNsaWNrI2NsaWNrXG4gKi9cblRpbWVDbGljay5wcm90b3R5cGUuX29uQ2xpY2sgPSBmdW5jdGlvbihjbGlja0V2ZW50KSB7XG4gICAgdmFyIHRhcmdldCA9IGNsaWNrRXZlbnQudGFyZ2V0LFxuICAgICAgICB0aW1lVmlldyA9IHRoaXMuY2hlY2tFeHBlY3RDb25kaXRpb24odGFyZ2V0KSxcbiAgICAgICAgYmxvY2tFbGVtZW50ID0gZG9tdXRpbC5jbG9zZXN0KHRhcmdldCwgJy5zY2hlZHVsZS12aWV3LXRpbWUtZGF0ZS1ldmVudC1ibG9jaycpLFxuICAgICAgICBldmVudENvbGxlY3Rpb24gPSB0aGlzLmJhc2VDb250cm9sbGVyLmV2ZW50cztcblxuICAgIGlmICghdGltZVZpZXcgfHwgIWJsb2NrRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnRDb2xsZWN0aW9uLmRvV2hlbkhhcyhkb211dGlsLmdldERhdGEoYmxvY2tFbGVtZW50LCAnaWQnKSwgZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudHMgVGltZUNsaWNrI2NsaWNrXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IG1vZGVsIC0gbW9kZWwgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlyZSgnY2xpY2snLCB7XG4gICAgICAgICAgICBtb2RlbDogIG1vZGVsXG4gICAgICAgIH0pO1xuICAgIH0sIHRoaXMpO1xufTtcblxudXRpbC5DdXN0b21FdmVudHMubWl4aW4oVGltZUNsaWNrKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lQ2xpY2s7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBDb3JlIG1ldGhvZHMgZm9yIGRyYWdnaW5nIGFjdGlvbnNcbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2NvbW1vbicpO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgZG9tZXZlbnQgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tZXZlbnQnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9wb2ludCcpO1xuXG4vKipcbiAqIEBtaXhpbiBUaW1lLkNvcmVcbiAqL1xudmFyIHRpbWVDb3JlID0ge1xuICAgIC8qKlxuICAgICAqIEdldCBZIGluZGV4IHJhdGlvKGhvdXIpIGluIHRpbWUgZ3JpZHMgYnkgc3VwcGxpZWQgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmFzZU1pbCAtIGJhc2UgbWlsbGlzZWNvbmRzIG51bWJlciBmb3Igc3VwcGxpZWQgaGVpZ2h0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBjb250YWluZXIgZWxlbWVudCBoZWlnaHQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGUgdG8gY2FsY3VsYXRlIGhvdXIgcmF0aW8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gaG91ciBpbmRleCByYXRpbyB2YWx1ZS5cbiAgICAgKi9cbiAgICBfY2FsY0dyaWRZSW5kZXg6IGZ1bmN0aW9uKGJhc2VNaWwsIGhlaWdodCwgeSkge1xuICAgICAgICAvLyBnZXQgcmF0aW8gZnJvbSByaWdodCBleHByZXNzaW9uID4gcG9pbnQueSA6IHggPSBzZXNzaW9uLmhlaWdodCA6IGJhc2VNaWxcbiAgICAgICAgLy8gYW5kIGNvbnZlcnQgbWlsbGlzZWNvbmRzIHZhbHVlIHRvIGhvdXJzLlxuICAgICAgICB2YXIgcmVzdWx0ID0gZGF0ZXRpbWUubWlsbGlzZWNvbmRzVG8oJ2hvdXInLCAoeSAqIGJhc2VNaWwpIC8gaGVpZ2h0KSxcbiAgICAgICAgICAgIGZsb29yZWQgPSByZXN1bHQgfCAwLFxuICAgICAgICAgICAgbmVhcmVzdCA9IGNvbW1vbi5uZWFyZXN0KHJlc3VsdCAtIGZsb29yZWQsIFswLCAxXSk7XG5cbiAgICAgICAgcmV0dXJuIGZsb29yZWQgKyAobmVhcmVzdCA/IDAuNSA6IDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZnVuY3Rpb24gdG8gbWFrZXMgZXZlbnQgZGF0YSBmcm9tIFRpbWUgYW5kIG1vdXNlRXZlbnRcbiAgICAgKiBAcGFyYW0ge1RpbWV9IHRpbWVWaWV3IC0gSW5zdGFuY2Ugb2YgdGltZSB2aWV3LlxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn0gLSBGdW5jdGlvbiB0aGF0IHJldHVybiBldmVudCBkYXRhIGZyb20gbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgX3JldHJpdmVFdmVudERhdGE6IGZ1bmN0aW9uKHRpbWVWaWV3KSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aW1lVmlldy5jb250YWluZXIsXG4gICAgICAgICAgICBvcHRpb25zID0gdGltZVZpZXcub3B0aW9ucyxcbiAgICAgICAgICAgIHZpZXdIZWlnaHQgPSB0aW1lVmlldy5nZXRWaWV3Qm91bmQoKS5oZWlnaHQsXG4gICAgICAgICAgICB2aWV3VGltZSA9ICt0aW1lVmlldy5nZXREYXRlKCksXG4gICAgICAgICAgICBob3VyTGVuZ3RoID0gb3B0aW9ucy5ob3VyRW5kIC0gb3B0aW9ucy5ob3VyU3RhcnQsXG4gICAgICAgICAgICBiYXNlTWlsID0gZGF0ZXRpbWUubWlsbGlzZWNvbmRzRnJvbSgnaG91cicsIGhvdXJMZW5ndGgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IG1vdXNlRXZlbnQgLSBtb3VzZSBldmVudCBvYmplY3QgdG8gZ2V0IGNvbW1vbiBldmVudCBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gW2V4dGVuZF0gLSBvYmplY3QgdG8gZXh0ZW5kIGV2ZW50IGRhdGEgYmVmb3JlIHJldHVybi5cbiAgICAgICAgICogQHJldHVybnMge29iamVjdH0gLSBjb21tb24gZXZlbnQgZGF0YSBmb3IgdGltZS4qXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gdXRpbC5iaW5kKGZ1bmN0aW9uKG1vdXNlRXZlbnQsIGV4dGVuZCkge1xuICAgICAgICAgICAgdmFyIG1vdXNlWSA9IFBvaW50Lm4oZG9tZXZlbnQuZ2V0TW91c2VQb3NpdGlvbihtb3VzZUV2ZW50LCBjb250YWluZXIpKS55LFxuICAgICAgICAgICAgICAgIGdyaWRZID0gY29tbW9uLnJhdGlvKHZpZXdIZWlnaHQsIGhvdXJMZW5ndGgsIG1vdXNlWSksXG4gICAgICAgICAgICAgICAgdGltZVkgPSB2aWV3VGltZSArIGRhdGV0aW1lLm1pbGxpc2Vjb25kc0Zyb20oJ2hvdXInLCBncmlkWSksXG4gICAgICAgICAgICAgICAgbmVhcmVzdEdyaWRZID0gdGhpcy5fY2FsY0dyaWRZSW5kZXgoYmFzZU1pbCwgdmlld0hlaWdodCwgbW91c2VZKSxcbiAgICAgICAgICAgICAgICBuZWFyZXN0R3JpZFRpbWVZID0gdmlld1RpbWUgKyBkYXRldGltZS5taWxsaXNlY29uZHNGcm9tKCdob3VyJywgbmVhcmVzdEdyaWRZICsgb3B0aW9ucy5ob3VyU3RhcnQpO1xuXG4gICAgICAgICAgICByZXR1cm4gdXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgICAgIHRhcmdldDogbW91c2VFdmVudC50YXJnZXQgfHwgbW91c2VFdmVudC5zcmNFbGVtZW50LFxuICAgICAgICAgICAgICAgIHJlbGF0ZWRWaWV3OiB0aW1lVmlldyxcbiAgICAgICAgICAgICAgICBvcmlnaW5FdmVudDogbW91c2VFdmVudCxcbiAgICAgICAgICAgICAgICBtb3VzZVk6IG1vdXNlWSxcbiAgICAgICAgICAgICAgICBncmlkWTogZ3JpZFksXG4gICAgICAgICAgICAgICAgdGltZVk6IHRpbWVZLFxuICAgICAgICAgICAgICAgIG5lYXJlc3RHcmlkWTogbmVhcmVzdEdyaWRZLFxuICAgICAgICAgICAgICAgIG5lYXJlc3RHcmlkVGltZVk6IG5lYXJlc3RHcmlkVGltZVlcbiAgICAgICAgICAgIH0sIGV4dGVuZCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNaXhpbiBtZXRob2QuXG4gICAgICogQHBhcmFtIHsoVGltZUNyZWF0aW9ufFRpbWVNb3ZlKX0gb2JqIC0gQ29uc3RydWN0b3IgZnVuY3Rpb25zXG4gICAgICovXG4gICAgbWl4aW46IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICB2YXIgcHJvdG8gPSBvYmoucHJvdG90eXBlO1xuICAgICAgICB1dGlsLmZvckVhY2godGltZUNvcmUsIGZ1bmN0aW9uKG1ldGhvZCwgbWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdtaXhpbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb3RvW21ldGhvZE5hbWVdID0gbWV0aG9kO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRpbWVDb3JlO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgSGFuZGxpbmcgY3JlYXRpb24gZXZlbnRzIGZyb20gZHJhZyBoYW5kbGVyIGFuZCB0aW1lIGdyaWQgdmlld1xuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBhcnJheSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9hcnJheScpO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgVGltZUNyZWF0aW9uR3VpZGUgPSByZXF1aXJlKCcuL2NyZWF0aW9uR3VpZGUnKTtcbnZhciB0aW1lQ29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG52YXIgcGFyc2VWaWV3SURSeCA9IC9ec2NoZWR1bGUtdmlldy10aW1lLWRhdGVbXFxzXXNjaGVkdWxlLXZpZXctKFxcZCspLztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtIYW5kbGVyfVxuICogQG1peGVzIHRpbWVDb3JlXG4gKiBAbWl4ZXMgQ3VzdG9tRXZlbnRzXG4gKiBAcGFyYW0ge0RyYWd9IFtkcmFnSGFuZGxlcl0gLSBEcmFnIGhhbmRsZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge1RpbWVHcmlkfSBbdGltZUdyaWRWaWV3XSAtIFRpbWVHcmlkIHZpZXcgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0Jhc2V9IFtiYXNlQ29udHJvbGxlcl0gLSBCYXNlIGNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIFRpbWVDcmVhdGlvbihkcmFnSGFuZGxlciwgdGltZUdyaWRWaWV3LCBiYXNlQ29udHJvbGxlcikge1xuICAgIC8qKlxuICAgICAqIERyYWcgaGFuZGxlciBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7RHJhZ31cbiAgICAgKi9cbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRpbWVHcmlkIHZpZXcgaW5zdGFuY2UuXG4gICAgICogQHR5cGUge1RpbWVHcmlkfVxuICAgICAqL1xuICAgIHRoaXMudGltZUdyaWRWaWV3ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEJhc2UgY29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7QmFzZX1cbiAgICAgKi9cbiAgICB0aGlzLmJhc2VDb250cm9sbGVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtUaW1lQ3JlYXRpb25HdWlkZX1cbiAgICAgKi9cbiAgICB0aGlzLmd1aWRlID0gbmV3IFRpbWVDcmVhdGlvbkd1aWRlKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogVGVtcG9yYXJ5IGZ1bmN0aW9uIGZvciBzaW5nbGUgZHJhZyBzZXNzaW9uJ3MgY2FsYy5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5fZ2V0RXZlbnREYXRhRnVuYyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUZW1wb3JhcnkgZnVuY3Rpb24gZm9yIGRyYWcgc3RhcnQgZGF0YSBjYWNoZS5cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuX2RyYWdTdGFydCA9IG51bGw7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmNvbm5lY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG59XG5cbi8qKlxuICogRGVzdHJveSBtZXRob2RcbiAqL1xuVGltZUNyZWF0aW9uLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5ndWlkZS5kZXN0cm95KCk7XG4gICAgdGhpcy5kcmFnSGFuZGxlci5vZmYodGhpcyk7XG4gICAgdGhpcy5kcmFnSGFuZGxlciA9IHRoaXMudGltZUdyaWRWaWV3ID0gdGhpcy5iYXNlQ29udHJvbGxlciA9XG4gICAgICAgIHRoaXMuX2dldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9kcmFnU3RhcnQgPSB0aGlzLmd1aWRlID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ29ubmVjdCBoYW5kbGVyLCB2aWV3LCBjb250cm9sbGVycyBmb3IgZXZlbnQgY3JlYXRpb25zLlxuICogQHBhcmFtIHtEcmFnfSBbZHJhZ0hhbmRsZXJdIC0gRHJhZyBoYW5kbGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHtUaW1lR3JpZH0gW3RpbWVHcmlkVmlld10gLSBUaW1lR3JpZCB2aWV3IGluc3RhbmNlLlxuICogQHBhcmFtIHtCYXNlfSBbYmFzZUNvbnRyb2xsZXJdIC0gQmFzZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICovXG5UaW1lQ3JlYXRpb24ucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihkcmFnSGFuZGxlciwgdGltZUdyaWRWaWV3LCBiYXNlQ29udHJvbGxlcikge1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBkcmFnSGFuZGxlcjtcbiAgICB0aGlzLnRpbWVHcmlkVmlldyA9IHRpbWVHcmlkVmlldztcbiAgICB0aGlzLmJhc2VDb250cm9sbGVyID0gYmFzZUNvbnRyb2xsZXI7XG5cbiAgICBkcmFnSGFuZGxlci5vbih7XG4gICAgICAgIGRyYWdTdGFydDogdGhpcy5fb25EcmFnU3RhcnRcbiAgICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdGFyZ2V0IGVsZW1lbnQgaXMgZXhwZWN0ZWQgY29uZGl0aW9uIGZvciBhY3RpdmF0ZSB0aGlzIHBsdWdpbnMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBUaGUgZWxlbWVudCB0byBjaGVja1xuICogQHJldHVybnMgeyhib29sZWFufFRpbWUpfSAtIHJldHVybiBUaW1lIHZpZXcgaW5zdGFuY2Ugd2hlbiBzYXRpYXRlIGNvbmRpdGlvbi5cbiAqL1xuVGltZUNyZWF0aW9uLnByb3RvdHlwZS5jaGVja0V4cGVjdGVkQ29uZGl0aW9uID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgdmFyIGNzc0NsYXNzID0gZG9tdXRpbC5nZXRDbGFzcyh0YXJnZXQpLFxuICAgICAgICBtYXRjaGVzO1xuXG4gICAgaWYgKGNzc0NsYXNzID09PSAnc2NoZWR1bGUtdmlldy10aW1lLWRhdGUtZXZlbnQtYmxvY2snKSB7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICBjc3NDbGFzcyA9IGRvbXV0aWwuZ2V0Q2xhc3ModGFyZ2V0KTtcbiAgICB9XG5cbiAgICBtYXRjaGVzID0gY3NzQ2xhc3MubWF0Y2gocGFyc2VWaWV3SURSeCk7XG5cbiAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbC5waWNrKHRoaXMudGltZUdyaWRWaWV3LmNoaWxkcy5pdGVtcywgbWF0Y2hlc1sxXSk7XG59O1xuXG4vKipcbiAqIERyYWcjZHJhZ1N0YXJ0IGV2ZW50IGhhbmRsZXIuXG4gKiBAZW1pdHMgVGltZUNyZWF0aW9uI3RpbWVfY3JlYXRpb25fZHJhZ3N0YXJ0XG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ1N0YXJ0RXZlbnREYXRhIC0gRHJhZyNkcmFnU3RhcnQgZXZlbnQgZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3ZlcnJpZGVFdmVudE5hbWVdIC0gb3ZlcnJpZGUgZW1pdHRlZCBldmVudCBuYW1lIHdoZW4gc3VwcGxpZWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcmV2aXNlXSAtIHN1cHBseSBmdW5jdGlvbiBmb3IgcmV2aXNlIGV2ZW50IGRhdGEgYmVmb3JlIGVtaXQuXG4gKi9cblRpbWVDcmVhdGlvbi5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZHJhZ1N0YXJ0RXZlbnREYXRhLCBvdmVycmlkZUV2ZW50TmFtZSwgcmV2aXNlKSB7XG4gICAgdmFyIHRhcmdldCA9IGRyYWdTdGFydEV2ZW50RGF0YS50YXJnZXQsXG4gICAgICAgIHJlc3VsdCA9IHRoaXMuY2hlY2tFeHBlY3RlZENvbmRpdGlvbih0YXJnZXQpLFxuICAgICAgICBnZXRFdmVudERhdGFGdW5jLFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX2dldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9yZXRyaXZlRXZlbnREYXRhKHJlc3VsdCk7XG4gICAgZXZlbnREYXRhID0gdGhpcy5fZHJhZ1N0YXJ0ID0gZ2V0RXZlbnREYXRhRnVuYyhkcmFnU3RhcnRFdmVudERhdGEub3JpZ2luRXZlbnQpO1xuXG4gICAgaWYgKHJldmlzZSkge1xuICAgICAgICByZXZpc2UoZXZlbnREYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9uKHtcbiAgICAgICAgZHJhZzogdGhpcy5fb25EcmFnLFxuICAgICAgICBkcmFnRW5kOiB0aGlzLl9vbkRyYWdFbmQsXG4gICAgICAgIGNsaWNrOiB0aGlzLl9vbkNsaWNrXG4gICAgfSwgdGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgVGltZUNyZWF0aW9uI3RpbWVfY3JlYXRpb25fZHJhZ3N0YXJ0XG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge1RpbWV9IHJlbGF0ZWRWaWV3IC0gdGltZSB2aWV3IGluc3RhbmNlIHJlbGF0ZWQgd2l0aCBtb3VzZSBwb3NpdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge01vdXNlRXZlbnR9IG9yaWdpbkV2ZW50IC0gbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb3VzZVkgLSBtb3VzZSBZIHB4IG1vdXNlIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBncmlkWSAtIGdyaWQgWSBpbmRleCB2YWx1ZSByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lWSAtIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiBtb3VzZVkgcG9pbnRzLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFkgLSBuZWFyZXN0IGdyaWQgaW5kZXggcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRUaW1lWSAtIHRpbWUgdmFsdWUgZm9yIG5lYXJlc3RHcmlkWS5cbiAgICAgKi9cbiAgICB0aGlzLmZpcmUob3ZlcnJpZGVFdmVudE5hbWUgfHwgJ3RpbWVfY3JlYXRpb25fZHJhZ3N0YXJ0JywgZXZlbnREYXRhKTtcbn07XG5cbi8qKlxuICogRHJhZyNkcmFnIGV2ZW50IGhhbmRsZXJcbiAqIEBlbWl0cyBUaW1lQ3JlYXRpb24jdGltZV9jcmVhdGlvbl9kcmFnXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ0V2ZW50RGF0YSAtIGV2ZW50IGRhdGEgZnJvbSBEcmFnI2RyYWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW292ZXJyaWRlRXZlbnROYW1lXSAtIG92ZXJyaWRlIGVtaXR0ZWQgZXZlbnQgbmFtZSB3aGVuIHN1cHBsaWVkLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3JldmlzZV0gLSBzdXBwbHkgZnVuY3Rpb24gZm9yIHJldmlzZSBldmVudCBkYXRhIGJlZm9yZSBlbWl0LlxuICovXG5UaW1lQ3JlYXRpb24ucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbihkcmFnRXZlbnREYXRhLCBvdmVycmlkZUV2ZW50TmFtZSwgcmV2aXNlKSB7XG4gICAgdmFyIGdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9nZXRFdmVudERhdGFGdW5jLFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICBpZiAoIWdldEV2ZW50RGF0YUZ1bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50RGF0YSA9IGdldEV2ZW50RGF0YUZ1bmMoZHJhZ0V2ZW50RGF0YS5vcmlnaW5FdmVudCk7XG5cbiAgICBpZiAocmV2aXNlKSB7XG4gICAgICAgIHJldmlzZShldmVudERhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBldmVudCBUaW1lQ3JlYXRpb24jdGltZV9jcmVhdGlvbl9kcmFnXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge1RpbWV9IHJlbGF0ZWRWaWV3IC0gdGltZSB2aWV3IGluc3RhbmNlIHJlbGF0ZWQgd2l0aCBtb3VzZSBwb3NpdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge01vdXNlRXZlbnR9IG9yaWdpbkV2ZW50IC0gbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb3VzZVkgLSBtb3VzZSBZIHB4IG1vdXNlIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBncmlkWSAtIGdyaWQgWSBpbmRleCB2YWx1ZSByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lWSAtIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiBtb3VzZVkgcG9pbnRzLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFkgLSBuZWFyZXN0IGdyaWQgaW5kZXggcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRUaW1lWSAtIHRpbWUgdmFsdWUgZm9yIG5lYXJlc3RHcmlkWS5cbiAgICAgKi9cbiAgICB0aGlzLmZpcmUob3ZlcnJpZGVFdmVudE5hbWUgfHwgJ3RpbWVfY3JlYXRpb25fZHJhZycsIGV2ZW50RGF0YSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBldmVudERhdGEgLSBldmVudCBkYXRhIG9iamVjdCBmcm9tIFRpbWVDcmVhdGlvbiN0aW1lX2NyZWF0aW9uX2RyYWdlbmRcbiAqIG9yIFRpbWVDcmVhdGlvbiN0aW1lX2NyZWF0aW9uX2NsaWNrXG4gKi9cblRpbWVDcmVhdGlvbi5wcm90b3R5cGUuX2NyZWF0ZUV2ZW50ID0gZnVuY3Rpb24oZXZlbnREYXRhKSB7XG4gICAgdmFyIHRpdGxlID0gd2luZG93LnByb21wdCgnTmFtZSBvZiBldmVudCB0byBjcmVhdGU6JyksXG4gICAgICAgIGN0cmwgPSB0aGlzLmJhc2VDb250cm9sbGVyLFxuICAgICAgICByZWxhdGVkVmlldyA9IGV2ZW50RGF0YS5yZWxhdGVkVmlldyxcbiAgICAgICAgY3JlYXRlUmFuZ2UgPSBldmVudERhdGEuY3JlYXRlUmFuZ2UsXG4gICAgICAgIG5lYXJlc3RHcmlkVGltZVkgPSBldmVudERhdGEubmVhcmVzdEdyaWRUaW1lWSxcbiAgICAgICAgYmFzZURhdGUsXG4gICAgICAgIGRhdGVTdGFydCxcbiAgICAgICAgZGF0ZUVuZCxcbiAgICAgICAgbmV3U3RhcnRzLFxuICAgICAgICBuZXdFbmRzO1xuXG4gICAgdGhpcy5ndWlkZS5jbGVhckd1aWRlRWxlbWVudCgpO1xuXG4gICAgaWYgKCF0aXRsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFjcmVhdGVSYW5nZSkge1xuICAgICAgICBjcmVhdGVSYW5nZSA9IFtcbiAgICAgICAgICAgIG5lYXJlc3RHcmlkVGltZVksXG4gICAgICAgICAgICBuZWFyZXN0R3JpZFRpbWVZICsgZGF0ZXRpbWUubWlsbGlzZWNvbmRzRnJvbSgnbWludXRlcycsIDMwKVxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGJhc2VEYXRlID0gbmV3IERhdGUocmVsYXRlZFZpZXcuZ2V0RGF0ZSgpKTtcbiAgICBkYXRlU3RhcnQgPSBkYXRldGltZS5zdGFydChiYXNlRGF0ZSk7XG4gICAgZGF0ZUVuZCA9IGRhdGV0aW1lLmVuZChiYXNlRGF0ZSk7XG4gICAgbmV3U3RhcnRzID0gTWF0aC5tYXgoZGF0ZVN0YXJ0LmdldFRpbWUoKSwgY3JlYXRlUmFuZ2VbMF0pO1xuICAgIG5ld0VuZHMgPSBNYXRoLm1pbihkYXRlRW5kLmdldFRpbWUoKSwgY3JlYXRlUmFuZ2VbMV0pO1xuXG4gICAgY3RybC5jcmVhdGVFdmVudCh7XG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgaXNBbGxEYXk6IGZhbHNlLFxuICAgICAgICBzdGFydHM6IG5ldyBEYXRlKG5ld1N0YXJ0cyksXG4gICAgICAgIGVuZHM6IG5ldyBEYXRlKG5ld0VuZHMpXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIERyYWcjZHJhZ0VuZCBldmVudCBoYW5kbGVyXG4gKiBAZW1pdHMgVGltZUNyZWF0aW9uI3RpbWVfY3JlYXRpb25fZHJhZ2VuZFxuICogQHBhcmFtIHtvYmplY3R9IGRyYWdFbmRFdmVudERhdGEgLSBldmVudCBkYXRhIGZyb20gRHJhZyNkcmFnZW5kXG4gKi9cblRpbWVDcmVhdGlvbi5wcm90b3R5cGUuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uKGRyYWdFbmRFdmVudERhdGEpIHtcbiAgICB2YXIgZHJhZ1N0YXJ0ID0gdGhpcy5fZHJhZ1N0YXJ0O1xuXG4gICAgdGhpcy5kcmFnSGFuZGxlci5vZmYoe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIGZ1bmN0aW9uIHJldmlzZUZ1bmMoZXZlbnREYXRhKSB7XG4gICAgICAgIHZhciByYW5nZSA9IFtcbiAgICAgICAgICAgIGRyYWdTdGFydC5uZWFyZXN0R3JpZFRpbWVZLFxuICAgICAgICAgICAgZXZlbnREYXRhLm5lYXJlc3RHcmlkVGltZVlcbiAgICAgICAgXS5zb3J0KGFycmF5LmNvbXBhcmUubnVtLmFzYyk7XG4gICAgICAgIHJhbmdlWzFdICs9IGRhdGV0aW1lLm1pbGxpc2Vjb25kc0Zyb20oJ2hvdXInLCAwLjUpO1xuXG4gICAgICAgIGV2ZW50RGF0YS5jcmVhdGVSYW5nZSA9IHJhbmdlO1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZUV2ZW50KGV2ZW50RGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFRpbWVDcmVhdGlvbiN0aW1lX2NyZWF0aW9uX2RyYWdlbmRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7VGltZX0gcmVsYXRlZFZpZXcgLSB0aW1lIHZpZXcgaW5zdGFuY2UgcmVsYXRlZCB3aXRoIG1vdXNlIHBvc2l0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7TW91c2VFdmVudH0gb3JpZ2luRXZlbnQgLSBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1vdXNlWSAtIG1vdXNlIFkgcHggbW91c2UgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGdyaWRZIC0gZ3JpZCBZIGluZGV4IHZhbHVlIHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVZIC0gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIG1vdXNlWSBwb2ludHMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkWSAtIG5lYXJlc3QgZ3JpZCBpbmRleCByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFRpbWVZIC0gdGltZSB2YWx1ZSBmb3IgbmVhcmVzdEdyaWRZLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IGNyZWF0ZVJhbmdlIC0gbWlsbGlzZWNvbmRzIHJhbmdlIGJldHdlZW4gZHJhZyBzdGFydCBhbmQgZW5kIHRvIGNyZWF0ZS5cbiAgICAgKi9cbiAgICB0aGlzLl9vbkRyYWcoZHJhZ0VuZEV2ZW50RGF0YSwgJ3RpbWVfY3JlYXRpb25fZHJhZ2VuZCcsIHV0aWwuYmluZChyZXZpc2VGdW5jLCB0aGlzKSk7XG5cbiAgICB0aGlzLl9kcmFnU3RhcnQgPSB0aGlzLl9nZXRFdmVudERhdGFGdW5jID0gbnVsbDtcbn07XG5cbi8qKlxuICogRHJhZyNjbGljayBldmVudCBoYW5kbGVyXG4gKiBAZW1pdHMgVGltZUNyZWF0aW9uI3RpbWVfY3JlYXRpb25fY2xpY2tcbiAqIEBwYXJhbSB7b2JqZWN0fSBjbGlja0V2ZW50RGF0YSAtIGV2ZW50IGRhdGEgZnJvbSBEcmFnI2NsaWNrLlxuICovXG5UaW1lQ3JlYXRpb24ucHJvdG90eXBlLl9vbkNsaWNrID0gZnVuY3Rpb24oY2xpY2tFdmVudERhdGEpIHtcbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9mZih7XG4gICAgICAgIGRyYWc6IHRoaXMuX29uRHJhZyxcbiAgICAgICAgZHJhZ0VuZDogdGhpcy5fb25EcmFnRW5kLFxuICAgICAgICBjbGljazogdGhpcy5fb25DbGlja1xuICAgIH0sIHRoaXMpO1xuXG4gICAgZnVuY3Rpb24gcmV2aXNlRnVuYyhldmVudERhdGEpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlRXZlbnQoZXZlbnREYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgVGltZUNyZWF0aW9uI3RpbWVfY3JlYXRpb25fY2xpY2tcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7VGltZX0gcmVsYXRlZFZpZXcgLSB0aW1lIHZpZXcgaW5zdGFuY2UgcmVsYXRlZCB3aXRoIG1vdXNlIHBvc2l0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7TW91c2VFdmVudH0gb3JpZ2luRXZlbnQgLSBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1vdXNlWSAtIG1vdXNlIFkgcHggbW91c2UgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGdyaWRZIC0gZ3JpZCBZIGluZGV4IHZhbHVlIHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVZIC0gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIG1vdXNlWSBwb2ludHMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkWSAtIG5lYXJlc3QgZ3JpZCBpbmRleCByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFRpbWVZIC0gdGltZSB2YWx1ZSBmb3IgbmVhcmVzdEdyaWRZLlxuICAgICAqL1xuICAgIHRoaXMuX29uRHJhZyhjbGlja0V2ZW50RGF0YSwgJ3RpbWVfY3JlYXRpb25fY2xpY2snLCB1dGlsLmJpbmQocmV2aXNlRnVuYywgdGhpcykpO1xuXG4gICAgdGhpcy5fZHJhZ1N0YXJ0ID0gdGhpcy5fZ2V0RXZlbnREYXRhRnVuYyA9IG51bGw7XG59O1xuXG50aW1lQ29yZS5taXhpbihUaW1lQ3JlYXRpb24pO1xudXRpbC5DdXN0b21FdmVudHMubWl4aW4oVGltZUNyZWF0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lQ3JlYXRpb247XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBNb2R1bGUgZm9yIFRpbWUuQ3JlYXRpb24gZWZmZWN0IHdoaWxlIGRyYWdnaW5nLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciByZXFBbmltRnJhbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vcmVxQW5pbUZyYW1lJyk7XG5cbnZhciByYXRpbyA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9jb21tb24nKS5yYXRpbztcblxuLyoqXG4gKiBDbGFzcyBmb3IgVGltZS5DcmVhdGlvbiBkcmFnZ2luZyBlZmZlY3QuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VGltZUNyZWF0aW9ufSB0aW1lQ3JlYXRpb24gLSBpbnN0YW5jZSBvZiBUaW1lQ3JlYXRpb24uXG4gKi9cbmZ1bmN0aW9uIFRpbWVDcmVhdGlvbkd1aWRlKHRpbWVDcmVhdGlvbikge1xuICAgIC8qKlxuICAgICAqIEd1aWRlIGVsZW1lbnQgZm9yIGNyZWF0aW9uIGVmZmVjdC5cbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5ndWlkZUVsZW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VGltZUNyZWF0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudGltZUNyZWF0aW9uID0gdGltZUNyZWF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9zdGFydEdyaWRZID0gMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLl9nZXRUb3BGdW5jID0gbnVsbDtcblxuICAgIGRvbXV0aWwuYWRkQ2xhc3ModGhpcy5ndWlkZUVsZW1lbnQsICdzY2hlZHVsZS12aWV3LXRpbWUtY3JlYXRpb24tZ3VpZGUnKTtcblxuICAgIHRpbWVDcmVhdGlvbi5vbih7XG4gICAgICAgICd0aW1lX2NyZWF0aW9uX2RyYWdzdGFydCc6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuICAgICAgICAndGltZV9jcmVhdGlvbl9kcmFnJzogdGhpcy5fb25EcmFnLFxuICAgICAgICAvLyAndGltZV9jcmVhdGlvbl9kcmFnZW5kJzogdGhpcy5jbGVhckd1aWRlRWxlbWVudCxcbiAgICAgICAgJ3RpbWVfY3JlYXRpb25fY2xpY2snOiB0aGlzLmNsZWFyR3VpZGVFbGVtZW50XG4gICAgfSwgdGhpcyk7XG59XG5cbi8qKlxuICogRGVzdHJveSBtZXRob2QuXG4gKi9cblRpbWVDcmVhdGlvbkd1aWRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhckd1aWRlRWxlbWVudCgpO1xuICAgIHRoaXMudGltZUNyZWF0aW9uLm9mZih0aGlzKTtcbiAgICB0aGlzLmd1aWRlRWxlbWVudCA9IHRoaXMudGltZUNyZWF0aW9uID0gdGhpcy5fc3RhcnRHcmlkWSA9XG4gICAgICAgIHRoaXMuX2dldFRvcEZ1bmMgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhciBndWlkZSBlbGVtZW50LlxuICovXG5UaW1lQ3JlYXRpb25HdWlkZS5wcm90b3R5cGUuY2xlYXJHdWlkZUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ3VpZGVFbGVtZW50ID0gdGhpcy5ndWlkZUVsZW1lbnQ7XG5cbiAgICBkb211dGlsLnJlbW92ZShndWlkZUVsZW1lbnQpO1xuXG4gICAgcmVxQW5pbUZyYW1lLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgIGd1aWRlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBndWlkZUVsZW1lbnQuc3R5bGUudG9wID0gJyc7XG4gICAgICAgIGd1aWRlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnJztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmVmcmVzaCBndWlkZSBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIC0gVGhlIG51bWJlciBvZiBndWlkZSBlbGVtZW50J3Mgc3R5bGUgdG9wLlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBudW1iZXIgb2YgZ3VpZGUgZWxlbWVudCdzIHN0eWxlIGhlaWdodC5cbiAqL1xuVGltZUNyZWF0aW9uR3VpZGUucHJvdG90eXBlLl9yZWZyZXNoR3VpZGVFbGVtZW50ID0gZnVuY3Rpb24odG9wLCBoZWlnaHQpIHtcbiAgICB2YXIgZ3VpZGVFbGVtZW50ID0gdGhpcy5ndWlkZUVsZW1lbnQ7XG5cbiAgICByZXFBbmltRnJhbWUucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgZ3VpZGVFbGVtZW50LnN0eWxlLnRvcCA9IHRvcCArICdweCc7XG4gICAgICAgIGd1aWRlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICBndWlkZUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIERyYWdTdGFydCBldmVudCBoYW5kbGVyXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ1N0YXJ0RXZlbnREYXRhIC0gZHJhZ1N0YXJ0IGV2ZW50IGRhdGEuXG4gKi9cblRpbWVDcmVhdGlvbkd1aWRlLnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbihkcmFnU3RhcnRFdmVudERhdGEpIHtcbiAgICB2YXIgdGltZVZpZXcgPSBkcmFnU3RhcnRFdmVudERhdGEucmVsYXRlZFZpZXcsXG4gICAgICAgIHZpZXdPcHRpb25zID0gdGltZVZpZXcub3B0aW9ucyxcbiAgICAgICAgdmlld0hlaWdodCA9IHRpbWVWaWV3LmdldFZpZXdCb3VuZCgpLmhlaWdodCxcbiAgICAgICAgaG91ckxlbmd0aCA9IHZpZXdPcHRpb25zLmhvdXJFbmQgLSB2aWV3T3B0aW9ucy5ob3VyU3RhcnQsXG4gICAgICAgIGdldFRvcEZ1bmM7XG5cbiAgICBnZXRUb3BGdW5jID0gdGhpcy5fZ2V0VG9wRnVuYyA9IHV0aWwuYmluZChmdW5jdGlvbihpbmRleFkpIHtcbiAgICAgICAgLy8gbWVtb1xuICAgICAgICBpZiAoZ2V0VG9wRnVuY1tpbmRleFldKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VG9wRnVuY1tpbmRleFldO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0VG9wRnVuY1tpbmRleFldID0gcmF0aW8oaG91ckxlbmd0aCwgdmlld0hlaWdodCwgaW5kZXhZKTtcblxuICAgICAgICByZXR1cm4gZ2V0VG9wRnVuY1tpbmRleFldO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fc3RhcnRHcmlkWSA9IGdldFRvcEZ1bmMoZHJhZ1N0YXJ0RXZlbnREYXRhLm5lYXJlc3RHcmlkWSk7XG5cbiAgICB0aGlzLl9yZWZyZXNoR3VpZGVFbGVtZW50KFxuICAgICAgICB0aGlzLl9zdGFydEdyaWRZLFxuICAgICAgICBnZXRUb3BGdW5jKDAuNSlcbiAgICApO1xuXG4gICAgdGltZVZpZXcuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZ3VpZGVFbGVtZW50KTtcbn07XG5cbi8qKlxuICogRHJhZyBldmVudCBoYW5kbGVyXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ0V2ZW50RGF0YSAtIGRyYWcgZXZlbnQgZGF0YS5cbiAqL1xuVGltZUNyZWF0aW9uR3VpZGUucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbihkcmFnRXZlbnREYXRhKSB7XG4gICAgdmFyIGdldFRvcEZ1bmMgPSB0aGlzLl9nZXRUb3BGdW5jLFxuICAgICAgICBzdGFydEdyaWRZID0gdGhpcy5fc3RhcnRHcmlkWSxcbiAgICAgICAgZW5kR3JpZFk7XG5cbiAgICBpZiAoIWdldFRvcEZ1bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGRyYXdpbmcgZ3VpZGUgZnJvbSBzdGFydCBwb2ludCB0byBhdCBsZWFzdCAzMG1pbiBwb2ludHMuXG4gICAgZW5kR3JpZFkgPSBnZXRUb3BGdW5jKGRyYWdFdmVudERhdGEubmVhcmVzdEdyaWRZKSArIGdldFRvcEZ1bmMoMC41KTtcblxuICAgIGlmIChlbmRHcmlkWSA+IHN0YXJ0R3JpZFkpIHtcbiAgICAgICAgdGhpcy5fcmVmcmVzaEd1aWRlRWxlbWVudChzdGFydEdyaWRZLCBlbmRHcmlkWSAtIHN0YXJ0R3JpZFkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcmVmcmVzaEd1aWRlRWxlbWVudChcbiAgICAgICAgZW5kR3JpZFkgLSBnZXRUb3BGdW5jKDAuNSksXG4gICAgICAgIChzdGFydEdyaWRZICsgZ2V0VG9wRnVuYygxKSkgLSBlbmRHcmlkWVxuICAgICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVDcmVhdGlvbkd1aWRlO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgSGFuZGxpbmcgbW92ZSBldmVudHMgZnJvbSBkcmFnIGhhbmRsZXIgYW5kIHRpbWUgZ3JpZCB2aWV3XG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgdGltZUNvcmUgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBUaW1lTW92ZUd1aWRlID0gcmVxdWlyZSgnLi9tb3ZlR3VpZGUnKTtcblxudmFyIHBhcnNlVGltZVZpZXdJRFJ4ID0gL15zY2hlZHVsZS12aWV3LXRpbWUtZGF0ZVtcXHNdc2NoZWR1bGUtdmlldy0oXFxkKykvO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge0hhbmRsZXJ9XG4gKiBAbWl4ZXMgdGltZUNvcmVcbiAqIEBtaXhlcyB1dGlsLkN1c3RvbUV2ZW50c1xuICogQHBhcmFtIHtEcmFnfSBbZHJhZ0hhbmRsZXJdIC0gRHJhZyBoYW5kbGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHtUaW1lR3JpZH0gW3RpbWVHcmlkVmlld10gLSBUaW1lR3JpZCB2aWV3IGluc3RhbmNlLlxuICogQHBhcmFtIHtCYXNlfSBbYmFzZUNvbnRyb2xsZXJdIC0gQmFzZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBUaW1lTW92ZShkcmFnSGFuZGxlciwgdGltZUdyaWRWaWV3LCBiYXNlQ29udHJvbGxlcikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEcmFnfVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1RpbWVHcmlkfVxuICAgICAqL1xuICAgIHRoaXMudGltZUdyaWRWaWV3ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCYXNlfVxuICAgICAqL1xuICAgIHRoaXMuYmFzZUNvbnRyb2xsZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuX2dldEV2ZW50RGF0YUZ1bmMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLl9kcmFnU3RhcnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1RpbWVNb3ZlR3VpZGV9XG4gICAgICovXG4gICAgdGhpcy5fZ3VpZGUgPSBuZXcgVGltZU1vdmVHdWlkZSh0aGlzKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEZXN0cm95IG1ldGhvZC5cbiAqL1xuVGltZU1vdmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9ndWlkZS5kZXN0cm95KCk7XG4gICAgdGhpcy5kcmFnSGFuZGxlci5vZmYodGhpcyk7XG4gICAgdGhpcy5kcmFnSGFuZGxlciA9IHRoaXMudGltZUdyaWRWaWV3ID0gdGhpcy5iYXNlQ29udHJvbGxlciA9XG4gICAgICAgIHRoaXMuX2dldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9kcmFnU3RhcnQgPSB0aGlzLl9ndWlkZSA9IG51bGw7XG59O1xuXG4vKipcbiAqIENvbm5lY3QgaGFuZGxlciwgdmlldywgY29udHJvbGxlcnMgZm9yIGV2ZW50IGNyZWF0aW9ucy5cbiAqIEBwYXJhbSB7RHJhZ30gW2RyYWdIYW5kbGVyXSAtIERyYWcgaGFuZGxlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7VGltZUdyaWR9IFt0aW1lR3JpZFZpZXddIC0gVGltZUdyaWQgdmlldyBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7QmFzZX0gW2Jhc2VDb250cm9sbGVyXSAtIEJhc2UgY29udHJvbGxlciBpbnN0YW5jZS5cbiAqL1xuVGltZU1vdmUucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihkcmFnSGFuZGxlciwgdGltZUdyaWRWaWV3LCBiYXNlQ29udHJvbGxlcikge1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBkcmFnSGFuZGxlcjtcbiAgICB0aGlzLnRpbWVHcmlkVmlldyA9IHRpbWVHcmlkVmlldztcbiAgICB0aGlzLmJhc2VDb250cm9sbGVyID0gYmFzZUNvbnRyb2xsZXI7XG5cbiAgICBkcmFnSGFuZGxlci5vbih7XG4gICAgICAgIGRyYWdTdGFydDogdGhpcy5fb25EcmFnU3RhcnRcbiAgICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdGFyZ2V0IGVsZW1lbnQgaXMgZXhwZWN0ZWQgY29uZGl0aW9uIGZvciBhY3RpdmF0ZSB0aGlzIHBsdWdpbnMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBUaGUgZWxlbWVudCB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW58b2JqZWN0fSAtIHJldHVybiBvYmplY3Qgd2hlbiBzYXRpYXRlIGNvbmRpdGlvbi5cbiAqL1xuVGltZU1vdmUucHJvdG90eXBlLmNoZWNrRXhwZWN0Q29uZGl0aW9uID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgaWYgKGRvbXV0aWwuZ2V0Q2xhc3ModGFyZ2V0KSAhPT0gJ3NjaGVkdWxlLXZpZXctdGltZS1ldmVudCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9nZXRUaW1lVmlldyh0YXJnZXQpO1xufTtcblxuLyoqXG4gKiBHZXQgVGltZSB2aWV3IGNvbnRhaW5lciBmcm9tIHN1cHBsaWVkIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBlbGVtZW50IHRvIGZpbmQgdGltZSB2aWV3IGNvbnRhaW5lci5cbiAqIEByZXR1cm5zIHtvYmplY3R8Ym9vbGVhbn0gLSByZXR1cm4gdGltZSB2aWV3IGluc3RhbmNlIHdoZW4gZmluZGVkLlxuICovXG5UaW1lTW92ZS5wcm90b3R5cGUuX2dldFRpbWVWaWV3ID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvbXV0aWwuY2xvc2VzdCh0YXJnZXQsICcuc2NoZWR1bGUtdmlldy10aW1lLWRhdGUnKSxcbiAgICAgICAgbWF0Y2hlcztcblxuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBtYXRjaGVzID0gZG9tdXRpbC5nZXRDbGFzcyhjb250YWluZXIpLm1hdGNoKHBhcnNlVGltZVZpZXdJRFJ4KTtcblxuICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlsLnBpY2sodGhpcy50aW1lR3JpZFZpZXcuY2hpbGRzLml0ZW1zLCArbWF0Y2hlc1sxXSk7XG59O1xuXG4vKipcbiAqIEBlbWl0cyBUaW1lTW92ZSN0aW1lX21vdmVfZHJhZ3N0YXJ0XG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ1N0YXJ0RXZlbnREYXRhIC0gRHJhZyNkcmFnU3RhcnQgZXZlbnQgZGF0YS5cbiAqL1xuVGltZU1vdmUucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGRyYWdTdGFydEV2ZW50RGF0YSkge1xuICAgIHZhciB0YXJnZXQgPSBkcmFnU3RhcnRFdmVudERhdGEudGFyZ2V0LFxuICAgICAgICB0aW1lVmlldyA9IHRoaXMuY2hlY2tFeHBlY3RDb25kaXRpb24odGFyZ2V0KSxcbiAgICAgICAgYmxvY2tFbGVtZW50ID0gZG9tdXRpbC5jbG9zZXN0KHRhcmdldCwgJy5zY2hlZHVsZS12aWV3LXRpbWUtZGF0ZS1ldmVudC1ibG9jaycpLFxuICAgICAgICBnZXRFdmVudERhdGFGdW5jLFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICBpZiAoIXRpbWVWaWV3IHx8ICFibG9ja0VsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9nZXRFdmVudERhdGFGdW5jID0gdGhpcy5fcmV0cml2ZUV2ZW50RGF0YSh0aW1lVmlldyk7XG4gICAgZXZlbnREYXRhID0gdGhpcy5fZHJhZ1N0YXJ0ID0gZ2V0RXZlbnREYXRhRnVuYyhcbiAgICAgICAgZHJhZ1N0YXJ0RXZlbnREYXRhLm9yaWdpbkV2ZW50LCB7XG4gICAgICAgICAgICB0YXJnZXRNb2RlbElEOiBkb211dGlsLmdldERhdGEoYmxvY2tFbGVtZW50LCAnaWQnKVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIHRoaXMuZHJhZ0hhbmRsZXIub24oe1xuICAgICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICB9LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBUaW1lTW92ZSN0aW1lX21vdmVfZHJhZ3N0YXJ0XG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBjdXJyZW50IHRhcmdldCBpbiBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtUaW1lfSByZWxhdGVkVmlldyAtIHRpbWUgdmlldyBpbnN0YW5jZSByZWxhdGVkIHdpdGggbW91c2UgcG9zaXRpb24uXG4gICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBvcmlnaW5FdmVudCAtIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW91c2VZIC0gbW91c2UgWSBweCBtb3VzZSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZ3JpZFkgLSBncmlkIFkgaW5kZXggdmFsdWUgcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZVkgLSBtaWxsaXNlY29uZHMgdmFsdWUgb2YgbW91c2VZIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRZIC0gbmVhcmVzdCBncmlkIGluZGV4IHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkVGltZVkgLSB0aW1lIHZhbHVlIGZvciBuZWFyZXN0R3JpZFkuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHRhcmdldE1vZGVsSUQgLSBUaGUgbW9kZWwgdW5pcXVlIGlkIGVtaXR0ZWQgbW92ZSBldmVudC5cbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ3RpbWVfbW92ZV9kcmFnc3RhcnQnLCBldmVudERhdGEpO1xufTtcblxuLyoqXG4gKiBAZW1pdHMgVGltZU1vdmUjdGltZV9tb3ZlX2RyYWdcbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gZHJhZ0V2ZW50RGF0YSAtIG1vdXNlbW92ZSBldmVudCBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3ZlcnJpZGVFdmVudE5hbWVdIC0gbmFtZSBvZiBlbWl0dGluZyBldmVudCB0byBvdmVycmlkZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtyZXZpc2VdIC0gc3VwcGx5IGZ1bmN0aW9uIGZvciByZXZpc2UgZXZlbnQgZGF0YSBiZWZvcmUgZW1pdC5cbiAqL1xuVGltZU1vdmUucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbihkcmFnRXZlbnREYXRhLCBvdmVycmlkZUV2ZW50TmFtZSwgcmV2aXNlKSB7XG4gICAgdmFyIGdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9nZXRFdmVudERhdGFGdW5jLFxuICAgICAgICB0aW1lVmlldyA9IHRoaXMuX2dldFRpbWVWaWV3KGRyYWdFdmVudERhdGEudGFyZ2V0KSxcbiAgICAgICAgZHJhZ1N0YXJ0ID0gdGhpcy5fZHJhZ1N0YXJ0LFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICBpZiAoIXRpbWVWaWV3IHx8ICFnZXRFdmVudERhdGFGdW5jIHx8ICFkcmFnU3RhcnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50RGF0YSA9IGdldEV2ZW50RGF0YUZ1bmMoZHJhZ0V2ZW50RGF0YS5vcmlnaW5FdmVudCwge1xuICAgICAgICBjdXJyZW50VmlldzogdGltZVZpZXcsXG4gICAgICAgIHRhcmdldE1vZGVsSUQ6IGRyYWdTdGFydC50YXJnZXRNb2RlbElEXG4gICAgfSk7XG5cbiAgICBpZiAocmV2aXNlKSB7XG4gICAgICAgIHJldmlzZShldmVudERhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBldmVudCBUaW1lTW92ZSN0aW1lX21vdmVfZHJhZ1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gY3VycmVudCB0YXJnZXQgaW4gbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqIEBwcm9wZXJ0eSB7VGltZX0gcmVsYXRlZFZpZXcgLSB0aW1lIHZpZXcgaW5zdGFuY2UgcmVsYXRlZCB3aXRoIGRyYWcgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBvcmlnaW5FdmVudCAtIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW91c2VZIC0gbW91c2UgWSBweCBtb3VzZSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZ3JpZFkgLSBncmlkIFkgaW5kZXggdmFsdWUgcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZVkgLSBtaWxsaXNlY29uZHMgdmFsdWUgb2YgbW91c2VZIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRZIC0gbmVhcmVzdCBncmlkIGluZGV4IHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkVGltZVkgLSB0aW1lIHZhbHVlIGZvciBuZWFyZXN0R3JpZFkuXG4gICAgICogQHByb3BlcnR5IHtUaW1lfSBjdXJyZW50VmlldyAtIHRpbWUgdmlldyBpbnN0YW5jZSByZWxhdGVkIHdpdGggY3VycmVudCBtb3VzZSBwb3NpdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdGFyZ2V0TW9kZWxJRCAtIFRoZSBtb2RlbCB1bmlxdWUgaWQgZW1pdHRlZCBtb3ZlIGV2ZW50LlxuICAgICAqL1xuICAgIHRoaXMuZmlyZShvdmVycmlkZUV2ZW50TmFtZSB8fCAndGltZV9tb3ZlX2RyYWcnLCBldmVudERhdGEpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgbW9kZWwgaW5zdGFuY2UgYnkgZHJhZ2VuZCBldmVudCByZXN1bHRzLlxuICogQHBhcmFtIHtvYmplY3R9IGV2ZW50RGF0YSAtIGV2ZW50IGRhdGEgZnJvbSBUaW1lTW92ZSN0aW1lX21vdmVfZHJhZ2VuZFxuICovXG5UaW1lTW92ZS5wcm90b3R5cGUuX3VwZGF0ZUV2ZW50ID0gZnVuY3Rpb24oZXZlbnREYXRhKSB7XG4gICAgdmFyIGN0cmwgPSB0aGlzLmJhc2VDb250cm9sbGVyLFxuICAgICAgICBtb2RlbElEID0gZXZlbnREYXRhLnRhcmdldE1vZGVsSUQsXG4gICAgICAgIHJhbmdlID0gZXZlbnREYXRhLm5lYXJlc3RSYW5nZSxcbiAgICAgICAgdGltZURpZmYgPSByYW5nZVsxXSAtIHJhbmdlWzBdLFxuICAgICAgICBkYXRlRGlmZiA9IDAsXG4gICAgICAgIG1vZGVsID0gY3RybC5ldmVudHMuaXRlbXNbbW9kZWxJRF0sXG4gICAgICAgIHJlbGF0ZWRWaWV3ID0gZXZlbnREYXRhLnJlbGF0ZWRWaWV3LFxuICAgICAgICBjdXJyZW50VmlldyA9IGV2ZW50RGF0YS5jdXJyZW50VmlldyxcbiAgICAgICAgZXZlbnREdXJhdGlvbixcbiAgICAgICAgZGF0ZVN0YXJ0LFxuICAgICAgICBkYXRlRW5kLFxuICAgICAgICBuZXdTdGFydHMsXG4gICAgICAgIG5ld0VuZHMsXG4gICAgICAgIGJhc2VEYXRlO1xuXG4gICAgaWYgKCFtb2RlbCB8fCAhY3VycmVudFZpZXcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRpbWVEaWZmIC09IGRhdGV0aW1lLm1pbGxpc2Vjb25kc0Zyb20oJ21pbnV0ZXMnLCAzMCk7XG4gICAgYmFzZURhdGUgPSBuZXcgRGF0ZShyZWxhdGVkVmlldy5nZXREYXRlKCkpO1xuICAgIGRhdGVTdGFydCA9IGRhdGV0aW1lLnN0YXJ0KGJhc2VEYXRlKTtcbiAgICBkYXRlRW5kID0gZGF0ZXRpbWUuZW5kKGJhc2VEYXRlKTtcbiAgICBuZXdTdGFydHMgPSBuZXcgRGF0ZShtb2RlbC5nZXRTdGFydHMoKS5nZXRUaW1lKCkgKyB0aW1lRGlmZik7XG4gICAgbmV3RW5kcyA9IG5ldyBEYXRlKG1vZGVsLmdldEVuZHMoKS5nZXRUaW1lKCkgKyB0aW1lRGlmZik7XG4gICAgZXZlbnREdXJhdGlvbiA9IG1vZGVsLmR1cmF0aW9uKCk7XG5cbiAgICBpZiAoY3VycmVudFZpZXcpIHtcbiAgICAgICAgZGF0ZURpZmYgPSBjdXJyZW50Vmlldy5nZXREYXRlKCkgLSByZWxhdGVkVmlldy5nZXREYXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKG5ld1N0YXJ0cyA8IGRhdGVTdGFydCkge1xuICAgICAgICBuZXdTdGFydHMgPSBuZXcgRGF0ZShkYXRlU3RhcnQuZ2V0VGltZSgpKTtcbiAgICAgICAgbmV3RW5kcyA9IG5ldyBEYXRlKG5ld1N0YXJ0cy5nZXRUaW1lKCkgKyBldmVudER1cmF0aW9uLmdldFRpbWUoKSk7XG4gICAgfSBlbHNlIGlmIChuZXdFbmRzID4gZGF0ZUVuZCkge1xuICAgICAgICBuZXdFbmRzID0gbmV3IERhdGUoZGF0ZUVuZC5nZXRUaW1lKCkpO1xuICAgICAgICBuZXdTdGFydHMgPSBuZXcgRGF0ZShuZXdFbmRzLmdldFRpbWUoKSAtIGV2ZW50RHVyYXRpb24uZ2V0VGltZSgpKTtcbiAgICB9XG5cbiAgICBuZXdTdGFydHMgPSBuZXcgRGF0ZShuZXdTdGFydHMuZ2V0VGltZSgpICsgZGF0ZURpZmYpO1xuICAgIG5ld0VuZHMgPSBuZXcgRGF0ZShuZXdFbmRzLmdldFRpbWUoKSArIGRhdGVEaWZmKTtcblxuICAgIGN0cmwudXBkYXRlRXZlbnQobW9kZWxJRCwge1xuICAgICAgICBzdGFydHM6IG5ld1N0YXJ0cyxcbiAgICAgICAgZW5kczogbmV3RW5kc1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAZW1pdHMgVGltZU1vdmUjdGltZV9tb3ZlX2RyYWdlbmRcbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gZHJhZ0VuZEV2ZW50RGF0YSAtIG1vdXNldXAgbW91c2UgZXZlbnQgb2JqZWN0LlxuICovXG5UaW1lTW92ZS5wcm90b3R5cGUuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uKGRyYWdFbmRFdmVudERhdGEpIHtcbiAgICB2YXIgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX2dldEV2ZW50RGF0YUZ1bmMsXG4gICAgICAgIGN1cnJlbnRWaWV3ID0gdGhpcy5fZ2V0VGltZVZpZXcoZHJhZ0VuZEV2ZW50RGF0YS50YXJnZXQpLFxuICAgICAgICBkcmFnU3RhcnQgPSB0aGlzLl9kcmFnU3RhcnQsXG4gICAgICAgIGV2ZW50RGF0YTtcblxuICAgIHRoaXMuZHJhZ0hhbmRsZXIub2ZmKHtcbiAgICAgICAgZHJhZzogdGhpcy5fb25EcmFnLFxuICAgICAgICBkcmFnRW5kOiB0aGlzLl9vbkRyYWdFbmQsXG4gICAgICAgIGNsaWNrOiB0aGlzLl9vbkNsaWNrXG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoIWdldEV2ZW50RGF0YUZ1bmMgfHwgIWRyYWdTdGFydCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnREYXRhID0gZ2V0RXZlbnREYXRhRnVuYyhkcmFnRW5kRXZlbnREYXRhLm9yaWdpbkV2ZW50LCB7XG4gICAgICAgIGN1cnJlbnRWaWV3OiBjdXJyZW50VmlldyxcbiAgICAgICAgdGFyZ2V0TW9kZWxJRDogZHJhZ1N0YXJ0LnRhcmdldE1vZGVsSURcbiAgICB9KTtcblxuICAgIGV2ZW50RGF0YS5yYW5nZSA9IFtcbiAgICAgICAgZHJhZ1N0YXJ0LnRpbWVZLFxuICAgICAgICBldmVudERhdGEudGltZVkgKyBkYXRldGltZS5taWxsaXNlY29uZHNGcm9tKCdob3VyJywgMC41KVxuICAgIF07XG5cbiAgICBldmVudERhdGEubmVhcmVzdFJhbmdlID0gW1xuICAgICAgICBkcmFnU3RhcnQubmVhcmVzdEdyaWRUaW1lWSxcbiAgICAgICAgZXZlbnREYXRhLm5lYXJlc3RHcmlkVGltZVkgKyBkYXRldGltZS5taWxsaXNlY29uZHNGcm9tKCdob3VyJywgMC41KVxuICAgIF07XG5cbiAgICB0aGlzLl91cGRhdGVFdmVudChldmVudERhdGEpO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFRpbWVNb3ZlI3RpbWVfbW92ZV9kcmFnZW5kXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBjdXJyZW50IHRhcmdldCBpbiBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtUaW1lfSByZWxhdGVkVmlldyAtIHRpbWUgdmlldyBpbnN0YW5jZSByZWxhdGVkIHdpdGggZHJhZyBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge1RpbWV9IGN1cnJlbnRWaWV3IC0gdGltZSB2aWV3IGluc3RhbmNlIHJlbGF0ZWQgd2l0aCBjdXJyZW50IG1vdXNlIHBvc2l0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7TW91c2VFdmVudH0gb3JpZ2luRXZlbnQgLSBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1vdXNlWSAtIG1vdXNlIFkgcHggbW91c2UgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGdyaWRZIC0gZ3JpZCBZIGluZGV4IHZhbHVlIHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVZIC0gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIG1vdXNlWSBwb2ludHMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkWSAtIG5lYXJlc3QgZ3JpZCBpbmRleCByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFRpbWVZIC0gdGltZSB2YWx1ZSBmb3IgbmVhcmVzdEdyaWRZLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0YXJnZXRNb2RlbElEIC0gVGhlIG1vZGVsIHVuaXF1ZSBpZCBlbWl0dGVkIG1vdmUgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJbXX0gcmFuZ2UgLSBtaWxsaXNlY29uZHMgcmFuZ2UgYmV0d2VlbiBkcmFnIHN0YXJ0IGFuZCBlbmQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJbXX0gbmVhcmVzdFJhbmdlIC0gbWlsbGlzZWNvbmRzIHJhbmdlIHJlbGF0ZWQgd2l0aCBuZWFyZXN0R3JpZFkgYmV0d2VlbiBzdGFydCBhbmQgZW5kLlxuICAgICAqL1xuICAgIHRoaXMuZmlyZSgndGltZV9tb3ZlX2RyYWdlbmQnLCBldmVudERhdGEpO1xufTtcblxuLyoqXG4gKiBAZW1pdHMgVGltZU1vdmUjdGltZV9tb3ZlX2NsaWNrXG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IGNsaWNrRXZlbnREYXRhIC0gY2xpY2sgbW91c2UgZXZlbnQgb2JqZWN0LlxuICovXG5UaW1lTW92ZS5wcm90b3R5cGUuX29uQ2xpY2sgPSBmdW5jdGlvbihjbGlja0V2ZW50RGF0YSkge1xuICAgIHZhciBnZXRFdmVudERhdGFGdW5jID0gdGhpcy5fZ2V0RXZlbnREYXRhRnVuYyxcbiAgICAgICAgZHJhZ1N0YXJ0ID0gdGhpcy5fZHJhZ1N0YXJ0LFxuICAgICAgICBldmVudERhdGE7XG5cbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9mZih7XG4gICAgICAgIGRyYWc6IHRoaXMuX29uRHJhZyxcbiAgICAgICAgZHJhZ0VuZDogdGhpcy5fb25EcmFnRW5kLFxuICAgICAgICBjbGljazogdGhpcy5fb25DbGlja1xuICAgIH0sIHRoaXMpO1xuXG4gICAgaWYgKCFnZXRFdmVudERhdGFGdW5jIHx8ICFkcmFnU3RhcnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50RGF0YSA9IGdldEV2ZW50RGF0YUZ1bmMoY2xpY2tFdmVudERhdGEub3JpZ2luRXZlbnQsIHtcbiAgICAgICAgdGFyZ2V0TW9kZWxJRDogZHJhZ1N0YXJ0LnRhcmdldE1vZGVsSURcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBUaW1lTW92ZSN0aW1lX21vdmVfY2xpY2tcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIGN1cnJlbnQgdGFyZ2V0IGluIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge1RpbWV9IHJlbGF0ZWRWaWV3IC0gdGltZSB2aWV3IGluc3RhbmNlIHJlbGF0ZWQgd2l0aCBkcmFnIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7TW91c2VFdmVudH0gb3JpZ2luRXZlbnQgLSBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1vdXNlWSAtIG1vdXNlIFkgcHggbW91c2UgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGdyaWRZIC0gZ3JpZCBZIGluZGV4IHZhbHVlIHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVZIC0gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIG1vdXNlWSBwb2ludHMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkWSAtIG5lYXJlc3QgZ3JpZCBpbmRleCByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFRpbWVZIC0gdGltZSB2YWx1ZSBmb3IgbmVhcmVzdEdyaWRZLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0YXJnZXRNb2RlbElEIC0gVGhlIG1vZGVsIHVuaXF1ZSBpZCBlbWl0dGVkIG1vdmUgZXZlbnQuXG4gICAgICovXG4gICAgdGhpcy5maXJlKCd0aW1lX21vdmVfY2xpY2snLCBldmVudERhdGEpO1xufTtcblxudGltZUNvcmUubWl4aW4oVGltZU1vdmUpO1xudXRpbC5DdXN0b21FdmVudHMubWl4aW4oVGltZU1vdmUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVNb3ZlO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTW9kdWxlIGZvciBUaW1lLk1vdmUgZWZmZWN0IHdoaWxlIGRyYWdnaW5nLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciByZXFBbmltRnJhbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vcmVxQW5pbUZyYW1lJyk7XG5cbnZhciByYXRpbyA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9jb21tb24nKS5yYXRpbztcblxuLyoqXG4gKiBDbGFzcyBmb3IgVGltZS5Nb3ZlIGVmZmVjdC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtUaW1lTW92ZX0gdGltZU1vdmUgLSBUaGUgaW5zdGFuY2Ugb2YgVGltZU1vdmUuXG4gKi9cbmZ1bmN0aW9uIFRpbWVNb3ZlR3VpZGUodGltZU1vdmUpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5ndWlkZUVsZW1lbnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1RpbWVNb3ZlfVxuICAgICAqL1xuICAgIHRoaXMudGltZU1vdmUgPSB0aW1lTW92ZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLl9jb250YWluZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuX2dldFRvcEZ1bmMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9zdGFydEdyaWRZID0gMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fc3RhcnRUb3BQaXhlbCA9IDA7XG5cbiAgICB0aW1lTW92ZS5vbih7XG4gICAgICAgICd0aW1lX21vdmVfZHJhZ3N0YXJ0JzogdGhpcy5fb25EcmFnU3RhcnQsXG4gICAgICAgICd0aW1lX21vdmVfZHJhZyc6IHRoaXMuX29uRHJhZyxcbiAgICAgICAgJ3RpbWVfbW92ZV9kcmFnZW5kJzogdGhpcy5fY2xlYXJHdWlkZUVsZW1lbnQsXG4gICAgICAgICd0aW1lX21vdmVfY2xpY2snOiB0aGlzLl9jbGVhckd1aWRlRWxlbWVudFxuICAgIH0sIHRoaXMpO1xufVxuXG4vKipcbiAqIERlc3Ryb3kgbWV0aG9kXG4gKi9cblRpbWVNb3ZlR3VpZGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jbGVhckd1aWRlRWxlbWVudCgpO1xuICAgIHRoaXMudGltZU1vdmUub2ZmKHRoaXMpO1xuICAgIHRoaXMuZ3VpZGVFbGVtZW50ID0gdGhpcy50aW1lTW92ZSA9IHRoaXMuX2NvbnRhaW5lciA9XG4gICAgICAgIHRoaXMuX2dldFRvcEZ1bmMgPSB0aGlzLl9zdGFydEdyaWRZID0gdGhpcy5fc3RhcnRUb3BQaXhlbCA9IG51bGw7XG59O1xuXG4vKipcbiAqIENsZWFyIGd1aWRlIGVsZW1lbnQuXG4gKi9cblRpbWVNb3ZlR3VpZGUucHJvdG90eXBlLl9jbGVhckd1aWRlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBndWlkZUVsZW1lbnQgPSB0aGlzLmd1aWRlRWxlbWVudDtcblxuICAgIGlmICghdXRpbC5icm93c2VyLm1zaWUpIHtcbiAgICAgICAgZG9tdXRpbC5yZW1vdmVDbGFzcyhnbG9iYWwuZG9jdW1lbnQuYm9keSwgJ3NjaGVkdWxlLXZpZXctZHJhZ2dpbmcnKTtcbiAgICB9XG5cbiAgICBkb211dGlsLnJlbW92ZShndWlkZUVsZW1lbnQpO1xuXG4gICAgdGhpcy5ndWlkZUVsZW1lbnQgPSB0aGlzLl9nZXRUb3BGdW5jID1cbiAgICAgICAgdGhpcy5fc3RhcnRHcmlkWSA9IHRoaXMuX3N0YXJ0VG9wUGl4ZWwgPSBudWxsO1xufTtcblxuLyoqXG4gKiBSZWZyZXNoIGd1aWRlIGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3AgLSBndWlkZSBlbGVtZW50J3Mgc3R5bGUgdG9wLlxuICovXG5UaW1lTW92ZUd1aWRlLnByb3RvdHlwZS5fcmVmcmVzaEd1aWRlRWxlbWVudCA9IGZ1bmN0aW9uKHRvcCkge1xuICAgIHZhciBndWlkZUVsZW1lbnQgPSB0aGlzLmd1aWRlRWxlbWVudDtcblxuICAgIGlmICghZ3VpZGVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXFBbmltRnJhbWUucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgZ3VpZGVFbGVtZW50LnN0eWxlLnRvcCA9IHRvcCArICdweCc7XG4gICAgICAgIGd1aWRlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogVGltZU1vdmUjdGltZV9tb3ZlX2RyYWdzdGFydCBldmVudCBoYW5kbGVyXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ1N0YXJ0RXZlbnREYXRhIC0gZHJhZ3N0YXJ0IGV2ZW50IGRhdGFcbiAqL1xuVGltZU1vdmVHdWlkZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZHJhZ1N0YXJ0RXZlbnREYXRhKSB7XG4gICAgdmFyIGd1aWRlRWxlbWVudCA9IGRvbXV0aWwuY2xvc2VzdChcbiAgICAgICAgZHJhZ1N0YXJ0RXZlbnREYXRhLnRhcmdldCxcbiAgICAgICAgJy5zY2hlZHVsZS12aWV3LXRpbWUtZGF0ZS1ldmVudC1ibG9jaydcbiAgICApO1xuXG4gICAgaWYgKCFndWlkZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGd1aWRlRWxlbWVudCA9IGd1aWRlRWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgZG9tdXRpbC5hZGRDbGFzcyhndWlkZUVsZW1lbnQsICdzY2hlZHVsZS12aWV3LXRpbWUtbW92ZS1ndWlkZScpO1xuXG4gICAgdGhpcy5fc3RhcnRUb3BQaXhlbCA9IHBhcnNlRmxvYXQoZ3VpZGVFbGVtZW50LnN0eWxlLnRvcCk7XG4gICAgdGhpcy5fc3RhcnRHcmlkWSA9IGRyYWdTdGFydEV2ZW50RGF0YS5uZWFyZXN0R3JpZFk7XG4gICAgdGhpcy5ndWlkZUVsZW1lbnQgPSBndWlkZUVsZW1lbnQ7XG4gICAgdGhpcy5fY29udGFpbmVyID0gZHJhZ1N0YXJ0RXZlbnREYXRhLnJlbGF0ZWRWaWV3LmNvbnRhaW5lcjtcbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoZ3VpZGVFbGVtZW50KTtcbn07XG5cbi8qKlxuICogVGltZU1vdmUjdGltZV9tb3ZlX2RyYWcgZXZlbnQgaGFuZGxlclxuICogQHBhcmFtIHtvYmplY3R9IGRyYWdFdmVudERhdGEgLSBkcmFnIGV2ZW50IGRhdGFcbiAqL1xuVGltZU1vdmVHdWlkZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uKGRyYWdFdmVudERhdGEpIHtcbiAgICB2YXIgdGltZVZpZXcgPSBkcmFnRXZlbnREYXRhLmN1cnJlbnRWaWV3LFxuICAgICAgICB2aWV3T3B0aW9ucyA9IHRpbWVWaWV3Lm9wdGlvbnMsXG4gICAgICAgIHZpZXdIZWlnaHQgPSB0aW1lVmlldy5nZXRWaWV3Qm91bmQoKS5oZWlnaHQsXG4gICAgICAgIGd1aWRlSGVpZ2h0ID0gcGFyc2VGbG9hdCh0aGlzLmd1aWRlRWxlbWVudC5zdHlsZS5oZWlnaHQpLFxuICAgICAgICBob3VyTGVuZ3RoID0gdmlld09wdGlvbnMuaG91ckVuZCAtIHZpZXdPcHRpb25zLmhvdXJTdGFydCxcbiAgICAgICAgZ3JpZFlPZmZzZXQgPSBkcmFnRXZlbnREYXRhLm5lYXJlc3RHcmlkWSAtIHRoaXMuX3N0YXJ0R3JpZFksXG4gICAgICAgIC8vIGhvdXJMZW5ndGggOiB2aWV3SGVpZ2h0ID0gZ3JpZFlPZmZzZXQgOiBYO1xuICAgICAgICBncmlkWU9mZnNldFBpeGVsID0gcmF0aW8oaG91ckxlbmd0aCwgdmlld0hlaWdodCwgZ3JpZFlPZmZzZXQpLFxuICAgICAgICBib3R0b21MaW1pdCxcbiAgICAgICAgdG9wO1xuXG4gICAgaWYgKCF1dGlsLmJyb3dzZXIubXNpZSkge1xuICAgICAgICBkb211dGlsLmFkZENsYXNzKGdsb2JhbC5kb2N1bWVudC5ib2R5LCAnc2NoZWR1bGUtdmlldy1kcmFnZ2luZycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb250YWluZXIgIT09IHRpbWVWaWV3LmNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSB0aW1lVmlldy5jb250YWluZXI7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmd1aWRlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgdG9wID0gdGhpcy5fc3RhcnRUb3BQaXhlbCArIGdyaWRZT2Zmc2V0UGl4ZWw7XG4gICAgYm90dG9tTGltaXQgPSB2aWV3SGVpZ2h0IC0gZ3VpZGVIZWlnaHQ7XG5cbiAgICB0b3AgPSBNYXRoLm1heCh0b3AsIDApO1xuICAgIHRvcCA9IE1hdGgubWluKHRvcCwgYm90dG9tTGltaXQpO1xuXG4gICAgdGhpcy5fcmVmcmVzaEd1aWRlRWxlbWVudCh0b3ApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lTW92ZUd1aWRlO1xuXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgSGFuZGxpbmcgcmVzaXplIGV2ZW50cyBmcm9tIGRyYWcgaGFuZGxlciBhbmQgdGltZSBncmlkIHZpZXdcbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgdGltZUNvcmUgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBUaW1lUmVzaXplR3VpZGUgPSByZXF1aXJlKCcuL3Jlc2l6ZUd1aWRlJyk7XG5cbnZhciBwYXJzZVRpbWVWaWV3SURSeCA9IC9ec2NoZWR1bGUtdmlldy10aW1lLWRhdGVbXFxzXXNjaGVkdWxlLXZpZXctKFxcZCspLztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtIYW5kbGVyfVxuICogQG1peGVzIHRpbWVDb3JlXG4gKiBAbWl4ZXMgdXRpbC5DdXN0b21FdmVudHNcbiAqIEBwYXJhbSB7RHJhZ30gW2RyYWdIYW5kbGVyXSAtIERyYWcgaGFuZGxlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7VGltZUdyaWR9IFt0aW1lR3JpZFZpZXddIC0gVGltZUdyaWQgdmlldyBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7QmFzZX0gW2Jhc2VDb250cm9sbGVyXSAtIEJhc2UgY29udHJvbGxlciBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gVGltZVJlc2l6ZShkcmFnSGFuZGxlciwgdGltZUdyaWRWaWV3LCBiYXNlQ29udHJvbGxlcikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEcmFnfVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ0hhbmRsZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1RpbWVHcmlkfVxuICAgICAqL1xuICAgIHRoaXMudGltZUdyaWRWaWV3ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCYXNlfVxuICAgICAqL1xuICAgIHRoaXMuYmFzZUNvbnRyb2xsZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuX2dldEV2ZW50RGF0YUZ1bmMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLl9kcmFnU3RhcnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1RpbWVSZXNpemVHdWlkZX1cbiAgICAgKi9cbiAgICB0aGlzLl9ndWlkZSA9IG5ldyBUaW1lUmVzaXplR3VpZGUodGhpcyk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmNvbm5lY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG59XG5cbi8qKlxuICogRGVzdHJveSBtZXRob2RcbiAqL1xuVGltZVJlc2l6ZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2d1aWRlLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9mZih0aGlzKTtcbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gdGhpcy50aW1lR3JpZFZpZXcgPSB0aGlzLmJhc2VDb250cm9sbGVyID1cbiAgICAgICAgdGhpcy5fZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX2RyYWdTdGFydCA9IHRoaXMuX2d1aWRlID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ29ubmVjdCBoYW5kbGVyLCB2aWV3LCBjb250cm9sbGVycyBmb3IgZXZlbnQgY3JlYXRpb25zLlxuICogQHBhcmFtIHtEcmFnfSBbZHJhZ0hhbmRsZXJdIC0gRHJhZyBoYW5kbGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHtUaW1lR3JpZH0gW3RpbWVHcmlkVmlld10gLSBUaW1lR3JpZCB2aWV3IGluc3RhbmNlLlxuICogQHBhcmFtIHtCYXNlfSBbYmFzZUNvbnRyb2xsZXJdIC0gQmFzZSBjb250cm9sbGVyIGluc3RhbmNlLlxuICovXG5UaW1lUmVzaXplLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oZHJhZ0hhbmRsZXIsIHRpbWVHcmlkVmlldywgYmFzZUNvbnRyb2xsZXIpIHtcbiAgICB0aGlzLmRyYWdIYW5kbGVyID0gZHJhZ0hhbmRsZXI7XG4gICAgdGhpcy50aW1lR3JpZFZpZXcgPSB0aW1lR3JpZFZpZXc7XG4gICAgdGhpcy5iYXNlQ29udHJvbGxlciA9IGJhc2VDb250cm9sbGVyO1xuXG4gICAgZHJhZ0hhbmRsZXIub24oe1xuICAgICAgICBkcmFnU3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0XG4gICAgfSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIGVsZW1lbnQgdG8gY2hlY2sgY29uZGl0aW9uLlxuICogQHJldHVybnMge29iamVjdHxib29sZWFufSAtIHJldHVybiB0aW1lIHZpZXcgaW5zdGFuY2Ugb3IgZmFsc2VcbiAqL1xuVGltZVJlc2l6ZS5wcm90b3R5cGUuY2hlY2tFeHBlY3RDb25kaXRpb24gPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICB2YXIgY29udGFpbmVyLFxuICAgICAgICBtYXRjaGVzO1xuXG4gICAgaWYgKCFkb211dGlsLmhhc0NsYXNzKHRhcmdldCwgJ3NjaGVkdWxlLXZpZXctdGltZS1yZXNpemUtaGFuZGxlJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnRhaW5lciA9IGRvbXV0aWwuY2xvc2VzdCh0YXJnZXQsICcuc2NoZWR1bGUtdmlldy10aW1lLWRhdGUnKTtcblxuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBtYXRjaGVzID0gZG9tdXRpbC5nZXRDbGFzcyhjb250YWluZXIpLm1hdGNoKHBhcnNlVGltZVZpZXdJRFJ4KTtcblxuICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlsLnBpY2sodGhpcy50aW1lR3JpZFZpZXcuY2hpbGRzLml0ZW1zLCArbWF0Y2hlc1sxXSk7XG59O1xuXG4vKipcbiAqIEBlbWl0cyBUaW1lUmVzaXplI3RpbWVfcmVzaXplX2RyYWdzdGFydFxuICogQHBhcmFtIHtvYmplY3R9IGRyYWdTdGFydEV2ZW50RGF0YSAtIGV2ZW50IGRhdGEgb2YgRHJhZyNkcmFnc3RhcnRcbiAqL1xuVGltZVJlc2l6ZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZHJhZ1N0YXJ0RXZlbnREYXRhKSB7XG4gICAgdmFyIHRhcmdldCA9IGRyYWdTdGFydEV2ZW50RGF0YS50YXJnZXQsXG4gICAgICAgIHRpbWVWaWV3ID0gdGhpcy5jaGVja0V4cGVjdENvbmRpdGlvbih0YXJnZXQpLFxuICAgICAgICBibG9ja0VsZW1lbnQgPSBkb211dGlsLmNsb3Nlc3QodGFyZ2V0LCAnLnNjaGVkdWxlLXZpZXctdGltZS1kYXRlLWV2ZW50LWJsb2NrJyksXG4gICAgICAgIGdldEV2ZW50RGF0YUZ1bmMsXG4gICAgICAgIGV2ZW50RGF0YTtcblxuICAgIGlmICghdGltZVZpZXcgfHwgIWJsb2NrRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ2V0RXZlbnREYXRhRnVuYyA9IHRoaXMuX2dldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9yZXRyaXZlRXZlbnREYXRhKHRpbWVWaWV3KTtcbiAgICBldmVudERhdGEgPSB0aGlzLl9kcmFnU3RhcnQgPSBnZXRFdmVudERhdGFGdW5jKFxuICAgICAgICBkcmFnU3RhcnRFdmVudERhdGEub3JpZ2luRXZlbnQsIHtcbiAgICAgICAgICAgIHRhcmdldE1vZGVsSUQ6IGRvbXV0aWwuZ2V0RGF0YShibG9ja0VsZW1lbnQsICdpZCcpXG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy5kcmFnSGFuZGxlci5vbih7XG4gICAgICAgIGRyYWc6IHRoaXMuX29uRHJhZyxcbiAgICAgICAgZHJhZ0VuZDogdGhpcy5fb25EcmFnRW5kLFxuICAgICAgICBjbGljazogdGhpcy5fb25DbGlja1xuICAgIH0sIHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFRpbWVSZXNpemUjdGltZV9yZXNpemVfZHJhZ3N0YXJ0XG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBjdXJyZW50IHRhcmdldCBpbiBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtUaW1lfSByZWxhdGVkVmlldyAtIHRpbWUgdmlldyBpbnN0YW5jZSByZWxhdGVkIHdpdGggbW91c2UgcG9zaXRpb24uXG4gICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBvcmlnaW5FdmVudCAtIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW91c2VZIC0gbW91c2UgWSBweCBtb3VzZSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZ3JpZFkgLSBncmlkIFkgaW5kZXggdmFsdWUgcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZVkgLSBtaWxsaXNlY29uZHMgdmFsdWUgb2YgbW91c2VZIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRZIC0gbmVhcmVzdCBncmlkIGluZGV4IHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkVGltZVkgLSB0aW1lIHZhbHVlIGZvciBuZWFyZXN0R3JpZFkuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHRhcmdldE1vZGVsSUQgLSBUaGUgbW9kZWwgdW5pcXVlIGlkIGVtaXR0ZWQgbW92ZSBldmVudC5cbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ3RpbWVfcmVzaXplX2RyYWdzdGFydCcsIGV2ZW50RGF0YSk7XG59O1xuXG4vKipcbiAqIERyYWcjZHJhZyBldmVudCBoYW5kbGVyXG4gKiBAZW1pdHMgVGltZVJlc2l6ZSN0aW1lX3Jlc2l6ZV9kcmFnXG4gKiBAcGFyYW0ge29iamVjdH0gZHJhZ0V2ZW50RGF0YSAtIGV2ZW50IGRhdGEgb2YgRHJhZyNkcmFnIGN1c3RvbSBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3ZlcnJpZGVFdmVudE5hbWVdIC0gb3ZlcnJpZGUgZW1pdHRlZCBldmVudCBuYW1lIHdoZW4gc3VwcGxpZWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcmV2aXNlXSAtIHN1cHBseSBmdW5jdGlvbiBmb3IgcmV2aXNlIGV2ZW50IGRhdGEgYmVmb3JlIGVtaXQuXG4gKi9cblRpbWVSZXNpemUucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbihkcmFnRXZlbnREYXRhLCBvdmVycmlkZUV2ZW50TmFtZSwgcmV2aXNlKSB7XG4gICAgdmFyIGdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9nZXRFdmVudERhdGFGdW5jLFxuICAgICAgICBzdGFydEV2ZW50RGF0YSA9IHRoaXMuX2RyYWdTdGFydCxcbiAgICAgICAgZXZlbnREYXRhO1xuXG4gICAgaWYgKCFnZXRFdmVudERhdGFGdW5jIHx8ICFzdGFydEV2ZW50RGF0YSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnREYXRhID0gZ2V0RXZlbnREYXRhRnVuYyhkcmFnRXZlbnREYXRhLm9yaWdpbkV2ZW50LCB7XG4gICAgICAgIHRhcmdldE1vZGVsSUQ6IHN0YXJ0RXZlbnREYXRhLnRhcmdldE1vZGVsSURcbiAgICB9KTtcblxuICAgIGlmIChyZXZpc2UpIHtcbiAgICAgICAgcmV2aXNlKGV2ZW50RGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFRpbWVSZXNpemUjdGltZV9yZXNpemVfZHJhZ1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gY3VycmVudCB0YXJnZXQgaW4gbW91c2UgZXZlbnQgb2JqZWN0LlxuICAgICAqIEBwcm9wZXJ0eSB7VGltZX0gcmVsYXRlZFZpZXcgLSB0aW1lIHZpZXcgaW5zdGFuY2UgcmVsYXRlZCB3aXRoIGRyYWcgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHByb3BlcnR5IHtNb3VzZUV2ZW50fSBvcmlnaW5FdmVudCAtIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW91c2VZIC0gbW91c2UgWSBweCBtb3VzZSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZ3JpZFkgLSBncmlkIFkgaW5kZXggdmFsdWUgcmVsYXRlZCB3aXRoIG1vdXNlWSB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZVkgLSBtaWxsaXNlY29uZHMgdmFsdWUgb2YgbW91c2VZIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmVhcmVzdEdyaWRZIC0gbmVhcmVzdCBncmlkIGluZGV4IHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkVGltZVkgLSB0aW1lIHZhbHVlIGZvciBuZWFyZXN0R3JpZFkuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHRhcmdldE1vZGVsSUQgLSBUaGUgbW9kZWwgdW5pcXVlIGlkIGVtaXR0ZWQgbW92ZSBldmVudC5cbiAgICAgKi9cbiAgICB0aGlzLmZpcmUob3ZlcnJpZGVFdmVudE5hbWUgfHwgJ3RpbWVfcmVzaXplX2RyYWcnLCBldmVudERhdGEpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgbW9kZWwgaW5zdGFuY2UgYnkgZHJhZ2VuZCBldmVudCByZXN1bHRzLlxuICogQHBhcmFtIHtvYmplY3R9IGV2ZW50RGF0YSAtIGV2ZW50IGRhdGEgZnJvbSBUaW1lUmVzaXplI3RpbWVfcmVzaXplX2RyYWdlbmRcbiAqL1xuVGltZVJlc2l6ZS5wcm90b3R5cGUuX3VwZGF0ZUV2ZW50ID0gZnVuY3Rpb24oZXZlbnREYXRhKSB7XG4gICAgdmFyIGN0cmwgPSB0aGlzLmJhc2VDb250cm9sbGVyLFxuICAgICAgICBtb2RlbElEID0gZXZlbnREYXRhLnRhcmdldE1vZGVsSUQsXG4gICAgICAgIHJhbmdlID0gZXZlbnREYXRhLm5lYXJlc3RSYW5nZSxcbiAgICAgICAgdGltZURpZmYgPSByYW5nZVsxXSAtIHJhbmdlWzBdLFxuICAgICAgICBtb2RlbCA9IGN0cmwuZXZlbnRzLml0ZW1zW21vZGVsSURdLFxuICAgICAgICByZWxhdGVkVmlldyA9IGV2ZW50RGF0YS5yZWxhdGVkVmlldyxcbiAgICAgICAgZGF0ZUVuZCxcbiAgICAgICAgbmV3RW5kcyxcbiAgICAgICAgYmFzZURhdGU7XG5cbiAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aW1lRGlmZiAtPSBkYXRldGltZS5taWxsaXNlY29uZHNGcm9tKCdtaW51dGVzJywgMzApO1xuXG4gICAgYmFzZURhdGUgPSBuZXcgRGF0ZShyZWxhdGVkVmlldy5nZXREYXRlKCkpO1xuICAgIGRhdGVFbmQgPSBkYXRldGltZS5lbmQoYmFzZURhdGUpO1xuICAgIG5ld0VuZHMgPSBuZXcgRGF0ZShtb2RlbC5nZXRFbmRzKCkuZ2V0VGltZSgpICsgdGltZURpZmYpO1xuXG4gICAgaWYgKG5ld0VuZHMgPiBkYXRlRW5kKSB7XG4gICAgICAgIG5ld0VuZHMgPSBuZXcgRGF0ZShkYXRlRW5kLmdldFRpbWUoKSk7XG4gICAgfVxuXG4gICAgaWYgKG5ld0VuZHMuZ2V0VGltZSgpIC0gbW9kZWwuZ2V0U3RhcnRzKCkuZ2V0VGltZSgpIDwgZGF0ZXRpbWUubWlsbGlzZWNvbmRzRnJvbSgnbWludXRlcycsIDMwKSkge1xuICAgICAgICBuZXdFbmRzID0gbmV3IERhdGUobW9kZWwuZ2V0U3RhcnRzKCkuZ2V0VGltZSgpICsgZGF0ZXRpbWUubWlsbGlzZWNvbmRzRnJvbSgnbWludXRlcycsIDMwKSk7XG4gICAgfVxuXG4gICAgY3RybC51cGRhdGVFdmVudChtb2RlbElELCB7XG4gICAgICAgIGVuZHM6IG5ld0VuZHNcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRHJhZyNkcmFnRW5kIGV2ZW50IGhhbmRsZXJcbiAqIEBlbWl0cyBUaW1lUmVzaXplI3RpbWVfcmVzaXplX2RyYWdlbmRcbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gZHJhZ0VuZEV2ZW50RGF0YSAtIE1vdXNlIGV2ZW50IG9mIERyYWcjZHJhZ0VuZCBjdXN0b20gZXZlbnQuXG4gKi9cblRpbWVSZXNpemUucHJvdG90eXBlLl9vbkRyYWdFbmQgPSBmdW5jdGlvbihkcmFnRW5kRXZlbnREYXRhKSB7XG4gICAgdmFyIGdldEV2ZW50RGF0YUZ1bmMgPSB0aGlzLl9nZXRFdmVudERhdGFGdW5jLFxuICAgICAgICBkcmFnU3RhcnQgPSB0aGlzLl9kcmFnU3RhcnQsXG4gICAgICAgIGV2ZW50RGF0YTtcblxuICAgIHRoaXMuZHJhZ0hhbmRsZXIub2ZmKHtcbiAgICAgICAgZHJhZzogdGhpcy5fb25EcmFnLFxuICAgICAgICBkcmFnRW5kOiB0aGlzLl9vbkRyYWdFbmQsXG4gICAgICAgIGNsaWNrOiB0aGlzLl9vbkNsaWNrXG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoIWdldEV2ZW50RGF0YUZ1bmMgfHwgIWRyYWdTdGFydCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnREYXRhID0gZ2V0RXZlbnREYXRhRnVuYyhkcmFnRW5kRXZlbnREYXRhLm9yaWdpbkV2ZW50LCB7XG4gICAgICAgIHRhcmdldE1vZGVsSUQ6IGRyYWdTdGFydC50YXJnZXRNb2RlbElEXG4gICAgfSk7XG5cbiAgICBldmVudERhdGEucmFuZ2UgPSBbXG4gICAgICAgIGRyYWdTdGFydC50aW1lWSxcbiAgICAgICAgZXZlbnREYXRhLnRpbWVZICsgZGF0ZXRpbWUubWlsbGlzZWNvbmRzRnJvbSgnaG91cicsIDAuNSlcbiAgICBdO1xuXG4gICAgZXZlbnREYXRhLm5lYXJlc3RSYW5nZSA9IFtcbiAgICAgICAgZHJhZ1N0YXJ0Lm5lYXJlc3RHcmlkVGltZVksXG4gICAgICAgIGV2ZW50RGF0YS5uZWFyZXN0R3JpZFRpbWVZICsgZGF0ZXRpbWUubWlsbGlzZWNvbmRzRnJvbSgnaG91cicsIDAuNSlcbiAgICBdO1xuXG4gICAgdGhpcy5fdXBkYXRlRXZlbnQoZXZlbnREYXRhKTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBUaW1lUmVzaXplI3RpbWVfcmVzaXplX2RyYWdlbmRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIGN1cnJlbnQgdGFyZ2V0IGluIG1vdXNlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge1RpbWV9IHJlbGF0ZWRWaWV3IC0gdGltZSB2aWV3IGluc3RhbmNlIHJlbGF0ZWQgd2l0aCBkcmFnIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7TW91c2VFdmVudH0gb3JpZ2luRXZlbnQgLSBtb3VzZSBldmVudCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1vdXNlWSAtIG1vdXNlIFkgcHggbW91c2UgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGdyaWRZIC0gZ3JpZCBZIGluZGV4IHZhbHVlIHJlbGF0ZWQgd2l0aCBtb3VzZVkgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVZIC0gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIG1vdXNlWSBwb2ludHMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5lYXJlc3RHcmlkWSAtIG5lYXJlc3QgZ3JpZCBpbmRleCByZWxhdGVkIHdpdGggbW91c2VZIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZWFyZXN0R3JpZFRpbWVZIC0gdGltZSB2YWx1ZSBmb3IgbmVhcmVzdEdyaWRZLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0YXJnZXRNb2RlbElEIC0gVGhlIG1vZGVsIHVuaXF1ZSBpZCBlbWl0dGVkIG1vdmUgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJbXX0gcmFuZ2UgLSBtaWxsaXNlY29uZHMgcmFuZ2UgYmV0d2VlbiBkcmFnIHN0YXJ0IGFuZCBlbmQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJbXX0gbmVhcmVzdFJhbmdlIC0gbWlsbGlzZWNvbmRzIHJhbmdlIHJlbGF0ZWQgd2l0aCBuZWFyZXN0R3JpZFkgYmV0d2VlbiBzdGFydCBhbmQgZW5kLlxuICAgICAqL1xuICAgIHRoaXMuZmlyZSgndGltZV9yZXNpemVfZHJhZ2VuZCcsIGV2ZW50RGF0YSk7XG5cbiAgICB0aGlzLl9nZXRFdmVudERhdGFGdW5jID0gdGhpcy5fZHJhZ1N0YXJ0ID0gbnVsbDtcbn07XG5cbi8qKlxuICogQGVtaXRzIFRpbWVSZXNpemUjdGltZV9yZXNpemVfY2xpY2tcbiAqL1xuVGltZVJlc2l6ZS5wcm90b3R5cGUuX29uQ2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRyYWdIYW5kbGVyLm9mZih7XG4gICAgICAgIGRyYWc6IHRoaXMuX29uRHJhZyxcbiAgICAgICAgZHJhZ0VuZDogdGhpcy5fb25EcmFnRW5kLFxuICAgICAgICBjbGljazogdGhpcy5fb25DbGlja1xuICAgIH0sIHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFRpbWVSZXNpemUjdGltZV9yZXNpemVfY2xpY2tcbiAgICAgKi9cbiAgICB0aGlzLmZpcmUoJ3RpbWVfcmVzaXplX2NsaWNrJyk7XG59O1xuXG50aW1lQ29yZS5taXhpbihUaW1lUmVzaXplKTtcbnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKFRpbWVSZXNpemUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVSZXNpemU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBNb2R1bGUgZm9yIFRpbWUuUmVzaXplIGVmZmVjdCB3aGlsZSBkcmFnZ2luZy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIHJlcUFuaW1GcmFtZSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9yZXFBbmltRnJhbWUnKTtcblxudmFyIHJhdGlvID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2NvbW1vbicpLnJhdGlvO1xuXG4vKipcbiAqIENsYXNzIGZvciBUaW1lLlJlc2l6ZSBlZmZlY3QuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VGltZVJlc2l6ZX0gdGltZVJlc2l6ZSAtIHRoZSBpbnN0YW5jZSBvZiBUaW1lUmVzaXplIGhhbmRsZXIuXG4gKi9cbmZ1bmN0aW9uIFRpbWVSZXNpemVHdWlkZSh0aW1lUmVzaXplKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZ3VpZGVFbGVtZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtUaW1lUmVzaXplfVxuICAgICAqL1xuICAgIHRoaXMudGltZVJlc2l6ZSA9IHRpbWVSZXNpemU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5fZ2V0VG9wRnVuYyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5fb3JpZ2luRXZlbnRFbGVtZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fc3RhcnRUb3BQaXhlbCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX3N0YXJ0SGVpZ2h0UGl4ZWwgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9zdGFydEdyaWRZID0gMDtcblxuICAgIHRpbWVSZXNpemUub24oe1xuICAgICAgICAndGltZV9yZXNpemVfZHJhZ3N0YXJ0JzogdGhpcy5fb25EcmFnU3RhcnQsXG4gICAgICAgICd0aW1lX3Jlc2l6ZV9kcmFnJzogdGhpcy5fb25EcmFnLFxuICAgICAgICAndGltZV9yZXNpemVfZHJhZ2VuZCc6IHRoaXMuX2NsZWFyR3VpZGVFbGVtZW50LFxuICAgICAgICAndGltZV9yZXNpemVfY2xpY2snOiB0aGlzLl9jbGVhckd1aWRlRWxlbWVudFxuICAgIH0sIHRoaXMpO1xufVxuXG4vKipcbiAqIERlc3Ryb3kgbWV0aG9kXG4gKi9cblRpbWVSZXNpemVHdWlkZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NsZWFyR3VpZGVFbGVtZW50KCk7XG4gICAgdGhpcy50aW1lUmVzaXplLm9mZih0aGlzKTtcbiAgICB0aGlzLmd1aWRlRWxlbWVudCA9IHRoaXMudGltZVJlc2l6ZSA9IHRoaXMuX2dldFRvcEZ1bmMgPVxuICAgICAgICB0aGlzLl9vcmlnaW5FdmVudEVsZW1lbnQgPSB0aGlzLl9zdGFydEhlaWdodFBpeGVsID1cbiAgICAgICAgdGhpcy5fc3RhcnRHcmlkWSA9IHRoaXMuX3N0YXJ0VG9wUGl4ZWwgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhciBndWlkZSBlbGVtZW50LlxuICovXG5UaW1lUmVzaXplR3VpZGUucHJvdG90eXBlLl9jbGVhckd1aWRlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBndWlkZUVsZW1lbnQgPSB0aGlzLmd1aWRlRWxlbWVudCxcbiAgICAgICAgb3JpZ2luRWxlbWVudCA9IHRoaXMuX29yaWdpbkV2ZW50RWxlbWVudDtcblxuICAgIGlmICghdXRpbC5icm93c2VyLm1zaWUpIHtcbiAgICAgICAgZG9tdXRpbC5yZW1vdmVDbGFzcyhnbG9iYWwuZG9jdW1lbnQuYm9keSwgJ3NjaGVkdWxlLXZpZXctcmVzaXppbmcnKTtcbiAgICB9XG5cbiAgICBpZiAob3JpZ2luRWxlbWVudCkge1xuICAgICAgICBvcmlnaW5FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH1cblxuICAgIGRvbXV0aWwucmVtb3ZlKGd1aWRlRWxlbWVudCk7XG5cbiAgICB0aGlzLmd1aWRlRWxlbWVudCA9IHRoaXMuX2dldFRvcEZ1bmMgPSB0aGlzLl9vcmlnaW5FdmVudEVsZW1lbnQgPVxuICAgICAgICB0aGlzLl9zdGFydEhlaWdodFBpeGVsID0gdGhpcy5fc3RhcnRHcmlkWSA9IHRoaXMuX3N0YXJ0VG9wUGl4ZWwgPSBudWxsO1xufTtcblxuLyoqXG4gKiBSZWZyZXNoIGd1aWRlIGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZWlnaHQgLSBndWlkZSBlbGVtZW50J3Mgc3R5bGUgaGVpZ2h0LlxuICovXG5UaW1lUmVzaXplR3VpZGUucHJvdG90eXBlLl9yZWZyZXNoR3VpZGVFbGVtZW50ID0gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgdmFyIGd1aWRlRWxlbWVudCA9IHRoaXMuZ3VpZGVFbGVtZW50O1xuXG4gICAgaWYgKCFndWlkZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlcUFuaW1GcmFtZS5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICBndWlkZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgZ3VpZGVFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIFRpbWVNb3ZlI3RpbWVfbW92ZV9kcmFnc3RhcnQgZXZlbnQgaGFuZGxlclxuICogQHBhcmFtIHtvYmplY3R9IGRyYWdTdGFydEV2ZW50RGF0YSAtIGRyYWdzdGFydCBldmVudCBkYXRhXG4gKi9cblRpbWVSZXNpemVHdWlkZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZHJhZ1N0YXJ0RXZlbnREYXRhKSB7XG4gICAgdmFyIG9yaWdpbkVsZW1lbnQgPSBkb211dGlsLmNsb3Nlc3QoXG4gICAgICAgICAgICBkcmFnU3RhcnRFdmVudERhdGEudGFyZ2V0LFxuICAgICAgICAgICAgJy5zY2hlZHVsZS12aWV3LXRpbWUtZGF0ZS1ldmVudC1ibG9jaydcbiAgICAgICAgKSxcbiAgICAgICAgZ3VpZGVFbGVtZW50O1xuXG4gICAgaWYgKCF1dGlsLmJyb3dzZXIubXNpZSkge1xuICAgICAgICBkb211dGlsLmFkZENsYXNzKGdsb2JhbC5kb2N1bWVudC5ib2R5LCAnc2NoZWR1bGUtdmlldy1yZXNpemluZycpO1xuICAgIH1cblxuICAgIGlmICghb3JpZ2luRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhcnRHcmlkWSA9IGRyYWdTdGFydEV2ZW50RGF0YS5uZWFyZXN0R3JpZFk7XG4gICAgdGhpcy5fc3RhcnRIZWlnaHRQaXhlbCA9IHBhcnNlRmxvYXQob3JpZ2luRWxlbWVudC5zdHlsZS5oZWlnaHQpO1xuICAgIHRoaXMuX3N0YXJ0VG9wUGl4ZWwgPSBwYXJzZUZsb2F0KG9yaWdpbkVsZW1lbnQuc3R5bGUudG9wKTtcblxuICAgIHRoaXMuX29yaWdpbkV2ZW50RWxlbWVudCA9IG9yaWdpbkVsZW1lbnQ7XG4gICAgZ3VpZGVFbGVtZW50ID0gdGhpcy5ndWlkZUVsZW1lbnQgPSBvcmlnaW5FbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgICBkb211dGlsLmFkZENsYXNzKGd1aWRlRWxlbWVudCwgJ3NjaGVkdWxlLXZpZXctdGltZS1yZXNpemUtZ3VpZGUnKTtcblxuICAgIG9yaWdpbkVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBkcmFnU3RhcnRFdmVudERhdGEucmVsYXRlZFZpZXcuY29udGFpbmVyLmFwcGVuZENoaWxkKGd1aWRlRWxlbWVudCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcmFnRXZlbnREYXRhIC0gZXZlbnQgZGF0YSBmcm9tIERyYWcjZHJhZy5cbiAqL1xuVGltZVJlc2l6ZUd1aWRlLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24oZHJhZ0V2ZW50RGF0YSkge1xuICAgIHZhciB0aW1lVmlldyA9IGRyYWdFdmVudERhdGEucmVsYXRlZFZpZXcsXG4gICAgICAgIHZpZXdPcHRpb25zID0gdGltZVZpZXcub3B0aW9ucyxcbiAgICAgICAgdmlld0hlaWdodCA9IHRpbWVWaWV3LmdldFZpZXdCb3VuZCgpLmhlaWdodCxcbiAgICAgICAgaG91ckxlbmd0aCA9IHZpZXdPcHRpb25zLmhvdXJFbmQgLSB2aWV3T3B0aW9ucy5ob3VyU3RhcnQsXG4gICAgICAgIGd1aWRlRWxlbWVudCA9IHRoaXMuZ3VpZGVFbGVtZW50LFxuICAgICAgICBndWlkZVRvcCA9IHBhcnNlRmxvYXQoZ3VpZGVFbGVtZW50LnN0eWxlLnRvcCksXG4gICAgICAgIGdyaWRZT2Zmc2V0ID0gZHJhZ0V2ZW50RGF0YS5uZWFyZXN0R3JpZFkgLSB0aGlzLl9zdGFydEdyaWRZLFxuICAgICAgICAvLyBob3VyTGVuZ3RoIDogdmlld0hlaWdodCA9IGdyaWRZT2Zmc2V0IDogWDtcbiAgICAgICAgZ3JpZFlPZmZzZXRQaXhlbCA9IHJhdGlvKGhvdXJMZW5ndGgsIHZpZXdIZWlnaHQsIGdyaWRZT2Zmc2V0KSxcbiAgICAgICAgbWluSGVpZ2h0LFxuICAgICAgICBtYXhIZWlnaHQsXG4gICAgICAgIGhlaWdodDtcblxuICAgIGhlaWdodCA9ICh0aGlzLl9zdGFydEhlaWdodFBpeGVsICsgZ3JpZFlPZmZzZXRQaXhlbCk7XG4gICAgLy8gYXQgbGVhc3QgbGFyZ2UgdGhhbiAzMG1pbiBmcm9tIGV2ZW50IHN0YXJ0IHRpbWUuXG4gICAgbWluSGVpZ2h0ID0gZ3VpZGVUb3AgKyByYXRpbyhob3VyTGVuZ3RoLCB2aWV3SGVpZ2h0LCAwLjUpO1xuICAgIG1pbkhlaWdodCAtPSB0aGlzLl9zdGFydFRvcFBpeGVsO1xuICAgIC8vIHNtYWxsZXIgdGhhbiAyNGhcbiAgICBtYXhIZWlnaHQgPSB2aWV3SGVpZ2h0IC0gZ3VpZGVUb3A7XG5cbiAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIG1pbkhlaWdodCk7XG4gICAgaGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0LCBtYXhIZWlnaHQpO1xuXG4gICAgdGhpcy5fcmVmcmVzaEd1aWRlRWxlbWVudChoZWlnaHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lUmVzaXplR3VpZGU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBNb2RlbCBvZiBldmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBkaXJ0eSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9kaXJ0eScpO1xudmFyIG1vZGVsID0gcmVxdWlyZSgnLi4vY29tbW9uL21vZGVsJyk7XG5cbi8qKlxuICogVGhlIG1vZGVsIG9mIGNhbGVuZGFyIGV2ZW50cy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQG1peGVzIGRpcnR5XG4gKiBAbWl4ZXMgbW9kZWxcbiAqL1xuZnVuY3Rpb24gRXZlbnQoKSB7XG4gICAgLyoqXG4gICAgICogYE9wdGlvbmFsYCB1bmlxdWUgaWQgZm9yIHZhcmlvdXMgdXNlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5pZCA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogdGl0bGUgZm9yIGV2ZW50LlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50aXRsZSA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogaXMgZXZlbnQgaXMgYWxsIGRheSBldmVudD9cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzQWxsRGF5ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBldmVudCBzdGFydHNcbiAgICAgKiBAdHlwZSB7RGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0cyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBldmVudCBlbmRzXG4gICAgICogQHR5cGUge0RhdGV9XG4gICAgICovXG4gICAgdGhpcy5lbmRzID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIGV2ZW50IHRleHQgY29sb3JcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY29sb3IgPSAnIzAwMCc7XG5cbiAgICAvKipcbiAgICAgKiBldmVudCBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmJnQ29sb3IgPSAnI2ExYjU2Yyc7XG5cbiAgICAvLyBpbml0aWFsaXplIG1vZGVsIGlkXG4gICAgdXRpbC5zdGFtcCh0aGlzKTtcbn1cblxuLyoqKioqKioqKipcbiAqIHN0YXRpYyBwcm9wc1xuICoqKioqKioqKiovXG5cbkV2ZW50LnNjaGVtYSA9IHtcbiAgICByZXF1aXJlZDogWyd0aXRsZSddLFxuICAgIGRhdGVSYW5nZTogWydzdGFydHMnLCAnZW5kcyddXG59O1xuXG4vKipcbiAqIGNyZWF0ZSBldmVudCBtb2RlbCBmcm9tIGpzb24ob2JqZWN0KSBkYXRhLlxuICogQHBhcmFtIHtvYmplY3R9IGRhdGEgb2JqZWN0IGZvciBtb2RlbC5cbiAqIEByZXR1cm5zIHtFdmVudH0gRXZlbnQgbW9kZWwgaW5zdGFuY2UuXG4gKi9cbkV2ZW50LmNyZWF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgaW5zdCA9IG5ldyBFdmVudCgpO1xuICAgIGluc3QuaW5pdChkYXRhKTtcblxuICAgIHJldHVybiBpbnN0O1xufTtcblxuLyoqKioqKioqKipcbiAqIHByb3RvdHlwZSBwcm9wc1xuICoqKioqKioqKiovXG5cbi8qKlxuICogSW5pdGlhbGl6ZSBldmVudCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIG9wdGlvbnMuXG4gKi9cbkV2ZW50LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5pZCA9IG9wdGlvbnMuaWQgfHwgJyc7XG4gICAgdGhpcy50aXRsZSA9IG9wdGlvbnMudGl0bGUgfHwgJyc7XG4gICAgdGhpcy5pc0FsbERheSA9IHV0aWwuaXNFeGlzdHkob3B0aW9ucy5pc0FsbERheSkgPyBvcHRpb25zLmlzQWxsRGF5IDogZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydHMpIHtcbiAgICAgICAgdGhpcy5zdGFydHMgPSBuZXcgRGF0ZShvcHRpb25zLnN0YXJ0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGFydHMgPSBuZXcgRGF0ZSgpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmVuZHMpIHtcbiAgICAgICAgdGhpcy5lbmRzID0gbmV3IERhdGUob3B0aW9ucy5lbmRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVuZHMgPSBuZXcgRGF0ZSh0aGlzLnN0YXJ0cy5nZXRUaW1lKCkpO1xuICAgICAgICB0aGlzLmVuZHMuc2V0TWludXRlcyh0aGlzLmVuZHMuZ2V0TWludXRlcygpICsgMzApO1xuICAgIH1cblxuICAgIHRoaXMuY29sb3IgPSBvcHRpb25zLmNvbG9yIHx8IHRoaXMuY29sb3I7XG4gICAgdGhpcy5iZ0NvbG9yID0gb3B0aW9ucy5iZ0NvbG9yIHx8IHRoaXMuYmdDb2xvcjtcbn07XG5cbi8qKlxuICogQHJldHVybnMge0RhdGV9IHJlbmRlciBzdGFydCBkYXRlLlxuICovXG5FdmVudC5wcm90b3R5cGUuZ2V0U3RhcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnRzO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7RGF0ZX0gcmVuZGVyIGVuZCBkYXRlLlxuICovXG5FdmVudC5wcm90b3R5cGUuZ2V0RW5kcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmVuZHM7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGluc3RhbmNlIHVuaXF1ZSBpZC5cbiAqL1xuRXZlbnQucHJvdG90eXBlLmNpZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB1dGlsLnN0YW1wKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDaGVjayB0d28gZXZlbnQgYXJlIGVxdWFscyAobWVhbnMgdGl0bGUsIGlzQWxsRGF5LCBzdGFydHMsIGVuZHMgYXJlIHNhbWUpXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBFdmVudCBtb2RlbCBpbnN0YW5jZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybiBmYWxzZSB3aGVuIG5vdCBzYW1lLlxuICovXG5FdmVudC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy5pZCAhPT0gZXZlbnQuaWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRpdGxlICE9PSBldmVudC50aXRsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNBbGxEYXkgIT09IGV2ZW50LmlzQWxsRGF5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0ZXRpbWUuY29tcGFyZSh0aGlzLmdldFN0YXJ0cygpLCBldmVudC5nZXRTdGFydHMoKSkgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChkYXRldGltZS5jb21wYXJlKHRoaXMuZ2V0RW5kcygpLCBldmVudC5nZXRFbmRzKCkpICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb2xvciAhPT0gZXZlbnQuY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJnQ29sb3IgIT09IGV2ZW50LmJnQ29sb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiByZXR1cm4gZHVyYXRpb24gYmV0d2VlbiBzdGFydHMgYW5kIGVuZHMuXG4gKiBAcmV0dXJucyB7RGF0ZX0gZHVyYXRpb24gKFVUQylcbiAqL1xuRXZlbnQucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0cyA9IHRoaXMuZ2V0U3RhcnRzKCksXG4gICAgICAgIGVuZHMgPSB0aGlzLmdldEVuZHMoKSxcbiAgICAgICAgZHVyYXRpb247XG5cbiAgICBpZiAodGhpcy5pc0FsbERheSkge1xuICAgICAgICBkdXJhdGlvbiA9IG5ldyBEYXRlKGRhdGV0aW1lLmVuZChlbmRzKSAtIGRhdGV0aW1lLnN0YXJ0KHN0YXJ0cykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGR1cmF0aW9uID0gbmV3IERhdGUoZW5kcyAtIHN0YXJ0cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGR1cmF0aW9uO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIEV2ZW50IGNvaW5jaWRlcyB3aXRoIHRoZSBzYW1lIHRpbWUgYXMgdGhlXG4gKiBjYWxsaW5nIEV2ZW50LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIG90aGVyIGV2ZW50IHRvIGNvbXBhcmUgd2l0aCB0aGlzIEV2ZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IElmIHRoZSBvdGhlciBldmVudCBvY2N1cnMgd2l0aGluIHRoZSBzYW1lIHRpbWUgYXMgdGhlIGZpcnN0IG9iamVjdC5cbiAqL1xuRXZlbnQucHJvdG90eXBlLmNvbGxpZGVzV2l0aCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIG93blN0YXJ0cyA9IHRoaXMuZ2V0U3RhcnRzKCksXG4gICAgICAgIG93bkVuZHMgPSB0aGlzLmdldEVuZHMoKSxcbiAgICAgICAgc3RhcnRzID0gZXZlbnQuZ2V0U3RhcnRzKCksXG4gICAgICAgIGVuZHMgPSBldmVudC5nZXRFbmRzKCk7XG5cbiAgICBpZiAoKHN0YXJ0cyA+IG93blN0YXJ0cyAmJiBzdGFydHMgPCBvd25FbmRzKSB8fFxuICAgICAgICAoZW5kcyA+IG93blN0YXJ0cyAmJiBlbmRzIDwgb3duRW5kcykgfHxcbiAgICAgICAgKHN0YXJ0cyA8PSBvd25TdGFydHMgJiYgZW5kcyA+PSBvd25FbmRzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxubW9kZWwubWl4aW4oRXZlbnQucHJvdG90eXBlKTtcbmRpcnR5Lm1peGluKEV2ZW50LnByb3RvdHlwZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnQ7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBNb2RlbCBmb3Igdmlld3NcbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG5cbi8qKlxuICogRXZlbnQgVmlld01vZGVsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEV2ZW50IGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBFdmVudFZpZXdNb2RlbChldmVudCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBtb2RlbCBvZiBldmVudC5cbiAgICAgKiBAdHlwZSB7RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy5tb2RlbCA9IGV2ZW50O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRvcCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVmdCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnQgZXZlbnQgaGFzIGNvbGxpZGUgd2l0aCBvdGhlciBldmVudHMgd2hlbiByZW5kZXJpbmcuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5oYXNDb2xsaWRlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYSBzcGFjZSBhdCByaWd0aCBzaWRlIG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmV4dHJhU3BhY2UgPSAwO1xuXG4gICAgLyoqXG4gICAgICogcmVwcmVzZW50IHRoaXMgZXZlbnQgYmxvY2sgaXMgbm90IHZpc2libGUgYWZ0ZXIgcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBpbiBtb250aCB2aWV3LCBzb21lIHZpZXdtb2RlbCBpbiBkYXRlIG5lZWQgdG8gaGlkZSB3aGVuIGFscmVhZHkgcmVuZGVyZWQgYmVmb3JlIGRhdGVzLlxuICAgICAqXG4gICAgICogc2V0IHRydWUgdGhlbiBpdCBqdXN0IHNob3dzIGVtcHR5IHNwYWNlLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiByZXByZXNlbnQgcmVuZGVyIHN0YXJ0IGRhdGUgdXNlZCBhdCByZW5kZXJpbmcuXG4gICAgICpcbiAgICAgKiBpZiBzZXQgbnVsbCB0aGVuIHVzZSBtb2RlbCdzICdzdGFydHMnIHByb3BlcnR5LlxuICAgICAqIEB0eXBlIHtEYXRlfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyU3RhcnRzID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIHJlcHJlc2VudCByZW5kZXIgZW5kIGRhdGUgdXNlZCBhdCByZW5kZXJpbmcuXG4gICAgICpcbiAgICAgKiBpZiBzZXQgbnVsbCB0aGVuIHVzZSBtb2RlbCdzICdlbmRzJyBwcm9wZXJ0eS5cbiAgICAgKiBAdHlwZSB7RGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlckVuZHMgPSBudWxsO1xufVxuXG4vKioqKioqKioqKlxuICogc3RhdGljIHByb3BzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBFdmVudFZpZXdNb2RlbCBmYWN0b3J5IG1ldGhvZC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEV2ZW50IGluc3RhbmNlLlxuICogQHJldHVybnMge0V2ZW50Vmlld01vZGVsfSBFdmVudFZpZXdNb2RlbCBpbnN0YW5jZS5cbiAqL1xuRXZlbnRWaWV3TW9kZWwuY3JlYXRlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IEV2ZW50Vmlld01vZGVsKGV2ZW50KTtcbn07XG5cblxuLyoqKioqKioqKipcbiAqIHByb3RvdHlwZSBwcm9wc1xuICoqKioqKioqKiovXG5cbi8qKlxuICogcmV0dXJuIHJlbmRlclN0YXJ0cyBwcm9wZXJ0eSB0byByZW5kZXIgcHJvcGVybHkgd2hlbiBzcGVjaWZpYyBldmVudCB0aGF0IGV4Y2VlZCByZW5kZXJpbmcgZGF0ZSByYW5nZS5cbiAqXG4gKiBpZiByZW5kZXJTdGFydHMgaXMgbm90IHNldC4gcmV0dXJuIG1vZGVsJ3Mgc3RhcnRzIHByb3BlcnR5LlxuICogQG92ZXJyaWRlXG4gKiBAcmV0dXJucyB7RGF0ZX0gcmVuZGVyIHN0YXJ0IGRhdGUuXG4gKi9cbkV2ZW50Vmlld01vZGVsLnByb3RvdHlwZS5nZXRTdGFydHMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJTdGFydHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyU3RhcnRzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm1vZGVsLnN0YXJ0cztcbn07XG5cbi8qKlxuICogcmV0dXJuIHJlbmRlclN0YXJ0cyBwcm9wZXJ0eSB0byByZW5kZXIgcHJvcGVybHkgd2hlbiBzcGVjaWZpYyBldmVudCB0aGF0IGV4Y2VlZCByZW5kZXJpbmcgZGF0ZSByYW5nZS5cbiAqXG4gKiBpZiByZW5kZXJFbmRzIGlzIG5vdCBzZXQuIHJldHVybiBtb2RlbCdzIGVuZHMgcHJvcGVydHkuXG4gKiBAb3ZlcnJpZGVcbiAqIEByZXR1cm5zIHtEYXRlfSByZW5kZXIgZW5kIGRhdGUuXG4gKi9cbkV2ZW50Vmlld01vZGVsLnByb3RvdHlwZS5nZXRFbmRzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyRW5kcykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJFbmRzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm1vZGVsLmVuZHM7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHVuaXF1ZSBudW1iZXIgZm9yIG1vZGVsLlxuICovXG5FdmVudFZpZXdNb2RlbC5wcm90b3R5cGUuY2lkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHV0aWwuc3RhbXAodGhpcy5tb2RlbCk7XG59O1xuXG4vKipcbiAqIFNoYWRvd2luZyB2YWx1ZU9mIG1ldGhvZCBmb3IgZXZlbnQgc29ydGluZy5cbiAqIEByZXR1cm5zIHtFdmVudH0gVGhlIG1vZGVsIG9mIGV2ZW50LlxuICovXG5FdmVudFZpZXdNb2RlbC5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1vZGVsO1xufTtcblxuLyoqXG4gKiBMaW5rIGR1cmF0aW9uIG1ldGhvZFxuICogQHJldHVybnMge251bWJlcn0gRXZlbnQjZHVyYXRpb24gcmVzdWx0LlxuICovXG5FdmVudFZpZXdNb2RlbC5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbC5kdXJhdGlvbigpO1xufTtcblxuLyoqXG4gKiBMaW5rIGNvbGxpZGVzV2l0aCBtZXRob2RcbiAqIEBwYXJhbSB7RXZlbnR8RXZlbnRWaWV3TW9kZWx9IHZpZXdNb2RlbCAtIE1vZGVsIG9yIHZpZXdtb2RlbCBpbnN0YW5jZSBvZiBFdmVudHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gRXZlbnQjY29sbGlkZXNXaXRoIHJlc3VsdC5cbiAqL1xuRXZlbnRWaWV3TW9kZWwucHJvdG90eXBlLmNvbGxpZGVzV2l0aCA9IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgIHJldHVybiB0aGlzLm1vZGVsLmNvbGxpZGVzV2l0aCh2aWV3TW9kZWwudmFsdWVPZigpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRWaWV3TW9kZWw7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBMYXlvdXQgdmlldy4gd3JhcCBhbGwgdmlldyBjb250YWluZXJzIGF0IG91dHNpZGUuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9jb21tb24vY29sbGVjdGlvbicpO1xudmFyIFZpZXcgPSByZXF1aXJlKCcuL3ZpZXcnKTtcblxuLyoqXG4gKiBMYXlvdXQgdmlldyBmb3IgdG9nZ2xlIGVhY2ggY2hpbGQgdmlldy4gSXQgd2lsbCBjb250cm9sbGVkIHZpYSBuYXZpZ2F0aW9uIFVJLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7Vmlld31cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBDb250YWluZXIgZWxlbWVudCB0byB1c2UgbGF5b3V0IHZpZXcuXG4gKi9cbmZ1bmN0aW9uIExheW91dChjb250YWluZXIpIHtcbiAgICAvKmVzbGludC1kaXNhYmxlKi9cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbn0gQ2hpbGQgdmlldyBjb2xsZWN0aW9uLlxuICAgICAqL1xuICAgIHRoaXMuY2hpbGRzID0gbmV3IENvbGxlY3Rpb24oZnVuY3Rpb24oY2hpbGRWaWV3KSB7XG4gICAgICAgIHJldHVybiBjaGlsZFZpZXcudmlld05hbWU7XG4gICAgfSk7XG4gICAgLyplc2xpbnQtZW5hYmxlKi9cblxuICAgIGRvbXV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnc2NoZWR1bGUtdmlldy1sYXlvdXQnKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbn1cblxudXRpbC5pbmhlcml0KExheW91dCwgVmlldyk7XG5cbi8qKlxuICogQ2xlYXIgY2hpbGQgdmlld3MuXG4gKi9cbkxheW91dC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNoaWxkcy5lYWNoKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICBjaGlsZFZpZXcuZGVzdHJveSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jaGlsZHMuY2xlYXIoKTtcbiAgICB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbn07XG5cbi8qKlxuICogQWRkIGFuIHZpZXcgb2JqZWN0IGJ5IGNyZWF0aW9uIGZ1bmN0aW9uICoqKGFkZGVyRnVuYykqKi5cbiAqXG4gKiBJbnZvY2F0aW9ucyBvZiBhZGRlckZ1bmMgaXMgY2FsbGVkIHdpdGggbGF5b3V0IHZpZXcncyBjb250YWluZXIuXG4gKlxuICogQXMgcmVzdWx0IG9mIGFkZGVyRnVuYy4gYWRkZWQgaXQgdG8gbGF5b3V0IHZpZXcncyBjaGlsZHMuXG4gKiBAb3ZlcnJpZGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGFkZGVyRnVuYyBUaGUgYWRkZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7Vmlld30gVmlldyBpbnN0YW5jZSBhZGRlZC5cbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uKGFkZGVyRnVuYykge1xuICAgIHZhciBjaGlsZFZpZXcgPSBhZGRlckZ1bmModGhpcy5jb250YWluZXIpO1xuICAgIHRoaXMuY2hpbGRzLmFkZChjaGlsZFZpZXcpO1xuICAgIHJldHVybiBjaGlsZFZpZXc7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBjaGlsZCB2aWV3LlxuICogQG92ZXJyaWRlXG4gKiBAcGFyYW0geyhzdHJpbmd8Vmlldyl9IHZpZXdOYW1lIC0gbmFtZSBvZiB2aWV3IG9yIGluc3RhbmNlLlxuICovXG5MYXlvdXQucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24odmlld05hbWUpIHtcbiAgICB0aGlzLmNoaWxkcy5yZW1vdmUodmlld05hbWUpO1xufTtcblxuLyoqXG4gKiBUb2dnbGUgY2hpbGQgdmlld3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmlld05hbWUgLSBOYW1lIG9mIHZpZXcuXG4gKi9cbkxheW91dC5wcm90b3R5cGUudG9nZ2xlQ2hpbGRWaWV3ID0gZnVuY3Rpb24odmlld05hbWUpIHtcbiAgICB2YXIgY29udGFpbmVyLFxuICAgICAgICBwcmVmaXggPSBbJ2FkZCcsICdyZW1vdmUnXSxcbiAgICAgICAgZmxhZztcblxuICAgIHRoaXMuY2hpbGRzLmVhY2goZnVuY3Rpb24oY2hpbGRWaWV3KSB7XG4gICAgICAgIGNvbnRhaW5lciA9IGNoaWxkVmlldy5jb250YWluZXI7XG4gICAgICAgIGZsYWcgPSArKGNoaWxkVmlldy52aWV3TmFtZSA9PT0gdmlld05hbWUpO1xuICAgICAgICBkb211dGlsW3ByZWZpeFtmbGFnXSArICdDbGFzcyddKGNvbnRhaW5lciwgJ3NjaGVkdWxlLXZpZXctaGlkZGVuJyk7XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExheW91dDtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFZpZXcgb2Ygd2VlayBldmVudCBjb250YWluZXIgaW5zaWRlIG9mIFdlZWsgdmlldy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBWaWV3ID0gcmVxdWlyZSgnLi92aWV3Jyk7XG52YXIgdG1wbCA9IHJlcXVpcmUoJy4vdGVtcGxhdGUvbW9udGh3ZWVrLmhicycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge1ZpZXd9XG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIHZpZXcgb3B0aW9ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb250YWluZXJIZWlnaHQ9NDBdIC0gbWluaW11bSBoZWlnaHQgb2YgZXZlbnQgY29udGFpbmVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29udGFpbmVyQnV0dG9uR3V0dGVyPThdIC0gZnJlZSBzcGFjZSBhdCBib3R0b20gdG8gbWFrZSBjcmVhdGUgZWFzeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5ldmVudEhlaWdodD0xOF0gLSBoZWlnaHQgb2YgZWFjaCBldmVudCBibG9jay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5ldmVudEd1dHRlcj0yXSAtIGd1dHRlciBoZWlnaHQgb2YgZWFjaCBldmVudCBibG9jay5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLl9nZXRWaWV3TW9kZWxGdW5jXSAtIGZ1bmN0aW9uIGZvciBleHRyYWN0IHBhcnRpYWwgdmlldyBtb2RlbCBkYXRhIGZyb20gd2hvbGUgdmlldyBtb2RlbHMuXG4gKiBAcGFyYW0ge0hUTUxESVZFbGVtZW50fSBjb250YWluZXIgLSBET00gZWxlbWVudCB0byB1c2UgY29udGFpbmVyIGZvciB0aGlzIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIE1vbnRoV2VlayhvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICBjb250YWluZXIgPSBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAnc2NoZWR1bGUtdmlldy1hbGxkYXktbW9udGh3ZWVrJ1xuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgIGNvbnRhaW5lckhlaWdodDogNDAsXG4gICAgICAgIGNvbnRhaW5lckJvdHRvbUd1dHRlcjogOCxcbiAgICAgICAgZXZlbnRIZWlnaHQ6IDE4LFxuICAgICAgICBldmVudEd1dHRlcjogMlxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgb3B0aW9ucy5taW5IZWlnaHQgPSBvcHRpb25zLmNvbnRhaW5lckhlaWdodCArIG9wdGlvbnMuY29udGFpbmVyQm90dG9tR3V0dGVyO1xuXG4gICAgVmlldy5jYWxsKHRoaXMsIG51bGwsIGNvbnRhaW5lcik7XG59XG5cbnV0aWwuaW5oZXJpdChNb250aFdlZWssIFZpZXcpO1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSB2aWV3TW9kZWwgLSB2aWV3TW9kZWwgZnJvbSBwYXJlbnQgdmlld3MuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSB2aWV3TW9kZWwgdG8gcmVuZGVyaW5nLlxuICovXG5Nb250aFdlZWsucHJvdG90eXBlLl9nZXRCYXNlVmlld01vZGVsID0gZnVuY3Rpb24odmlld01vZGVsKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHJhbmdlID0gZGF0ZXRpbWUucmFuZ2UoXG4gICAgICAgICAgICB2aWV3TW9kZWwucmVuZGVyU3RhcnREYXRlLFxuICAgICAgICAgICAgdmlld01vZGVsLnJlbmRlckVuZERhdGUsXG4gICAgICAgICAgICBkYXRldGltZS5NSUxMSVNFQ09ORFNfUEVSX0RBWVxuICAgICAgICApLFxuICAgICAgICBtYXRyaWNlcyA9IG9wdGlvbnMuX2dldFZpZXdNb2RlbEZ1bmModmlld01vZGVsKSxcbiAgICAgICAgd2lkdGhQZXJjZW50ID0gMTAwIC8gcmFuZ2UubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHdpZHRoUGVyY2VudCxcbiAgICAgICAgaGVpZ2h0OiBvcHRpb25zLmNvbnRhaW5lckhlaWdodCxcbiAgICAgICAgZXZlbnRCbG9ja0hlaWdodDogb3B0aW9ucy5ldmVudEhlaWdodCArIG9wdGlvbnMuZXZlbnRHdXR0ZXIsXG4gICAgICAgIGV2ZW50QmxvY2tHdXR0ZXI6IG9wdGlvbnMuZXZlbnRHdXR0ZXIsXG4gICAgICAgIGV2ZW50R3JpZDogdXRpbC5tYXAocmFuZ2UsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpZHRoUGVyY2VudDtcbiAgICAgICAgfSksXG4gICAgICAgIG1hdHJpY2VzOiBtYXRyaWNlc1xuICAgIH07XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICogQHBhcmFtIHtvYmplY3R9IHZpZXdNb2RlbCAtIHZpZXdNb2RlbCBmcm9tIHBhcmVudCB2aWV3cy5cbiAqL1xuTW9udGhXZWVrLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbih2aWV3TW9kZWwpIHtcbiAgICB2YXIgYmFzZVZpZXdNb2RlbCA9IHRoaXMuX2dldEJhc2VWaWV3TW9kZWwodmlld01vZGVsKSxcbiAgICAgICAgbWF4RXZlbnRJbkRheSA9IDA7XG5cbiAgICBtYXhFdmVudEluRGF5ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgdXRpbC5tYXAoYmFzZVZpZXdNb2RlbC5tYXRyaWNlcywgZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCB1dGlsLm1hcChtYXRyaXgsIGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgcmV0dXJuIHJvdy5sZW5ndGg7XG4gICAgICAgIH0pKTtcbiAgICB9KSk7XG5cbiAgICB0aGlzLnJlc2l6ZShtYXhFdmVudEluRGF5KTtcblxuICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9IHRtcGwoYmFzZVZpZXdNb2RlbCk7XG59O1xuXG4vKipcbiAqIFJlc2l6ZSBNb250aFdlZWsgY29udGFpbmVyIGFuZCBzZW5kIGluZm9ybWF0aW9uIHRvIHBhcmVudCB2aWV3cy5cbiAqIEBvdmVycmlkZVxuICogQHBhcmFtIHtudW1iZXJ9IG1heEV2ZW50SW5EYXkgLSBob3cgbGFyZ2VzdCBldmVudCBibG9jayBpbiBvbmUgZGF5P1xuICovXG5Nb250aFdlZWsucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKG1heEV2ZW50SW5EYXkpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgbmV3SGVpZ2h0ID0gKG1heEV2ZW50SW5EYXkgKiAob3B0aW9ucy5ldmVudEhlaWdodCArIG9wdGlvbnMuZXZlbnRHdXR0ZXIpKSArIG9wdGlvbnMuY29udGFpbmVyQm90dG9tR3V0dGVyO1xuXG4gICAgbmV3SGVpZ2h0ID0gTWF0aC5tYXgobmV3SGVpZ2h0LCBvcHRpb25zLm1pbkhlaWdodCk7XG4gICAgXG4gICAgdGhpcy5jb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gbmV3SGVpZ2h0ICsgJ3B4Jztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTW9udGhXZWVrO1xuXG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoe1wiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1kaXNwbGF5LXRhYmxlXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1kaXNwbGF5LXRhYmxlLXJvd1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LWRpc3BsYXktdGFibGUtY2VsbFxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1zY3JvbGwteSBzY2hlZHVsZS12aWV3LWRheW5hbWUtbGF5b3V0XFxcIj48L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1kaXNwbGF5LXRhYmxlLXJvd1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LWRpc3BsYXktdGFibGUtY2VsbFxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1zY3JvbGwteSBzY2hlZHVsZS12aWV3LWFsbGRheS1sYXlvdXRcXFwiPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LWRpc3BsYXktdGFibGUtcm93XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctZGlzcGxheS10YWJsZS1jZWxsIHNjaGVkdWxlLXZpZXctdGltZWdyaWQtbGF5b3V0XFxcIj48L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG59LFwidXNlRGF0YVwiOnRydWV9KTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBIZWxwZXJzIGZvciBoYW5kbGViYXIgdGVtcGxhdGVzLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcblxuZnVuY3Rpb24gZ2V0RWxTaXplKHZhbHVlLCBwb3N0Zml4LCBwcmVmaXgpIHtcbiAgICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG4gICAgaWYgKHV0aWwuaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnOicgKyB2YWx1ZSArIHBvc3RmaXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZpeCArICc6YXV0byc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdzdGFtcCc6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gdXRpbC5zdGFtcChvYmopO1xuICAgIH0sXG5cbiAgICAnZXF1YWwnOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhID09PSBiO1xuICAgIH0sXG5cbiAgICAnb3InOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIHx8IGI7XG4gICAgfSxcblxuICAgICdmaSc6IGZ1bmN0aW9uKGEsIG9wZXIsIGIsIG9wdGlvbnMpIHtcbiAgICAgICAgc3dpdGNoIChvcGVyKSB7XG4gICAgICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhID09IGIpID8gb3B0aW9ucy5mbih0aGlzKSA6IG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICAgICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICAoYSA9PT0gYikgPyBvcHRpb25zLmZuKHRoaXMpIDogb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnY29tbW9uLXdpZHRoJzogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIGdldEVsU2l6ZSh3aWR0aCwgJyUnLCAnd2lkdGgnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXNlIGluIHRpbWUuaGJzXG4gICAgICogQHBhcmFtIHtFdmVudFZpZXdNb2RlbH0gZXZlbnRWaWV3TW9kZWwgdmlld01vZGVsXG4gICAgICogQHJldHVybnMge3N0cmluZ30gZWxlbWVudCBzaXplIGNzcyBjbGFzc1xuICAgICAqL1xuICAgICd0aW1lLWV2ZW50QmxvY2snOiBmdW5jdGlvbihldmVudFZpZXdNb2RlbCkge1xuICAgICAgICB2YXIgdG9wID0gZ2V0RWxTaXplKGV2ZW50Vmlld01vZGVsLnRvcCwgJ3B4JywgJ3RvcCcpLFxuICAgICAgICAgICAgbGVmdCA9IGdldEVsU2l6ZShldmVudFZpZXdNb2RlbC5sZWZ0LCAnJScsICdsZWZ0JyksXG4gICAgICAgICAgICB3aWR0aCA9IGdldEVsU2l6ZShldmVudFZpZXdNb2RlbC53aWR0aCwgJyUnLCAnd2lkdGgnKSxcbiAgICAgICAgICAgIGhlaWdodCA9IGdldEVsU2l6ZShldmVudFZpZXdNb2RlbC5oZWlnaHQsICdweCcsICdoZWlnaHQnKTtcblxuICAgICAgICByZXR1cm4gW3RvcCwgbGVmdCwgd2lkdGgsIGhlaWdodF0uam9pbignOycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2UgaW4gZGF5bmFtZS5oYnNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjc3MgY2xhc3NcbiAgICAgKi9cbiAgICAnZGF5bmFtZS1pc0hvbGxpZGF5JzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRheSA9PT0gMCB8fCB0aGlzLmRheSA9PT0gNikge1xuICAgICAgICAgICAgcmV0dXJuICdzY2hlZHVsZS12aWV3LWRheW5hbWUgc2NoZWR1bGUtaG9sbGlkYXknO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdzY2hlZHVsZS12aWV3LWRheW5hbWUnO1xuICAgIH0sXG5cbiAgICAnbXVsdGlwbHknOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhICogYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog7IWA66CJ7Yq467CV7IqkIO2XrO2NvFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0g7IWA66CJ7Yq467CV7IqkIG5hbWUg7IaN7ISx6rCSXG4gICAgICogQHBhcmFtIHt7dmFsdWU6IHN0cmluZywgbGFiZWw6IHN0cmluZ319IGxpc3QgLSDsmLXshZgg66as7Iqk7Yq4XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdGVkVmFsdWUgLSDquLDrs7jshKDtg53sspjrpqwg7JuQ7ZWY64qUIOqwklxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGh0bWwgdGFnXG4gICAgICovXG4gICAgJ3NlbGVjdGJveCc6IGZ1bmN0aW9uKG5hbWUsIGxpc3QsIHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgdmFyIGh0bWwgPSAnPHNlbGVjdCBuYW1lPVwiJyArIG5hbWUgKyAnXCI+JztcblxuICAgICAgICB1dGlsLmZvckVhY2gobGlzdCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgaHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIicgKyBkYXRhLnZhbHVlICsgJ1wiJyArIChzZWxlY3RlZFZhbHVlID09PSBkYXRhLnZhbHVlID8gJyBzZWxlY3RlZCcgOiAnJykgKyAnPicgKyBkYXRhLmxhYmVsICsgJzwvb3B0aW9uPic7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBodG1sICsgJzwvc2VsZWN0Pic7XG4gICAgfSxcblxuICAgICdyYWRpb0NhbGVuZGFyQ29sb3InOiBmdW5jdGlvbihuYW1lLCBsaXN0LCBjaGVja2VkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwubWFwKGxpc3QsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiAnPGxhYmVsPicgKyBcbiAgICAgICAgICAgICAgICAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCInICsgbmFtZSArICdcIiB2YWx1ZT1cIicgKyBkYXRhLnZhbHVlICsgJ1wiJyArIFxuICAgICAgICAgICAgICAgIChkYXRhLnZhbHVlID09PSBjaGVja2VkVmFsdWUgPyAnIGNoZWNrZWQnIDogJycpICsgJyAvPicgKyBcbiAgICAgICAgICAgICAgICAnPHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiMnICsgZGF0YS52YWx1ZSArICdcIj4mbmJzcDs8L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgJzwvbGFiZWw+JztcbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgfVxufTtcblxuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcIjFcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBhbGlhczE9Y29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1tb250aHdlZWstZ3JpZC1saW5lXFxcIiBzdHlsZT1cXFwid2lkdGg6XCJcbiAgICArIGFsaWFzMShjb250YWluZXIubGFtYmRhKGRlcHRoMCwgZGVwdGgwKSlcbiAgICArIFwiJTtsZWZ0OlwiXG4gICAgKyBhbGlhczEoKGhlbHBlcnMubXVsdGlwbHkgfHwgKGRlcHRoMCAmJiBkZXB0aDAubXVsdGlwbHkpIHx8IGhlbHBlcnMuaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LGRlcHRoMCwoZGF0YSAmJiBkYXRhLmluZGV4KSx7XCJuYW1lXCI6XCJtdWx0aXBseVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSlcbiAgICArIFwiJTtcXFwiPiZuYnNwOzwvZGl2PlxcblwiO1xufSxcIjNcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazE7XG5cbiAgcmV0dXJuICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSxkZXB0aDAse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSg0LCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKTtcbn0sXCI0XCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxO1xuXG4gIHJldHVybiBcIiBcXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LGRlcHRoMCx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDUsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpO1xufSxcIjVcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazE7XG5cbiAgcmV0dXJuIFwiIFxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sZGVwdGgwLHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDYsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpO1xufSxcIjZcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LCBhbGlhczI9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBhbGlhczM9Y29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb24sIGFsaWFzND1jb250YWluZXIubGFtYmRhO1xuXG4gIHJldHVybiBcIiBcXG48ZGl2IGRhdGEtaWQ9XFxcIlwiXG4gICAgKyBhbGlhczMoKGhlbHBlcnMuc3RhbXAgfHwgKGRlcHRoMCAmJiBkZXB0aDAuc3RhbXApIHx8IGFsaWFzMikuY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1vZGVsIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJzdGFtcFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSlcbiAgICArIFwiXFxcIiBcXG4gICAgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctYWxsZGF5LWV2ZW50LWJsb2NrIFwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAucmVuZGVyU3RhcnRzIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSg3LCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzW1wiaWZcIl0uY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnJlbmRlckVuZHMgOiBkZXB0aDApLHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDksIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIlxcXCJcXG4gICAgc3R5bGU9XFxcInRvcDpcIlxuICAgICsgYWxpYXMzKChoZWxwZXJzLm11bHRpcGx5IHx8IChkZXB0aDAgJiYgZGVwdGgwLm11bHRpcGx5KSB8fCBhbGlhczIpLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50b3AgOiBkZXB0aDApLCgoc3RhY2sxID0gKGRhdGEgJiYgZGF0YS5yb290KSkgJiYgc3RhY2sxLmV2ZW50QmxvY2tIZWlnaHQpLHtcIm5hbWVcIjpcIm11bHRpcGx5XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKVxuICAgICsgXCJweDtsZWZ0OlwiXG4gICAgKyBhbGlhczMoKGhlbHBlcnMubXVsdGlwbHkgfHwgKGRlcHRoMCAmJiBkZXB0aDAubXVsdGlwbHkpIHx8IGFsaWFzMikuY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmxlZnQgOiBkZXB0aDApLCgoc3RhY2sxID0gKGRhdGEgJiYgZGF0YS5yb290KSkgJiYgc3RhY2sxLndpZHRoKSx7XCJuYW1lXCI6XCJtdWx0aXBseVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSlcbiAgICArIFwiJTt3aWR0aDpcIlxuICAgICsgYWxpYXMzKChoZWxwZXJzLm11bHRpcGx5IHx8IChkZXB0aDAgJiYgZGVwdGgwLm11bHRpcGx5KSB8fCBhbGlhczIpLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC53aWR0aCA6IGRlcHRoMCksKChzdGFjazEgPSAoZGF0YSAmJiBkYXRhLnJvb3QpKSAmJiBzdGFjazEud2lkdGgpLHtcIm5hbWVcIjpcIm11bHRpcGx5XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKVxuICAgICsgXCIlO2hlaWdodDpcIlxuICAgICsgYWxpYXMzKGFsaWFzNCgoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS5ldmVudEJsb2NrSGVpZ2h0KSwgZGVwdGgwKSlcbiAgICArIFwicHg7bWFyZ2luLXRvcDpcIlxuICAgICsgYWxpYXMzKGFsaWFzNCgoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS5ldmVudEJsb2NrR3V0dGVyKSwgZGVwdGgwKSlcbiAgICArIFwicHhcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LWFsbGRheS1ldmVudFxcXCIgc3R5bGU9XFxcImhlaWdodDpcIlxuICAgICsgYWxpYXMzKGFsaWFzNCgoKHN0YWNrMSA9IChkYXRhICYmIGRhdGEucm9vdCkpICYmIHN0YWNrMS5ldmVudEhlaWdodCksIGRlcHRoMCkpXG4gICAgKyBcInB4O2JhY2tncm91bmQtY29sb3I6XCJcbiAgICArIGFsaWFzMyhhbGlhczQoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubW9kZWwgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLmJnQ29sb3IgOiBzdGFjazEpLCBkZXB0aDApKVxuICAgICsgXCJcXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctYWxsZGF5LWV2ZW50LXRpdGxlXFxcIiBzdHlsZT1cXFwiY29sb3I6XCJcbiAgICArIGFsaWFzMyhhbGlhczQoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubW9kZWwgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLmNvbG9yIDogc3RhY2sxKSwgZGVwdGgwKSlcbiAgICArIFwiXFxcIj5cIlxuICAgICsgYWxpYXMzKGFsaWFzNCgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tb2RlbCA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEudGl0bGUgOiBzdGFjazEpLCBkZXB0aDApKVxuICAgICsgXCI8L3NwYW4+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1hbGxkYXktcmVzaXplLWhhbmRsZSBoYW5kbGUteVxcXCI+Jm5ic3A7PC9zcGFuPlxcbiAgICA8L2Rpdj4gXFxuPC9kaXY+XFxuXCI7XG59LFwiN1wiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgcmV0dXJuIFwiIHNjaGVkdWxlLXZpZXctYWxsZGF5LWV4Y2VlZC1sZWZ0XCI7XG59LFwiOVwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgcmV0dXJuIFwiIHNjaGVkdWxlLXZpZXctYWxsZGF5LWV4Y2VlZC1yaWdodFwiO1xufSxcImNvbXBpbGVyXCI6WzcsXCI+PSA0LjAuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9O1xuXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctbW9udGh3ZWVrLWdyaWRcXFwiPlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZXZlbnRHcmlkIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDEsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctbW9udGh3ZWVrLWV2ZW50c1xcXCI+XFxuXCJcbiAgICArICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tYXRyaWNlcyA6IGRlcHRoMCkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgzLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L2Rpdj5cXG5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJlZ2lzdGVyIGRldmVsb3BlZCBjdXN0b20gaGFuZGxlYmFycyBoZWxwZXIuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGhlbHBlciA9IHJlcXVpcmUoJy4vaGVscGVyJyk7XG52YXIgSGFuZGxlYmFycyA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcblxudXRpbC5mb3JFYWNoKGhlbHBlciwgZnVuY3Rpb24oaGVscGVyLCBuYW1lKSB7XG4gICAgSGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcihuYW1lLCBoZWxwZXIpO1xufSwgdGhpcyk7XG5cbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZSh7XCJjb21waWxlclwiOls3LFwiPj0gNC4wLjBcIl0sXCJtYWluXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgaGVscGVyO1xuXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctYWxsZGF5LWxlZnRcXFwiPlxcbiAgICA8c3Bhbj5cIlxuICAgICsgY29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy50aXRsZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudGl0bGUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVycy5oZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gXCJmdW5jdGlvblwiID8gaGVscGVyLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSx7XCJuYW1lXCI6XCJ0aXRsZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCI8L3NwYW4+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy1hbGxkYXktcmlnaHRcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LWFsbGRheS1tb250aHdlZWstY29udGFpbmVyXFxcIj48L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pO1xuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcIjFcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBoZWxwZXIsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LCBhbGlhczI9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBhbGlhczM9XCJmdW5jdGlvblwiLCBhbGlhczQ9Y29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzW1wiZGF5bmFtZS1pc0hvbGxpZGF5XCJdIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMFtcImRheW5hbWUtaXNIb2xsaWRheVwiXSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiZGF5bmFtZS1pc0hvbGxpZGF5XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIlxcXCIgc3R5bGU9XFxcIlwiXG4gICAgKyBhbGlhczQoKGhlbHBlcnNbXCJjb21tb24td2lkdGhcIl0gfHwgKGRlcHRoMCAmJiBkZXB0aDBbXCJjb21tb24td2lkdGhcIl0pIHx8IGFsaWFzMikuY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLndpZHRoIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJjb21tb24td2lkdGhcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpXG4gICAgKyBcIlxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctZGF5bmFtZS1sYWJlbFxcXCI+XCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLmRheU5hbWUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmRheU5hbWUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcImRheU5hbWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctZGF5bmFtZS1kYXRlXFxcIj5cIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuZGF0ZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZGF0ZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiZGF0ZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCI8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbn0sXCJjb21waWxlclwiOls3LFwiPj0gNC4wLjBcIl0sXCJtYWluXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxO1xuXG4gIHJldHVybiAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sZGVwdGgwLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMSwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIik7XG59LFwidXNlRGF0YVwiOnRydWV9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZSh7XCIxXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxO1xuXG4gIHJldHVybiAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sZGVwdGgwLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMiwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIik7XG59LFwiMlwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMTtcblxuICByZXR1cm4gKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LGRlcHRoMCx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDMsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpO1xufSxcIjNcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazE7XG5cbiAgcmV0dXJuICgoc3RhY2sxID0gaGVscGVyc1tcImlmXCJdLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiB7fSxkZXB0aDAse1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oNCwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiXFxuXCI7XG59LFwiNFwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMSwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sIGFsaWFzMj1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGFsaWFzMz1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbiwgYWxpYXM0PWNvbnRhaW5lci5sYW1iZGE7XG5cbiAgcmV0dXJuIFwiICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy10aW1lLWRhdGUtZXZlbnQtYmxvY2tcXFwiIGRhdGEtaWQ9XFxcIlwiXG4gICAgKyBhbGlhczMoKGhlbHBlcnMuc3RhbXAgfHwgKGRlcHRoMCAmJiBkZXB0aDAuc3RhbXApIHx8IGFsaWFzMikuY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1vZGVsIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJzdGFtcFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSlcbiAgICArIFwiXFxcIiBzdHlsZT1cXFwiXCJcbiAgICArIGFsaWFzMygoaGVscGVyc1tcInRpbWUtZXZlbnRCbG9ja1wiXSB8fCAoZGVwdGgwICYmIGRlcHRoMFtcInRpbWUtZXZlbnRCbG9ja1wiXSkgfHwgYWxpYXMyKS5jYWxsKGFsaWFzMSxkZXB0aDAse1wibmFtZVwiOlwidGltZS1ldmVudEJsb2NrXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKVxuICAgICsgXCJcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LXRpbWUtZXZlbnRcXFwiIHN0eWxlPVxcXCJjb2xvcjpcIlxuICAgICsgYWxpYXMzKGFsaWFzNCgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tb2RlbCA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuY29sb3IgOiBzdGFjazEpLCBkZXB0aDApKVxuICAgICsgXCI7YmFja2dyb3VuZC1jb2xvcjpcIlxuICAgICsgYWxpYXMzKGFsaWFzNCgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tb2RlbCA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuYmdDb2xvciA6IHN0YWNrMSksIGRlcHRoMCkpXG4gICAgKyBcIlxcXCI+XCJcbiAgICArIGFsaWFzMyhhbGlhczQoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubW9kZWwgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLnRpdGxlIDogc3RhY2sxKSwgZGVwdGgwKSlcbiAgICArIFwiPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctdGltZS1yZXNpemUtaGFuZGxlIGhhbmRsZS14XFxcIj4mbmJzcDs8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cIjtcbn0sXCJjb21waWxlclwiOls3LFwiPj0gNC4wLjBcIl0sXCJtYWluXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxO1xuXG4gIHJldHVybiAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1hdHJpY2VzIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDEsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoe1wiMVwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sIGFsaWFzMj1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGFsaWFzMz1cImZ1bmN0aW9uXCIsIGFsaWFzND1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbjtcblxuICByZXR1cm4gXCI8bGkgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctdGltZWdyaWQtaG91ci1cIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuaG91ciB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaG91ciA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiaG91clwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJcXFwiPjxzcGFuPlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5ob3VyIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5ob3VyIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJob3VyXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIjwvc3Bhbj48L2xpPlwiO1xufSxcIjNcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctdGltZWdyaWQtZ3JpZFxcXCI+PC9kaXY+XCI7XG59LFwiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMSwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge307XG5cbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy10aW1lZ3JpZFxcXCI+XFxuICAgIDx1bCBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy10aW1lZ3JpZC1sZWZ0XFxcIj5cXG4gICAgICAgIFwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaG91cnMgOiBkZXB0aDApLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMSwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiXFxuICAgIDwvdWw+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctdGltZWdyaWQtcmlnaHRcXFwiPlxcbiAgICAgICAgXCJcbiAgICArICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5ob3VycyA6IGRlcHRoMCkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgzLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCJcXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctdGltZWdyaWQtZXZlbnRzXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctdGltZWdyaWQtZXZlbnRzLWNvbnRhaW5lclxcXCI+PC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LXRpbWVncmlkLWhvdXJtYXJrZXJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInNjaGVkdWxlLXZpZXctdGltZWdyaWQtaG91cm1hcmtlci13cmFwXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY2hlZHVsZS12aWV3LXRpbWVncmlkLWhvdXJtYXJrZXItbGluZVxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy10aW1lZ3JpZC1ob3VybWFya2VyLXRpbWVcXFwiPjAwOjAwPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwic2NoZWR1bGUtdmlldy10aW1lZ3JpZC10b2RheW1hcmtlclxcXCI+dG9kYXk8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoZSBiYXNlIGNsYXNzIG9mIHZpZXdzLlxuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBnbG9iYWwubmUudXRpbDtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2NvbGxlY3Rpb24nKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIG9mIHZpZXdzLlxuICpcbiAqIEFsbCB2aWV3cyBjcmVhdGUgb3duIGNvbnRhaW5lciBlbGVtZW50IGluc2lkZSBzdXBwbGllZCBjb250YWluZXIgZWxlbWVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvcHRpb25zfSBvcHRpb25zIFRoZSBvYmplY3QgZm9yIGRlc2NyaWJlIHZpZXcncyBzcGVjcy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBEZWZhdWx0IGNvbnRhaW5lciBlbGVtZW50IGZvciB2aWV3LiB5b3UgY2FuIHVzZSB0aGlzIGVsZW1lbnQgZm9yIHRoaXMuY29udGFpbmVyIHN5bnRheC5cbiAqL1xuZnVuY3Rpb24gVmlldyhvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICB2YXIgaWQgPSB1dGlsLnN0YW1wKHRoaXMpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChjb250YWluZXIpKSB7XG4gICAgICAgIGNvbnRhaW5lciA9IGRvbXV0aWwuYXBwZW5kSFRNTEVsZW1lbnQoJ2RpdicpO1xuICAgIH1cblxuICAgIGRvbXV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnc2NoZWR1bGUtdmlldy0nICsgaWQpO1xuXG4gICAgLyoqXG4gICAgICogdW5pcXVlIGlkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gaWQ7XG5cbiAgICAvKipcbiAgICAgKiBiYXNlIGVsZW1lbnQgb2Ygdmlldy5cbiAgICAgKiBAdHlwZSB7SFRNTERJVkVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICAvKmVzbGludC1kaXNhYmxlKi9cbiAgICAvKipcbiAgICAgKiBjaGlsZCB2aWV3cy5cbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNoaWxkcyA9IG5ldyBDb2xsZWN0aW9uKGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuc3RhbXAodmlldyk7XG4gICAgfSk7XG4gICAgLyplc2xpbnQtZW5hYmxlKi9cblxuICAgIC8qKlxuICAgICAqIHBhcmVudCB2aWV3IGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtWaWV3fVxuICAgICAqL1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBBZGQgY2hpbGQgdmlld3MuXG4gKiBAcGFyYW0ge1ZpZXd9IHZpZXcgVGhlIHZpZXcgaW5zdGFuY2UgdG8gYWRkLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZuXSBGdW5jdGlvbiBmb3IgaW52b2tlIGJlZm9yZSBhZGQuIHBhcmVudCB2aWV3IGNsYXNzIGlzIHN1cHBsaWVkIGZpcnN0IGFyZ3VtZW50cy5cbiAqL1xuVmlldy5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbih2aWV3LCBmbikge1xuICAgIGlmIChmbikge1xuICAgICAgICBmbi5jYWxsKHZpZXcsIHRoaXMpO1xuICAgIH1cbiAgICAvLyBhZGQgcGFyZW50IHZpZXdcbiAgICB2aWV3LnBhcmVudCA9IHRoaXM7XG5cbiAgICB0aGlzLmNoaWxkcy5hZGQodmlldyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhZGRlZCBjaGlsZCB2aWV3LlxuICogQHBhcmFtIHsobnVtYmVyfFZpZXcpfSBpZCBWaWV3IGlkIG9yIGluc3RhbmNlIGl0c2VsZiB0byByZW1vdmUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZm5dIEZ1bmN0aW9uIGZvciBpbnZva2UgYmVmb3JlIHJlbW92ZS4gcGFyZW50IHZpZXcgY2xhc3MgaXMgc3VwcGxpZWQgZmlyc3QgYXJndW1lbnRzLlxuICovXG5WaWV3LnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uKGlkLCBmbikge1xuICAgIHZhciB2aWV3ID0gdXRpbC5pc051bWJlcihpZCkgPyB0aGlzLmNoaWxkcy5pdGVtc1tpZF0gOiBpZDtcblxuICAgIGlkID0gdXRpbC5zdGFtcCh2aWV3KTtcblxuICAgIGlmIChmbikge1xuICAgICAgICBmbi5jYWxsKHZpZXcsIHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGRzLnJlbW92ZShpZCk7XG59O1xuXG4vKipcbiAqIFJlbmRlciB2aWV3IHJlY3Vyc2l2ZWx5LlxuICovXG5WaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNoaWxkcy5lYWNoKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICBjaGlsZFZpZXcucmVuZGVyKCk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEludm9rZSBmdW5jdGlvbiByZWN1cnNpdmVseS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gZnVuY3Rpb24gdG8gaW52b2tlIGNoaWxkIHZpZXcgcmVjdXJzaXZlbHlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBUaGlzPWZhbHNlXSAtIHNldCB0cnVlIHRoZW4gc2tpcCBpbnZva2Ugd2l0aCB0aGlzKHJvb3QpIHZpZXcuXG4gKi9cblZpZXcucHJvdG90eXBlLnJlY3Vyc2l2ZSA9IGZ1bmN0aW9uKGZuLCBza2lwVGhpcykge1xuICAgIGlmICghdXRpbC5pc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFza2lwVGhpcykge1xuICAgICAgICBmbih0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLmNoaWxkcy5lYWNoKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICBjaGlsZFZpZXcucmVjdXJzaXZlKGZuKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmVzaXplIHZpZXcgcmVjdXJzaXZlbHkgdG8gcGFyZW50LlxuICovXG5WaWV3LnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKHBhcmVudC5fb25SZXNpemUpKSB7XG4gICAgICAgICAgICBwYXJlbnQuX29uUmVzaXplLmFwcGx5KHBhcmVudCwgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbn07XG5cbi8qKlxuICogSW52b2tpbmcgbWV0aG9kIGJlZm9yZSBkZXN0cm95aW5nLlxuICovXG5WaWV3LnByb3RvdHlwZS5fYmVmb3JlRGVzdHJveSA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogQ2xlYXIgcHJvcGVydGllc1xuICovXG5WaWV3LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JlZm9yZURlc3Ryb3koKTtcbiAgICB0aGlzLmNoaWxkcy5jbGVhcigpO1xuICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuXG4gICAgdGhpcy5pZCA9IHRoaXMucGFyZW50ID0gdGhpcy5jaGlsZHMgPSB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG59O1xuXG4vKmVzbGludC1kaXNhYmxlKi9cbi8qKlxuICogRGVzdHJveSBjaGlsZCB2aWV3IHJlY3Vyc2l2ZWx5LlxuICovXG5WaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oaXNDaGlsZFZpZXcpIHtcbiAgICB0aGlzLmNoaWxkcy5lYWNoKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICBjaGlsZFZpZXcuZGVzdHJveSh0cnVlKTtcbiAgICAgICAgY2hpbGRWaWV3Ll9kZXN0cm95KCk7XG4gICAgfSk7XG5cbiAgICBpZiAoaXNDaGlsZFZpZXcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2Rlc3Ryb3koKTtcbn07XG4vKmVzbGludC1lbmFibGUqL1xuXG4vKipcbiAqIENhbGN1bGF0ZSB2aWV3J3MgY29udGFpbmVyIGVsZW1lbnQgYm91bmQuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgYm91bmQgb2YgY29udGFpbmVyIGVsZW1lbnQuXG4gKi9cblZpZXcucHJvdG90eXBlLmdldFZpZXdCb3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgcG9zaXRpb24gPSBkb211dGlsLmdldFBvc2l0aW9uKGNvbnRhaW5lciksXG4gICAgICAgIHNpemUgPSBkb211dGlsLmdldFNpemUoY29udGFpbmVyKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBvc2l0aW9uWzBdLFxuICAgICAgICB5OiBwb3NpdGlvblsxXSxcbiAgICAgICAgd2lkdGg6IHNpemVbMF0sXG4gICAgICAgIGhlaWdodDogc2l6ZVsxXVxuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXc7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBWaWV3IG9mIGFsbGRheSBldmVudCBjb250YWluZXIgaW5zaWRlIG9mIFdlZWsgdmlldy5cbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXcnKTtcbnZhciBNb250aFdlZWsgPSByZXF1aXJlKCcuLi9tb250aHdlZWsnKTtcbnZhciBtYWluVG1wbCA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlL3dlZWsvYWxsZGF5LmhicycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge1ZpZXd9XG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBUaGUgb2JqZWN0IGZvciB2aWV3IGN1c3RvbWl6YXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yZW5kZXJTdGFydERhdGUgLSBzdGFydCBkYXRlIG9mIGFsbGRheSB2aWV3J3MgcmVuZGVyIGRhdGUuIFlZWVktTU0tRERcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJlbmRlckVuZERhdGUgLSBlbmQgZGF0ZSBvZiBhbGxkYXkgdmlldydzIHJlbmRlciBkYXRlLiBZWVlZLU1NLUREXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaGVpZ2h0PTYwXSAtIG1pbmltdW0gaGVpZ2h0IG9mIGV2ZW50IGNvbnRhaW5lciBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmV2ZW50QmxvY2tIZWlnaHQ9MThdIC0gaGVpZ2h0IG9mIGVhY2ggZXZlbnQgYmxvY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZXZlbnRCbG9ja0d1dHRlcj0yXSAtIGd1dHRlciBoZWlnaHQgb2YgZWFjaCBldmVudCBibG9jay5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLl9nZXRWaWV3TW9kZWxGdW5jXSAtIGZ1bmN0aW9uIGZvciBleHRyYWN0IHBhcnRpYWwgdmlldyBtb2RlbCBkYXRhIGZyb20gd2hvbGUgdmlldyBtb2RlbHMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgQ29udGFpbmVyIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIEFsbGRheShvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICBjb250YWluZXIgPSBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAnc2NoZWR1bGUtdmlldy1hbGxkYXktY29udGFpbmVyJ1xuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiByZW5kZXJpbmcgb3B0aW9ucy5cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgdGl0bGU6ICfsooXsnbzsnbzsoJUnLFxuICAgICAgICByZW5kZXJTdGFydERhdGU6ICcnLFxuICAgICAgICByZW5kZXJFbmREYXRlOiAnJyxcbiAgICAgICAgY29udGFpbmVySGVpZ2h0OiA0MCxcbiAgICAgICAgY29udGFpbmVyQm90dG9tR3V0dGVyOiA4LFxuICAgICAgICBldmVudEhlaWdodDogMTgsXG4gICAgICAgIGV2ZW50R3V0dGVyOiAyLFxuICAgICAgICBfZ2V0Vmlld01vZGVsRnVuYzogZnVuY3Rpb24odmlld01vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlld01vZGVsLmV2ZW50c0luRGF0ZVJhbmdlLmFsbGRheTtcbiAgICAgICAgfVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgVmlldy5jYWxsKHRoaXMsIG51bGwsIGNvbnRhaW5lcik7XG59XG5cbnV0aWwuaW5oZXJpdChBbGxkYXksIFZpZXcpO1xuXG4vKipcbiAqIGNyZWF0ZSBtb250aCB3ZWVrIHZpZXcgbW9kZWwgZm9yIHJlbmRlciBhbGxkYXkgZXZlbnRzIGluIHRvcCBvZiB3ZWVrIHZpZXdzLlxuICogQG92ZXJyaWRlXG4gKiBAcGFyYW0ge29iamVjdH0gdmlld01vZGVsIC0gdmlld01vZGVsIGZyb20gcGFyZW50IHZpZXdzLlxuICovXG5BbGxkYXkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgbW9udGhXZWVrSW5zdDtcblxuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBtYWluVG1wbCh0aGlzLm9wdGlvbnMpO1xuXG4gICAgdGhpcy5jaGlsZHMuY2xlYXIoKTtcblxuICAgIG1vbnRoV2Vla0luc3QgPSBuZXcgTW9udGhXZWVrKFxuICAgICAgICB0aGlzLm9wdGlvbnMsIFxuICAgICAgICBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LWFsbGRheS1tb250aHdlZWstY29udGFpbmVyJywgY29udGFpbmVyKVxuICAgICk7XG5cbiAgICB0aGlzLmFkZENoaWxkKG1vbnRoV2Vla0luc3QpO1xuXG4gICAgdGhpcy5jaGlsZHMuZWFjaChmdW5jdGlvbihjaGlsZFZpZXcpIHtcbiAgICAgICAgY2hpbGRWaWV3LnJlbmRlcih2aWV3TW9kZWwpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbGxkYXk7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBWaWV3IGZvciByZW5kZXJpbmcgZGF5bmFtZXNcbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gZ2xvYmFsLm5lLnV0aWw7XG52YXIgZGF0ZXRpbWUgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZGF0ZXRpbWUnKTtcbnZhciBkb211dGlsID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RvbXV0aWwnKTtcbnZhciBWaWV3ID0gcmVxdWlyZSgnLi4vdmlldycpO1xudmFyIGRheW5hbWVUbXBsID0gcmVxdWlyZSgnLi4vdGVtcGxhdGUvd2Vlay9kYXluYW1lcy5oYnMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbiB7b2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgZGF5bmFtZSB2aWV3XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgQ29udGFpbmVyIGVsZW1lbnQgdG8gdXNlLlxuICogQGV4dGVuZHMge1ZpZXd9XG4gKi9cbmZ1bmN0aW9uIERheU5hbWUob3B0aW9ucywgY29udGFpbmVyKSB7XG4gICAgY29udGFpbmVyID0gZG9tdXRpbC5hcHBlbmRIVE1MRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgJ3NjaGVkdWxlLXZpZXctZGF5bmFtZS1jb250YWluZXInXG4gICAgKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgZGF5bmFtZXM6IFsn7J28JywgJ+yblCcsICftmZQnLCAn7IiYJywgJ+uqqScsICfquIgnLCAn7YagJ11cbiAgICB9LCBvcHRpb25zKTtcblxuICAgIFZpZXcuY2FsbCh0aGlzLCBudWxsLCBjb250YWluZXIpO1xufVxuXG51dGlsLmluaGVyaXQoRGF5TmFtZSwgVmlldyk7XG5cbi8qKlxuICogR2V0IGRlZmF1bHQgdmlld21vZGVscy5cbiAqIEBwYXJhbSB7RGF0ZX0gc3RhcnQgVGhlIGRhdGUgb2Ygc3RhcnQgcmVuZGVyXG4gKiBAcGFyYW0ge0RhdGV9IGVuZCBUaGUgZW5kIG9mIGVuZCByZW5kZXJcbiAqIEByZXR1cm5zIHthcnJheX0gdmlld21vZGVsLlxuICovXG5EYXlOYW1lLnByb3RvdHlwZS5fZ2V0QmFzZVZpZXdNb2RlbCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgZGF5bmFtZXMgPSB0aGlzLm9wdGlvbnMuZGF5bmFtZXMsXG4gICAgICAgIHZpZXdNb2RlbDtcblxuICAgIHZpZXdNb2RlbCA9IHV0aWwubWFwKGRhdGV0aW1lLnJhbmdlKFxuICAgICAgICBkYXRldGltZS5zdGFydChzdGFydCksXG4gICAgICAgIGRhdGV0aW1lLnN0YXJ0KGVuZCksXG4gICAgICAgIGRhdGV0aW1lLk1JTExJU0VDT05EU19QRVJfREFZXG4gICAgKSwgZnVuY3Rpb24oZCwgaSwgYXJyKSB7XG4gICAgICAgIHZhciBkYXkgPSBkLmdldERheSgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXk6IGRheSxcbiAgICAgICAgICAgIGRheU5hbWU6IGRheW5hbWVzW2RheV0sXG4gICAgICAgICAgICBkYXRlOiBkLmdldERhdGUoKSxcbiAgICAgICAgICAgIHdpZHRoOiAxMDAgLyBhcnIubGVuZ3RoXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdmlld01vZGVsO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2aWV3TW9kZWwgVmlldyBtb2RlbCBmcm9tIHBhcmVudCAoV2Vla1ZpZXcpXG4gKi9cbkRheU5hbWUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgIHZhciBfdmlld01vZGVsID0gdGhpcy5fZ2V0QmFzZVZpZXdNb2RlbChcbiAgICAgICAgdmlld01vZGVsLnJlbmRlclN0YXJ0RGF0ZSxcbiAgICAgICAgdmlld01vZGVsLnJlbmRlckVuZERhdGVcbiAgICApO1xuXG4gICAgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gZGF5bmFtZVRtcGwoX3ZpZXdNb2RlbCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERheU5hbWU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBWaWV3IG9mIHRpbWUuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgZG9tdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9kb211dGlsJyk7XG52YXIgVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXcnKTtcbnZhciB0aW1lVG1wbCA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlL3dlZWsvdGltZS5oYnMnKTtcbnZhciBmb3JFYWNoQXJyID0gdXRpbC5mb3JFYWNoQXJyYXk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7Vmlld31cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBEYXRlIGVsZW1lbnQgd2lkdGggKHBlcmNlbnQpXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBPcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy55bWQgWVlZTU1ERCBzdHJpbmcgZm9yIHRoaXMgdmlld1xuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmlzVG9kYXkgd2hlbiBzZXQgdHJ1ZSB0aGVuIGFzc2lnbiB0b2RheSBkZXNpZ24gY2xhc3MgdG8gY29udGFpbmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuaG91clN0YXJ0IENhbiBsaW1pdCBvZiByZW5kZXIgaG91ciBzdGFydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmhvdXJFbmQgQ2FuIGxpbWl0IG9mIHJlbmRlciBob3VyIGVuZC5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBFbGVtZW50IHRvIHVzZSBjb250YWluZXIgZm9yIHRoaXMgdmlldy5cbiAqL1xuZnVuY3Rpb24gVGltZSh3aWR0aCwgb3B0aW9ucywgY29udGFpbmVyKSB7XG4gICAgVmlldy5jYWxsKHRoaXMsIG51bGwsIGNvbnRhaW5lcik7XG5cbiAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSB3aWR0aCArICclJztcblxuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgeW1kOiAnJyxcbiAgICAgICAgaXNUb2RheTogZmFsc2UsXG4gICAgICAgIGhvdXJTdGFydDogMCxcbiAgICAgICAgaG91ckVuZDogMjRcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaXNUb2RheSkge1xuICAgICAgICBkb211dGlsLmFkZENsYXNzKHRoaXMuY29udGFpbmVyLCAnc2NoZWR1bGUtdmlldy10aW1lLWRhdGUtdG9kYXknKTtcbiAgICB9XG59XG5cbnV0aWwuaW5oZXJpdChUaW1lLCBWaWV3KTtcblxuLyoqXG4gKiBDb252ZXJ0IFlZWVlNTUREIGZvcm1hdHRlZCBzdHJpbmcgZGF0ZSB0byBEYXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBmb3JtYXR0ZWQgc3RyaW5nLlxuICogQHJldHVybnMge0RhdGV9IHN0YXJ0IG9mIGRhdGUuXG4gKi9cblRpbWUucHJvdG90eXBlLl9wYXJzZURhdGVHcm91cCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciB5ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigwLCA0KSwgMTApLFxuICAgICAgICBtID0gcGFyc2VJbnQoc3RyLnN1YnN0cig0LCAyKSwgMTApLFxuICAgICAgICBkID0gcGFyc2VJbnQoc3RyLnN1YnN0cig2LCAyKSwgMTApO1xuXG4gICAgcmV0dXJuIG5ldyBEYXRlKHksIG0gLSAxLCBkKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFdmVudFZpZXdNb2RlbH0gdmlld01vZGVsIC0gdmlldyBtb2RlbCBpbnN0YW5jZSB0byBjYWxjdWxhdGUgYm91bmQuXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIGNhbGN1bGF0aW5nIGV2ZW50IGVsZW1lbnQncyBib3VuZC5cbiAqIEBwYXJhbSB7RGF0ZX0gb3B0aW9ucy50b2RheVN0YXJ0IC0gZGF0ZSBvYmplY3QgcmVwcmVzZW50IGV2ZW50IGRhdGUncyBzdGFydCAoMDA6MDA6MDApXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5iYXNlTVMgLSB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byByZW5kZXIgZXZlbnQgYmxvY2tzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuYmFzZUhlaWdodCAtIHBpeGVsIHZhbHVlIHJlbGF0ZWQgd2l0aCBiYXNlTVMgb3B0aW9ucy5cbiAqIEBwYXJhbSB7bnVtYmVyW119IG9wdGlvbnMuYmFzZUxlZnQgLSBsZWZ0IHBvc2l0aW9uIHBlcmNlbnRzIGZvciBlYWNoIGNvbHVtbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5iYXNlV2lkdGggLSB0aGUgdW5pdCBvZiBldmVudCBibG9ja3Mgd2lkdGggcGVyY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNvbHVtbkluZGV4IC0gdGhlIG51bWJlciBpbmRleCBvZiBldmVudCBibG9ja3MuXG4gKiBpdCByZXByZXNlbnQgcmVuZGVyaW5nIGluZGV4IGZyb20gbGVmdCBzaWRlcyBpbiB2aWV3LlxuICogQHJldHVybnMge29iamVjdH0gYm91bmQgb2JqZWN0IGZvciBzdXBwbGllZCB2aWV3IG1vZGVsLlxuICovXG5UaW1lLnByb3RvdHlwZS5nZXRFdmVudFZpZXdCb3VuZCA9IGZ1bmN0aW9uKHZpZXdNb2RlbCwgb3B0aW9ucykge1xuICAgIHZhciBiYXNlTVMgPSBvcHRpb25zLmJhc2VNUyxcbiAgICAgICAgYmFzZUhlaWdodCA9IG9wdGlvbnMuYmFzZUhlaWdodCxcbiAgICAgICAgb2Zmc2V0U3RhcnQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHRvcDtcblxuICAgIG9mZnNldFN0YXJ0ID0gdmlld01vZGVsLnZhbHVlT2YoKS5zdGFydHMgLSBvcHRpb25zLnRvZGF5U3RhcnQ7XG5cbiAgICAvLyBjb250YWluZXJIZWlnaHQgOiBtaWxsaXNlY29uZHMgaW4gZGF5ID0geCA6IGV2ZW50J3MgbWlsbGlzZWNvbmRzXG4gICAgdG9wID0gKGJhc2VIZWlnaHQgKiBvZmZzZXRTdGFydCkgLyBiYXNlTVM7XG4gICAgaGVpZ2h0ID0gKGJhc2VIZWlnaHQgKiB2aWV3TW9kZWwuZHVyYXRpb24oKSkgLyBiYXNlTVM7XG4gICAgd2lkdGggPSBvcHRpb25zLmJhc2VXaWR0aCAqICh2aWV3TW9kZWwuZXh0cmFTcGFjZSArIDEpO1xuXG4gICAgLy8gc2V0IHdpZHRoIGF1dG8gd2hlbiBoYXMgbm8gY29sbGlzaW9ucy5cbiAgICBpZiAoIXZpZXdNb2RlbC5oYXNDb2xsaWRlKSB7XG4gICAgICAgIHdpZHRoID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgbGVmdDogb3B0aW9ucy5iYXNlTGVmdFtvcHRpb25zLmNvbHVtbkluZGV4XSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG59O1xuXG4vKipcbiAqIFNldCB2aWV3bW9kZWxzIGZvciByZW5kZXJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30geW1kIFRoZSBkYXRlIG9mIGV2ZW50cy4gWVlZWU1NREQgZm9ybWF0LlxuICogQHBhcmFtIHthcnJheX0gbWF0cmljZXMgVGhlIG1hdHJpY2VzIGZvciBldmVudCBwbGFjaW5nLlxuICovXG5UaW1lLnByb3RvdHlwZS5fZ2V0QmFzZVZpZXdNb2RlbCA9IGZ1bmN0aW9uKHltZCwgbWF0cmljZXMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgaG91clN0YXJ0ID0gb3B0aW9ucy5ob3VyU3RhcnQsXG4gICAgICAgIGhvdXJFbmQgPSBvcHRpb25zLmhvdXJFbmQsXG4gICAgICAgIGNvbnRhaW5lckhlaWdodCxcbiAgICAgICAgdG9kYXlTdGFydCxcbiAgICAgICAgYmFzZU1TO1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGVhY2ggZXZlbnQgZWxlbWVudCBib3VuZHMgcmVsYXRpdmUgd2l0aCByZW5kZXJlZCBob3VyIG1pbGxpc2Vjb25kcyBhbmRcbiAgICAgKiB3cmFwIGVhY2ggZXZlbnQgbW9kZWwgdG8gdmlld21vZGVscy5cbiAgICAgKi9cbiAgICBjb250YWluZXJIZWlnaHQgPSB0aGlzLmdldFZpZXdCb3VuZCgpLmhlaWdodDtcbiAgICB0b2RheVN0YXJ0ID0gdGhpcy5fcGFyc2VEYXRlR3JvdXAoeW1kKTtcbiAgICB0b2RheVN0YXJ0LnNldEhvdXJzKGhvdXJTdGFydCk7XG4gICAgYmFzZU1TID0gZGF0ZXRpbWUubWlsbGlzZWNvbmRzRnJvbSgnaG91cicsIChob3VyRW5kIC0gaG91clN0YXJ0KSk7XG5cbiAgICBmb3JFYWNoQXJyKG1hdHJpY2VzLCBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICAgICAgdmFyIG1heFJvd0xlbmd0aCxcbiAgICAgICAgICAgIHdpZHRoUGVyY2VudCxcbiAgICAgICAgICAgIGxlZnRQZXJjZW50cyxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgbWF4Um93TGVuZ3RoID0gTWF0aC5tYXguYXBwbHkobnVsbCwgdXRpbC5tYXAobWF0cml4LCBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiByb3cubGVuZ3RoO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgd2lkdGhQZXJjZW50ID0gMTAwIC8gbWF4Um93TGVuZ3RoO1xuXG4gICAgICAgIGxlZnRQZXJjZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWF4Um93TGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGxlZnRQZXJjZW50c1tpXSA9IHdpZHRoUGVyY2VudCAqIGk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JFYWNoQXJyKG1hdHJpeCwgZnVuY3Rpb24ocm93KSB7XG4gICAgICAgICAgICBmb3JFYWNoQXJyKHJvdywgZnVuY3Rpb24odmlld01vZGVsLCBjb2wpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmlld0JvdW5kO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3TW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZpZXdCb3VuZCA9IHRoaXMuZ2V0RXZlbnRWaWV3Qm91bmQodmlld01vZGVsLCB7XG4gICAgICAgICAgICAgICAgICAgIHRvZGF5U3RhcnQ6IHRvZGF5U3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VNUzogYmFzZU1TLFxuICAgICAgICAgICAgICAgICAgICBiYXNlTGVmdDogbGVmdFBlcmNlbnRzLFxuICAgICAgICAgICAgICAgICAgICBiYXNlV2lkdGg6IHdpZHRoUGVyY2VudCxcbiAgICAgICAgICAgICAgICAgICAgYmFzZUhlaWdodDogY29udGFpbmVySGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleDogY29sXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB1dGlsLmV4dGVuZCh2aWV3TW9kZWwsIHZpZXdCb3VuZCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtEYXRlfSAtIERhdGUgb2YgdGhpcyB2aWV3LlxuICovXG5UaW1lLnByb3RvdHlwZS5nZXREYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlRGF0ZUdyb3VwKHRoaXMub3B0aW9ucy55bWQpO1xufTtcblxuXG4vKipcbiAqIEBvdmVycmlkZVxuICogQHBhcmFtIHtzdHJpbmd9IHltZCBUaGUgZGF0ZSBvZiBldmVudHMuIFlZWVlNTUREIGZvcm1hdFxuICogQHBhcmFtIHthcnJheX0gbWF0cmljZXMgTWF0cmljZXMgZm9yIHBsYWNpbmcgZXZlbnRzXG4gKi9cblRpbWUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHltZCwgbWF0cmljZXMpIHtcbiAgICB0aGlzLl9nZXRCYXNlVmlld01vZGVsKHltZCwgbWF0cmljZXMpO1xuICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9IHRpbWVUbXBsKHtcbiAgICAgICAgbWF0cmljZXM6IG1hdHJpY2VzXG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWU7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBWaWV3IGZvciByZW5kZXJlZCBldmVudHMgYnkgdGltZXMuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgcmVxQW5pbUZyYW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL3JlcUFuaW1GcmFtZScpO1xudmFyIFZpZXcgPSByZXF1aXJlKCcuLi92aWV3Jyk7XG52YXIgVGltZSA9IHJlcXVpcmUoJy4vdGltZScpO1xudmFyIEF1dG9TY3JvbGwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vYXV0b1Njcm9sbCcpO1xudmFyIG1haW5UbXBsID0gcmVxdWlyZSgnLi4vdGVtcGxhdGUvd2Vlay90aW1lR3JpZC5oYnMnKTtcblxudmFyIFBJWEVMX1JFTkRFUl9FUlJPUiA9IDAuNTtcbnZhciBIT1VSTUFSS0VSX1JFRlJFU0hfSU5URVJWQUwgPSAxMDAwICogMTA7XG52YXIgSU5JVElBTF9BVVRPU0NST0xMX0RFTEFZID0gdXRpbC5icm93c2VyLm1zaWUgPyAxMDAgOiA1MDtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtWaWV3fVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgVGhlIG9iamVjdCBmb3IgdmlldyBjdXN0b21pemF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhvdXJTdGFydD0wXSBZb3UgY2FuIGNoYW5nZSB2aWV3J3Mgc3RhcnQgaG91cnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaG91ckVuZD0wXSBZb3UgY2FuIGNoYW5nZSB2aWV3J3MgZW5kIGhvdXJzLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIENvbnRhaW5lciBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBUaW1lR3JpZChvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICBjb250YWluZXIgPSBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAnc2NoZWR1bGUtdmlldy10aW1lZ3JpZC1jb250YWluZXInXG4gICAgKTtcblxuICAgIFZpZXcuY2FsbCh0aGlzLCBudWxsLCBjb250YWluZXIpO1xuXG4gICAgaWYgKCF1dGlsLmJyb3dzZXIuc2FmYXJpKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXV0b1Njcm9sbH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2F1dG9TY3JvbGwgPSBuZXcgQXV0b1Njcm9sbChjb250YWluZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRpbWUgdmlldyBvcHRpb25zLlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICBob3VyU3RhcnQ6IDAsXG4gICAgICAgIGhvdXJFbmQ6IDI0XG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcnZhbCBpZCBmb3IgaG91cm1hcmtlciBhbmltYXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmludGVydmFsSUQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fc2Nyb2xsZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuYXR0YWNoRXZlbnQoKTtcbn1cblxudXRpbC5pbmhlcml0KFRpbWVHcmlkLCBWaWV3KTtcblxuLyoqKioqKioqKipcbiAqIFByb3RvdHlwZSBwcm9wc1xuICoqKioqKioqKiovXG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuVGltZUdyaWQucHJvdG90eXBlLnZpZXdOYW1lID0gJ3RpbWVncmlkJztcblxuLyoqXG4gKiBEZXN0cm95IHZpZXcuXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVGltZUdyaWQucHJvdG90eXBlLl9iZWZvcmVEZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElEKTtcblxuICAgIGlmICh0aGlzLl9hdXRvU2Nyb2xsKSB7XG4gICAgICAgIHRoaXMuX2F1dG9TY3JvbGwuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2F1dG9TY3JvbGwgPSB0aGlzLmhvdXJtYXJrZXIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgYmFzZSB2aWV3TW9kZWwuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBWaWV3TW9kZWxcbiAqL1xuVGltZUdyaWQucHJvdG90eXBlLl9nZXRCYXNlVmlld01vZGVsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGVuZCA9IG9wdGlvbnMuaG91ckVuZCxcbiAgICAgICAgaSA9IG9wdGlvbnMuaG91clN0YXJ0LFxuICAgICAgICBob3VycyA9IFtdO1xuXG4gICAgZm9yICg7IGkgPCBlbmQ7IGkgKz0gMSkge1xuICAgICAgICBob3Vycy5wdXNoKHtob3VyOiBpfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtob3VyczogaG91cnN9O1xufTtcblxuLyoqXG4gKiBSZWNvbmNpbGF0aW9uIGNoaWxkIHZpZXdzIGFuZCByZW5kZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gdmlld01vZGVscyBWaWV3bW9kZWxcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggcGVyY2VudCBvZiBlYWNoIHRpbWUgdmlldy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBDb250YWluZXIgZWxlbWVudCBmb3IgZWFjaCB0aW1lIHZpZXcuXG4gKi9cblRpbWVHcmlkLnByb3RvdHlwZS5fcmVuZGVyQ2hpbGRzID0gZnVuY3Rpb24odmlld01vZGVscywgd2lkdGgsIGNvbnRhaW5lcikge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBjaGlsZE9wdGlvbixcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIGlzVG9kYXksXG4gICAgICAgIHRvZGF5ID0gZGF0ZXRpbWUuZm9ybWF0KG5ldyBEYXRlKCksICdZWVlZTU1ERCcpO1xuXG4gICAgLy8gY2xlYXIgY29udGVudHNcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgdGhpcy5jaGlsZHMuY2xlYXIoKTtcbiAgICB0aGlzLnRvZGF5bWFya2VyTGVmdCA9IG51bGw7XG5cbiAgICAvLyByZWNvbmNpbGF0aW9uIG9mIGNoaWxkIHZpZXdzXG4gICAgdXRpbC5mb3JFYWNoKHZpZXdNb2RlbHMsIGZ1bmN0aW9uKGV2ZW50cywgeW1kKSB7XG4gICAgICAgIGlzVG9kYXkgPSB5bWQgPT09IHRvZGF5O1xuXG4gICAgICAgIGlmIChpc1RvZGF5KSB7XG4gICAgICAgICAgICB0aGlzLnRvZGF5bWFya2VyTGVmdCA9IHdpZHRoICogdGhpcy5jaGlsZHMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGRPcHRpb24gPSB7XG4gICAgICAgICAgICB5bWQ6IHltZCxcbiAgICAgICAgICAgIGlzVG9kYXk6IGlzVG9kYXksXG4gICAgICAgICAgICBob3VyU3RhcnQ6IG9wdGlvbnMuaG91clN0YXJ0LFxuICAgICAgICAgICAgaG91ckVuZDogb3B0aW9ucy5ob3VyRW5kXG4gICAgICAgIH07XG5cbiAgICAgICAgY2hpbGQgPSBuZXcgVGltZShcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgY2hpbGRPcHRpb24sXG4gICAgICAgICAgICBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KCdkaXYnLCBjb250YWluZXIsICdzY2hlZHVsZS12aWV3LXRpbWUtZGF0ZScpXG4gICAgICAgICk7XG4gICAgICAgIGNoaWxkLnJlbmRlcih5bWQsIGV2ZW50cyk7XG5cbiAgICAgICAgdGhpcy5hZGRDaGlsZChjaGlsZCk7XG4gICAgfSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICogQHBhcmFtIHtvYmplY3R9IHZpZXdNb2RlbCBWaWV3TW9kZWwgbGlzdCBmcm9tIFdlZWsgdmlldy5cbiAqL1xuVGltZUdyaWQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgIHZhciB0aW1lVmlld01vZGVsID0gdmlld01vZGVsLmV2ZW50c0luRGF0ZVJhbmdlLnRpbWUsXG4gICAgICAgIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLFxuICAgICAgICBiYXNlVmlld01vZGVsID0gdGhpcy5fZ2V0QmFzZVZpZXdNb2RlbCgpLFxuICAgICAgICBldmVudExlbiA9IHV0aWwua2V5cyh0aW1lVmlld01vZGVsKS5sZW5ndGg7XG5cbiAgICBpZiAoIWV2ZW50TGVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gbWFpblRtcGwoYmFzZVZpZXdNb2RlbCk7XG5cbiAgICAvKioqKioqKioqKlxuICAgICAqIFJlbmRlciBjaGlsZHNcbiAgICAgKioqKioqKioqKi9cbiAgICB0aGlzLl9yZW5kZXJDaGlsZHMoXG4gICAgICAgIHRpbWVWaWV3TW9kZWwsXG4gICAgICAgIDEwMCAvIGV2ZW50TGVuLFxuICAgICAgICBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LXRpbWVncmlkLWV2ZW50cy1jb250YWluZXInLCBjb250YWluZXIpXG4gICAgKTtcblxuICAgIHRoaXMuX2hvdXJMYWJlbHMgPSBkb211dGlsLmZpbmQoJ3VsJywgY29udGFpbmVyKTtcblxuICAgIC8qKioqKioqKioqXG4gICAgICogUmVuZGVyIGhvdXJtYXJrZXJcbiAgICAgKioqKioqKioqKi9cbiAgICB0aGlzLmhvdXJtYXJrZXIgPSBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LXRpbWVncmlkLWhvdXJtYXJrZXInLCBjb250YWluZXIpO1xuICAgIHRoaXMucmVmcmVzaEhvdXJtYXJrZXIoKTtcblxuICAgIGlmICghdGhpcy5fc2Nyb2xsZWQpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNjcm9sbFRvTm93KCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZWZyZXNoIGhvdXJtYXJrZXIgZWxlbWVudC5cbiAqL1xuVGltZUdyaWQucHJvdG90eXBlLnJlZnJlc2hIb3VybWFya2VyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhvdXJMYWJlbHMgPSB0aGlzLl9ob3VyTGFiZWxzLFxuICAgICAgICBob3VybWFya2VyID0gdGhpcy5ob3VybWFya2VyLFxuXG4gICAgICAgIHZpZXdNb2RlbCA9IHRoaXMuX2dldEhvdXJtYXJrZXJWaWV3TW9kZWwoKSxcbiAgICAgICAgdG9kYXltYXJrZXJMZWZ0ID0gdGhpcy50b2RheW1hcmtlckxlZnQsXG4gICAgICAgIHRvZGF5bWFya2VyLFxuICAgICAgICB0ZXh0LFxuICAgICAgICBsYWJlbFRvVmlzaWJsZSxcbiAgICAgICAgbGFiZWxUb0ludmlzaWJsZTtcblxuICAgIGlmICghaG91cm1hcmtlciB8fCAhdmlld01vZGVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2RheW1hcmtlciA9IGRvbXV0aWwuZmluZCgnLnNjaGVkdWxlLXZpZXctdGltZWdyaWQtdG9kYXltYXJrZXInLCBob3VybWFya2VyKTtcbiAgICB0ZXh0ID0gZG9tdXRpbC5maW5kKCcuc2NoZWR1bGUtdmlldy10aW1lZ3JpZC1ob3VybWFya2VyLXRpbWUnLCBob3VybWFya2VyKTtcbiAgICBsYWJlbFRvVmlzaWJsZSA9IGRvbXV0aWwuZmluZCgnLnNjaGVkdWxlLWludmlzaWJsZScsIGhvdXJMYWJlbHMpO1xuICAgIGxhYmVsVG9JbnZpc2libGUgPSBkb211dGlsLmZpbmQoJy5zY2hlZHVsZS12aWV3LXRpbWVncmlkLWhvdXItJyArIHZpZXdNb2RlbC5ob3VyLCBob3VyTGFiZWxzKTtcblxuICAgIHJlcUFuaW1GcmFtZS5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobGFiZWxUb1Zpc2libGUgIT09IGxhYmVsVG9JbnZpc2libGUpIHtcbiAgICAgICAgICAgIGlmIChsYWJlbFRvVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGRvbXV0aWwucmVtb3ZlQ2xhc3MobGFiZWxUb1Zpc2libGUsICdzY2hlZHVsZS1pbnZpc2libGUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxhYmVsVG9JbnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBkb211dGlsLmFkZENsYXNzKGxhYmVsVG9JbnZpc2libGUsICdzY2hlZHVsZS1pbnZpc2libGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGhvdXJtYXJrZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIGhvdXJtYXJrZXIuc3R5bGUudG9wID0gKHZpZXdNb2RlbC50b3AgLSBQSVhFTF9SRU5ERVJfRVJST1IpICsgJ3B4JztcblxuICAgICAgICBpZiAoIXV0aWwuaXNOdWxsKHRvZGF5bWFya2VyTGVmdCkpIHtcbiAgICAgICAgICAgIHRvZGF5bWFya2VyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgdG9kYXltYXJrZXIuc3R5bGUubGVmdCA9IHRvZGF5bWFya2VyTGVmdCArICclJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvZGF5bWFya2VyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0LmlubmVySFRNTCA9IHZpZXdNb2RlbC50ZXh0O1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gZ3JpZCBzaXplLlxuICogQHJldHVybnMge251bWJlcltdfSBUaGUgc2l6ZSBvZiBncmlkIGVsZW1lbnQuXG4gKi9cblRpbWVHcmlkLnByb3RvdHlwZS5fZ2V0R3JpZFNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdGhpcy5jb250YWluZXIuY2hpbGROb2Rlc1swXTtcblxuICAgIGlmICghY2hpbGROb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9tdXRpbC5nZXRTaXplKGNoaWxkTm9kZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RGF0ZX0gW3RpbWVdIC0gZGF0ZSBvYmplY3QgdG8gY29udmVydCBwaXhlbCBpbiBncmlkcy5cbiAqIHVzZSAqKkRhdGUubm93KCkqKiB3aGVuIG5vdCBzdXBwbGllZC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBwaXhlbCB2YWx1ZSByZXByZXNlbnQgY3VycmVudCB0aW1lIGluIGdyaWRzLlxuICovXG5UaW1lR3JpZC5wcm90b3R5cGUuX2dldFRvcEJ5VGltZSA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICB2YXIgbm93ID0gdXRpbC5pc0RhdGUodGltZSkgPyBuZXcgRGF0ZSh0aW1lLmdldFRpbWUoKSkgOiBuZXcgRGF0ZSgpLFxuICAgICAgICBzdGFydCA9IGRhdGV0aW1lLnN0YXJ0KG5vdyksXG4gICAgICAgIGhvdXJTdGFydCA9IHRoaXMub3B0aW9ucy5ob3VyU3RhcnQsXG4gICAgICAgIGdyaWRTaXplID0gdGhpcy5fZ2V0R3JpZFNpemUoKSxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICB0b3A7XG5cbiAgICBpZiAoIWdyaWRTaXplKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIG9mZnNldCA9ICtub3cgLSArc3RhcnQ7XG4gICAgaWYgKGhvdXJTdGFydCkge1xuICAgICAgICBvZmZzZXQgLT0gZGF0ZXRpbWUubWlsbGlzZWNvbmRzRnJvbSgnaG91cicsIGhvdXJTdGFydCk7XG4gICAgfVxuXG4gICAgdG9wID0gKG9mZnNldCAqIGdyaWRTaXplWzFdKSAvIChkYXRldGltZS5taWxsaXNlY29uZHNGcm9tKCdob3VyJywgdGhpcy5fZ2V0QmFzZVZpZXdNb2RlbCgpLmhvdXJzLmxlbmd0aCkpO1xuXG4gICAgcmV0dXJuIHRvcDtcbn07XG5cbi8qKlxuICogR2V0IEhvdXJtYXJrZXIgdmlld21vZGVsLlxuICogQHJldHVybnMge29iamVjdH0gVmlld01vZGVsIG9mIGhvdXJtYXJrZXIuXG4gKi9cblRpbWVHcmlkLnByb3RvdHlwZS5fZ2V0SG91cm1hcmtlclZpZXdNb2RlbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiB0aGlzLl9nZXRUb3BCeVRpbWUoKSxcbiAgICAgICAgaG91cjogbm93LmdldEhvdXJzKCksXG4gICAgICAgIHRleHQ6IGRhdGV0aW1lLmZvcm1hdChub3csICdISDptbScpXG4gICAgfTtcbn07XG5cbi8qKlxuICogQXR0YWNoIGV2ZW50c1xuICovXG5UaW1lR3JpZC5wcm90b3R5cGUuYXR0YWNoRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSUQpO1xuICAgIHRoaXMuaW50ZXJ2YWxJRCA9IHdpbmRvdy5zZXRJbnRlcnZhbCh1dGlsLmJpbmQodGhpcy5vblRpY2ssIHRoaXMpLCBIT1VSTUFSS0VSX1JFRlJFU0hfSU5URVJWQUwpO1xufTtcblxuLyoqXG4gKiBTY3JvbGwgdGltZSBncmlkIHRvIGN1cnJlbnQgaG91cm1hcmtlci5cbiAqL1xuVGltZUdyaWQucHJvdG90eXBlLnNjcm9sbFRvTm93ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1cnJlbnRIb3VyVG9wID0gdGhpcy5fZ2V0VG9wQnlUaW1lKCksXG4gICAgICAgIHZpZXdCb3VuZCA9IHRoaXMuZ2V0Vmlld0JvdW5kKCksXG4gICAgICAgIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuXG4gICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgPSAoMCwgY3VycmVudEhvdXJUb3AgLSAodmlld0JvdW5kLmhlaWdodCAvIDIpKTtcbiAgICB9LCBJTklUSUFMX0FVVE9TQ1JPTExfREVMQVkpO1xufTtcblxuLyoqKioqKioqKipcbiAqIEV2ZW50IGhhbmRsZXJzXG4gKioqKioqKioqKi9cblxuLyoqXG4gKiBJbnRlcnZhbCB0aWNrIGhhbmRsZXJcbiAqL1xuVGltZUdyaWQucHJvdG90eXBlLm9uVGljayA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVmcmVzaEhvdXJtYXJrZXIoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZUdyaWQ7XG5cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBWaWV3IG9mIGRheXMgVUkuXG4gKiBAYXV0aG9yIE5ITiBFbnQuIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IGdsb2JhbC5uZS51dGlsO1xudmFyIGRvbXV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vZG9tdXRpbCcpO1xudmFyIGRhdGV0aW1lID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2RhdGV0aW1lJyk7XG52YXIgVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXcnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QmFzZS5XZWVrfSBjb250cm9sbGVyIFRoZSBjb250cm9sbGVyIG1peGluIHBhcnQuXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBWaWV3IG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZW5kZXJTdGFydERhdGVdIFN0YXJ0IGRhdGUgb2YgcmVuZGVyLiBpZiBub3Qgc3VwcGxpZWQgdGhlbiB1c2UgLTNkIGZyb20gdG9kYXkuIFlZWVktTU0tREQgZm9ybWF0LlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlbmRlckVuZERhdGVdIEVuZCBkYXRlIG9mIHJlbmRlci4gaWYgbm90IHN1cHBsaWVkIHRoZW4gdXNlICszZCBmcm9tIHRvZGF5LiBZWVlZLU1NLUREIGZvcm1hdC5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBUaGUgZWxlbWVudCB0byB1c2UgY29udGFpbmVyIGZvciB0aGlzIHZpZXcuXG4gKiBAZXh0ZW5kcyB7Vmlld31cbiAqL1xuZnVuY3Rpb24gV2Vlayhjb250cm9sbGVyLCBvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICB2YXIgcmFuZ2U7XG5cbiAgICBjb250YWluZXIgPSBkb211dGlsLmFwcGVuZEhUTUxFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAnc2NoZWR1bGUtdmlldy13ZWVrLWNvbnRhaW5lcidcbiAgICApO1xuXG4gICAgVmlldy5jYWxsKHRoaXMsIG51bGwsIGNvbnRhaW5lcik7XG5cbiAgICByYW5nZSA9IHRoaXMuX2dldFJlbmRlckRhdGVSYW5nZShuZXcgRGF0ZSgpKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtvYmplY3R9IE9wdGlvbnMgZm9yIHZpZXcuXG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICByZW5kZXJTdGFydERhdGU6IGRhdGV0aW1lLmZvcm1hdChyYW5nZS5zdGFydCwgJ1lZWVktTU0tREQnKSxcbiAgICAgICAgcmVuZGVyRW5kRGF0ZTogZGF0ZXRpbWUuZm9ybWF0KHJhbmdlLmVuZCwgJ1lZWVktTU0tREQnKVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogV2VlayBjb250cm9sbGVyIG1peGluLlxuICAgICAqIEB0eXBlIHtCYXNlLldlZWt9XG4gICAgICovXG4gICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbn1cblxudXRpbC5pbmhlcml0KFdlZWssIFZpZXcpO1xuXG4vKioqKioqKioqKlxuICogT3ZlcnJpZGUgcHJvcHNcbiAqKioqKioqKioqL1xuXG4vKipcbiAqIFJlbmRlciBlYWNoIGNoaWxkIHZpZXcgd2l0aCBldmVudHMgaW4gcmFuZ2VzLlxuICogQG92ZXJyaWRlXG4gKi9cbldlZWsucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICByZW5kZXJTdGFydERhdGUgPSBkYXRldGltZS5wYXJzZShvcHRpb25zLnJlbmRlclN0YXJ0RGF0ZSksXG4gICAgICAgIHJlbmRlckVuZERhdGUgPSBkYXRldGltZS5wYXJzZShvcHRpb25zLnJlbmRlckVuZERhdGUpLFxuICAgICAgICBldmVudHNJbkRhdGVSYW5nZSA9IHRoaXMuY29udHJvbGxlci5maW5kQnlEYXRlUmFuZ2UoXG4gICAgICAgICAgICBkYXRldGltZS5zdGFydChyZW5kZXJTdGFydERhdGUpLFxuICAgICAgICAgICAgZGF0ZXRpbWUuZW5kKHJlbmRlckVuZERhdGUpXG4gICAgICAgICksXG4gICAgICAgIHZpZXdNb2RlbCA9IHtcbiAgICAgICAgICAgIGV2ZW50c0luRGF0ZVJhbmdlOiBldmVudHNJbkRhdGVSYW5nZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXJ0RGF0ZTogcmVuZGVyU3RhcnREYXRlLFxuICAgICAgICAgICAgcmVuZGVyRW5kRGF0ZTogcmVuZGVyRW5kRGF0ZVxuICAgICAgICB9O1xuXG4gICAgdGhpcy5jaGlsZHMuZWFjaChmdW5jdGlvbihjaGlsZFZpZXcpIHtcbiAgICAgICAgY2hpbGRWaWV3LnJlbmRlcih2aWV3TW9kZWwpO1xuICAgIH0pO1xufTtcblxuLyoqKioqKioqKipcbiAqIFByb3RvdHlwZSBwcm9wc1xuICoqKioqKioqKiovXG5cbldlZWsucHJvdG90eXBlLnZpZXdOYW1lID0gJ3dlZWsnO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBkZWZhdWx0IHJlbmRlciBkYXRlIHJhbmdlIGZyb20gc3VwcGxpZWQgZGF0ZS5cbiAqIEBwYXJhbSB7RGF0ZX0gYmFzZURhdGUgYmFzZSBkYXRlLlxuICogQHJldHVybnMge29iamVjdH0gZGF0ZSByYW5nZS5cbiAqL1xuV2Vlay5wcm90b3R5cGUuX2dldFJlbmRlckRhdGVSYW5nZSA9IGZ1bmN0aW9uKGJhc2VEYXRlKSB7XG4gICAgdmFyIGJhc2UgPSBkYXRldGltZS5zdGFydChiYXNlRGF0ZSksXG4gICAgICAgIHN0YXJ0ID0gbmV3IERhdGUoK2Jhc2UpLFxuICAgICAgICBlbmQgPSBuZXcgRGF0ZSgrYmFzZSk7XG5cbiAgICBzdGFydC5zZXREYXRlKHN0YXJ0LmdldERhdGUoKSAtIDMpO1xuICAgIGVuZC5zZXREYXRlKGVuZC5nZXREYXRlKCkgKyAzKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgZW5kOiBlbmRcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWVrO1xuXG4iXX0=
